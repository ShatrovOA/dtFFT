var tipuesearch = {"pages":[{"title":" dtFFT ","text":"dtFFT Developer Info Oleg Shatrov","tags":"home","loc":"index.html"},{"title":"abstract_executor – dtFFT ","text":"type, public, abstract :: abstract_executor The “most” abstract executor.\nAll FFT executors are extending this class. Inherits type~~abstract_executor~~InheritsGraph type~abstract_executor abstract_executor c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~abstract_executor~~InheritedByGraph type~abstract_executor abstract_executor type~cufft_executor cufft_executor type~cufft_executor->type~abstract_executor type~fft_executor fft_executor type~fft_executor->type~abstract_executor fft type~fftw_executor fftw_executor type~fftw_executor->type~abstract_executor type~mkl_executor mkl_executor type~mkl_executor->type~abstract_executor type~vkfft_executor vkfft_executor type~vkfft_executor->type~abstract_executor type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~fft_executor fft type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? logical, private :: is_created = .false. Is plan created? Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure( mem_alloc_interface ), public, deferred, nopass :: mem_alloc Allocates aligned memory subroutine mem_alloc_interface(alloc_bytes, ptr) Prototype Allocates aligned memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure( mem_free_interface ), public, deferred, nopass :: mem_free Frees aligned memory subroutine mem_free_interface(ptr) Prototype Frees aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free procedure( create_interface ), public, deferred, pass(self) :: create_private Creates FFT plan subroutine create_interface(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Prototype Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure( execute_interface ), public, deferred, pass(self) :: execute_private Executes plan subroutine execute_interface(self, a, b, sign) Prototype Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure( destroy_interface ), public, deferred, pass(self) :: destroy_private Destroys plan subroutine destroy_interface(self) Prototype Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor","tags":"","loc":"type/abstract_executor.html"},{"title":"backend_cufftmp – dtFFT ","text":"type, public, extends( abstract_backend ) :: backend_cufftmp cuFFTMp GPU Backend Inherits type~~backend_cufftmp~~InheritsGraph type~backend_cufftmp backend_cufftmp type~abstract_backend abstract_backend type~backend_cufftmp->type~abstract_backend type~cufftreshapehandle cufftReshapeHandle type~backend_cufftmp->type~cufftreshapehandle plan MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream type~nvrtc_kernel nvrtc_kernel type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 c_ptr c_ptr type~cufftreshapehandle->c_ptr cptr type~cudaevent->c_ptr event type~dtfft_stream_t->c_ptr stream type~cufunction CUfunction type~nvrtc_kernel->type~cufunction cuda_kernel type~dim3 dim3 type~nvrtc_kernel->type~dim3 num_blocks, block_size type~kernelargs kernelArgs type~nvrtc_kernel->type~kernelargs args type~cufunction->c_ptr ptr type~kernelargs->c_ptr ptrs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer type( nvrtc_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), public, pointer :: unpack_kernel2 Kernel for unpacking data type( cufftReshapeHandle ), private :: plan Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates Abstract GPU Backend private  subroutine create (self, backend, tranpose_type, helper, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend type( dtfft_backend_t ), intent(in) :: backend GPU Backend type type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public, non_overridable, pass(self) :: execute Executes GPU Backend private  subroutine execute (self, in, out, stream, aux) Executes GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer procedure, public, non_overridable, pass(self) :: destroy Destroys Abstract GPU Backend private  subroutine destroy (self) Destroys Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU backend procedure, public, non_overridable, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private  function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract GPU backend Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: set_unpack_kernel Sets unpack kernel for pipelined backend private  subroutine set_unpack_kernel (self, unpack_kernel, unpack_kernel2) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend type( nvrtc_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), intent(in), optional, target :: unpack_kernel2 Kernel for unpacking data procedure, public :: create_private => create private  subroutine create (self, helper, tranpose_type, base_storage) Creates cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public :: execute_private => execute private  subroutine execute (self, in, out, stream, aux) Executes cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer procedure, public :: destroy_private => destroy private  subroutine destroy (self) Destroys cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend","tags":"","loc":"type/backend_cufftmp.html"},{"title":"Box3D – dtFFT ","text":"type, private :: Box3D Components Type Visibility Attributes Name Initial integer(kind=c_long_long), public :: lower (3) integer(kind=c_long_long), public :: upper (3) integer(kind=c_long_long), public :: strides (3)","tags":"","loc":"type/box3d.html"},{"title":"dtfft_execute_t – dtFFT ","text":"type, public, bind(C) :: dtfft_execute_t Type that is used during call to execute method Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_execute_t.html"},{"title":"dtfft_transpose_t – dtFFT ","text":"type, public, bind(C) :: dtfft_transpose_t Type that is used during call to transpose method Inherited by type~~dtfft_transpose_t~~InheritedByGraph type~dtfft_transpose_t dtfft_transpose_t type~backend_helper backend_helper type~backend_helper->type~dtfft_transpose_t tranpose_type type~nvrtc_cache nvrtc_cache type~nvrtc_cache->type~dtfft_transpose_t transpose_type type~transpose_handle_cuda transpose_handle_cuda type~transpose_handle_cuda->type~dtfft_transpose_t transpose_type type~abstract_transpose_plan abstract_transpose_plan type~abstract_transpose_plan->type~backend_helper helper type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans type~transpose_plan_cuda->type~abstract_transpose_plan type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~abstract_transpose_plan plan type~transpose_plan_host transpose_plan_host type~transpose_plan_host->type~abstract_transpose_plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_transpose_t.html"},{"title":"dtfft_executor_t – dtFFT ","text":"type, public, bind(C) :: dtfft_executor_t Type that specifies external FFT executor Inherited by type~~dtfft_executor_t~~InheritedByGraph type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_executor_t.html"},{"title":"dtfft_effort_t – dtFFT ","text":"type, public, bind(C) :: dtfft_effort_t Type that specifies effort that dtFFT should use when creating plan Inherited by type~~dtfft_effort_t~~InheritedByGraph type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_effort_t.html"},{"title":"dtfft_precision_t – dtFFT ","text":"type, public, bind(C) :: dtfft_precision_t Type that specifies precision of dtFFT plan Inherited by type~~dtfft_precision_t~~InheritedByGraph type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_precision_t.html"},{"title":"dtfft_r2r_kind_t – dtFFT ","text":"type, public, bind(C) :: dtfft_r2r_kind_t Type that specifies various kinds of R2R FFTs Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_r2r_kind_t.html"},{"title":"dtfft_backend_t – dtFFT ","text":"type, public, bind(C) :: dtfft_backend_t Type that specifies various GPU Backend present in dtFFT Inherited by type~~dtfft_backend_t~~InheritedByGraph type~dtfft_backend_t dtfft_backend_t type~abstract_backend abstract_backend type~abstract_backend->type~dtfft_backend_t backend type~abstract_transpose_plan abstract_transpose_plan type~abstract_transpose_plan->type~dtfft_backend_t backend type~dtfft_config_t dtfft_config_t type~dtfft_config_t->type~dtfft_backend_t backend type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~abstract_transpose_plan plan type~transpose_handle_cuda transpose_handle_cuda type~transpose_handle_cuda->type~abstract_backend comm_handle type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~abstract_transpose_plan type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans type~transpose_plan_host transpose_plan_host type~transpose_plan_host->type~abstract_transpose_plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_backend_t.html"},{"title":"dtfft_stream_t – dtFFT ","text":"type, public, bind(C) :: dtfft_stream_t dtFFT stream representation. Inherits type~~dtfft_stream_t~~InheritsGraph type~dtfft_stream_t dtfft_stream_t c_ptr c_ptr type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~dtfft_stream_t~~InheritedByGraph type~dtfft_stream_t dtfft_stream_t type~abstract_backend abstract_backend type~abstract_backend->type~dtfft_stream_t copy_stream type~dtfft_config_t dtfft_config_t type~dtfft_config_t->type~dtfft_stream_t stream type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_stream_t stream type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~dtfft_stream_t stream type~transpose_handle_cuda transpose_handle_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~transpose_handle_cuda->type~abstract_backend comm_handle type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: stream Actual stream Constructor public        interface dtfft_stream_t Creates dtfft_stream_t from integer(cuda_stream_kind) private  function stream_from_int64 (cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream","tags":"","loc":"type/dtfft_stream_t.html"},{"title":"dtfft_platform_t – dtFFT ","text":"type, public, bind(C) :: dtfft_platform_t Type that specifies runtime platform, e.g. Host, CUDA, HIP Inherited by type~~dtfft_platform_t~~InheritedByGraph type~dtfft_platform_t dtfft_platform_t type~dtfft_config_t dtfft_config_t type~dtfft_config_t->type~dtfft_platform_t platform type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_platform_t.html"},{"title":"vkfft_wrapper – dtFFT ","text":"type, public :: vkfft_wrapper VkFFT Wrapper Inherits type~~vkfft_wrapper~~InheritsGraph type~vkfft_wrapper vkfft_wrapper c_funptr c_funptr type~vkfft_wrapper->c_funptr vkfft_functions c_ptr c_ptr type~vkfft_wrapper->c_ptr lib_handle Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~vkfft_wrapper~~InheritedByGraph type~vkfft_wrapper vkfft_wrapper type~vkfft_executor vkfft_executor type~vkfft_executor->type~vkfft_wrapper wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial procedure( vkfft_create_interface ), public, pointer, nopass :: create Fortran Pointer to vkFFT create function procedure( vkfft_execute_interface ), public, pointer, nopass :: execute Fortran Pointer to vkFFT execute function procedure( vkfft_destroy_interface ), public, pointer, nopass :: destroy Fortran Pointer to vkFFT destroy function logical, private :: is_loaded = .false. Is VkFFT library loaded type(c_ptr), private :: lib_handle Handle to the loaded library type(c_funptr), private :: vkfft_functions (3) Array of VkFFT functions","tags":"","loc":"type/vkfft_wrapper.html"},{"title":"nvrtcProgram – dtFFT ","text":"type, public, bind(C) :: nvrtcProgram nvrtcProgram is the unit of compilation, and an opaque handle for a program. Inherits type~~nvrtcprogram~~InheritsGraph type~nvrtcprogram nvrtcProgram c_ptr c_ptr type~nvrtcprogram->c_ptr cptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: cptr Actual pointer","tags":"","loc":"type/nvrtcprogram.html"},{"title":"fftw_executor – dtFFT ","text":"type, public, extends( abstract_executor ) :: fftw_executor FFTW3 FFT Executor Inherits type~~fftw_executor~~InheritsGraph type~fftw_executor fftw_executor type~abstract_executor abstract_executor type~fftw_executor->type~abstract_executor c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? procedure( apply_interface ), private, nopass, pointer :: apply => NULL() Pointer to FFTW3 function that executes FFT plan procedure( free_interface ), private, nopass, pointer :: free => NULL() Pointer to FFTW3 function that destroys FFT plan procedure( apply_interface ), private, nopass, pointer :: apply_inverse => NULL() Pointer to FFTW3 function that executes inverse FFT plan\nUsed in R2C only Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure, public :: create_private => create Creates FFT plan via FFTW3 Interface private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via FFTW3 Interface Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure, public :: execute_private => execute Executes FFTW3 plan private  subroutine execute (self, a, b, sign) Executes FFTW3 plan Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(in) :: self FFTW FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public :: destroy_private => destroy Destroys FFTW3 plan private  subroutine destroy (self) Destroys FFTW3 plan Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor procedure, public, nopass :: mem_alloc Allocates FFTW3 memory private  subroutine mem_alloc (alloc_bytes, ptr) Allocates FFTW3 memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure, public, nopass :: mem_free Frees FFTW3 aligned memory private  subroutine mem_free (ptr) Frees FFTW3 aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"type/fftw_executor.html"},{"title":"mkl_executor – dtFFT ","text":"type, public, extends( abstract_executor ) :: mkl_executor MKL FFT Executor Inherits type~~mkl_executor~~InheritsGraph type~mkl_executor mkl_executor type~abstract_executor abstract_executor type~mkl_executor->type~abstract_executor c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? logical, private :: need_reconfigure Needed for R2C plans integer(kind=c_long), private, allocatable :: istrides (:) Input strides. Needed for R2C plans to reconfigure plan integer(kind=c_long), private, allocatable :: ostrides (:) Output strides. Needed for R2C plans to reconfigure plan integer(kind=int32), private :: idist Input distance between the first data elements of consecutive data sets integer(kind=int32), private :: odist Output distance between the first data elements of consecutive data sets Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure, public :: create_private => create Creates FFT plan via MKL DFTI Interface private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via MKL DFTI Interface Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure, public :: execute_private => execute Executes MKL plan private  subroutine execute (self, a, b, sign) Executes MKL plan Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(in) :: self MKL FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public :: destroy_private => destroy Destroys MKL plan private  subroutine destroy (self) Destroys MKL plan Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor procedure, public, nopass :: mem_alloc Allocates MKL memory private  subroutine mem_alloc (alloc_bytes, ptr) Allocates MKL memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure, public, nopass :: mem_free Frees MKL aligned memory private  subroutine mem_free (ptr) Frees MKL aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"type/mkl_executor.html"},{"title":"cufftReshapeHandle – dtFFT ","text":"type, public, bind(C) :: cufftReshapeHandle An opaque handle to a reshape operation. Inherits type~~cufftreshapehandle~~InheritsGraph type~cufftreshapehandle cufftReshapeHandle c_ptr c_ptr type~cufftreshapehandle->c_ptr cptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~cufftreshapehandle~~InheritedByGraph type~cufftreshapehandle cufftReshapeHandle type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~cufftreshapehandle plan Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: cptr","tags":"","loc":"type/cufftreshapehandle.html"},{"title":"transpose_plan_cuda – dtFFT ","text":"type, public, extends( abstract_transpose_plan ) :: transpose_plan_cuda CUDA Transpose Plan Inherits type~~transpose_plan_cuda~~InheritsGraph type~transpose_plan_cuda transpose_plan_cuda c_ptr c_ptr type~transpose_plan_cuda->c_ptr aux type~abstract_transpose_plan abstract_transpose_plan type~transpose_plan_cuda->type~abstract_transpose_plan type~dtfft_stream_t dtfft_stream_t type~transpose_plan_cuda->type~dtfft_stream_t stream type~transpose_handle_cuda transpose_handle_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans type~backend_helper backend_helper type~abstract_transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~abstract_transpose_plan->type~dtfft_backend_t backend type~dtfft_stream_t->c_ptr stream type~abstract_backend abstract_backend type~transpose_handle_cuda->type~abstract_backend comm_handle type~dtfft_transpose_t dtfft_transpose_t type~transpose_handle_cuda->type~dtfft_transpose_t transpose_type type~nvrtc_kernel nvrtc_kernel type~transpose_handle_cuda->type~nvrtc_kernel transpose_kernel, unpack_kernel, unpack_kernel2 type~abstract_backend->type~dtfft_stream_t copy_stream type~abstract_backend->type~dtfft_backend_t backend type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~backend_helper->c_ptr nccl_register type~backend_helper->type~dtfft_transpose_t tranpose_type type~backend_helper->MPI_Comm comms type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~pencil pencil type~backend_helper->type~pencil pencils type~cufunction CUfunction type~nvrtc_kernel->type~cufunction cuda_kernel type~dim3 dim3 type~nvrtc_kernel->type~dim3 num_blocks, block_size type~kernelargs kernelArgs type~nvrtc_kernel->type~kernelargs args type~cudaevent->c_ptr event type~cufunction->c_ptr ptr type~kernelargs->c_ptr ptrs type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend = DTFFT_BACKEND_MPI_DATATYPE GPU backend type( backend_helper ), public :: helper Backend helper logical, public :: is_z_slab Z-slab optimization flag (for 3D transforms) integer(kind=int64), public :: min_buffer_size Minimal buffer size for transposition type( dtfft_stream_t ), private :: stream CUDA stream type(c_ptr), private :: aux Auxiliary memory real(kind=real32), private, pointer :: paux (:) Pointer to auxiliary memory logical, private :: is_aux_alloc Is auxiliary memory allocated type( transpose_handle_cuda ), private, allocatable :: fplans (:) Forward transposition plans type( transpose_handle_cuda ), private, allocatable :: bplans (:) Backward transposition plans Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Create transposition plan private  function create (self, dims, base_comm, effort, base_dtype, base_storage, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plans Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code procedure, public, non_overridable, pass(self) :: execute Executes transposition private  subroutine execute (self, in, out, transpose_type) Executes single transposition Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming pointer type(c_ptr), intent(in) :: out Result pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose procedure, public, non_overridable, pass(self) :: get_backend Returns backend id private  function get_backend (self) Returns plan GPU backend Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(in) :: self Transposition class Return Value type( dtfft_backend_t ) procedure, public, non_overridable, pass(self) :: mem_alloc Allocates memory based on selected backend private  subroutine mem_alloc (self, comm, alloc_bytes, ptr, error_code) Allocates memory based on selected backend Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code procedure, public, non_overridable, pass(self) :: mem_free Frees memory allocated with mem_alloc private  subroutine mem_free (self, ptr, error_code) Frees memory allocated with mem_alloc Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code procedure, public :: create_private => create_cuda Creates CUDA transpose plan private  function create_cuda (self, dims, transposed_dims, base_comm, comm_dims, effort, base_dtype, base_storage, is_custom_cart_comm, cart_comm, comms, pencils, ipencil) Creates CUDA transpose plan Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(inout) :: self GPU transpose plan integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm Base communicator integer(kind=int32), intent(in) :: comm_dims (:) Number of processors in each dimension type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_custom_cart_comm is custom Cartesian communicator provided by user type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) procedure, public :: execute_private => execute_cuda Executes single transposition private  subroutine execute_cuda (self, in, out, transpose_type) Executes single transposition Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(inout) :: self Transposition class real(kind=real32), intent(inout) :: in (:) Incoming buffer real(kind=real32), intent(inout) :: out (:) Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to execute procedure, public :: destroy => destroy_cuda Destroys CUDA transpose plan private  subroutine destroy_cuda (self) Destroys transposition plans Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(inout) :: self Transposition class procedure, public :: get_aux_size Returns auxiliary buffer size private  function get_aux_size (self) result(aux_size) Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(in) :: self Transposition class Return Value integer(kind=int64)","tags":"","loc":"type/transpose_plan_cuda.html"},{"title":"dim3 – dtFFT ","text":"type, public, bind(C) :: dim3 Dimension specification type Inherited by type~~dim3~~InheritedByGraph type~dim3 dim3 type~nvrtc_kernel nvrtc_kernel type~nvrtc_kernel->type~dim3 num_blocks, block_size type~abstract_backend abstract_backend type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 type~transpose_handle_cuda transpose_handle_cuda type~transpose_handle_cuda->type~nvrtc_kernel transpose_kernel, unpack_kernel, unpack_kernel2 type~transpose_handle_cuda->type~abstract_backend comm_handle type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: x integer(kind=c_int), public :: y integer(kind=c_int), public :: z","tags":"","loc":"type/dim3.html"},{"title":"cudaEvent – dtFFT ","text":"type, public, bind(C) :: cudaEvent CUDA event types Inherits type~~cudaevent~~InheritsGraph type~cudaevent cudaEvent c_ptr c_ptr type~cudaevent->c_ptr event Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~cudaevent~~InheritedByGraph type~cudaevent cudaEvent type~abstract_backend abstract_backend type~abstract_backend->type~cudaevent execution_event, copy_event type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~transpose_handle_cuda transpose_handle_cuda type~transpose_handle_cuda->type~abstract_backend comm_handle type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: event Handle","tags":"","loc":"type/cudaevent.html"},{"title":"nvshmem_team_t – dtFFT ","text":"type, public, bind(C) :: nvshmem_team_t NVSHMEM team. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal representation of the NVSHMEM team.","tags":"","loc":"type/nvshmem_team_t.html"},{"title":"backend_helper – dtFFT ","text":"type, public :: backend_helper Helper with nccl, mpi and nvshmem communicators Inherits type~~backend_helper~~InheritsGraph type~backend_helper backend_helper MPI_Comm MPI_Comm type~backend_helper->MPI_Comm comms c_ptr c_ptr type~backend_helper->c_ptr nccl_register type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~pencil pencil type~backend_helper->type~pencil pencils type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~backend_helper~~InheritedByGraph type~backend_helper backend_helper type~abstract_transpose_plan abstract_transpose_plan type~abstract_transpose_plan->type~backend_helper helper type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~abstract_transpose_plan plan type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~abstract_transpose_plan type~transpose_plan_host transpose_plan_host type~transpose_plan_host->type~abstract_transpose_plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: is_nccl_created = .false. Flag is nccl_comm has been created type( ncclComm ), public :: nccl_comm NCCL communicator logical, public :: should_register If NCCL buffer should be registered type(c_ptr), public, allocatable :: nccl_register (:,:) NCCL register cache integer(kind=int32), public :: nccl_register_size Number of elements in nccl_register type(MPI_Comm), public, allocatable :: comms (:) MPI communicators integer(kind=int32), public, allocatable :: comm_mappings (:,:) Mapping of 1d comm ranks to global comm type( dtfft_transpose_t ), public :: tranpose_type Type of transpose to create type( pencil ), public, pointer :: pencils (:) Pencils Type-Bound Procedures procedure, public, pass(self) :: create => create_helper Creates helper private  subroutine create_helper (self, base_comm, comms, is_nccl_needed, pencils) Creates helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper type(MPI_Comm), intent(in) :: base_comm MPI communicator type(MPI_Comm), intent(in) :: comms (:) 1D Communicators logical, intent(in) :: is_nccl_needed If nccl communicator will be needed type( pencil ), intent(in), target :: pencils (:) Pencils procedure, public, pass(self) :: destroy => destroy_helper Destroys helper private  subroutine destroy_helper (self) Destroys helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper","tags":"","loc":"type/backend_helper.html"},{"title":"abstract_backend – dtFFT ","text":"type, public, abstract :: abstract_backend The most Abstract GPU Backend Inherits type~~abstract_backend~~InheritsGraph type~abstract_backend abstract_backend MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream type~nvrtc_kernel nvrtc_kernel type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 c_ptr c_ptr type~cudaevent->c_ptr event type~dtfft_stream_t->c_ptr stream type~cufunction CUfunction type~nvrtc_kernel->type~cufunction cuda_kernel type~dim3 dim3 type~nvrtc_kernel->type~dim3 num_blocks, block_size type~kernelargs kernelArgs type~nvrtc_kernel->type~kernelargs args type~cufunction->c_ptr ptr type~kernelargs->c_ptr ptrs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~abstract_backend~~InheritedByGraph type~abstract_backend abstract_backend type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~transpose_handle_cuda transpose_handle_cuda type~transpose_handle_cuda->type~abstract_backend comm_handle type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer type( nvrtc_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), public, pointer :: unpack_kernel2 Kernel for unpacking data Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates Abstract GPU Backend private  subroutine create (self, backend, tranpose_type, helper, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend type( dtfft_backend_t ), intent(in) :: backend GPU Backend type type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public, non_overridable, pass(self) :: execute Executes GPU Backend private  subroutine execute (self, in, out, stream, aux) Executes GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer procedure, public, non_overridable, pass(self) :: destroy Destroys Abstract GPU Backend private  subroutine destroy (self) Destroys Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU backend procedure, public, non_overridable, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private  function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract GPU backend Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: set_unpack_kernel Sets unpack kernel for pipelined backend private  subroutine set_unpack_kernel (self, unpack_kernel, unpack_kernel2) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend type( nvrtc_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), intent(in), optional, target :: unpack_kernel2 Kernel for unpacking data procedure( create_interface ), public, deferred, pass(self) :: create_private Creates overring class subroutine create_interface(self, helper, tranpose_type, base_storage) Prototype Creates overring class Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure( execute_interface ), public, deferred, pass(self) :: execute_private Executes GPU Backend subroutine execute_interface(self, in, out, stream, aux) Prototype Executes GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer procedure( destroy_interface ), public, deferred, pass(self) :: destroy_private Destroys overring class subroutine destroy_interface(self) Prototype Destroys overring class Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend","tags":"","loc":"type/abstract_backend.html"},{"title":"vkfft_executor – dtFFT ","text":"type, public, extends( abstract_executor ) :: vkfft_executor vkFFT FFT Executor Inherits type~~vkfft_executor~~InheritsGraph type~vkfft_executor vkfft_executor type~abstract_executor abstract_executor type~vkfft_executor->type~abstract_executor type~vkfft_wrapper vkfft_wrapper type~vkfft_executor->type~vkfft_wrapper wrapper c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward c_funptr c_funptr type~vkfft_wrapper->c_funptr vkfft_functions type~vkfft_wrapper->c_ptr lib_handle Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? type( vkfft_wrapper ), private, pointer :: wrapper => null() VkFFT Wrapper logical, private :: is_inverse_required Should be create separate inverse FFT Plan or not Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure, public, pass(self) :: create_private => create Creates FFT plan via vkFFT Interface private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via vkFFT Interface Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure, public, pass(self) :: execute_private => execute Executes vkFFT plan private  subroutine execute (self, a, b, sign) Executes vkFFT plan Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(in) :: self vkFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, pass(self) :: destroy_private => destroy Destroys vkFFT plan private  subroutine destroy (self) Destroys vkFFT plan Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor procedure, public, nopass :: mem_alloc Dummy method. Raises error stop private  subroutine mem_alloc (alloc_bytes, ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure, public, nopass :: mem_free Dummy method. Raises error stop private  subroutine mem_free (ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"type/vkfft_executor.html"},{"title":"transpose_plan_host – dtFFT ","text":"type, public, extends( abstract_transpose_plan ) :: transpose_plan_host Host transpose plan Inherits type~~transpose_plan_host~~InheritsGraph type~transpose_plan_host transpose_plan_host type~abstract_transpose_plan abstract_transpose_plan type~transpose_plan_host->type~abstract_transpose_plan type~transpose_handle_host transpose_handle_host type~transpose_plan_host->type~transpose_handle_host fplans, bplans type~backend_helper backend_helper type~abstract_transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~abstract_transpose_plan->type~dtfft_backend_t backend MPI_Comm MPI_Comm type~transpose_handle_host->MPI_Comm comm MPI_Request MPI_Request type~transpose_handle_host->MPI_Request request type~handle_t handle_t type~transpose_handle_host->type~handle_t send, recv type~backend_helper->MPI_Comm comms c_ptr c_ptr type~backend_helper->c_ptr nccl_register type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~pencil pencil type~backend_helper->type~pencil pencils MPI_Datatype MPI_Datatype type~handle_t->MPI_Datatype dtypes type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend = DTFFT_BACKEND_MPI_DATATYPE GPU backend type( backend_helper ), public :: helper Backend helper logical, public :: is_z_slab Z-slab optimization flag (for 3D transforms) integer(kind=int64), public :: min_buffer_size Minimal buffer size for transposition type( transpose_handle_host ), private, allocatable :: fplans (:) Forward plans type( transpose_handle_host ), private, allocatable :: bplans (:) Backward plans Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Create transposition plan private  function create (self, dims, base_comm, effort, base_dtype, base_storage, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plans Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code procedure, public, non_overridable, pass(self) :: execute Executes transposition private  subroutine execute (self, in, out, transpose_type) Executes single transposition Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming pointer type(c_ptr), intent(in) :: out Result pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose procedure, public, pass(self) :: get_aux_size Returns auxiliary buffer size private  function get_aux_size (self) result(aux_size) Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(in) :: self Transposition class Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: get_backend Returns backend id private  function get_backend (self) Returns plan GPU backend Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(in) :: self Transposition class Return Value type( dtfft_backend_t ) procedure, public, non_overridable, pass(self) :: mem_alloc Allocates memory based on selected backend private  subroutine mem_alloc (self, comm, alloc_bytes, ptr, error_code) Allocates memory based on selected backend Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code procedure, public, non_overridable, pass(self) :: mem_free Frees memory allocated with mem_alloc private  subroutine mem_free (self, ptr, error_code) Frees memory allocated with mem_alloc Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code procedure, public :: create_private private  function create_private (self, dims, transposed_dims, base_comm, comm_dims, effort, base_dtype, base_storage, is_custom_cart_comm, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plans Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator integer(kind=int32), intent(in) :: comm_dims (:) Number of MPI Processes in all directions type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_custom_cart_comm Is custom Cartesian communicator provided by user type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Pencils type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code procedure, public :: execute_private private  subroutine execute_private (self, in, out, transpose_type) Executes single transposition Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(inout) :: self Transposition class real(kind=real32), intent(inout) :: in (:) Incoming buffer real(kind=real32), intent(inout) :: out (:) Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to execute procedure, public :: destroy private  subroutine destroy (self) Destroys transposition plans Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(inout) :: self Transposition class procedure, private, nopass :: get_plan_execution_time private  function get_plan_execution_time (comm, cart_comm, from, to, base_dtype, base_storage, datatype_id, transpose_name_id, a, b) result(elapsed_time) Creates transpose plan and executes it DTFFT_MEASURE_WARMUP_ITERS + DTFFT_MEASURE_ITERS times Read more… Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm 1D comm in case of pencils, 3D comm in case of z_slabs type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: datatype_id ID of transpose (1 or 2) integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer Return Value real(kind=real64) Execution time procedure, private, pass(self) :: autotune_transpose_id private  function autotune_transpose_id (self, comm, cart_comm, from, to, base_dtype, base_storage, transpose_name_id, a, b, forward_id, backward_id) result(elapsed_time) Creates forward and backward transpose plans bases on source and target data distributing,\nexecutes them DTFFT_MEASURE_ITERS times ( 4 * DTFFT_MEASURE_ITERS iterations total ) Read more… Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Abstract plan type(MPI_Comm), intent(in) :: comm 1D comm in case of pencils, 3D comm in case of z_slabs type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer integer(kind=int8), intent(out) :: forward_id Best forward plan ID integer(kind=int8), intent(out) :: backward_id Best backward plan ID Return Value real(kind=real64) Elapsed time for best plans selected procedure, private, pass(self) :: autotune_mpi_datatypes private  subroutine autotune_mpi_datatypes (self, pencils, cart_comm, comms, base_dtype, base_storage, a, b, forward_ids, backward_ids, elapsed_time) Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Host plan type( pencil ), intent(in) :: pencils (:) Array of pencils type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type(MPI_Comm), intent(in) :: comms (:) Array of 1d communicators type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype real(kind=real32), intent(inout) :: a (:) Work buffer real(kind=real32), intent(inout) :: b (:) Work buffer integer(kind=int8), intent(inout) :: forward_ids (:) Forward plan IDs integer(kind=int8), intent(inout) :: backward_ids (:) Backward plan IDs real(kind=real64), intent(out) :: elapsed_time Elapsed time procedure, private, pass(self) :: autotune_grid_decomposition private  subroutine autotune_grid_decomposition (self, dims, transposed_dims, base_comm, effort, n_transpose_plans, base_dtype, base_storage, best_comm_dims, best_forward_ids, best_backward_ids) Runs through all possible grid decompositions and selects the best one based on the lowest average execution time Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dims (:) Global dims integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dims type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int8), intent(in) :: n_transpose_plans Number of transpose plans to test type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(out) :: best_comm_dims (:) Best communicator dimensions integer(kind=int8), intent(inout) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(inout) :: best_backward_ids (:) Best Datatype ids for backward plan procedure, private, pass(self) :: autotune_grid private  subroutine autotune_grid (self, base_comm, comm_dims, dims, transposed_dims, effort, base_dtype, base_storage, latest_timer_id, timers, decomps, forw_ids, back_ids, ipencil) Creates cartesian communicator and executes various datatypes on it Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Abstract plan type(MPI_Comm), intent(in) :: base_comm Base communicator integer(kind=int32), intent(in) :: comm_dims (:) Number of MPI Processes in Y and Z directions integer(kind=int32), intent(in) :: dims (:) Global dims integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dims type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int32), intent(inout) :: latest_timer_id Current timer id real(kind=real64), intent(inout) :: timers (:) Time of current function execution is stored in timers(latest_timer_id) integer(kind=int32), intent(inout) :: decomps (:,:) Current decomposition is stored in decomps(:, latest_timer_id) integer(kind=int8), intent(inout) :: forw_ids (:,:) Best Forward ids are stored in forw_ids(:, latest_timer_id) integer(kind=int8), intent(inout) :: back_ids (:,:) Best Backward ids are stored in back_ids(:, latest_timer_id) type( pencil_init ), intent(in), optional :: ipencil","tags":"","loc":"type/transpose_plan_host.html"},{"title":"cufft_executor – dtFFT ","text":"type, public, extends( abstract_executor ) :: cufft_executor cuFFT FFT Executor Inherits type~~cufft_executor~~InheritsGraph type~cufft_executor cufft_executor type~abstract_executor abstract_executor type~cufft_executor->type~abstract_executor c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure, public :: create_private => create Creates FFT plan via cuFFT Interface private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via cuFFT Interface Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure, public :: execute_private => execute Executes cuFFT plan private  subroutine execute (self, a, b, sign) Executes cuFFT plan Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(in) :: self cuFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public :: destroy_private => destroy Destroys cuFFT plan private  subroutine destroy (self) Destroys cuFFT plan Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor procedure, public, nopass :: mem_alloc Dummy method. Raises error stop private  subroutine mem_alloc (alloc_bytes, ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure, public, nopass :: mem_free Dummy method. Raises error stop private  subroutine mem_free (ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"type/cufft_executor.html"},{"title":"backend_mpi – dtFFT ","text":"type, public, extends( abstract_backend ) :: backend_mpi MPI Backend Inherits type~~backend_mpi~~InheritsGraph type~backend_mpi backend_mpi type~abstract_backend abstract_backend type~backend_mpi->type~abstract_backend type~mpi_backend_helper mpi_backend_helper type~backend_mpi->type~mpi_backend_helper send, recv MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream type~nvrtc_kernel nvrtc_kernel type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 MPI_Request MPI_Request type~mpi_backend_helper->MPI_Request requests c_ptr c_ptr type~cudaevent->c_ptr event type~dtfft_stream_t->c_ptr stream type~cufunction CUfunction type~nvrtc_kernel->type~cufunction cuda_kernel type~dim3 dim3 type~nvrtc_kernel->type~dim3 num_blocks, block_size type~kernelargs kernelArgs type~nvrtc_kernel->type~kernelargs args type~cufunction->c_ptr ptr type~kernelargs->c_ptr ptrs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer type( nvrtc_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), public, pointer :: unpack_kernel2 Kernel for unpacking data type( mpi_backend_helper ), private :: send MPI Helper for send data type( mpi_backend_helper ), private :: recv MPI Helper for recv data Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates Abstract GPU Backend private  subroutine create (self, backend, tranpose_type, helper, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend type( dtfft_backend_t ), intent(in) :: backend GPU Backend type type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public, non_overridable, pass(self) :: execute Executes GPU Backend private  subroutine execute (self, in, out, stream, aux) Executes GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer procedure, public, non_overridable, pass(self) :: destroy Destroys Abstract GPU Backend private  subroutine destroy (self) Destroys Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU backend procedure, public, non_overridable, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private  function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract GPU backend Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: set_unpack_kernel Sets unpack kernel for pipelined backend private  subroutine set_unpack_kernel (self, unpack_kernel, unpack_kernel2) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend type( nvrtc_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), intent(in), optional, target :: unpack_kernel2 Kernel for unpacking data procedure, public :: create_private => create_mpi Creates MPI backend private  subroutine create_mpi (self, helper, tranpose_type, base_storage) Creates MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI GPU Backend type( backend_helper ), intent(in) :: helper Backend helper (unused) type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create (unused) integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) procedure, public :: execute_private => execute_mpi Executes MPI backend private  subroutine execute_mpi (self, in, out, stream, aux) Executes MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer procedure, public :: destroy_private => destroy_mpi Destroys MPI backend private  subroutine destroy_mpi (self) Destroys MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI GPU Backend","tags":"","loc":"type/backend_mpi.html"},{"title":"mpi_backend_helper – dtFFT ","text":"type, private :: mpi_backend_helper MPI Helper Inherits type~~mpi_backend_helper~~InheritsGraph type~mpi_backend_helper mpi_backend_helper MPI_Request MPI_Request type~mpi_backend_helper->MPI_Request requests Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mpi_backend_helper~~InheritedByGraph type~mpi_backend_helper mpi_backend_helper type~backend_mpi backend_mpi type~backend_mpi->type~mpi_backend_helper send, recv Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=CNT_KIND), public, allocatable :: counts (:) Counts of data to send or recv integer(kind=ADDR_KIND), public, allocatable :: displs (:) Displacements of data to send or recv type(MPI_Request), public, allocatable :: requests (:) MPI Requests integer(kind=int32), public :: n_requests Number of requests logical, public :: is_request_created = .false. Request created flag. Used for persistent functions Type-Bound Procedures procedure, public, pass(self) :: create => create_helper Creates MPI helper private  subroutine create_helper (self, counts, displs, max_requests) Creates MPI helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper integer(kind=int64), intent(in) :: counts (:) Counts of data to send or recv integer(kind=int64), intent(in) :: displs (:) Displacements of data to send or recv integer(kind=int32), intent(in) :: max_requests Maximum number of requests required procedure, public, pass(self) :: destroy => destoy_helper Destroys MPI helper private  subroutine destoy_helper (self) Destroys MPI helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper","tags":"","loc":"type/mpi_backend_helper.html"},{"title":"nvtxDomainHandle – dtFFT ","text":"type, private, bind(C) :: nvtxDomainHandle Inherits type~~nvtxdomainhandle~~InheritsGraph type~nvtxdomainhandle nvtxDomainHandle c_ptr c_ptr type~nvtxdomainhandle->c_ptr handle Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: handle","tags":"","loc":"type/nvtxdomainhandle.html"},{"title":"dtfft_plan_t – dtFFT ","text":"type, public, abstract :: dtfft_plan_t Abstract class for all dtFFT plans Inherits type~~dtfft_plan_t~~InheritsGraph type~dtfft_plan_t dtfft_plan_t MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~abstract_transpose_plan abstract_transpose_plan type~dtfft_plan_t->type~abstract_transpose_plan plan type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~backend_helper backend_helper type~abstract_transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~abstract_transpose_plan->type~dtfft_backend_t backend type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~dtfft_plan_t~~InheritedByGraph type~dtfft_plan_t dtfft_plan_t type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int8), private :: ndims Number of global dimensions integer(kind=int32), private, allocatable :: dims (:) Global dimensions type( dtfft_precision_t ), private :: precision Precision of transform logical, private :: is_created = .false. Plan creation flag logical, private :: is_transpose_plan = .false. Plan is transpose only logical, private :: is_aux_alloc = .false. Auxiliary buffer is allocated internally logical, private :: is_z_slab = .false. Using Z-slab optimization Only 3D plan. When .true., then data is distributed only Z direction and it creates a possibility for optimization: 2 dimensional FFT plan is created for both X and Y dimensions Single call to MPI_Alltoall is required to transpose data from X-align to Z align For CUDA build this optimization means single CUDA kernel that tranposes data directly from X to Z type( dtfft_effort_t ), private :: effort User defined type of effort integer(kind=int64), private :: storage_size Single element size in bytes type( dtfft_executor_t ), private :: executor FFT executor type type(MPI_Comm), private :: comm Grid communicator type(MPI_Comm), private, allocatable :: comms (:) Local 1d communicators class( abstract_transpose_plan ), private, allocatable :: plan Transpose plan handle type( pencil ), private, allocatable :: pencils (:) Information about data aligment and datatypes type( dtfft_platform_t ), private :: platform Execution platform type( dtfft_stream_t ), private :: stream CUDA Stream associated with current plan type(c_ptr), private :: aux_ptr Auxiliary pointer type( fft_executor ), private, allocatable :: fft (:) Internal fft runners integer(kind=int32), private, allocatable :: fft_mapping (:) Memory and plan creation optimization.\nIn case same FFTs needs to be run in different dimensions\nonly single FFT plan needs to be created Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, dim, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dim Required dimension: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  subroutine mem_alloc_ptr (self, alloc_bytes, ptr, error_code) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d Allocates memory specific for this plan private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d Frees previously allocated memory specific for this plan private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) procedure, public, pass(self), non_overridable :: get_backend Returns selected GPU backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 Returns CUDA stream associated with plan private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: get_stream_ptr Returns CUDA stream associated with plan private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: get_stream_int64 Returns CUDA stream associated with plan private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: execute_private Executes plan private  subroutine execute_private (self, in, out, execute_type, aux, inplace) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. logical, intent(in) :: inplace Inplace execution flag procedure, private, pass(self), non_overridable :: check_create_args Check arguments provided to create subroutines private  function check_create_args (self, dims, pencil, comm, precision, effort, executor, kinds) Check arguments provided by user and sets private variables Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm Optional MPI Communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) procedure, private, pass(self), non_overridable :: create_private Creates core private  function create_private (self, sngl_type, sngl_storage_size, dbl_type, dbl_storage_size, dims, pencil, comm, precision, effort, executor, kinds) Creates core Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(MPI_Datatype), intent(in) :: sngl_type MPI_Datatype for single precision plan integer(kind=int64), intent(in) :: sngl_storage_size Number of bytes needed to store single element (single precision) type(MPI_Datatype), intent(in) :: dbl_type MPI_Datatype for double precision plan integer(kind=int64), intent(in) :: dbl_storage_size Number of bytes needed to store single element (double precision) integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm User-defined communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) procedure, private, pass(self), non_overridable :: alloc_fft_plans Allocates fft_executor classes private  subroutine alloc_fft_plans (self, kinds) Allocates abstract_executor with required FFT class\nand populates fft_mapping with similar FFT ids Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform procedure, private, pass(self), non_overridable :: check_aux Checks if aux buffer was passed\nand if not will allocate one internally private  subroutine check_aux (self, aux) Checks if aux buffer was passed by user and if not will allocate one internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: aux Optional auxiliary buffer. procedure, private, pass(self), non_overridable :: mem_alloc_r32_1d Allocates memory for 1d real32 pointer private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r64_1d Allocates memory for 1d real64 pointer private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r32_2d Allocates memory for 2d real32 pointer private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r64_2d Allocates memory for 2d real64 pointer private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r32_3d Allocates memory for 2d real32 pointer private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r64_3d Allocates memory for 2d real64 pointer private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c32_1d Allocates memory for 1d complex32 pointer private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c64_1d Allocates memory for 1d complex64 pointer private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c32_2d Allocates memory for 2d complex32 pointer private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c64_2d Allocates memory for 2d complex64 pointer private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c32_3d Allocates memory for 3d complex32 pointer private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c64_3d Allocates memory for 3d complex64 pointer private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r32_1d Frees real32 1d pointer private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r64_1d Frees real64 1d pointer private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r32_2d Frees real32 2d pointer private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r64_2d Frees real64 2d pointer private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r32_3d Frees real32 3d pointer private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r64_3d Frees real64 3d pointer private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c32_1d Frees complex32 1d pointer private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c64_1d Frees complex64 1d pointer private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c32_2d Frees complex32 2d pointer private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c64_2d Frees complex64 2d pointer private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c32_3d Frees complex32 3d pointer private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c64_3d Frees complex64 3d pointer private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user","tags":"","loc":"type/dtfft_plan_t.html"},{"title":"dtfft_plan_c2c_t – dtFFT ","text":"type, public, extends( dtfft_core_c2c ) :: dtfft_plan_c2c_t C2C Plan Inherits type~~dtfft_plan_c2c_t~~InheritsGraph type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_t dtfft_plan_t type~dtfft_core_c2c->type~dtfft_plan_t MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~abstract_transpose_plan abstract_transpose_plan type~dtfft_plan_t->type~abstract_transpose_plan plan type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~backend_helper backend_helper type~abstract_transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~abstract_transpose_plan->type~dtfft_backend_t backend type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, dim, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dim Required dimension: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  subroutine mem_alloc_ptr (self, alloc_bytes, ptr, error_code) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) procedure, public, pass(self), non_overridable :: get_backend Returns selected GPU backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: create => create_c2c , create_c2c_pencil Creates C2C plan private  subroutine create_c2c (self, dims, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_c2c_pencil (self, pencil, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_c2c Creates C2C plan using global dimensions private  subroutine create_c2c (self, dims, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_c2c_pencil Creates C2C plan using Pencil of local data private  subroutine create_c2c_pencil (self, pencil, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_c2c_internal Private method that combines common logic for C2C plan creation private  function create_c2c_internal (self, dims, pencil, comm, precision, effort, executor) Private method that combines common logic for C2C plan creation Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32)","tags":"","loc":"type/dtfft_plan_c2c_t.html"},{"title":"dtfft_plan_r2c_t – dtFFT ","text":"type, public, extends( dtfft_core_c2c ) :: dtfft_plan_r2c_t R2C Plan Inherits type~~dtfft_plan_r2c_t~~InheritsGraph type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_r2c_t->type~dtfft_core_c2c type~pencil pencil type~dtfft_plan_r2c_t->type~pencil real_pencil type~dtfft_plan_t dtfft_plan_t type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_t->type~pencil pencils MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~abstract_transpose_plan abstract_transpose_plan type~dtfft_plan_t->type~abstract_transpose_plan plan type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~backend_helper backend_helper type~abstract_transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~abstract_transpose_plan->type~dtfft_backend_t backend type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->type~pencil pencils type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( pencil ), private :: real_pencil “Real” pencil decomposition info Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, dim, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dim Required dimension: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  subroutine mem_alloc_ptr (self, alloc_bytes, ptr, error_code) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) procedure, public, pass(self), non_overridable :: get_backend Returns selected GPU backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: create => create_r2c , create_r2c_pencil Creates R2C plan private  subroutine create_r2c (self, dims, executor, comm, precision, effort, error_code) R2C Generic Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2c_pencil (self, pencil, executor, comm, precision, effort, error_code) R2C Plan Constructor with pencil Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2c Creates R2C plan using global dimensions private  subroutine create_r2c (self, dims, executor, comm, precision, effort, error_code) R2C Generic Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2c_pencil Creates R2C plan using Pencil of local data private  subroutine create_r2c_pencil (self, pencil, executor, comm, precision, effort, error_code) R2C Plan Constructor with pencil Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2c_internal Private method that combines common logic for R2C plan creation private  function create_r2c_internal (self, executor, dims, pencil, comm, precision, effort) Private method that combines common logic for R2C plan creation Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan Return Value integer(kind=int32)","tags":"","loc":"type/dtfft_plan_r2c_t.html"},{"title":"dtfft_plan_r2r_t – dtFFT ","text":"type, public, extends( dtfft_plan_t ) :: dtfft_plan_r2r_t R2R Plan Inherits type~~dtfft_plan_r2r_t~~InheritsGraph type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_r2r_t->type~dtfft_plan_t MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~abstract_transpose_plan abstract_transpose_plan type~dtfft_plan_t->type~abstract_transpose_plan plan type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~backend_helper backend_helper type~abstract_transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~abstract_transpose_plan->type~dtfft_backend_t backend type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, dim, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dim Required dimension: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  subroutine mem_alloc_ptr (self, alloc_bytes, ptr, error_code) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) procedure, public, pass(self), non_overridable :: get_backend Returns selected GPU backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: create => create_r2r , create_r2r_pencil Creates R2R plan private  subroutine create_r2r (self, dims, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2r_pencil (self, pencil, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2r Creates R2R plan using global dimensions private  subroutine create_r2r (self, dims, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2r_pencil Creates R2R plan using Pencil of local data private  subroutine create_r2r_pencil (self, pencil, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2r_internal Private method that combines common logic for R2R plan creation private  function create_r2r_internal (self, dims, pencil, kinds, comm, precision, effort, executor) Creates plan for R2R plans Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32)","tags":"","loc":"type/dtfft_plan_r2r_t.html"},{"title":"fft_executor – dtFFT ","text":"type, private :: fft_executor FFT handle Inherits type~~fft_executor~~InheritsGraph type~fft_executor fft_executor type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~fft_executor~~InheritedByGraph type~fft_executor fft_executor type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~fft_executor fft type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( abstract_executor ), public, allocatable :: fft Executor","tags":"","loc":"type/fft_executor.html"},{"title":"dtfft_core_c2c – dtFFT ","text":"type, private, abstract, extends( dtfft_plan_t ) :: dtfft_core_c2c Abstract C2C Plan Inherits type~~dtfft_core_c2c~~InheritsGraph type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_t dtfft_plan_t type~dtfft_core_c2c->type~dtfft_plan_t MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~abstract_transpose_plan abstract_transpose_plan type~dtfft_plan_t->type~abstract_transpose_plan plan type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~backend_helper backend_helper type~abstract_transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~abstract_transpose_plan->type~dtfft_backend_t backend type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~dtfft_core_c2c~~InheritedByGraph type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, dim, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dim Required dimension: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  subroutine mem_alloc_ptr (self, alloc_bytes, ptr, error_code) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) procedure, public, pass(self), non_overridable :: get_backend Returns selected GPU backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: create_c2c_core Creates plan for both C2C and R2C private  function create_c2c_core (self, dims, pencil, comm, precision, effort, executor) Creates plan for both C2C and R2C Arguments Type Intent Optional Attributes Name class( dtfft_core_c2c ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32)","tags":"","loc":"type/dtfft_core_c2c.html"},{"title":"nvrtc_kernel – dtFFT ","text":"type, public :: nvrtc_kernel nvRTC Compiled kernel class Inherits type~~nvrtc_kernel~~InheritsGraph type~nvrtc_kernel nvrtc_kernel type~cufunction CUfunction type~nvrtc_kernel->type~cufunction cuda_kernel type~dim3 dim3 type~nvrtc_kernel->type~dim3 num_blocks, block_size type~kernelargs kernelArgs type~nvrtc_kernel->type~kernelargs args c_ptr c_ptr type~cufunction->c_ptr ptr type~kernelargs->c_ptr ptrs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~nvrtc_kernel~~InheritedByGraph type~nvrtc_kernel nvrtc_kernel type~abstract_backend abstract_backend type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 type~transpose_handle_cuda transpose_handle_cuda type~transpose_handle_cuda->type~nvrtc_kernel transpose_kernel, unpack_kernel, unpack_kernel2 type~transpose_handle_cuda->type~abstract_backend comm_handle type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, private :: is_created = .false. Kernel is created flag. logical, private :: is_dummy = .false. If kernel should do anything or not. type( CUfunction ), private :: cuda_kernel Pointer to CUDA kernel. type( dim3 ), private :: num_blocks Grid of blocks. type( dim3 ), private :: block_size Thread block. integer(kind=int8), private :: kernel_type Type of kernel to execute. type( kernelArgs ), private :: args Kernel arguments. integer(kind=int32), private, allocatable :: pointers (:,:) Optional pointers that hold info about counts and displacements\nin KERNEL_UNPACK_PIPELINED kernel. Type-Bound Procedures procedure, public, pass(self) :: create Creates kernel private  subroutine create (self, comm, dims, base_storage, transpose_type, kernel_type, pointers) Creates kernel Arguments Type Intent Optional Attributes Name class( nvrtc_kernel ), intent(inout) :: self nvRTC Compiled kernel class type(MPI_Comm), intent(in) :: comm MPI Communicator integer(kind=int32), intent(in), target :: dims (0:) Global dimensions to process integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition to perform integer(kind=int8), intent(in) :: kernel_type Type of kernel to build integer(kind=int32), intent(in), optional :: pointers (:,:) Optional pointers to unpack kernels procedure, public, pass(self) :: execute Executes kernel private  subroutine execute (self, in, out, stream, source) Executes kernel on stream Arguments Type Intent Optional Attributes Name class( nvrtc_kernel ), intent(inout) :: self nvRTC Compiled kernel class real(kind=real32), intent(in), target :: in (:) Source pointer real(kind=real32), intent(in), target :: out (:) Target pointer type( dtfft_stream_t ), intent(in) :: stream CUDA Stream integer(kind=int32), intent(in), optional :: source Source rank for pipelined unpacking procedure, public, pass(self) :: destroy Destroys kernel private  subroutine destroy (self) Destroys kernel Arguments Type Intent Optional Attributes Name class( nvrtc_kernel ), intent(inout) :: self nvRTC Compiled kernel class","tags":"","loc":"type/nvrtc_kernel.html"},{"title":"kernel_code – dtFFT ","text":"type, private :: kernel_code Class to build CUDA kernel code Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: raw String that holds CUDA code Type-Bound Procedures procedure, public, pass(self) :: to_cstr Converts Fortran CUDA code to C pointer private  subroutine to_cstr (self, c_code) Converts Fortran CUDA code to C pointer Arguments Type Intent Optional Attributes Name class( kernel_code ), intent(in) :: self Kernel code character(len=c_char), intent(out), allocatable :: c_code (:) C pointer to code procedure, public, pass(self) :: add_line Adds new line to CUDA code private  subroutine add_line (self, line) Adds new line to CUDA code Arguments Type Intent Optional Attributes Name class( kernel_code ), intent(inout) :: self Kernel code character(len=*), intent(in) :: line Line to add procedure, public, pass(self) :: destroy => destroy_code Frees all memory private  subroutine destroy_code (self) Frees all memory Arguments Type Intent Optional Attributes Name class( kernel_code ), intent(inout) :: self Kernel code","tags":"","loc":"type/kernel_code.html"},{"title":"nvrtc_cache – dtFFT ","text":"type, private :: nvrtc_cache Class to cache compiled kernels Inherits type~~nvrtc_cache~~InheritsGraph type~nvrtc_cache nvrtc_cache type~cufunction CUfunction type~nvrtc_cache->type~cufunction cuda_kernel type~cumodule CUmodule type~nvrtc_cache->type~cumodule cuda_module type~dtfft_transpose_t dtfft_transpose_t type~nvrtc_cache->type~dtfft_transpose_t transpose_type c_ptr c_ptr type~cufunction->c_ptr ptr type~cumodule->c_ptr ptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int32), private :: ref_count = 0 Number of references to this kernel type( CUmodule ), private :: cuda_module = CUmodule(c_null_ptr) Pointer to CUDA Module. type( CUfunction ), private :: cuda_kernel = CUfunction(c_null_ptr) Pointer to CUDA kernel. integer(kind=int8), private :: kernel_type Type of kernel to execute. type( dtfft_transpose_t ), private :: transpose_type Type of transpose integer(kind=int32), private :: tile_size Tile size of transpose kernel integer(kind=int64), private :: base_storage Number of bytes needed to store single element logical, private :: has_inner_loop If kernel has inner loop","tags":"","loc":"type/nvrtc_cache.html"},{"title":"string – dtFFT ","text":"type, public :: string Class used to create array of strings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: raw String Constructor public        interface string Creates string object private  function string_constructor (str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string )","tags":"","loc":"type/string.html"},{"title":"kernelArgs – dtFFT ","text":"type, public, bind(C) :: kernelArgs Arguments passed to nvrtc-compiled kernels Inherits type~~kernelargs~~InheritsGraph type~kernelargs kernelArgs c_ptr c_ptr type~kernelargs->c_ptr ptrs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~kernelargs~~InheritedByGraph type~kernelargs kernelArgs type~nvrtc_kernel nvrtc_kernel type~nvrtc_kernel->type~kernelargs args type~abstract_backend abstract_backend type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 type~transpose_handle_cuda transpose_handle_cuda type~transpose_handle_cuda->type~nvrtc_kernel transpose_kernel, unpack_kernel, unpack_kernel2 type~transpose_handle_cuda->type~abstract_backend comm_handle type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: n_ints = 0 Number of integers provided integer(kind=c_int), public :: ints (5) Integer array integer(kind=c_int), public :: n_ptrs = 0 Number of pointers provided type(c_ptr), public :: ptrs (3) Pointer array","tags":"","loc":"type/kernelargs.html"},{"title":"CUmodule – dtFFT ","text":"type, public, bind(C) :: CUmodule CUDA module Inherits type~~cumodule~~InheritsGraph type~cumodule CUmodule c_ptr c_ptr type~cumodule->c_ptr ptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~cumodule~~InheritedByGraph type~cumodule CUmodule type~nvrtc_cache nvrtc_cache type~nvrtc_cache->type~cumodule cuda_module Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr Actual pointer","tags":"","loc":"type/cumodule.html"},{"title":"CUfunction – dtFFT ","text":"type, public, bind(C) :: CUfunction CUDA function Inherits type~~cufunction~~InheritsGraph type~cufunction CUfunction c_ptr c_ptr type~cufunction->c_ptr ptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~cufunction~~InheritedByGraph type~cufunction CUfunction type~nvrtc_cache nvrtc_cache type~nvrtc_cache->type~cufunction cuda_kernel type~nvrtc_kernel nvrtc_kernel type~nvrtc_kernel->type~cufunction cuda_kernel type~abstract_backend abstract_backend type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 type~transpose_handle_cuda transpose_handle_cuda type~transpose_handle_cuda->type~nvrtc_kernel transpose_kernel, unpack_kernel, unpack_kernel2 type~transpose_handle_cuda->type~abstract_backend comm_handle type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr Actual pointer","tags":"","loc":"type/cufunction.html"},{"title":"ncclUniqueId – dtFFT ","text":"type, public, bind(c) :: ncclUniqueId Components Type Visibility Attributes Name Initial character(len=c_char), public :: internal (128)","tags":"","loc":"type/nccluniqueid.html"},{"title":"ncclComm – dtFFT ","text":"type, public, bind(c) :: ncclComm Inherits type~~ncclcomm~~InheritsGraph type~ncclcomm ncclComm c_ptr c_ptr type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~ncclcomm~~InheritedByGraph type~ncclcomm ncclComm type~backend_helper backend_helper type~backend_helper->type~ncclcomm nccl_comm type~backend_nccl backend_nccl type~backend_nccl->type~ncclcomm nccl_comm type~abstract_transpose_plan abstract_transpose_plan type~abstract_transpose_plan->type~backend_helper helper type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~abstract_transpose_plan plan type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~abstract_transpose_plan type~transpose_plan_host transpose_plan_host type~transpose_plan_host->type~abstract_transpose_plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: member","tags":"","loc":"type/ncclcomm.html"},{"title":"ncclDataType – dtFFT ","text":"type, public, bind(c) :: ncclDataType Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: member","tags":"","loc":"type/nccldatatype.html"},{"title":"backend_nccl – dtFFT ","text":"type, public, extends( abstract_backend ) :: backend_nccl NCCL backend Inherits type~~backend_nccl~~InheritsGraph type~backend_nccl backend_nccl type~abstract_backend abstract_backend type~backend_nccl->type~abstract_backend type~ncclcomm ncclComm type~backend_nccl->type~ncclcomm nccl_comm MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream type~nvrtc_kernel nvrtc_kernel type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 c_ptr c_ptr type~ncclcomm->c_ptr member type~cudaevent->c_ptr event type~dtfft_stream_t->c_ptr stream type~cufunction CUfunction type~nvrtc_kernel->type~cufunction cuda_kernel type~dim3 dim3 type~nvrtc_kernel->type~dim3 num_blocks, block_size type~kernelargs kernelArgs type~nvrtc_kernel->type~kernelargs args type~cufunction->c_ptr ptr type~kernelargs->c_ptr ptrs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer type( nvrtc_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), public, pointer :: unpack_kernel2 Kernel for unpacking data type( ncclComm ), private :: nccl_comm NCCL Communicator Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates Abstract GPU Backend private  subroutine create (self, backend, tranpose_type, helper, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend type( dtfft_backend_t ), intent(in) :: backend GPU Backend type type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public, non_overridable, pass(self) :: execute Executes GPU Backend private  subroutine execute (self, in, out, stream, aux) Executes GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer procedure, public, non_overridable, pass(self) :: destroy Destroys Abstract GPU Backend private  subroutine destroy (self) Destroys Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU backend procedure, public, non_overridable, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private  function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract GPU backend Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: set_unpack_kernel Sets unpack kernel for pipelined backend private  subroutine set_unpack_kernel (self, unpack_kernel, unpack_kernel2) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend type( nvrtc_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), intent(in), optional, target :: unpack_kernel2 Kernel for unpacking data procedure, public :: create_private => create_nccl Creates NCCL backend private  subroutine create_nccl (self, helper, tranpose_type, base_storage) Creates NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create (unused) integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) procedure, public :: execute_private => execute_nccl Executes NCCL backend private  subroutine execute_nccl (self, in, out, stream, aux) Executes NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Auxiliary pointer procedure, public :: destroy_private => destroy_nccl Destroys NCCL backend private  subroutine destroy_nccl (self) Destroys NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend","tags":"","loc":"type/backend_nccl.html"},{"title":"transpose_handle_cuda – dtFFT ","text":"type, public :: transpose_handle_cuda CUDA Transpose Handle Inherits type~~transpose_handle_cuda~~InheritsGraph type~transpose_handle_cuda transpose_handle_cuda type~abstract_backend abstract_backend type~transpose_handle_cuda->type~abstract_backend comm_handle type~dtfft_transpose_t dtfft_transpose_t type~transpose_handle_cuda->type~dtfft_transpose_t transpose_type type~nvrtc_kernel nvrtc_kernel type~transpose_handle_cuda->type~nvrtc_kernel transpose_kernel, unpack_kernel, unpack_kernel2 type~abstract_backend->type~nvrtc_kernel unpack_kernel, unpack_kernel2 MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream type~cufunction CUfunction type~nvrtc_kernel->type~cufunction cuda_kernel type~dim3 dim3 type~nvrtc_kernel->type~dim3 num_blocks, block_size type~kernelargs kernelArgs type~nvrtc_kernel->type~kernelargs args c_ptr c_ptr type~cudaevent->c_ptr event type~cufunction->c_ptr ptr type~dtfft_stream_t->c_ptr stream type~kernelargs->c_ptr ptrs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~transpose_handle_cuda~~InheritedByGraph type~transpose_handle_cuda transpose_handle_cuda type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~transpose_handle_cuda fplans, bplans Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_transpose_t ), private :: transpose_type logical, private :: has_exchange = .false. If current handle has exchanges between GPUs logical, private :: is_pipelined = .false. If underlying exchanges are pipelined type( nvrtc_kernel ), private :: transpose_kernel Transposes data type( nvrtc_kernel ), private :: unpack_kernel Unpacks data type( nvrtc_kernel ), private :: unpack_kernel2 class( abstract_backend ), private, allocatable :: comm_handle Communication handle Type-Bound Procedures procedure, public, pass(self) :: create Creates CUDA Transpose Handle private  subroutine create (self, helper, send, recv, base_storage, backend) Creates CUDA Transpose Handle Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(inout) :: self CUDA Transpose Handle type( backend_helper ), intent(in) :: helper Backend helper type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_backend_t ), intent(in) :: backend Backend type procedure, public, pass(self) :: execute Executes transpose - exchange - unpack private  subroutine execute (self, in, out, stream, aux) Executes transpose - exchange - unpack Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(inout) :: self CUDA Transpose Handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer procedure, public, pass(self) :: destroy Destroys CUDA Transpose Handle private  subroutine destroy (self) Destroys CUDA Transpose Handle Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(inout) :: self CUDA Transpose Handle procedure, public, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private  function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(in) :: self CUDA Transpose Handle Return Value integer(kind=int64) procedure, public, pass(self) :: get_tranpose_type Returns transpose_type, associated with handle private  function get_tranpose_type (self) result(tranpose_type) Returns transpose_type, associated with handle Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(in) :: self CUDA Transpose Handle Return Value type( dtfft_transpose_t )","tags":"","loc":"type/transpose_handle_cuda.html"},{"title":"data_handle – dtFFT ","text":"type, private :: data_handle Helper class used to obtain displacements and \ncounts needed to send to other processes Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: ls (:,:) Starts of my data that I should send or recv\nwhile communicating with other processes integer(kind=int32), public, allocatable :: ln (:,:) Counts of my data that I should send or recv\nwhile communicating with other processes integer(kind=int32), public, allocatable :: sizes (:,:) Counts of every rank in a comm integer(kind=int32), public, allocatable :: starts (:,:) Starts of every rank in a comm integer(kind=int32), public, allocatable :: displs (:) Local buffer displacement integer(kind=int32), public, allocatable :: counts (:) Number of elements to send or recv Type-Bound Procedures procedure, public, pass(self) :: create => create_data_handle Creates handle private  subroutine create_data_handle (self, info, comm, comm_size) Creates handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class type( pencil ), intent(in) :: info Pencil info type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int32), intent(in) :: comm_size Size of comm procedure, public, pass(self) :: destroy => destroy_data_handle Destroys handle private  subroutine destroy_data_handle (self) Destroys handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class","tags":"","loc":"type/data_handle.html"},{"title":"dtfft_pencil_t – dtFFT ","text":"type, public :: dtfft_pencil_t Structure to hold pencil decomposition info Components Type Visibility Attributes Name Initial integer(kind=int8), public :: dim Aligned dimension id integer(kind=int8), public :: ndims = 0 Number of dimensions integer(kind=int32), public, allocatable :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), public, allocatable :: counts (:) Local counts of data, in elements integer(kind=int64), public :: size Total number of elements in a pencil logical, private :: is_created = .false. Is pencil created Constructor public        interface dtfft_pencil_t Type bound constuctor for dtfft_pencil_t private  function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t ) Finalization Procedures final :: destroy_pencil_t private  subroutine destroy_pencil_t (self) Destroys pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_t ), intent(inout) :: self Public pencil Type-Bound Procedures procedure, private, pass(self) :: destroy => destroy_pencil_t_private private  subroutine destroy_pencil_t_private (self) Destroys pencil Arguments Type Intent Optional Attributes Name class( dtfft_pencil_t ), intent(inout) :: self Public pencil","tags":"","loc":"type/dtfft_pencil_t.html"},{"title":"dtfft_pencil_c – dtFFT ","text":"type, public, bind(C) :: dtfft_pencil_c Structure to hold pencil decomposition info Components Type Visibility Attributes Name Initial integer(kind=c_int8_t), public :: dim Aligned dimension id integer(kind=c_int8_t), public :: ndims Number of dimensions integer(kind=c_int32_t), public :: starts (3) Local starts, starting from 0 for both C and Fortran integer(kind=c_int32_t), public :: counts (3) Local counts of data, in elements integer(kind=c_size_t), public :: size Total number of elements in a pencil","tags":"","loc":"type/dtfft_pencil_c.html"},{"title":"pencil – dtFFT ","text":"type, public :: pencil Class that describes information about data layout Inherited by type~~pencil~~InheritedByGraph type~pencil pencil type~backend_helper backend_helper type~backend_helper->type~pencil pencils type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~pencil real_pencil type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_r2c_t->type~dtfft_core_c2c type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~pencil pencils type~abstract_transpose_plan abstract_transpose_plan type~dtfft_plan_t->type~abstract_transpose_plan plan type~abstract_transpose_plan->type~backend_helper helper type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~abstract_transpose_plan type~transpose_plan_host transpose_plan_host type~transpose_plan_host->type~abstract_transpose_plan Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int8), public :: aligned_dim Position of aligned dimension. For example: X pencil aligned_dim = 1, Z pencil aligned_dim = 3 integer(kind=int8), public :: rank Rank of buffer: 2 or 3 integer(kind=int32), public, allocatable :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), public, allocatable :: counts (:) Local counts of data, in elements logical, public :: is_even Is data evenly distributed across processes Type-Bound Procedures procedure, public, pass(self) :: create Creates pencil private  subroutine create (self, rank, aligned_dim, counts, comms, lstarts, lcounts) Creates pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil integer(kind=int8), intent(in) :: rank Rank of buffer integer(kind=int8), intent(in) :: aligned_dim Position of aligned dimension integer(kind=int32), intent(in) :: counts (:) Global counts type(MPI_Comm), intent(in) :: comms (:) Grid communicators integer(kind=int32), intent(in), optional :: lstarts (:) Local starts integer(kind=int32), intent(in), optional :: lcounts (:) Local counts procedure, public, pass(self) :: destroy Destroys pencil private  subroutine destroy (self) Destroys pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil procedure, public, pass(self) :: make_public Creates public object that users can use to create own FFT backends private  function make_public (self) Creates public object that users can use to create own FFT backends Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: self Pencil Return Value type( dtfft_pencil_t )","tags":"","loc":"type/pencil.html"},{"title":"pencil_init – dtFFT ","text":"type, public :: pencil_init Class that describes information about data layout It is an extension of dtfft_pencil_t with additional fields Inherits type~~pencil_init~~InheritsGraph type~pencil_init pencil_init MPI_Comm MPI_Comm type~pencil_init->MPI_Comm comms Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(MPI_Comm), public, allocatable :: comms (:) 1D communicators for each dimension integer(kind=int32), public, allocatable :: starts (:) Local starts integer(kind=int32), public, allocatable :: counts (:) Local counts integer(kind=int32), public, allocatable :: dims (:) Global dimensions of entire region Type-Bound Procedures procedure, public, pass(self) :: create => create_pencil_init Creates and validates pencil passed by user to plan constructors private  function create_pencil_init (self, pencil, comm) result(error_code) Creates and validates pencil passed by user to plan constructors Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t type( dtfft_pencil_t ), intent(in) :: pencil Pencil passed by user to plan constructors type(MPI_Comm), intent(in) :: comm MPI Communicator passed to plan constructors Return Value integer(kind=int32) Error code procedure, public, pass(self) :: destroy => destroy_pencil_init Destroys pencil_init private  subroutine destroy_pencil_init (self) Destroys pencil_init Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t","tags":"","loc":"type/pencil_init.html"},{"title":"transpose_handle_host – dtFFT ","text":"type, public :: transpose_handle_host Transposition class Inherits type~~transpose_handle_host~~InheritsGraph type~transpose_handle_host transpose_handle_host MPI_Comm MPI_Comm type~transpose_handle_host->MPI_Comm comm MPI_Request MPI_Request type~transpose_handle_host->MPI_Request request type~handle_t handle_t type~transpose_handle_host->type~handle_t send, recv MPI_Datatype MPI_Datatype type~handle_t->MPI_Datatype dtypes Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~transpose_handle_host~~InheritedByGraph type~transpose_handle_host transpose_handle_host type~transpose_plan_host transpose_plan_host type~transpose_plan_host->type~transpose_handle_host fplans, bplans Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(MPI_Comm), private :: comm 1d communicator logical, private :: is_even Is decomposition even type( handle_t ), private :: send Handle to send data type( handle_t ), private :: recv Handle to recieve data type(MPI_Request), private :: request Request for persistent communication logical, private :: is_request_created Is request created Type-Bound Procedures procedure, public, pass(self) :: create Initializes class private  subroutine create (self, comm, send, recv, base_type, base_storage, datatype_id) Creates transpose_handle_host class Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm 1d communicator class( pencil ), intent(in) :: send Information about send buffer class( pencil ), intent(in) :: recv Information about recv buffer type(MPI_Datatype), intent(in) :: base_type Base MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int8), intent(in) :: datatype_id Type of datatype to use procedure, public, pass(self) :: execute Performs MPI_Alltoall(w) private  subroutine execute (self, send, recv) Executes transposition Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class real(kind=real32), intent(in) :: send (:) Incoming buffer real(kind=real32), intent(inout) :: recv (:) Resulting buffer procedure, public, pass(self) :: destroy Destroys class private  subroutine destroy (self) Destroys transpose_handle_host class Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class procedure, private, pass(self) :: create_transpose_2d Creates two-dimensional transposition datatypes private  subroutine create_transpose_2d (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates two-dimensional transposition datatypes Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element procedure, private, pass(self) :: create_transpose_XY Creates three-dimensional X –> Y, Y –> X transposition datatypes private  subroutine create_transpose_XY (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional X –> Y, Y –> X transposition datatypes Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element procedure, private, pass(self) :: create_transpose_YZ Creates three-dimensional Y –> Z, Z –> Y transposition datatypes private  subroutine create_transpose_YZ (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional Y –> Z, Z –> Y transposition datatypes Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element procedure, private, pass(self) :: create_transpose_XZ Creates three-dimensional X –> Z datatype, only slab! private  subroutine create_transpose_XZ (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional X –> Z transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element procedure, private, pass(self) :: create_transpose_ZX Creates three-dimensional Z –> X datatype, only slab! private  subroutine create_transpose_ZX (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional Z –> X transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element","tags":"","loc":"type/transpose_handle_host.html"},{"title":"handle_t – dtFFT ","text":"type, private :: handle_t Transposition handle class Inherits type~~handle_t~~InheritsGraph type~handle_t handle_t MPI_Datatype MPI_Datatype type~handle_t->MPI_Datatype dtypes Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~handle_t~~InheritedByGraph type~handle_t handle_t type~transpose_handle_host transpose_handle_host type~transpose_handle_host->type~handle_t send, recv type~transpose_plan_host transpose_plan_host type~transpose_plan_host->type~transpose_handle_host fplans, bplans Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(MPI_Datatype), public, allocatable :: dtypes (:) Datatypes buffer integer(kind=int32), public, allocatable :: counts (:) Number of datatypes (always equals 1) integer(kind=int32), public, allocatable :: displs (:) Displacements is bytes Type-Bound Procedures procedure, public, pass(self) :: create => create_handle Creates transposition handle private  subroutine create_handle (self, n) Creates transposition handle Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle integer(kind=int32), intent(in) :: n Number of datatypes to be created procedure, public, pass(self) :: destroy => destroy_handle Destroys transposition handle private  subroutine destroy_handle (self) Destroys transposition handle Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle","tags":"","loc":"type/handle_t.html"},{"title":"abstract_transpose_plan – dtFFT ","text":"type, public, abstract :: abstract_transpose_plan The most Abstract Transpose Plan Inherits type~~abstract_transpose_plan~~InheritsGraph type~abstract_transpose_plan abstract_transpose_plan type~backend_helper backend_helper type~abstract_transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~abstract_transpose_plan->type~dtfft_backend_t backend MPI_Comm MPI_Comm type~backend_helper->MPI_Comm comms c_ptr c_ptr type~backend_helper->c_ptr nccl_register type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~pencil pencil type~backend_helper->type~pencil pencils type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~abstract_transpose_plan~~InheritedByGraph type~abstract_transpose_plan abstract_transpose_plan type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~abstract_transpose_plan plan type~transpose_plan_cuda transpose_plan_cuda type~transpose_plan_cuda->type~abstract_transpose_plan type~transpose_plan_host transpose_plan_host type~transpose_plan_host->type~abstract_transpose_plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend = DTFFT_BACKEND_MPI_DATATYPE GPU backend type( backend_helper ), public :: helper Backend helper logical, public :: is_z_slab Z-slab optimization flag (for 3D transforms) integer(kind=int64), public :: min_buffer_size Minimal buffer size for transposition Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Create transposition plan private  function create (self, dims, base_comm, effort, base_dtype, base_storage, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plans Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code procedure, public, non_overridable, pass(self) :: execute Executes transposition private  subroutine execute (self, in, out, transpose_type) Executes single transposition Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming pointer type(c_ptr), intent(in) :: out Result pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose procedure, public, pass(self) :: get_aux_size Returns auxiliary buffer size private  function get_aux_size (self) result(aux_size) Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(in) :: self Transposition class Return Value integer(kind=int64) procedure( create_interface ), public, deferred, pass(self) :: create_private Creates overriding class function create_interface(self, dims, transposed_dims, base_comm, comm_dims, effort, base_dtype, base_storage, is_custom_cart_comm, cart_comm, comms, pencils, ipencil) result(error_code) Prototype Creates transposition plans Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base MPI communicator integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_custom_cart_comm Custom cartesian communicator provided by user type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code procedure( execute_interface ), public, deferred, pass(self) :: execute_private Executes overriding class subroutine execute_interface(self, in, out, transpose_type) Prototype Executes single transposition Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class real(kind=real32), intent(inout) :: in (:) Incoming buffer real(kind=real32), intent(inout) :: out (:) Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroys overriding class subroutine destroy_interface(self) Prototype Destroys transposition plans Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class procedure, public, non_overridable, pass(self) :: get_backend Returns backend id private  function get_backend (self) Returns plan GPU backend Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(in) :: self Transposition class Return Value type( dtfft_backend_t ) procedure, public, non_overridable, pass(self) :: mem_alloc Allocates memory based on selected backend private  subroutine mem_alloc (self, comm, alloc_bytes, ptr, error_code) Allocates memory based on selected backend Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code procedure, public, non_overridable, pass(self) :: mem_free Frees memory allocated with mem_alloc private  subroutine mem_free (self, ptr, error_code) Frees memory allocated with mem_alloc Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code","tags":"","loc":"type/abstract_transpose_plan.html"},{"title":"dtfft_config_t – dtFFT ","text":"type, public, bind(C) :: dtfft_config_t Type that can be used to set additional configuration parameters to dtFFT Inherits type~~dtfft_config_t~~InheritsGraph type~dtfft_config_t dtfft_config_t type~dtfft_backend_t dtfft_backend_t type~dtfft_config_t->type~dtfft_backend_t backend type~dtfft_platform_t dtfft_platform_t type~dtfft_config_t->type~dtfft_platform_t platform type~dtfft_stream_t dtfft_stream_t type~dtfft_config_t->type~dtfft_stream_t stream c_ptr c_ptr type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical(kind=c_bool), public :: enable_z_slab Should dtFFT use Z-slab optimization or not. Default is true. One should consider disabling Z-slab optimization in order to resolve DTFFT_ERROR_VKFFT_R2R_2D_PLAN error \nOR when underlying FFT implementation of 2D plan is too slow.\nIn all other cases it is considered that Z-slab is always faster, since it reduces number of data transpositions. type( dtfft_platform_t ), public :: platform Selects platform to execute plan. Default is DTFFT_PLATFORM_HOST This option is only defined with device support build.\nEven when dtFFT is build with device support it does not nessasary means that all plans must be related to device.\nThis enables single library installation to be compiled with both host, CUDA and HIP plans. type( dtfft_stream_t ), public :: stream Main CUDA stream that will be used in dtFFT. This parameter is a placeholder for user to set custom stream. Stream that is actually used by dtFFT plan is returned by plan%get_stream function. When user sets stream he is responsible of destroying it. Stream must not be destroyed before call to plan%destroy . type( dtfft_backend_t ), public :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . Default is DTFFT_GPU_BACKEND_NCCL if NCCL is enabled, otherwise DTFFT_BACKEND_MPI_P2P . logical(kind=c_bool), public :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. Default is false. MPI Backends are disabled by default during autotuning process due to OpenMPI Bug https://github.com/open-mpi/ompi/issues/12849\nIt was noticed that during plan autotuning GPU memory not being freed completely.\nFor example:\n1024x1024x512 C2C, double precision, single GPU, using Z-slab optimization, with MPI backends enabled, plan autotuning will leak 8Gb GPU memory.\nWithout Z-slab optimization, running on 4 GPUs, will leak 24Gb on each of the GPUs. One of the workarounds is to disable MPI Backends by default, which is done here. Other is to pass “–mca btl_smcuda_use_cuda_ipc 0” to mpiexec ,\nbut it was noticed that disabling CUDA IPC seriously affects overall performance of MPI algorithms logical(kind=c_bool), public :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. Default is true. Pipelined backends require additional buffer that user has no control over. logical(kind=c_bool), public :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. Default is true. logical(kind=c_bool), public :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. Default is true. Constructor public        interface dtfft_config_t Interface to create a new configuration private pure function config_constructor (enable_z_slab, platform, stream, backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config","tags":"","loc":"type/dtfft_config_t.html"},{"title":"plan_c – dtFFT ","text":"type, private :: plan_c C pointer to Fortran plan Inherits type~~plan_c~~InheritsGraph type~plan_c plan_c type~dtfft_plan_t dtfft_plan_t type~plan_c->type~dtfft_plan_t p MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~abstract_transpose_plan abstract_transpose_plan type~dtfft_plan_t->type~abstract_transpose_plan plan type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~backend_helper backend_helper type~abstract_transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~abstract_transpose_plan->type~dtfft_backend_t backend type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( dtfft_plan_t ), public, allocatable :: p Actual Fortran plan","tags":"","loc":"type/plan_c.html"},{"title":"create_interface – dtFFT","text":"interface private  subroutine create_interface(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Description Creates FFT plan","tags":"","loc":"interface/create_interface.html"},{"title":"execute_interface – dtFFT","text":"interface private  subroutine execute_interface(self, a, b, sign) Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform Description Executes plan","tags":"","loc":"interface/execute_interface.html"},{"title":"destroy_interface – dtFFT","text":"interface private  subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor Description Destroys plan","tags":"","loc":"interface/destroy_interface.html"},{"title":"mem_alloc_interface – dtFFT","text":"interface private  subroutine mem_alloc_interface(alloc_bytes, ptr) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer Description Allocates aligned memory","tags":"","loc":"interface/mem_alloc_interface.html"},{"title":"mem_free_interface – dtFFT","text":"interface private  subroutine mem_free_interface(ptr) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free Description Frees aligned memory","tags":"","loc":"interface/mem_free_interface.html"},{"title":"vkfft_create_interface – dtFFT","text":"interface private  subroutine vkfft_create_interface(rank, dims, double_precision, how_many, r2c, c2r, dct, dst, stream, app_handle) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), value :: rank Rank of fft: 1 or 2 integer(kind=c_int) :: dims (*) Dimensions of transform integer(kind=c_int), value :: double_precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=c_int), value :: how_many Number of transforms to create integer(kind=c_int8_t), value :: r2c Is R2C transform required integer(kind=c_int8_t), value :: c2r Is C2R transform required integer(kind=c_int8_t), value :: dct Is DCT transform required integer(kind=c_int8_t), value :: dst Is DST transform required type( dtfft_stream_t ), value :: stream CUDA stream type(c_ptr) :: app_handle vkFFT application handle Description Creates FFT plan via vkFFT Interface","tags":"","loc":"interface/vkfft_create_interface.html"},{"title":"vkfft_execute_interface – dtFFT","text":"interface private  subroutine vkfft_execute_interface(app_handle, in, out, sign) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: app_handle vkFFT application handle type(c_ptr), value :: in Input data type(c_ptr), value :: out Output data integer(kind=c_int8_t), value :: sign Sign of FFT Description Executes vkFFT plan","tags":"","loc":"interface/vkfft_execute_interface.html"},{"title":"vkfft_destroy_interface – dtFFT","text":"interface private  subroutine vkfft_destroy_interface(app_handle) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: app_handle vkFFT application handle Description Destroys vkFFT plan","tags":"","loc":"interface/vkfft_destroy_interface.html"},{"title":"nvrtcGetErrorString_interface – dtFFT","text":"interface private  function nvrtcGetErrorString_interface(error_code) result(string) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: error_code CUDA Runtime Compilation API result code. Return Value type(c_ptr) Pointer to C string Description Helper function that returns a string describing the given nvrtcResult code\nFor unrecognized enumeration values, it returns “NVRTC_ERROR unknown”","tags":"","loc":"interface/nvrtcgeterrorstring_interface.html"},{"title":"nvrtcCreateProgram_interface – dtFFT","text":"interface private  function nvrtcCreateProgram_interface(prog, src, name, numHeaders, headers, includeNames) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ) :: prog CUDA Runtime Compilation program. character(len=c_char) :: src (*) CUDA program source. character(len=c_char) :: name (*) CUDA program name. integer(kind=c_int), value :: numHeaders Number of headers used. Must be greater than or equal to 0. type(c_ptr), value :: headers Sources of the headers type(c_ptr), value :: includeNames Name of each header by which they can be included in the CUDA program source Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Creates an instance of nvrtcProgram with the given input parameters, \nand sets the output parameter prog with it.","tags":"","loc":"interface/nvrtccreateprogram_interface.html"},{"title":"nvrtcDestroyProgram_interface – dtFFT","text":"interface private  function nvrtcDestroyProgram_interface(prog) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ) :: prog CUDA Runtime Compilation program. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Destroys the given program.","tags":"","loc":"interface/nvrtcdestroyprogram_interface.html"},{"title":"nvrtcCompileProgram_interface – dtFFT","text":"interface private  function nvrtcCompileProgram_interface(prog, numOptions, options) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_int), value :: numOptions Number of compiler options passed. type(c_ptr) :: options (*) Compiler options in the form of C string array Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Compiles the given program.","tags":"","loc":"interface/nvrtccompileprogram_interface.html"},{"title":"nvrtcGetProgramLog_interface – dtFFT","text":"interface private  function nvrtcGetProgramLog_interface(prog, log) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. type(c_ptr), value :: log Compilation log. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Stores the log generated by the previous compilation of prog in the memory pointed by log","tags":"","loc":"interface/nvrtcgetprogramlog_interface.html"},{"title":"nvrtcGetCUBINSize_interface – dtFFT","text":"interface private  function nvrtcGetCUBINSize_interface(prog, cubinSizeRet) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_size_t) :: cubinSizeRet Size of the generated cubin. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Sets the value of cubinSizeRet with the size of the cubin generated by the previous compilation of prog .","tags":"","loc":"interface/nvrtcgetcubinsize_interface.html"},{"title":"nvrtcGetCUBIN_interface – dtFFT","text":"interface private  function nvrtcGetCUBIN_interface(prog, cubin) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. character(len=c_char) :: cubin (*) Compiled and assembled result. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Stores the cubin generated by the previous compilation of prog in the memory pointed by cubin .","tags":"","loc":"interface/nvrtcgetcubin_interface.html"},{"title":"create_c2c_plan – dtFFT","text":"interface private  function create_c2c_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2C FFTW3 Plan","tags":"","loc":"interface/create_c2c_plan.html"},{"title":"create_r2c_plan – dtFFT","text":"interface private  function create_r2c_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2C FFTW3 Plan","tags":"","loc":"interface/create_r2c_plan.html"},{"title":"create_r2r_plan – dtFFT","text":"interface private  function create_r2r_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kinds, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kinds (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2R FFTW3 Plan","tags":"","loc":"interface/create_r2r_plan.html"},{"title":"apply_interface – dtFFT","text":"interface private  subroutine apply_interface(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes FFTW3 Plan","tags":"","loc":"interface/apply_interface.html"},{"title":"free_interface – dtFFT","text":"interface private  subroutine free_interface(plan) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Description Destroys FFTW3 Plan","tags":"","loc":"interface/free_interface.html"},{"title":"create_interface – dtFFT","text":"interface private  subroutine create_interface(self, helper, tranpose_type, base_storage) Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element Description Creates overring class","tags":"","loc":"interface/create_interface~2.html"},{"title":"execute_interface – dtFFT","text":"interface private  subroutine execute_interface(self, in, out, stream, aux) Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer Description Executes GPU Backend","tags":"","loc":"interface/execute_interface~2.html"},{"title":"destroy_interface – dtFFT","text":"interface private  subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend Description Destroys overring class","tags":"","loc":"interface/destroy_interface~2.html"},{"title":"cuModuleLoadDataEx_interface – dtFFT","text":"interface private  function cuModuleLoadDataEx_interface(mod, image, numOptions, options, optionValues) result(cuResult) Arguments Type Intent Optional Attributes Name type( CUmodule ) :: mod Returned module character(len=c_char) :: image (*) Module data to load integer(kind=c_int), value :: numOptions Number of options type(c_ptr), value :: options Options for JIT type(c_ptr) :: optionValues Option values for JIT Return Value integer(kind=c_int) Driver result code Description Load a module’s data with options. Takes a pointer image and loads the corresponding module module into the current context. \nThe image may be a cubin or fatbin as output by nvcc, or a NULL-terminated PTX, either as output by nvcc or hand-written.","tags":"","loc":"interface/cumoduleloaddataex_interface.html"},{"title":"cuModuleUnload_interface – dtFFT","text":"interface private  function cuModuleUnload_interface(hmod) result(cuResult) Arguments Type Intent Optional Attributes Name type( CUmodule ), value :: hmod Module to unload Return Value integer(kind=c_int) Driver result code Description Unloads a module. Unloads a module hmod from the current context. \nAttempting to unload a module which was obtained from the Library Management API \nsuch as cuLibraryGetModule will return CUDA_ERROR_NOT_PERMITTED .","tags":"","loc":"interface/cumoduleunload_interface.html"},{"title":"cuModuleGetFunction_interface – dtFFT","text":"interface private  function cuModuleGetFunction_interface(hfunc, hmod, name) result(cuResult) Arguments Type Intent Optional Attributes Name type( CUfunction ) :: hfunc Returns a function handle. type( CUmodule ), value :: hmod Module to retrieve function from character(len=c_char) :: name (*) Name of function to retrieve Return Value integer(kind=c_int) Driver result code Description Returns a function handle. Returns in hfunc the handle of the function of name name located in module hmod.\nIf no function of that name exists, cuModuleGetFunction returns CUDA_ERROR_NOT_FOUND .","tags":"","loc":"interface/cumodulegetfunction_interface.html"},{"title":"create_interface – dtFFT","text":"interface private  function create_interface(self, dims, transposed_dims, base_comm, comm_dims, effort, base_dtype, base_storage, is_custom_cart_comm, cart_comm, comms, pencils, ipencil) result(error_code) Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base MPI communicator integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_custom_cart_comm Custom cartesian communicator provided by user type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code Description Creates transposition plans","tags":"","loc":"interface/create_interface~3.html"},{"title":"execute_interface – dtFFT","text":"interface private  subroutine execute_interface(self, in, out, transpose_type) Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class real(kind=real32), intent(inout) :: in (:) Incoming buffer real(kind=real32), intent(inout) :: out (:) Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose Description Executes single transposition","tags":"","loc":"interface/execute_interface~3.html"},{"title":"destroy_interface – dtFFT","text":"interface private  subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class Description Destroys transposition plans","tags":"","loc":"interface/destroy_interface~3.html"},{"title":"create – dtFFT","text":"private  function create(self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Type Bound abstract_executor Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) Calls proc~~create~~CallsGraph proc~create abstract_executor%create create_private create_private proc~create->create_private is_null_ptr is_null_ptr proc~create->is_null_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, sign) Executes plan Type Bound abstract_executor Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform Calls proc~~execute~~CallsGraph proc~execute abstract_executor%execute execute_private execute_private proc~execute->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys plan Type Bound abstract_executor Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor Calls proc~~destroy~~CallsGraph proc~destroy abstract_executor%destroy destroy_private destroy_private proc~destroy->destroy_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, helper, tranpose_type, base_storage) Uses iso_c_binding iso_fortran_env proc~~create~2~~UsesGraph proc~create~2 backend_cufftmp%create iso_c_binding iso_c_binding proc~create~2->iso_c_binding iso_fortran_env iso_fortran_env proc~create~2->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates cuFFTMp GPU Backend Type Bound backend_cufftmp Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element Calls proc~~create~2~~CallsGraph proc~create~2 backend_cufftmp%create interface~comm_f2c Comm_f2c proc~create~2->interface~comm_f2c interface~cufftmpattachreshapecomm cufftMpAttachReshapeComm proc~create~2->interface~cufftmpattachreshapecomm interface~cufftmpcreatereshape cufftMpCreateReshape proc~create~2->interface~cufftmpcreatereshape interface~cufftmpgetreshapesize cufftMpGetReshapeSize proc~create~2->interface~cufftmpgetreshapesize interface~cufftmpmakereshape cufftMpMakeReshape proc~create~2->interface~cufftmpmakereshape interface~int_to_str int_to_str proc~create~2->interface~int_to_str mpi_abort mpi_abort proc~create~2->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~create~2->proc~cufftgeterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~2.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, stream, aux) Uses iso_c_binding iso_fortran_env proc~~execute~2~~UsesGraph proc~execute~2 backend_cufftmp%execute iso_c_binding iso_c_binding proc~execute~2->iso_c_binding iso_fortran_env iso_fortran_env proc~execute~2->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes cuFFTMp GPU Backend Type Bound backend_cufftmp Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer Calls proc~~execute~2~~CallsGraph proc~execute~2 backend_cufftmp%execute interface~cudastreamsynchronize cudaStreamSynchronize proc~execute~2->interface~cudastreamsynchronize interface~cufftmpexecreshapeasync cufftMpExecReshapeAsync proc~execute~2->interface~cufftmpexecreshapeasync interface~int_to_str int_to_str proc~execute~2->interface~int_to_str mpi_abort mpi_abort proc~execute~2->mpi_abort mpi_barrier mpi_barrier proc~execute~2->mpi_barrier proc~cudageterrorstring cudaGetErrorString proc~execute~2->proc~cudageterrorstring proc~cufftgeterrorstring cufftGetErrorString proc~execute~2->proc~cufftgeterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~2.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Uses iso_c_binding iso_fortran_env proc~~destroy~2~~UsesGraph proc~destroy~2 backend_cufftmp%destroy iso_c_binding iso_c_binding proc~destroy~2->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy~2->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys cuFFTMp GPU Backend Type Bound backend_cufftmp Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend Calls proc~~destroy~2~~CallsGraph proc~destroy~2 backend_cufftmp%destroy interface~cufftmpdestroyreshape cufftMpDestroyReshape proc~destroy~2->interface~cufftmpdestroyreshape interface~int_to_str int_to_str proc~destroy~2->interface~int_to_str mpi_abort mpi_abort proc~destroy~2->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~destroy~2->proc~cufftgeterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~2.html"},{"title":"is_valid_execute_type – dtFFT","text":"public pure elemental function is_valid_execute_type(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_execute_type~~CalledByGraph proc~is_valid_execute_type is_valid_execute_type proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~is_valid_execute_type proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_execute_type.html"},{"title":"is_valid_transpose_type – dtFFT","text":"public pure elemental function is_valid_transpose_type(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_transpose_type~~CalledByGraph proc~is_valid_transpose_type is_valid_transpose_type proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~is_valid_transpose_type proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_transpose_type.html"},{"title":"is_valid_executor – dtFFT","text":"public pure elemental function is_valid_executor(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_executor~~CalledByGraph proc~is_valid_executor is_valid_executor proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_executor proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_executor.html"},{"title":"is_valid_effort – dtFFT","text":"public pure elemental function is_valid_effort(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_effort~~CalledByGraph proc~is_valid_effort is_valid_effort proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_effort proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_effort.html"},{"title":"is_valid_precision – dtFFT","text":"public pure elemental function is_valid_precision(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_precision~~CalledByGraph proc~is_valid_precision is_valid_precision proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_precision proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_precision.html"},{"title":"is_valid_r2r_kind – dtFFT","text":"public pure elemental function is_valid_r2r_kind(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_r2r_kind~~CalledByGraph proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_r2r_kind proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_r2r_kind.html"},{"title":"is_valid_dimension – dtFFT","text":"public pure elemental function is_valid_dimension(param) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: param Return Value logical Called by proc~~is_valid_dimension~~CalledByGraph proc~is_valid_dimension is_valid_dimension proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_dimension proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_dimension.html"},{"title":"is_valid_comm_type – dtFFT","text":"public pure elemental function is_valid_comm_type(param) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: param Return Value logical Called by proc~~is_valid_comm_type~~CalledByGraph proc~is_valid_comm_type is_valid_comm_type proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_comm_type proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_comm_type.html"},{"title":"dtfft_get_precision_string – dtFFT","text":"public  function dtfft_get_precision_string(precision) result(string) Gets the string description of a precision Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: precision Precision type Return Value character(len=:), allocatable Precision string Called by proc~~dtfft_get_precision_string~~CalledByGraph proc~dtfft_get_precision_string dtfft_get_precision_string proc~dtfft_get_precision_string_c dtfft_get_precision_string_c proc~dtfft_get_precision_string_c->proc~dtfft_get_precision_string proc~report dtfft_plan_t%report proc~report->proc~dtfft_get_precision_string proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_precision_string.html"},{"title":"dtfft_get_executor_string – dtFFT","text":"public  function dtfft_get_executor_string(executor) result(string) Gets the string description of an executor Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: executor Executor type Return Value character(len=:), allocatable Executor string Called by proc~~dtfft_get_executor_string~~CalledByGraph proc~dtfft_get_executor_string dtfft_get_executor_string proc~dtfft_get_executor_string_c dtfft_get_executor_string_c proc~dtfft_get_executor_string_c->proc~dtfft_get_executor_string proc~report dtfft_plan_t%report proc~report->proc~dtfft_get_executor_string proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_executor_string.html"},{"title":"is_host_executor – dtFFT","text":"public pure elemental function is_host_executor(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical Called by proc~~is_host_executor~~CalledByGraph proc~is_host_executor is_host_executor proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_host_executor proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_host_executor.html"},{"title":"is_cuda_executor – dtFFT","text":"public pure elemental function is_cuda_executor(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical Called by proc~~is_cuda_executor~~CalledByGraph proc~is_cuda_executor is_cuda_executor proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_cuda_executor proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_cuda_executor.html"},{"title":"is_valid_platform – dtFFT","text":"public pure elemental function is_valid_platform(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_platform~~CalledByGraph proc~is_valid_platform is_valid_platform proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~is_valid_platform proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_platform.html"},{"title":"is_valid_gpu_backend – dtFFT","text":"public pure elemental function is_valid_gpu_backend(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_gpu_backend~~CalledByGraph proc~is_valid_gpu_backend is_valid_gpu_backend proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~is_valid_gpu_backend proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_gpu_backend.html"},{"title":"is_backend_pipelined – dtFFT","text":"public pure elemental function is_backend_pipelined(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_pipelined~~CalledByGraph proc~is_backend_pipelined is_backend_pipelined proc~create~5 abstract_backend%create proc~create~5->proc~is_backend_pipelined proc~create~9 transpose_handle_cuda%create proc~create~9->proc~is_backend_pipelined proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~is_backend_pipelined proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_pipelined.html"},{"title":"is_backend_mpi – dtFFT","text":"public pure elemental function is_backend_mpi(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_mpi~~CalledByGraph proc~is_backend_mpi is_backend_mpi proc~create_mpi backend_mpi%create_mpi proc~create_mpi->proc~is_backend_mpi proc~create~5 abstract_backend%create proc~create~5->proc~is_backend_mpi proc~create~9 transpose_handle_cuda%create proc~create~9->proc~is_backend_mpi proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~is_backend_mpi proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_mpi.html"},{"title":"is_backend_nccl – dtFFT","text":"public pure elemental function is_backend_nccl(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_nccl~~CalledByGraph proc~is_backend_nccl is_backend_nccl proc~alloc_mem alloc_mem proc~alloc_mem->proc~is_backend_nccl proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~is_backend_nccl proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_nccl backend_nccl%create_nccl proc~create_nccl->proc~is_backend_nccl proc~create~9 transpose_handle_cuda%create proc~create~9->proc~is_backend_nccl proc~free_mem free_mem proc~free_mem->proc~is_backend_nccl proc~run_autotune_backend->proc~is_backend_nccl proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_nccl.html"},{"title":"is_backend_cufftmp – dtFFT","text":"public pure elemental function is_backend_cufftmp(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_cufftmp~~CalledByGraph proc~is_backend_cufftmp is_backend_cufftmp proc~create~9 transpose_handle_cuda%create proc~create~9->proc~is_backend_cufftmp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_cufftmp.html"},{"title":"is_backend_nvshmem – dtFFT","text":"public pure elemental function is_backend_nvshmem(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_nvshmem~~CalledByGraph proc~is_backend_nvshmem is_backend_nvshmem proc~alloc_mem alloc_mem proc~alloc_mem->proc~is_backend_nvshmem proc~check_device_pointers check_device_pointers proc~check_device_pointers->proc~is_backend_nvshmem proc~free_mem free_mem proc~free_mem->proc~is_backend_nvshmem proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_local_sizes->proc~is_backend_nvshmem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~is_backend_nvshmem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_device_pointers proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~check_device_pointers proc~autotune_grid_decomposition->proc~autotune_grid proc~check_aux->proc~get_alloc_size proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_nvshmem.html"},{"title":"dtfft_get_backend_string – dtFFT","text":"public  function dtfft_get_backend_string(backend) result(string) Gets the string description of a GPU backend Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: backend GPU backend Return Value character(len=:), allocatable Backend string Called by proc~~dtfft_get_backend_string~~CalledByGraph proc~dtfft_get_backend_string dtfft_get_backend_string proc~alloc_mem alloc_mem proc~alloc_mem->proc~dtfft_get_backend_string proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~dtfft_get_backend_string proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~dtfft_get_backend_string_c dtfft_get_backend_string_c proc~dtfft_get_backend_string_c->proc~dtfft_get_backend_string proc~report dtfft_plan_t%report proc~report->proc~dtfft_get_backend_string proc~run_autotune_backend->proc~dtfft_get_backend_string proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_backend_string.html"},{"title":"dtfft_get_cuda_stream – dtFFT","text":"public  function dtfft_get_cuda_stream(stream) result(cuda_stream) Returns the CUDA stream from dtfft_stream_t Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), intent(in) :: stream dtfft stream Return Value integer(kind=int64) CUDA stream Called by proc~~dtfft_get_cuda_stream~~CalledByGraph proc~dtfft_get_cuda_stream dtfft_get_cuda_stream proc~get_stream_int64 dtfft_plan_t%get_stream_int64 proc~get_stream_int64->proc~dtfft_get_cuda_stream none~get_stream dtfft_plan_t%get_stream proc~get_stream_int64->none~get_stream none~get_stream->proc~get_stream_int64 proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_cuda_stream.html"},{"title":"execute_type_eq – dtFFT","text":"private pure elemental function execute_type_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical Called by proc~~execute_type_eq~~CalledByGraph proc~execute_type_eq execute_type_eq interface~operator(==) operator(==) interface~operator(==)->proc~execute_type_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_type_eq.html"},{"title":"transpose_type_eq – dtFFT","text":"private pure elemental function transpose_type_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical Called by proc~~transpose_type_eq~~CalledByGraph proc~transpose_type_eq transpose_type_eq interface~operator(==) operator(==) interface~operator(==)->proc~transpose_type_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_type_eq.html"},{"title":"executor_eq – dtFFT","text":"private pure elemental function executor_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical Called by proc~~executor_eq~~CalledByGraph proc~executor_eq executor_eq interface~operator(==) operator(==) interface~operator(==)->proc~executor_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/executor_eq.html"},{"title":"effort_eq – dtFFT","text":"private pure elemental function effort_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical Called by proc~~effort_eq~~CalledByGraph proc~effort_eq effort_eq interface~operator(==) operator(==) interface~operator(==)->proc~effort_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/effort_eq.html"},{"title":"precision_eq – dtFFT","text":"private pure elemental function precision_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical Called by proc~~precision_eq~~CalledByGraph proc~precision_eq precision_eq interface~operator(==) operator(==) interface~operator(==)->proc~precision_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/precision_eq.html"},{"title":"r2r_kind_eq – dtFFT","text":"private pure elemental function r2r_kind_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical Called by proc~~r2r_kind_eq~~CalledByGraph proc~r2r_kind_eq r2r_kind_eq interface~operator(==) operator(==) interface~operator(==)->proc~r2r_kind_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/r2r_kind_eq.html"},{"title":"platform_eq – dtFFT","text":"private pure elemental function platform_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical Called by proc~~platform_eq~~CalledByGraph proc~platform_eq platform_eq interface~operator(==) operator(==) interface~operator(==)->proc~platform_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/platform_eq.html"},{"title":"execute_type_ne – dtFFT","text":"private pure elemental function execute_type_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical Called by proc~~execute_type_ne~~CalledByGraph proc~execute_type_ne execute_type_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~execute_type_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_type_ne.html"},{"title":"transpose_type_ne – dtFFT","text":"private pure elemental function transpose_type_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical Called by proc~~transpose_type_ne~~CalledByGraph proc~transpose_type_ne transpose_type_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~transpose_type_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_type_ne.html"},{"title":"executor_ne – dtFFT","text":"private pure elemental function executor_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical Called by proc~~executor_ne~~CalledByGraph proc~executor_ne executor_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~executor_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/executor_ne.html"},{"title":"effort_ne – dtFFT","text":"private pure elemental function effort_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical Called by proc~~effort_ne~~CalledByGraph proc~effort_ne effort_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~effort_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/effort_ne.html"},{"title":"precision_ne – dtFFT","text":"private pure elemental function precision_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical Called by proc~~precision_ne~~CalledByGraph proc~precision_ne precision_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~precision_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/precision_ne.html"},{"title":"r2r_kind_ne – dtFFT","text":"private pure elemental function r2r_kind_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical Called by proc~~r2r_kind_ne~~CalledByGraph proc~r2r_kind_ne r2r_kind_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~r2r_kind_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/r2r_kind_ne.html"},{"title":"platform_ne – dtFFT","text":"private pure elemental function platform_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical Called by proc~~platform_ne~~CalledByGraph proc~platform_ne platform_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~platform_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/platform_ne.html"},{"title":"dtfft_get_version_current – dtFFT","text":"private  function dtfft_get_version_current() bind(C) Returns the current version code Arguments None Return Value integer(kind=c_int32_t) Called by proc~~dtfft_get_version_current~~CalledByGraph proc~dtfft_get_version_current dtfft_get_version_current interface~dtfft_get_version dtfft_get_version interface~dtfft_get_version->proc~dtfft_get_version_current proc~report dtfft_plan_t%report proc~report->interface~dtfft_get_version proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_version_current.html"},{"title":"dtfft_get_version_required – dtFFT","text":"private  function dtfft_get_version_required(major, minor, patch) Returns the version code required by the user Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: major Major version integer(kind=int32), intent(in) :: minor Minor version integer(kind=int32), intent(in) :: patch Patch version Return Value integer(kind=int32) Called by proc~~dtfft_get_version_required~~CalledByGraph proc~dtfft_get_version_required dtfft_get_version_required interface~dtfft_get_version dtfft_get_version interface~dtfft_get_version->proc~dtfft_get_version_required proc~report dtfft_plan_t%report proc~report->interface~dtfft_get_version proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_version_required.html"},{"title":"gpu_backend_eq – dtFFT","text":"private pure elemental function gpu_backend_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical Called by proc~~gpu_backend_eq~~CalledByGraph proc~gpu_backend_eq gpu_backend_eq interface~operator(==) operator(==) interface~operator(==)->proc~gpu_backend_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/gpu_backend_eq.html"},{"title":"gpu_backend_ne – dtFFT","text":"private pure elemental function gpu_backend_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical Called by proc~~gpu_backend_ne~~CalledByGraph proc~gpu_backend_ne gpu_backend_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~gpu_backend_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/gpu_backend_ne.html"},{"title":"stream_from_int64 – dtFFT","text":"private  function stream_from_int64(cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream Called by proc~~stream_from_int64~~CalledByGraph proc~stream_from_int64 stream_from_int64 interface~dtfft_stream_t dtfft_stream_t interface~dtfft_stream_t->proc~stream_from_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/stream_from_int64.html"},{"title":"dtfft_get_version – dtFFT","text":"public interface dtfft_get_version Get dtFFT version Calls interface~~dtfft_get_version~~CallsGraph interface~dtfft_get_version dtfft_get_version proc~dtfft_get_version_current dtfft_get_version_current interface~dtfft_get_version->proc~dtfft_get_version_current proc~dtfft_get_version_required dtfft_get_version_required interface~dtfft_get_version->proc~dtfft_get_version_required Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dtfft_get_version~~CalledByGraph interface~dtfft_get_version dtfft_get_version proc~report dtfft_plan_t%report proc~report->interface~dtfft_get_version proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function dtfft_get_version_current () bind(C) Returns the current version code Arguments None Return Value integer(kind=c_int32_t) private  function dtfft_get_version_required (major, minor, patch) Returns the version code required by the user Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: major Major version integer(kind=int32), intent(in) :: minor Minor version integer(kind=int32), intent(in) :: patch Patch version Return Value integer(kind=int32)","tags":"","loc":"interface/dtfft_get_version.html"},{"title":"operator(==) – dtFFT","text":"public interface operator(==) Calls interface~~operator(==)~~CallsGraph interface~operator(==) operator(==) proc~effort_eq effort_eq interface~operator(==)->proc~effort_eq proc~execute_type_eq execute_type_eq interface~operator(==)->proc~execute_type_eq proc~executor_eq executor_eq interface~operator(==)->proc~executor_eq proc~gpu_backend_eq gpu_backend_eq interface~operator(==)->proc~gpu_backend_eq proc~platform_eq platform_eq interface~operator(==)->proc~platform_eq proc~precision_eq precision_eq interface~operator(==)->proc~precision_eq proc~r2r_kind_eq r2r_kind_eq interface~operator(==)->proc~r2r_kind_eq proc~transpose_type_eq transpose_type_eq interface~operator(==)->proc~transpose_type_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure elemental function execute_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical","tags":"","loc":"interface/operator(==).html"},{"title":"operator(/=) – dtFFT","text":"public interface operator(/=) Calls interface~~operator(SLASH=)~~CallsGraph interface~operator(SLASH=) operator(/=) proc~effort_ne effort_ne interface~operator(SLASH=)->proc~effort_ne proc~execute_type_ne execute_type_ne interface~operator(SLASH=)->proc~execute_type_ne proc~executor_ne executor_ne interface~operator(SLASH=)->proc~executor_ne proc~gpu_backend_ne gpu_backend_ne interface~operator(SLASH=)->proc~gpu_backend_ne proc~platform_ne platform_ne interface~operator(SLASH=)->proc~platform_ne proc~precision_ne precision_ne interface~operator(SLASH=)->proc~precision_ne proc~r2r_kind_ne r2r_kind_ne interface~operator(SLASH=)->proc~r2r_kind_ne proc~transpose_type_ne transpose_type_ne interface~operator(SLASH=)->proc~transpose_type_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure elemental function execute_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical","tags":"","loc":"interface/operator(SLASH=).html"},{"title":"dtfft_stream_t – dtFFT","text":"public interface dtfft_stream_t Creates dtfft_stream_t from integer(cuda_stream_kind) Calls interface~~dtfft_stream_t~~CallsGraph interface~dtfft_stream_t dtfft_stream_t proc~stream_from_int64 stream_from_int64 interface~dtfft_stream_t->proc~stream_from_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function stream_from_int64 (cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream","tags":"","loc":"interface/dtfft_stream_t.html"},{"title":"load_vkfft – dtFFT","text":"public  function load_vkfft(platform) Loads VkFFT library based on the platform Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to load VkFFT library for Return Value integer(kind=int32) Calls proc~~load_vkfft~~CallsGraph proc~load_vkfft load_vkfft proc~load load proc~load_vkfft->proc~load proc~destroy_strings destroy_strings proc~load->proc~destroy_strings proc~dynamic_load dynamic_load proc~load->proc~dynamic_load interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_vkfft~~CalledByGraph proc~load_vkfft load_vkfft proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_vkfft.html"},{"title":"load – dtFFT","text":"private  function load(wrapper, suffix) result(error_code) Loads VkFFT library Arguments Type Intent Optional Attributes Name class( vkfft_wrapper ), intent(inout) :: wrapper VkFFT Wrapper character(len=*), intent(in) :: suffix Suffix for the library name Return Value integer(kind=int32) Calls proc~~load~~CallsGraph proc~load load proc~destroy_strings destroy_strings proc~load->proc~destroy_strings proc~dynamic_load dynamic_load proc~load->proc~dynamic_load interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load~~CalledByGraph proc~load load proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load.html"},{"title":"nvrtcGetErrorString – dtFFT","text":"public  function nvrtcGetErrorString(error_code) result(string) Helper function that returns a string describing the given nvrtcResult code\nFor unrecognized enumeration values, it returns “NVRTC_ERROR unknown” Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: error_code CUDA Runtime Compilation API result code. Return Value character(len=:), allocatable Result string Calls proc~~nvrtcgeterrorstring~~CallsGraph proc~nvrtcgeterrorstring nvrtcGetErrorString proc~string_c2f string_c2f proc~nvrtcgeterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nvrtcgeterrorstring~~CalledByGraph proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~nvrtcgeterrorstring proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nvrtcgeterrorstring.html"},{"title":"load_nvrtc – dtFFT","text":"public  function load_nvrtc() result(error_code) Dynamically loads nvRTC library and its functions Arguments None Return Value integer(kind=int32) Error code Calls proc~~load_nvrtc~~CallsGraph proc~load_nvrtc load_nvrtc proc~destroy_strings destroy_strings proc~load_nvrtc->proc~destroy_strings proc~dynamic_load dynamic_load proc~load_nvrtc->proc~dynamic_load interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_nvrtc~~CalledByGraph proc~load_nvrtc load_nvrtc proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_nvrtc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_nvrtc.html"},{"title":"dtfft_get_error_string – dtFFT","text":"public pure function dtfft_get_error_string(error_code) result(error_string) Gets the string description of an error code Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: error_code Error code Return Value character(len=:), allocatable Error string Called by proc~~dtfft_get_error_string~~CalledByGraph proc~dtfft_get_error_string dtfft_get_error_string proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~dtfft_get_error_string proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~dtfft_get_error_string proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~dtfft_get_error_string proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~dtfft_get_error_string proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~dtfft_get_error_string proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~dtfft_get_error_string proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~dtfft_get_error_string proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~dtfft_get_error_string proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~dtfft_get_error_string proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~dtfft_get_error_string proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~9->proc~mem_free_ptr proc~dtfft_get_error_string_c dtfft_get_error_string_c proc~dtfft_get_error_string_c->proc~dtfft_get_error_string proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~dtfft_get_error_string proc~execute_ptr->proc~check_aux proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~dtfft_get_error_string proc~get_alloc_bytes->proc~get_element_size proc~get_alloc_bytes->proc~get_alloc_size proc~get_dims dtfft_plan_t%get_dims proc~get_dims->proc~dtfft_get_error_string proc~get_element_size->proc~dtfft_get_error_string proc~get_executor dtfft_plan_t%get_executor proc~get_executor->proc~dtfft_get_error_string proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_local_sizes->proc~dtfft_get_error_string proc~get_pencil dtfft_plan_t%get_pencil proc~get_pencil->proc~dtfft_get_error_string proc~get_precision dtfft_plan_t%get_precision proc~get_precision->proc~dtfft_get_error_string proc~get_stream_ptr dtfft_plan_t%get_stream_ptr proc~get_stream_ptr->proc~dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~report dtfft_plan_t%report proc~report->proc~dtfft_get_error_string proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~dtfft_get_error_string proc~run_autotune_backend->proc~alloc_and_set_aux proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~dtfft_get_error_string none~get_stream dtfft_plan_t%get_stream none~get_stream->proc~get_stream_ptr proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream->proc~get_stream_int64 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~dtfft_get_dims_c dtfft_get_dims_c proc~dtfft_get_dims_c->proc~get_dims proc~dtfft_get_element_size_c dtfft_get_element_size_c proc~dtfft_get_element_size_c->proc~get_element_size proc~dtfft_get_executor_c dtfft_get_executor_c proc~dtfft_get_executor_c->proc~get_executor proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes proc~dtfft_get_pencil_c dtfft_get_pencil_c proc~dtfft_get_pencil_c->proc~get_pencil proc~dtfft_get_precision_c dtfft_get_precision_c proc~dtfft_get_precision_c->proc~get_precision proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~dtfft_mem_free_c dtfft_mem_free_c proc~dtfft_mem_free_c->proc~mem_free_ptr proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~get_alloc_size->proc~get_local_sizes proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_c32_1d->proc~mem_free_ptr proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_c32_2d->proc~mem_free_ptr proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_c32_3d->proc~mem_free_ptr proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_c64_1d->proc~mem_free_ptr proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_c64_2d->proc~mem_free_ptr proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_c64_3d->proc~mem_free_ptr proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_r32_1d->proc~mem_free_ptr proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_r32_2d->proc~mem_free_ptr proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_r32_3d->proc~mem_free_ptr proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_r64_1d->proc~mem_free_ptr proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_r64_2d->proc~mem_free_ptr proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_r64_3d->proc~mem_free_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_grid_decomposition->proc~autotune_grid proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream proc~get_stream_int64->none~get_stream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_error_string.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via FFTW3 Interface Type Bound fftw_executor Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Calls proc~~create~3~~CallsGraph proc~create~3 fftw_executor%create constructor constructor proc~create~3->constructor constructor_inverse constructor_inverse proc~create~3->constructor_inverse inverse_kinds inverse_kinds proc~create~3->inverse_kinds knds knds proc~create~3->knds proc~get_inverse_kind get_inverse_kind proc~create~3->proc~get_inverse_kind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~3.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, a, b, sign) Executes FFTW3 plan Type Bound fftw_executor Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(in) :: self FFTW FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform","tags":"","loc":"proc/execute~3.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys FFTW3 plan Type Bound fftw_executor Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor","tags":"","loc":"proc/destroy~3.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(alloc_bytes, ptr) Allocates FFTW3 memory Type Bound fftw_executor Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer Calls proc~~mem_alloc~~CallsGraph proc~mem_alloc fftw_executor%mem_alloc fftw_malloc fftw_malloc proc~mem_alloc->fftw_malloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(ptr) Frees FFTW3 aligned memory Type Bound fftw_executor Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free Calls proc~~mem_free~~CallsGraph proc~mem_free fftw_executor%mem_free fftw_free fftw_free proc~mem_free->fftw_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free.html"},{"title":"make_plan – dtFFT","text":"private  subroutine make_plan(fft_rank, fft_sizes, mkl_precision, forward_domain, how_many, idist, odist, plan) Creates general MKL plan Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=c_long), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: mkl_precision MKL Precision integer(kind=int32), intent(in) :: forward_domain C2C or R2C flag integer(kind=int32), intent(in) :: how_many Sets DFTI_NUMBER_OF_TRANSFORMS integer(kind=int32), intent(in) :: idist Sets DFTI_INPUT_DISTANCE integer(kind=int32), intent(in) :: odist Sets DFTI_OUTPUT_DISTANCE type(c_ptr), intent(inout) :: plan Resulting plan Calls proc~~make_plan~~CallsGraph proc~make_plan make_plan interface~int_to_str int_to_str proc~make_plan->interface~int_to_str interface~mkl_dfti_commit_desc mkl_dfti_commit_desc proc~make_plan->interface~mkl_dfti_commit_desc interface~mkl_dfti_create_desc mkl_dfti_create_desc proc~make_plan->interface~mkl_dfti_create_desc interface~mkl_dfti_set_value mkl_dfti_set_value proc~make_plan->interface~mkl_dfti_set_value mpi_abort mpi_abort proc~make_plan->mpi_abort proc~dftierrormessage DftiErrorMessage proc~make_plan->proc~dftierrormessage proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~make_plan~~CalledByGraph proc~make_plan make_plan proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/make_plan.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via MKL DFTI Interface Type Bound mkl_executor Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Calls proc~~create~4~~CallsGraph proc~create~4 mkl_executor%create proc~make_plan make_plan proc~create~4->proc~make_plan interface~int_to_str int_to_str proc~make_plan->interface~int_to_str interface~mkl_dfti_commit_desc mkl_dfti_commit_desc proc~make_plan->interface~mkl_dfti_commit_desc interface~mkl_dfti_create_desc mkl_dfti_create_desc proc~make_plan->interface~mkl_dfti_create_desc interface~mkl_dfti_set_value mkl_dfti_set_value proc~make_plan->interface~mkl_dfti_set_value mpi_abort mpi_abort proc~make_plan->mpi_abort proc~dftierrormessage DftiErrorMessage proc~make_plan->proc~dftierrormessage proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~4.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, a, b, sign) Executes MKL plan Type Bound mkl_executor Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(in) :: self MKL FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform Calls proc~~execute~4~~CallsGraph proc~execute~4 mkl_executor%execute interface~int_to_str int_to_str proc~execute~4->interface~int_to_str interface~mkl_dfti_commit_desc mkl_dfti_commit_desc proc~execute~4->interface~mkl_dfti_commit_desc interface~mkl_dfti_execute mkl_dfti_execute proc~execute~4->interface~mkl_dfti_execute interface~mkl_dfti_set_value mkl_dfti_set_value proc~execute~4->interface~mkl_dfti_set_value mpi_abort mpi_abort proc~execute~4->mpi_abort proc~dftierrormessage DftiErrorMessage proc~execute~4->proc~dftierrormessage proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~4.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys MKL plan Type Bound mkl_executor Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor Calls proc~~destroy~4~~CallsGraph proc~destroy~4 mkl_executor%destroy interface~int_to_str int_to_str proc~destroy~4->interface~int_to_str interface~mkl_dfti_free_desc mkl_dfti_free_desc proc~destroy~4->interface~mkl_dfti_free_desc mpi_abort mpi_abort proc~destroy~4->mpi_abort proc~dftierrormessage DftiErrorMessage proc~destroy~4->proc~dftierrormessage proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~4.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(alloc_bytes, ptr) Allocates MKL memory Type Bound mkl_executor Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer Calls proc~~mem_alloc~2~~CallsGraph proc~mem_alloc~2 mkl_executor%mem_alloc interface~int_to_str int_to_str proc~mem_alloc~2->interface~int_to_str interface~mkl_dfti_mem_alloc mkl_dfti_mem_alloc proc~mem_alloc~2->interface~mkl_dfti_mem_alloc mpi_abort mpi_abort proc~mem_alloc~2->mpi_abort proc~dftierrormessage DftiErrorMessage proc~mem_alloc~2->proc~dftierrormessage proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc~2.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(ptr) Frees MKL aligned memory Type Bound mkl_executor Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free Calls proc~~mem_free~2~~CallsGraph proc~mem_free~2 mkl_executor%mem_free interface~int_to_str int_to_str proc~mem_free~2->interface~int_to_str interface~mkl_dfti_mem_free mkl_dfti_mem_free proc~mem_free~2->interface~mkl_dfti_mem_free mpi_abort mpi_abort proc~mem_free~2->mpi_abort proc~dftierrormessage DftiErrorMessage proc~mem_free~2->proc~dftierrormessage proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free~2.html"},{"title":"cufftGetErrorString – dtFFT","text":"public  function cufftGetErrorString(error_code) result(string) Returns a string representation of the cuFFT error code. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: error_code cuFFT error code Return Value character(len=:), allocatable String representation of the cuFFT error code Called by proc~~cufftgeterrorstring~~CalledByGraph proc~cufftgeterrorstring cufftGetErrorString proc~create~2 backend_cufftmp%create proc~create~2->proc~cufftgeterrorstring proc~create~7 cufft_executor%create proc~create~7->proc~cufftgeterrorstring proc~destroy~2 backend_cufftmp%destroy proc~destroy~2->proc~cufftgeterrorstring proc~destroy~8 cufft_executor%destroy proc~destroy~8->proc~cufftgeterrorstring proc~execute~2 backend_cufftmp%execute proc~execute~2->proc~cufftgeterrorstring proc~execute~7 cufft_executor%execute proc~execute~7->proc~cufftgeterrorstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cufftgeterrorstring.html"},{"title":"cufftPlanMany – dtFFT","text":"interface Creates a FFT plan configuration of dimension rank, with sizes specified in the array n. Called by interface~~cufftplanmany~~CalledByGraph interface~cufftplanmany cufftPlanMany proc~create~7 cufft_executor%create proc~create~7->interface~cufftplanmany Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftPlanMany(plan, rank, n, inembed, istride, idist, onembed, ostride, odist, ffttype, batch) result(cufftResult) bind(C, name=\"cufftPlanMany\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: plan Pointer to an uninitialized cufftHandle object. integer(kind=c_int), value :: rank Dimensionality of the transform (1, 2, or 3). integer(kind=c_int) :: n (*) Array of size rank, describing the size of each dimension,\nn[0] being the size of the outermost\nand n[rank-1] innermost (contiguous) dimension of a transform. integer(kind=c_int) :: inembed (*) Pointer of size rank that indicates the storage dimensions of the input data in memory.\nIf set to NULL, all other advanced data layout parameters are ignored. integer(kind=c_int), value :: istride Indicates the distance between two successive input elements in the least\nsignificant (i.e., innermost) dimension. integer(kind=c_int), value :: idist Indicates the distance between the first element of two consecutive signals\nin a batch of the input data. integer(kind=c_int) :: onembed (*) Pointer of size rank that indicates the storage dimensions of the output data in memory.\nIf set to NULL, all other advanced data layout parameters are ignored. integer(kind=c_int), value :: ostride Indicates the distance between two successive output elements in the output array\nin the least significant (i.e., innermost) dimension. integer(kind=c_int), value :: odist Indicates the distance between the first element of two consecutive signals\nin a batch of the output data. integer(kind=c_int), value :: ffttype The transform data type (e.g., CUFFT_R2C for single precision real to complex). integer(kind=c_int), value :: batch Batch size for this transform. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftplanmany.html"},{"title":"cufftXtExec – dtFFT","text":"interface Executes any cuFFT transform regardless of precision and type.\nIn case of complex-to-real and real-to-complex transforms, the direction parameter is ignored. Called by interface~~cufftxtexec~~CalledByGraph interface~cufftxtexec cufftXtExec proc~execute~7 cufft_executor%execute proc~execute~7->interface~cufftxtexec Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftXtExec(plan, input, output, direction) result(cufftResult) bind(C, name=\"cufftXtExec\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan cufftHandle returned by cufftCreate. type(c_ptr), value :: input Pointer to the input data (in GPU memory) to transform. type(c_ptr), value :: output Pointer to the output data (in GPU memory). integer(kind=c_int), value :: direction The transform direction: CUFFT_FORWARD or CUFFT_INVERSE.\nIgnored for complex-to-real and real-to-complex transforms. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftxtexec.html"},{"title":"cufftDestroy – dtFFT","text":"interface Frees all GPU resources associated with a cuFFT plan and destroys the internal plan data structure. Called by interface~~cufftdestroy~~CalledByGraph interface~cufftdestroy cufftDestroy proc~destroy~8 cufft_executor%destroy proc~destroy~8->interface~cufftdestroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftDestroy(plan) result(cufftResult) bind(C, name=\"cufftDestroy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Object of the plan to be destroyed. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftdestroy.html"},{"title":"cufftSetStream – dtFFT","text":"interface Associates a CUDA stream with a cuFFT plan. Called by interface~~cufftsetstream~~CalledByGraph interface~cufftsetstream cufftSetStream proc~create~7 cufft_executor%create proc~create~7->interface~cufftsetstream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftSetStream(plan, stream) result(cufftResult) bind(C, name=\"cufftSetStream\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Object to associate with the stream. type( dtfft_stream_t ), value :: stream A valid CUDA stream. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftsetstream.html"},{"title":"cufftMpCreateReshape – dtFFT","text":"interface Initializes a reshape handle for future use. This function is not collective. Called by interface~~cufftmpcreatereshape~~CalledByGraph interface~cufftmpcreatereshape cufftMpCreateReshape proc~create~2 backend_cufftmp%create proc~create~2->interface~cufftmpcreatereshape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpCreateReshape(reshapeHandle) result(cufftResult) bind(C, name=\"cufftMpCreateReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ) :: reshapeHandle The reshape handle. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpcreatereshape.html"},{"title":"cufftMpAttachReshapeComm – dtFFT","text":"interface Attaches a communication handle to a reshape. This function is not collective. Called by interface~~cufftmpattachreshapecomm~~CalledByGraph interface~cufftmpattachreshapecomm cufftMpAttachReshapeComm proc~create~2 backend_cufftmp%create proc~create~2->interface~cufftmpattachreshapecomm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpAttachReshapeComm(reshapeHandle, commType, comm) result(cufftResult) bind(C, name=\"cufftMpAttachReshapeComm\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_int), value :: commType An enum describing the communication type of the handle. type(c_ptr) :: comm If commType is CUFFT_COMM_MPI, this should be a pointer to an MPI communicator.\nThe pointer should remain valid until destruction of the handle.\nOtherwise, this should be NULL. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpattachreshapecomm.html"},{"title":"cufftMpGetReshapeSize – dtFFT","text":"interface Returns the amount (in bytes) of workspace required to execute the handle. Called by interface~~cufftmpgetreshapesize~~CalledByGraph interface~cufftmpgetreshapesize cufftMpGetReshapeSize proc~create~2 backend_cufftmp%create proc~create~2->interface~cufftmpgetreshapesize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpGetReshapeSize(reshapeHandle, workSize) result(cufftResult) bind(C, name=\"cufftMpGetReshapeSize\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_size_t) :: workSize The size, in bytes, of the workspace required during reshape execution. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpgetreshapesize.html"},{"title":"cufftMpMakeReshape – dtFFT","text":"interface Creates a reshape intended to re-distribute a global array of 3D data. Called by interface~~cufftmpmakereshape~~CalledByGraph interface~cufftmpmakereshape cufftMpMakeReshape proc~create~2 backend_cufftmp%create proc~create~2->interface~cufftmpmakereshape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpMakeReshape(reshapeHandle, elementSize, rank, lower_input, upper_input, lower_output, upper_output, strides_input, strides_output) result(cufftResult) bind(C, name=\"cufftMpMakeReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_long_long), value :: elementSize The size of the individual elements, in bytes. Allowed values are 4, 8, and 16. integer(kind=c_int), value :: rank The length of the lower_input, upper_input, lower_output, upper_output, strides_input, and strides_output arrays. rank should be 3. integer(kind=c_long_long) :: lower_input (*) An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer(kind=c_long_long) :: upper_input (*) An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer(kind=c_long_long) :: lower_output (*) An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer(kind=c_long_long) :: upper_output (*) An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer(kind=c_long_long) :: strides_input (*) An array of length rank, representing the local data layout of the input descriptor in memory. All entries must be decreasing and positive. integer(kind=c_long_long) :: strides_output (*) An array of length rank, representing the local data layout of the output descriptor in memory. All entries must be decreasing and positive. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpmakereshape.html"},{"title":"cufftMpExecReshapeAsync – dtFFT","text":"interface Executes the reshape, redistributing data_in into data_out using the workspace in workspace. Called by interface~~cufftmpexecreshapeasync~~CalledByGraph interface~cufftmpexecreshapeasync cufftMpExecReshapeAsync proc~execute~2 backend_cufftmp%execute proc~execute~2->interface~cufftmpexecreshapeasync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpExecReshapeAsync(reshapeHandle, dataOut, dataIn, workSpace, stream) result(cufftResult) bind(C, name=\"cufftMpExecReshapeAsync\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. type(c_ptr), value :: dataOut A symmetric-heap pointer to the output data. This memory should be NVSHMEM allocated and identical on all processes. type(c_ptr), value :: dataIn A symmetric-heap pointer to the input data. This memory should be NVSHMEM allocated and identical on all processes. type(c_ptr), value :: workSpace A symmetric-heap pointer to the workspace data. This memory should be NVSHMEM allocated and identical on all processes. type( dtfft_stream_t ), value :: stream The CUDA stream in which to run the reshape operation. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpexecreshapeasync.html"},{"title":"cufftMpDestroyReshape – dtFFT","text":"interface Destroys a reshape and all its associated data. Called by interface~~cufftmpdestroyreshape~~CalledByGraph interface~cufftmpdestroyreshape cufftMpDestroyReshape proc~destroy~2 backend_cufftmp%destroy proc~destroy~2->interface~cufftmpdestroyreshape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpDestroyReshape(reshapeHandle) result(cufftResult) bind(C, name=\"cufftMpDestroyReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpdestroyreshape.html"},{"title":"create_cuda – dtFFT","text":"private  function create_cuda(self, dims, transposed_dims, base_comm, comm_dims, effort, base_dtype, base_storage, is_custom_cart_comm, cart_comm, comms, pencils, ipencil) Creates CUDA transpose plan Type Bound transpose_plan_cuda Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(inout) :: self GPU transpose plan integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm Base communicator integer(kind=int32), intent(in) :: comm_dims (:) Number of processors in each dimension type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_custom_cart_comm is custom Cartesian communicator provided by user type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Calls proc~~create_cuda~~CallsGraph proc~create_cuda transpose_plan_cuda%create_cuda interface~int_to_str int_to_str proc~create_cuda->interface~int_to_str mpi_comm_size mpi_comm_size proc~create_cuda->mpi_comm_size mpi_wtime mpi_wtime proc~create_cuda->mpi_wtime proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~clean_unused_cache clean_unused_cache proc~create_cuda->proc~clean_unused_cache proc~create_helper backend_helper%create_helper proc~create_cuda->proc~create_helper proc~create_pencils_and_comm create_pencils_and_comm proc~create_cuda->proc~create_pencils_and_comm proc~double_to_str double_to_str proc~create_cuda->proc~double_to_str proc~dtfft_get_backend_string dtfft_get_backend_string proc~create_cuda->proc~dtfft_get_backend_string proc~get_log_enabled get_log_enabled proc~create_cuda->proc~get_log_enabled proc~get_mpi_enabled get_mpi_enabled proc~create_cuda->proc~get_mpi_enabled proc~get_nccl_enabled get_nccl_enabled proc~create_cuda->proc~get_nccl_enabled proc~get_nvshmem_enabled get_nvshmem_enabled proc~create_cuda->proc~get_nvshmem_enabled proc~get_user_gpu_backend get_user_gpu_backend proc~create_cuda->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_cuda->proc~get_user_stream proc~is_backend_nccl is_backend_nccl proc~create_cuda->proc~is_backend_nccl proc~load_cuda load_cuda proc~create_cuda->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create_cuda->proc~load_nvrtc proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~write_message write_message proc~create_cuda->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_abort mpi_abort proc~alloc_and_set_aux->mpi_abort mpi_allreduce mpi_allreduce proc~alloc_and_set_aux->mpi_allreduce proc~alloc_mem alloc_mem proc~alloc_and_set_aux->proc~alloc_mem proc~dtfft_get_error_string dtfft_get_error_string proc~alloc_and_set_aux->proc~dtfft_get_error_string proc~get_aux_size~3 transpose_handle_cuda%get_aux_size proc~alloc_and_set_aux->proc~get_aux_size~3 proc~autotune_grid_decomposition->mpi_comm_size proc~autotune_grid autotune_grid proc~autotune_grid_decomposition->proc~autotune_grid proc~clean_unused_cache->interface~int_to_str is_null_ptr is_null_ptr proc~clean_unused_cache->is_null_ptr proc~clean_unused_cache->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~clean_unused_cache->proc~cudageterrorstring proc~create_helper->interface~int_to_str proc~create_helper->mpi_comm_size interface~get_env get_env proc~create_helper->interface~get_env interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid proc~create_helper->mpi_abort mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast mpi_comm_rank mpi_comm_rank proc~create_helper->mpi_comm_rank proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~ncclgeterrorstring ncclGetErrorString proc~create_helper->proc~ncclgeterrorstring lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~10 pencil%create proc~create_pencils_and_comm->proc~create~10 proc~get_mpi_enabled_from_env get_mpi_enabled_from_env proc~get_mpi_enabled->proc~get_mpi_enabled_from_env proc~get_nccl_enabled_from_env get_nccl_enabled_from_env proc~get_nccl_enabled->proc~get_nccl_enabled_from_env proc~get_nvshmem_enabled_from_env get_nvshmem_enabled_from_env proc~get_nvshmem_enabled->proc~get_nvshmem_enabled_from_env proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring proc~destroy_strings destroy_strings proc~load_cuda->proc~destroy_strings proc~dynamic_load dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~destroy_strings proc~load_nvrtc->proc~dynamic_load proc~run_autotune_backend->interface~int_to_str proc~run_autotune_backend->mpi_comm_size proc~run_autotune_backend->proc~alloc_and_set_aux proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~double_to_str proc~run_autotune_backend->proc~dtfft_get_backend_string proc~run_autotune_backend->proc~get_log_enabled proc~run_autotune_backend->proc~get_mpi_enabled proc~run_autotune_backend->proc~get_nvshmem_enabled proc~run_autotune_backend->proc~is_backend_nccl proc~run_autotune_backend->proc~write_message interface~cudaeventcreate cudaEventCreate proc~run_autotune_backend->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~run_autotune_backend->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~run_autotune_backend->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~run_autotune_backend->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~run_autotune_backend->interface~cudaeventsynchronize interface~cudastreamsynchronize cudaStreamSynchronize proc~run_autotune_backend->interface~cudastreamsynchronize proc~run_autotune_backend->mpi_abort proc~run_autotune_backend->mpi_allreduce mpi_barrier mpi_barrier proc~run_autotune_backend->mpi_barrier proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~cudageterrorstring proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~run_autotune_backend->proc~dtfft_get_error_string proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~free_mem free_mem proc~run_autotune_backend->proc~free_mem proc~get_iters_from_env get_iters_from_env proc~run_autotune_backend->proc~get_iters_from_env proc~get_local_sizes~2 get_local_sizes proc~run_autotune_backend->proc~get_local_sizes~2 proc~get_pipelined_enabled get_pipelined_enabled proc~run_autotune_backend->proc~get_pipelined_enabled proc~is_backend_mpi is_backend_mpi proc~run_autotune_backend->proc~is_backend_mpi proc~is_backend_nvshmem is_backend_nvshmem proc~run_autotune_backend->proc~is_backend_nvshmem proc~is_backend_pipelined is_backend_pipelined proc~run_autotune_backend->proc~is_backend_pipelined proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~alloc_mem->interface~int_to_str proc~alloc_mem->proc~dtfft_get_backend_string proc~alloc_mem->proc~get_log_enabled proc~alloc_mem->proc~is_backend_nccl proc~alloc_mem->proc~write_message proc~alloc_mem->is_null_ptr proc~alloc_mem->mpi_abort proc~alloc_mem->mpi_allreduce proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~is_backend_nvshmem proc~alloc_mem->proc~ncclgeterrorstring interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc temp temp proc~alloc_mem->temp proc~autotune_grid->interface~int_to_str proc~autotune_grid->proc~create_pencils_and_comm proc~autotune_grid->proc~get_log_enabled proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid->proc~write_message proc~autotune_grid->proc~pop_nvtx_domain_range proc~autotune_grid->proc~push_nvtx_domain_range mpi_comm_free mpi_comm_free proc~autotune_grid->mpi_comm_free proc~destroy~12 pencil%destroy proc~autotune_grid->proc~destroy~12 mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~create~10->proc~destroy~12 proc~get_local_size get_local_size proc~create~10->proc~get_local_size interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy_helper->interface~int_to_str proc~destroy_helper->proc~get_log_enabled proc~destroy_helper->proc~write_message proc~destroy_helper->mpi_abort proc~destroy_helper->proc~ncclgeterrorstring interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy proc~destroy~10 nvrtc_kernel%destroy proc~destroy~11->proc~destroy~10 interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library proc~execute~9 nvrtc_kernel%execute proc~execute~10->proc~execute~9 proc~free_mem->interface~int_to_str proc~free_mem->proc~is_backend_nccl proc~free_mem->mpi_abort proc~free_mem->proc~is_backend_nvshmem proc~free_mem->proc~ncclgeterrorstring interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~nvshmem_free nvshmem_free proc~free_mem->interface~nvshmem_free proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~get_aux_size~2 abstract_backend%get_aux_size proc~get_aux_size~3->proc~get_aux_size~2 proc~get_iters_from_env->interface~get_env proc~get_pipe_enabled_from_env get_pipe_enabled_from_env proc~get_pipelined_enabled->proc~get_pipe_enabled_from_env interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~ncclgeterrorstring->proc~string_c2f interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~check_if_even->mpi_comm_size proc~check_if_even->mpi_allgather proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~destroy~10->interface~int_to_str proc~destroy~10->mpi_abort proc~destroy~10->proc~cudageterrorstring proc~destroy~10->interface~cudafree proc~mark_unused mark_unused proc~destroy~10->proc~mark_unused proc~execute~9->interface~int_to_str proc~execute~9->mpi_abort proc~execute~9->mpi_comm_rank proc~execute~9->proc~cudageterrorstring interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_local_size->mpi_comm_size proc~get_local_size->mpi_allgather proc~get_local_size->mpi_comm_rank proc~load_library->interface~is_null_ptr proc~load_library->proc~astring_f2c interface~dlopen dlopen proc~load_library->interface~dlopen proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr proc~load_symbol->proc~astring_f2c interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel proc~dl_error->proc~get_log_enabled proc~dl_error->proc~write_message proc~dl_error->proc~string_c2f interface~dlerror dlerror proc~dl_error->interface~dlerror proc~mark_unused->proc~is_same_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_cuda.html"},{"title":"get_aux_size – dtFFT","text":"private  function get_aux_size(self) result(aux_size) Type Bound transpose_plan_cuda Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(in) :: self Transposition class Return Value integer(kind=int64) Calls proc~~get_aux_size~~CallsGraph proc~get_aux_size transpose_plan_cuda%get_aux_size proc~get_aux_size~3 transpose_handle_cuda%get_aux_size proc~get_aux_size->proc~get_aux_size~3 proc~get_aux_size~2 abstract_backend%get_aux_size proc~get_aux_size~3->proc~get_aux_size~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_aux_size.html"},{"title":"alloc_and_set_aux – dtFFT","text":"private  function alloc_and_set_aux(helper, backend, cart_comm, aux, paux, plans, bplans) result(is_aux_alloc) Uses iso_fortran_env proc~~alloc_and_set_aux~~UsesGraph proc~alloc_and_set_aux alloc_and_set_aux iso_fortran_env iso_fortran_env proc~alloc_and_set_aux->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Allocates auxiliary memory according to the backend and sets it to the plans Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(MPI_Comm), intent(in) :: cart_comm Cartesian communicator type(c_ptr), intent(inout) :: aux Allocatable auxiliary memory real(kind=real32), intent(inout), pointer :: paux (:) Pointer to auxiliary memory type( transpose_handle_cuda ), intent(inout) :: plans (:) Plans type( transpose_handle_cuda ), intent(inout), optional :: bplans (:) Backward plans Return Value logical Is auxiliary memory allocated Calls proc~~alloc_and_set_aux~~CallsGraph proc~alloc_and_set_aux alloc_and_set_aux mpi_abort mpi_abort proc~alloc_and_set_aux->mpi_abort mpi_allreduce mpi_allreduce proc~alloc_and_set_aux->mpi_allreduce proc~alloc_mem alloc_mem proc~alloc_and_set_aux->proc~alloc_mem proc~dtfft_get_error_string dtfft_get_error_string proc~alloc_and_set_aux->proc~dtfft_get_error_string proc~get_aux_size~3 transpose_handle_cuda%get_aux_size proc~alloc_and_set_aux->proc~get_aux_size~3 proc~alloc_mem->mpi_abort proc~alloc_mem->mpi_allreduce interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~int_to_str int_to_str proc~alloc_mem->interface~int_to_str interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr proc~cudageterrorstring cudaGetErrorString proc~alloc_mem->proc~cudageterrorstring proc~dtfft_get_backend_string dtfft_get_backend_string proc~alloc_mem->proc~dtfft_get_backend_string proc~get_log_enabled get_log_enabled proc~alloc_mem->proc~get_log_enabled proc~is_backend_nccl is_backend_nccl proc~alloc_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~alloc_mem->proc~is_backend_nvshmem proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring proc~write_message write_message proc~alloc_mem->proc~write_message temp temp proc~alloc_mem->temp proc~get_aux_size~2 abstract_backend%get_aux_size proc~get_aux_size~3->proc~get_aux_size~2 proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_and_set_aux~~CalledByGraph proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/alloc_and_set_aux.html"},{"title":"execute_cuda – dtFFT","text":"private  subroutine execute_cuda(self, in, out, transpose_type) Executes single transposition Type Bound transpose_plan_cuda Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(inout) :: self Transposition class real(kind=real32), intent(inout) :: in (:) Incoming buffer real(kind=real32), intent(inout) :: out (:) Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to execute Calls proc~~execute_cuda~~CallsGraph proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute~10 transpose_handle_cuda%execute proc~execute_cuda->proc~execute~10 proc~execute~9 nvrtc_kernel%execute proc~execute~10->proc~execute~9 interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync interface~int_to_str int_to_str proc~execute~9->interface~int_to_str mpi_abort mpi_abort proc~execute~9->mpi_abort mpi_comm_rank mpi_comm_rank proc~execute~9->mpi_comm_rank proc~cudageterrorstring cudaGetErrorString proc~execute~9->proc~cudageterrorstring proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_cuda.html"},{"title":"destroy_cuda – dtFFT","text":"private  subroutine destroy_cuda(self) Destroys transposition plans Type Bound transpose_plan_cuda Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(inout) :: self Transposition class Calls proc~~destroy_cuda~~CallsGraph proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy~11 transpose_handle_cuda%destroy proc~destroy_cuda->proc~destroy~11 proc~mem_free~5 abstract_transpose_plan%mem_free proc~destroy_cuda->proc~mem_free~5 proc~destroy~10 nvrtc_kernel%destroy proc~destroy~11->proc~destroy~10 proc~free_mem free_mem proc~mem_free~5->proc~free_mem interface~cudafree cudaFree proc~destroy~10->interface~cudafree interface~int_to_str int_to_str proc~destroy~10->interface~int_to_str mpi_abort mpi_abort proc~destroy~10->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy~10->proc~cudageterrorstring proc~mark_unused mark_unused proc~destroy~10->proc~mark_unused proc~free_mem->interface~cudafree proc~free_mem->interface~int_to_str interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~nvshmem_free nvshmem_free proc~free_mem->interface~nvshmem_free proc~free_mem->mpi_abort proc~is_backend_nccl is_backend_nccl proc~free_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~free_mem->proc~is_backend_nvshmem proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~ncclgeterrorstring ncclGetErrorString proc~free_mem->proc~ncclgeterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~mark_unused->proc~is_same_ptr interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~ncclgeterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_cuda.html"},{"title":"autotune_grid_decomposition – dtFFT","text":"private  subroutine autotune_grid_decomposition(dims, transposed_dims, base_comm, base_storage, stream, best_decomposition, backend, min_execution_time, best_backend) Runs through all possible grid decompositions and selects the best one based on the lowest average execution time Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm 3D comm integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use integer(kind=int32), intent(out) :: best_decomposition (:) Best decomposition found type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: min_execution_time Elapsed time for best plan selected type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected Calls proc~~autotune_grid_decomposition~~CallsGraph proc~autotune_grid_decomposition autotune_grid_decomposition mpi_comm_size mpi_comm_size proc~autotune_grid_decomposition->mpi_comm_size proc~autotune_grid autotune_grid proc~autotune_grid_decomposition->proc~autotune_grid interface~int_to_str int_to_str proc~autotune_grid->interface~int_to_str mpi_comm_free mpi_comm_free proc~autotune_grid->mpi_comm_free proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~destroy~12 pencil%destroy proc~autotune_grid->proc~destroy~12 proc~get_log_enabled get_log_enabled proc~autotune_grid->proc~get_log_enabled proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~autotune_grid->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~write_message write_message proc~autotune_grid->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~10 pencil%create proc~create_pencils_and_comm->proc~create~10 interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~run_autotune_backend->mpi_comm_size proc~run_autotune_backend->interface~int_to_str proc~run_autotune_backend->proc~get_log_enabled proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~write_message interface~cudaeventcreate cudaEventCreate proc~run_autotune_backend->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~run_autotune_backend->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~run_autotune_backend->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~run_autotune_backend->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~run_autotune_backend->interface~cudaeventsynchronize interface~cudastreamsynchronize cudaStreamSynchronize proc~run_autotune_backend->interface~cudastreamsynchronize mpi_abort mpi_abort proc~run_autotune_backend->mpi_abort mpi_allreduce mpi_allreduce proc~run_autotune_backend->mpi_allreduce mpi_barrier mpi_barrier proc~run_autotune_backend->mpi_barrier proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_mem alloc_mem proc~run_autotune_backend->proc~alloc_mem proc~create_helper backend_helper%create_helper proc~run_autotune_backend->proc~create_helper proc~cudageterrorstring cudaGetErrorString proc~run_autotune_backend->proc~cudageterrorstring proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~double_to_str double_to_str proc~run_autotune_backend->proc~double_to_str proc~dtfft_get_backend_string dtfft_get_backend_string proc~run_autotune_backend->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~run_autotune_backend->proc~dtfft_get_error_string proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~free_mem free_mem proc~run_autotune_backend->proc~free_mem proc~get_iters_from_env get_iters_from_env proc~run_autotune_backend->proc~get_iters_from_env proc~get_local_sizes~2 get_local_sizes proc~run_autotune_backend->proc~get_local_sizes~2 proc~get_mpi_enabled get_mpi_enabled proc~run_autotune_backend->proc~get_mpi_enabled proc~get_nvshmem_enabled get_nvshmem_enabled proc~run_autotune_backend->proc~get_nvshmem_enabled proc~get_pipelined_enabled get_pipelined_enabled proc~run_autotune_backend->proc~get_pipelined_enabled proc~is_backend_mpi is_backend_mpi proc~run_autotune_backend->proc~is_backend_mpi proc~is_backend_nccl is_backend_nccl proc~run_autotune_backend->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~run_autotune_backend->proc~is_backend_nvshmem proc~is_backend_pipelined is_backend_pipelined proc~run_autotune_backend->proc~is_backend_pipelined mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~alloc_and_set_aux->mpi_abort proc~alloc_and_set_aux->mpi_allreduce proc~alloc_and_set_aux->proc~alloc_mem proc~alloc_and_set_aux->proc~dtfft_get_error_string proc~get_aux_size~3 transpose_handle_cuda%get_aux_size proc~alloc_and_set_aux->proc~get_aux_size~3 proc~alloc_mem->interface~int_to_str proc~alloc_mem->proc~get_log_enabled proc~alloc_mem->proc~write_message proc~alloc_mem->mpi_abort proc~alloc_mem->mpi_allreduce proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~dtfft_get_backend_string proc~alloc_mem->proc~is_backend_nccl proc~alloc_mem->proc~is_backend_nvshmem interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring temp temp proc~alloc_mem->temp proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~create_helper->mpi_comm_size proc~create_helper->interface~int_to_str proc~create_helper->mpi_abort proc~create_helper->mpi_comm_rank interface~get_env get_env proc~create_helper->interface~get_env interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_helper->proc~ncclgeterrorstring proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create~10->proc~destroy~12 proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~get_local_size get_local_size proc~create~10->proc~get_local_size interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy~10 nvrtc_kernel%destroy proc~destroy~11->proc~destroy~10 proc~execute~9 nvrtc_kernel%execute proc~execute~10->proc~execute~9 proc~free_mem->interface~int_to_str proc~free_mem->mpi_abort proc~free_mem->proc~is_backend_nccl proc~free_mem->proc~is_backend_nvshmem interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~nvshmem_free nvshmem_free proc~free_mem->interface~nvshmem_free proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~free_mem->proc~ncclgeterrorstring proc~get_iters_from_env->interface~get_env proc~get_mpi_enabled_from_env get_mpi_enabled_from_env proc~get_mpi_enabled->proc~get_mpi_enabled_from_env proc~get_nvshmem_enabled_from_env get_nvshmem_enabled_from_env proc~get_nvshmem_enabled->proc~get_nvshmem_enabled_from_env proc~get_pipe_enabled_from_env get_pipe_enabled_from_env proc~get_pipelined_enabled->proc~get_pipe_enabled_from_env proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~check_if_even->mpi_comm_size proc~check_if_even->mpi_allgather proc~destroy_helper->interface~int_to_str proc~destroy_helper->proc~get_log_enabled proc~destroy_helper->proc~write_message proc~destroy_helper->mpi_abort proc~destroy_helper->proc~ncclgeterrorstring interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy proc~destroy~10->interface~int_to_str proc~destroy~10->mpi_abort proc~destroy~10->proc~cudageterrorstring proc~destroy~10->interface~cudafree proc~mark_unused mark_unused proc~destroy~10->proc~mark_unused proc~execute~9->interface~int_to_str proc~execute~9->mpi_abort proc~execute~9->mpi_comm_rank proc~execute~9->proc~cudageterrorstring interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks proc~get_aux_size~2 abstract_backend%get_aux_size proc~get_aux_size~3->proc~get_aux_size~2 proc~get_local_size->mpi_comm_size proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_allgather proc~ncclgeterrorstring->proc~string_c2f interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~mark_unused->proc~is_same_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~autotune_grid_decomposition~~CalledByGraph proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~autotune_grid_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autotune_grid_decomposition.html"},{"title":"autotune_grid – dtFFT","text":"private  subroutine autotune_grid(dims, transposed_dims, base_comm, comm_dims, base_storage, is_z_slab, stream, backend, best_time, best_backend) Creates cartesian grid and runs various backends on it. Can return best backend and execution time Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm Basic communicator to create 3d grid from integer(kind=int32), intent(in) :: comm_dims (:) Number of processors in each dimension integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_z_slab Is Z-slab optimization enabled type( dtfft_stream_t ), intent(in) :: stream Stream to use type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: best_time Elapsed time for best plan selected type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected for the grid Calls proc~~autotune_grid~~CallsGraph proc~autotune_grid autotune_grid interface~int_to_str int_to_str proc~autotune_grid->interface~int_to_str mpi_comm_free mpi_comm_free proc~autotune_grid->mpi_comm_free proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~destroy~12 pencil%destroy proc~autotune_grid->proc~destroy~12 proc~get_log_enabled get_log_enabled proc~autotune_grid->proc~get_log_enabled proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~autotune_grid->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~write_message write_message proc~autotune_grid->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~10 pencil%create proc~create_pencils_and_comm->proc~create~10 interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~run_autotune_backend->interface~int_to_str proc~run_autotune_backend->proc~get_log_enabled proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~write_message interface~cudaeventcreate cudaEventCreate proc~run_autotune_backend->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~run_autotune_backend->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~run_autotune_backend->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~run_autotune_backend->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~run_autotune_backend->interface~cudaeventsynchronize interface~cudastreamsynchronize cudaStreamSynchronize proc~run_autotune_backend->interface~cudastreamsynchronize mpi_abort mpi_abort proc~run_autotune_backend->mpi_abort mpi_allreduce mpi_allreduce proc~run_autotune_backend->mpi_allreduce mpi_barrier mpi_barrier proc~run_autotune_backend->mpi_barrier mpi_comm_size mpi_comm_size proc~run_autotune_backend->mpi_comm_size proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_mem alloc_mem proc~run_autotune_backend->proc~alloc_mem proc~create_helper backend_helper%create_helper proc~run_autotune_backend->proc~create_helper proc~cudageterrorstring cudaGetErrorString proc~run_autotune_backend->proc~cudageterrorstring proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~double_to_str double_to_str proc~run_autotune_backend->proc~double_to_str proc~dtfft_get_backend_string dtfft_get_backend_string proc~run_autotune_backend->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~run_autotune_backend->proc~dtfft_get_error_string proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~free_mem free_mem proc~run_autotune_backend->proc~free_mem proc~get_iters_from_env get_iters_from_env proc~run_autotune_backend->proc~get_iters_from_env proc~get_local_sizes~2 get_local_sizes proc~run_autotune_backend->proc~get_local_sizes~2 proc~get_mpi_enabled get_mpi_enabled proc~run_autotune_backend->proc~get_mpi_enabled proc~get_nvshmem_enabled get_nvshmem_enabled proc~run_autotune_backend->proc~get_nvshmem_enabled proc~get_pipelined_enabled get_pipelined_enabled proc~run_autotune_backend->proc~get_pipelined_enabled proc~is_backend_mpi is_backend_mpi proc~run_autotune_backend->proc~is_backend_mpi proc~is_backend_nccl is_backend_nccl proc~run_autotune_backend->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~run_autotune_backend->proc~is_backend_nvshmem proc~is_backend_pipelined is_backend_pipelined proc~run_autotune_backend->proc~is_backend_pipelined mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~alloc_and_set_aux->mpi_abort proc~alloc_and_set_aux->mpi_allreduce proc~alloc_and_set_aux->proc~alloc_mem proc~alloc_and_set_aux->proc~dtfft_get_error_string proc~get_aux_size~3 transpose_handle_cuda%get_aux_size proc~alloc_and_set_aux->proc~get_aux_size~3 proc~alloc_mem->interface~int_to_str proc~alloc_mem->proc~get_log_enabled proc~alloc_mem->proc~write_message proc~alloc_mem->mpi_abort proc~alloc_mem->mpi_allreduce proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~dtfft_get_backend_string proc~alloc_mem->proc~is_backend_nccl proc~alloc_mem->proc~is_backend_nvshmem interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring temp temp proc~alloc_mem->temp proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~create_helper->interface~int_to_str proc~create_helper->mpi_abort proc~create_helper->mpi_comm_rank proc~create_helper->mpi_comm_size interface~get_env get_env proc~create_helper->interface~get_env interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_helper->proc~ncclgeterrorstring proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create~10->proc~destroy~12 proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~get_local_size get_local_size proc~create~10->proc~get_local_size interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy~10 nvrtc_kernel%destroy proc~destroy~11->proc~destroy~10 proc~execute~9 nvrtc_kernel%execute proc~execute~10->proc~execute~9 proc~free_mem->interface~int_to_str proc~free_mem->mpi_abort proc~free_mem->proc~is_backend_nccl proc~free_mem->proc~is_backend_nvshmem interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~nvshmem_free nvshmem_free proc~free_mem->interface~nvshmem_free proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~free_mem->proc~ncclgeterrorstring proc~get_iters_from_env->interface~get_env proc~get_mpi_enabled_from_env get_mpi_enabled_from_env proc~get_mpi_enabled->proc~get_mpi_enabled_from_env proc~get_nvshmem_enabled_from_env get_nvshmem_enabled_from_env proc~get_nvshmem_enabled->proc~get_nvshmem_enabled_from_env proc~get_pipe_enabled_from_env get_pipe_enabled_from_env proc~get_pipelined_enabled->proc~get_pipe_enabled_from_env proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~check_if_even->mpi_comm_size proc~check_if_even->mpi_allgather proc~destroy_helper->interface~int_to_str proc~destroy_helper->proc~get_log_enabled proc~destroy_helper->proc~write_message proc~destroy_helper->mpi_abort proc~destroy_helper->proc~ncclgeterrorstring interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy proc~destroy~10->interface~int_to_str proc~destroy~10->mpi_abort proc~destroy~10->proc~cudageterrorstring proc~destroy~10->interface~cudafree proc~mark_unused mark_unused proc~destroy~10->proc~mark_unused proc~execute~9->interface~int_to_str proc~execute~9->mpi_abort proc~execute~9->mpi_comm_rank proc~execute~9->proc~cudageterrorstring interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks proc~get_aux_size~2 abstract_backend%get_aux_size proc~get_aux_size~3->proc~get_aux_size~2 proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_comm_size proc~get_local_size->mpi_allgather proc~ncclgeterrorstring->proc~string_c2f interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~mark_unused->proc~is_same_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~autotune_grid~~CalledByGraph proc~autotune_grid autotune_grid proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~autotune_grid_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autotune_grid.html"},{"title":"run_autotune_backend – dtFFT","text":"private  subroutine run_autotune_backend(comms, cart_comm, pencils, base_storage, stream, is_z_slab, backend, best_time, best_backend) Uses iso_c_binding iso_fortran_env proc~~run_autotune_backend~~UsesGraph proc~run_autotune_backend run_autotune_backend iso_c_binding iso_c_binding proc~run_autotune_backend->iso_c_binding iso_fortran_env iso_fortran_env proc~run_autotune_backend->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Runs autotune for all backends Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comms (:) 1D comms type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( pencil ), intent(in) :: pencils (:) Source meta integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use logical, intent(in) :: is_z_slab Is Z-slab optimization enabled type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: best_time Elapsed time for best backend type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected Calls proc~~run_autotune_backend~~CallsGraph proc~run_autotune_backend run_autotune_backend interface~cudaeventcreate cudaEventCreate proc~run_autotune_backend->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~run_autotune_backend->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~run_autotune_backend->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~run_autotune_backend->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~run_autotune_backend->interface~cudaeventsynchronize interface~cudastreamsynchronize cudaStreamSynchronize proc~run_autotune_backend->interface~cudastreamsynchronize interface~int_to_str int_to_str proc~run_autotune_backend->interface~int_to_str mpi_abort mpi_abort proc~run_autotune_backend->mpi_abort mpi_allreduce mpi_allreduce proc~run_autotune_backend->mpi_allreduce mpi_barrier mpi_barrier proc~run_autotune_backend->mpi_barrier mpi_comm_size mpi_comm_size proc~run_autotune_backend->mpi_comm_size proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_mem alloc_mem proc~run_autotune_backend->proc~alloc_mem proc~create_helper backend_helper%create_helper proc~run_autotune_backend->proc~create_helper proc~cudageterrorstring cudaGetErrorString proc~run_autotune_backend->proc~cudageterrorstring proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~double_to_str double_to_str proc~run_autotune_backend->proc~double_to_str proc~dtfft_get_backend_string dtfft_get_backend_string proc~run_autotune_backend->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~run_autotune_backend->proc~dtfft_get_error_string proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~free_mem free_mem proc~run_autotune_backend->proc~free_mem proc~get_iters_from_env get_iters_from_env proc~run_autotune_backend->proc~get_iters_from_env proc~get_local_sizes~2 get_local_sizes proc~run_autotune_backend->proc~get_local_sizes~2 proc~get_log_enabled get_log_enabled proc~run_autotune_backend->proc~get_log_enabled proc~get_mpi_enabled get_mpi_enabled proc~run_autotune_backend->proc~get_mpi_enabled proc~get_nvshmem_enabled get_nvshmem_enabled proc~run_autotune_backend->proc~get_nvshmem_enabled proc~get_pipelined_enabled get_pipelined_enabled proc~run_autotune_backend->proc~get_pipelined_enabled proc~is_backend_mpi is_backend_mpi proc~run_autotune_backend->proc~is_backend_mpi proc~is_backend_nccl is_backend_nccl proc~run_autotune_backend->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~run_autotune_backend->proc~is_backend_nvshmem proc~is_backend_pipelined is_backend_pipelined proc~run_autotune_backend->proc~is_backend_pipelined proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~write_message write_message proc~run_autotune_backend->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~alloc_and_set_aux->mpi_abort proc~alloc_and_set_aux->mpi_allreduce proc~alloc_and_set_aux->proc~alloc_mem proc~alloc_and_set_aux->proc~dtfft_get_error_string proc~get_aux_size~3 transpose_handle_cuda%get_aux_size proc~alloc_and_set_aux->proc~get_aux_size~3 proc~alloc_mem->interface~int_to_str proc~alloc_mem->mpi_abort proc~alloc_mem->mpi_allreduce proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~dtfft_get_backend_string proc~alloc_mem->proc~get_log_enabled proc~alloc_mem->proc~is_backend_nccl proc~alloc_mem->proc~is_backend_nvshmem proc~alloc_mem->proc~write_message interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring temp temp proc~alloc_mem->temp proc~create_helper->interface~int_to_str proc~create_helper->mpi_abort proc~create_helper->mpi_comm_size interface~get_env get_env proc~create_helper->interface~get_env interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast mpi_comm_rank mpi_comm_rank proc~create_helper->mpi_comm_rank proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_helper->proc~ncclgeterrorstring interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy~10 nvrtc_kernel%destroy proc~destroy~11->proc~destroy~10 proc~execute~9 nvrtc_kernel%execute proc~execute~10->proc~execute~9 proc~free_mem->interface~int_to_str proc~free_mem->mpi_abort proc~free_mem->proc~is_backend_nccl proc~free_mem->proc~is_backend_nvshmem interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~nvshmem_free nvshmem_free proc~free_mem->interface~nvshmem_free proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~free_mem->proc~ncclgeterrorstring proc~get_iters_from_env->interface~get_env proc~get_mpi_enabled_from_env get_mpi_enabled_from_env proc~get_mpi_enabled->proc~get_mpi_enabled_from_env proc~get_nvshmem_enabled_from_env get_nvshmem_enabled_from_env proc~get_nvshmem_enabled->proc~get_nvshmem_enabled_from_env proc~get_pipe_enabled_from_env get_pipe_enabled_from_env proc~get_pipelined_enabled->proc~get_pipe_enabled_from_env interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~destroy_helper->interface~int_to_str proc~destroy_helper->mpi_abort proc~destroy_helper->proc~get_log_enabled proc~destroy_helper->proc~write_message proc~destroy_helper->proc~ncclgeterrorstring interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy proc~destroy~10->interface~int_to_str proc~destroy~10->mpi_abort proc~destroy~10->proc~cudageterrorstring proc~destroy~10->interface~cudafree proc~mark_unused mark_unused proc~destroy~10->proc~mark_unused proc~execute~9->interface~int_to_str proc~execute~9->mpi_abort proc~execute~9->proc~cudageterrorstring proc~execute~9->mpi_comm_rank interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks proc~get_aux_size~2 abstract_backend%get_aux_size proc~get_aux_size~3->proc~get_aux_size~2 proc~ncclgeterrorstring->proc~string_c2f interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~mark_unused->proc~is_same_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_autotune_backend~~CalledByGraph proc~run_autotune_backend run_autotune_backend proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/run_autotune_backend.html"},{"title":"cudaGetErrorString – dtFFT","text":"public  function cudaGetErrorString(errcode) result(string) Helper function that returns a string describing the given nvrtcResult code\nIf the error code is not recognized, “unrecognized error code” is returned. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: errcode CUDA Runtime Compilation API result code. Return Value character(len=:), allocatable Result string Calls proc~~cudageterrorstring~~CallsGraph proc~cudageterrorstring cudaGetErrorString interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cudageterrorstring~~CalledByGraph proc~cudageterrorstring cudaGetErrorString proc~alloc_mem alloc_mem proc~alloc_mem->proc~cudageterrorstring proc~clean_unused_cache clean_unused_cache proc~clean_unused_cache->proc~cudageterrorstring proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~cudageterrorstring proc~create_device_pointer create_device_pointer proc~create_device_pointer->proc~cudageterrorstring proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~cudageterrorstring proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~create~5 abstract_backend%create proc~create~5->proc~cudageterrorstring proc~destroy_stream destroy_stream proc~destroy_stream->proc~cudageterrorstring proc~destroy~10 nvrtc_kernel%destroy proc~destroy~10->proc~cudageterrorstring proc~destroy~5 abstract_backend%destroy proc~destroy~5->proc~cudageterrorstring proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~cudageterrorstring proc~execute~9 nvrtc_kernel%execute proc~execute_mpi->proc~execute~9 proc~execute~2 backend_cufftmp%execute proc~execute~2->proc~cudageterrorstring proc~execute~5 abstract_backend%execute proc~execute~5->proc~cudageterrorstring proc~execute~5->proc~execute~9 proc~execute~9->proc~cudageterrorstring proc~get_user_stream->proc~cudageterrorstring proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~cudageterrorstring proc~run_autotune_backend->proc~alloc_mem proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~clean_unused_cache proc~create_cuda->proc~get_user_stream proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_stream proc~create~7 cufft_executor%create proc~create~7->proc~get_user_stream proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~8->proc~create_device_pointer proc~create~8->proc~destroy~10 proc~destroy~11->proc~destroy~10 proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~clean_unused_cache proc~destroy~9->proc~destroy_stream proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~9 proc~execute~10->proc~execute~9 proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cudageterrorstring.html"},{"title":"cudaStreamQuery – dtFFT","text":"interface Queries an asynchronous stream for completion status. Called by interface~~cudastreamquery~~CalledByGraph interface~cudastreamquery cudaStreamQuery proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->interface~cudastreamquery proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamQuery(stream) result(cudaError_t) bind(C, name=\"cudaStreamQuery\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if all operations in stream have completed, \nor cudaErrorNotReady if not.","tags":"","loc":"interface/cudastreamquery.html"},{"title":"cudaStreamCreate – dtFFT","text":"interface Creates an asynchronous stream. Called by interface~~cudastreamcreate~~CalledByGraph interface~cudastreamcreate cudaStreamCreate proc~create~5 abstract_backend%create proc~create~5->interface~cudastreamcreate proc~get_user_stream get_user_stream proc~get_user_stream->interface~cudastreamcreate proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_user_stream proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~get_user_stream proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_stream proc~create~7 cufft_executor%create proc~create~7->proc~get_user_stream proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamCreate(stream) result(cudaError_t) bind(C, name=\"cudaStreamCreate\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ) :: stream Pointer to the created stream Return Value integer(kind=c_int) Returns cudaSuccess if the stream was created successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudastreamcreate.html"},{"title":"cudaStreamDestroy – dtFFT","text":"interface Destroys an asynchronous stream. Called by interface~~cudastreamdestroy~~CalledByGraph interface~cudastreamdestroy cudaStreamDestroy proc~destroy_stream destroy_stream proc~destroy_stream->interface~cudastreamdestroy proc~destroy~5 abstract_backend%destroy proc~destroy~5->interface~cudastreamdestroy proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~destroy_stream proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamDestroy(stream) result(cudaError_t) bind(C, name=\"cudaStreamDestroy\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the stream was destroyed successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudastreamdestroy.html"},{"title":"cudaStreamSynchronize – dtFFT","text":"interface Waits for stream tasks to complete. Called by interface~~cudastreamsynchronize~~CalledByGraph interface~cudastreamsynchronize cudaStreamSynchronize proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->interface~cudastreamsynchronize proc~execute~2 backend_cufftmp%execute proc~execute~2->interface~cudastreamsynchronize proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudastreamsynchronize proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamSynchronize(stream) result(cudaError_t) bind(C, name=\"cudaStreamSynchronize\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the stream tasks completed successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudastreamsynchronize.html"},{"title":"cudaMalloc – dtFFT","text":"interface Allocates memory on the device. Called by interface~~cudamalloc~~CalledByGraph interface~cudamalloc cudaMalloc proc~alloc_mem alloc_mem proc~alloc_mem->interface~cudamalloc proc~create_device_pointer create_device_pointer proc~create_device_pointer->interface~cudamalloc proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~create~8 nvrtc_kernel%create proc~create~8->proc~create_device_pointer proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaMalloc(ptr, count) result(cudaError_t) bind(C, name=\"cudaMalloc\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr Pointer to allocated device memory integer(kind=c_size_t), value :: count Requested allocation size in bytes Return Value integer(kind=c_int) Returns cudaSuccess if memory was allocated successfully, \nor cudaErrorMemoryAllocation if the memory could not be allocated.","tags":"","loc":"interface/cudamalloc.html"},{"title":"cudaFree – dtFFT","text":"interface Frees memory on the device. Called by interface~~cudafree~~CalledByGraph interface~cudafree cudaFree proc~destroy~10 nvrtc_kernel%destroy proc~destroy~10->interface~cudafree proc~free_mem free_mem proc~free_mem->interface~cudafree proc~create~8 nvrtc_kernel%create proc~create~8->proc~destroy~10 proc~destroy~11 transpose_handle_cuda%destroy proc~destroy~11->proc~destroy~10 proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~destroy~11 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~destroy_cuda->proc~mem_free~5 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaFree(ptr) result(cudaError_t) bind(C, name=\"cudaFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to memory to free Return Value integer(kind=c_int) Returns cudaSuccess if memory was freed successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudafree.html"},{"title":"cudaMemset – dtFFT","text":"interface Initializes or sets device memory to a value. public  function cudaMemset(ptr, val, count) result(cudaError_t) bind(C, name=\"cudaMemset\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to device memory integer(kind=c_int), value :: val Value to set integer(kind=c_size_t), value :: count Size in bytes to set Return Value integer(kind=c_int) Returns cudaSuccess if the memory was set successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudamemset.html"},{"title":"cudaEventCreateWithFlags – dtFFT","text":"interface Creates an event with the specified flags. Called by interface~~cudaeventcreatewithflags~~CalledByGraph interface~cudaeventcreatewithflags cudaEventCreateWithFlags proc~create~5 abstract_backend%create proc~create~5->interface~cudaeventcreatewithflags Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventCreateWithFlags(event, flags) result(cudaError_t) bind(C, name=\"cudaEventCreateWithFlags\") Arguments Type Intent Optional Attributes Name type( cudaEvent ) :: event Event identifier integer(kind=c_int), value :: flags Flags for event creation Return Value integer(kind=c_int) Returns cudaSuccess if the event was created successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudaeventcreatewithflags.html"},{"title":"cudaEventRecord – dtFFT","text":"interface Records an event in a stream. Called by interface~~cudaeventrecord~~CalledByGraph interface~cudaeventrecord cudaEventRecord proc~execute~5 abstract_backend%execute proc~execute~5->interface~cudaeventrecord proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventrecord proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventRecord(event, stream) result(cudaError_t) bind(C, name=\"cudaEventRecord\") Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was recorded successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudaeventrecord.html"},{"title":"cudaStreamWaitEvent – dtFFT","text":"interface Makes a stream wait on an event. Called by interface~~cudastreamwaitevent~~CalledByGraph interface~cudastreamwaitevent cudaStreamWaitEvent proc~execute~5 abstract_backend%execute proc~execute~5->interface~cudastreamwaitevent Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamWaitEvent(stream, event, flags) result(cudaError_t) bind(C, name=\"cudaStreamWaitEvent\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier type( cudaEvent ), value :: event Event identifier integer(kind=c_int), value :: flags Flags for the wait operation Return Value integer(kind=c_int) Returns cudaSuccess if the stream is waiting successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudastreamwaitevent.html"},{"title":"cudaEventDestroy – dtFFT","text":"interface Destroys an event. Called by interface~~cudaeventdestroy~~CalledByGraph interface~cudaeventdestroy cudaEventDestroy proc~destroy~5 abstract_backend%destroy proc~destroy~5->interface~cudaeventdestroy proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventdestroy proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventDestroy(event) result(cudaError_t) bind(C, name=\"cudaEventDestroy\") Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was destroyed successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudaeventdestroy.html"},{"title":"cudaEventCreate – dtFFT","text":"interface Creates an event. Called by interface~~cudaeventcreate~~CalledByGraph interface~cudaeventcreate cudaEventCreate proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventcreate proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventCreate(event) result(cudaError_t) bind(C, name=\"cudaEventCreate\") Arguments Type Intent Optional Attributes Name type( cudaEvent ) :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was created successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudaeventcreate.html"},{"title":"cudaEventSynchronize – dtFFT","text":"interface Waits for an event to complete. Called by interface~~cudaeventsynchronize~~CalledByGraph interface~cudaeventsynchronize cudaEventSynchronize proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventsynchronize proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventSynchronize(event) result(cudaError_t) bind(C, name=\"cudaEventSynchronize\") Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event completed successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudaeventsynchronize.html"},{"title":"cudaEventElapsedTime – dtFFT","text":"interface Computes the elapsed time between two events. Called by interface~~cudaeventelapsedtime~~CalledByGraph interface~cudaeventelapsedtime cudaEventElapsedTime proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventelapsedtime proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventElapsedTime(time, start, end) result(cudaError_t) bind(C, name=\"cudaEventElapsedTime\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: time Elapsed time in milliseconds type( cudaEvent ), value :: start Starting event type( cudaEvent ), value :: end Ending event Return Value integer(kind=c_int) Returns cudaSuccess if the elapsed time was computed successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudaeventelapsedtime.html"},{"title":"cudaMemcpyAsync – dtFFT","text":"public interface cudaMemcpyAsync Copies data asynchronously between host and device. Called by interface~~cudamemcpyasync~~CalledByGraph interface~cudamemcpyasync cudaMemcpyAsync proc~execute~5 abstract_backend%execute proc~execute~5->interface~cudamemcpyasync proc~execute~9 nvrtc_kernel%execute proc~execute~5->proc~execute~9 proc~execute~9->interface~cudamemcpyasync proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~9 proc~execute~10 transpose_handle_cuda%execute proc~execute~10->proc~execute~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~execute~10 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function cudaMemcpyAsync_ptr(dst, src, count, kdir, stream) result(cudaError_t) bind(C, name=\"cudaMemcpyAsync\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dst Destination pointer type(c_ptr), value :: src Source pointer integer(kind=c_size_t), value :: count Size in bytes to copy integer(kind=c_int), value :: kdir Direction of copy (host-to-device, device-to-host, etc.) type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the copy was initiated successfully, \nor an error code if there was an issue. private  function cudaMemcpyAsync_r32(dst, src, count, kdir, stream) result(cudaError_t) bind(C, name=\"cudaMemcpyAsync\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: dst Destination array (32-bit float) real(kind=c_float) :: src Source array (32-bit float) integer(kind=c_size_t), value :: count Number of elements to copy integer(kind=c_int), value :: kdir Direction of copy type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the copy was initiated successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudamemcpyasync.html"},{"title":"cudaMemcpy – dtFFT","text":"public interface cudaMemcpy Copies data synchronously between host and device. Called by interface~~cudamemcpy~~CalledByGraph interface~cudamemcpy cudaMemcpy proc~create_device_pointer create_device_pointer proc~create_device_pointer->interface~cudamemcpy proc~create~8 nvrtc_kernel%create proc~create~8->proc~create_device_pointer proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function cudaMemcpy_ptr(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dst Destination pointer type(c_ptr), value :: src Source pointer integer(kind=c_size_t), value :: count Size in bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully, \nor an error code if there was an issue. private  function cudaMemcpy_r64(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name real(kind=c_double) :: dst (*) Destination array (64-bit float) real(kind=c_double) :: src (*) Source array (64-bit float) integer(kind=c_size_t), value :: count Number of bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully, \nor an error code if there was an issue. private  function cudaMemcpy_r32(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: dst (*) Destination array (32-bit float) real(kind=c_float) :: src (*) Source array (32-bit float) integer(kind=c_size_t), value :: count Number of bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudamemcpy.html"},{"title":"cudaGetDevice – dtFFT","text":"interface Returns the current device. Called by interface~~cudagetdevice~~CalledByGraph interface~cudagetdevice cudaGetDevice proc~compile_and_cache compile_and_cache proc~compile_and_cache->interface~cudagetdevice proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->interface~cudagetdevice proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaGetDevice(num) result(cudaError_t) bind(C, name=\"cudaGetDevice\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: num Device number Return Value integer(kind=c_int) Returns cudaSuccess if the device was retrieved successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudagetdevice.html"},{"title":"cudaGetDeviceCount – dtFFT","text":"interface Returns the number of available devices. Called by interface~~cudagetdevicecount~~CalledByGraph interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->interface~cudagetdevicecount proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaGetDeviceCount(num) result(cudaError_t) bind(C, name=\"cudaGetDeviceCount\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: num Number of devices Return Value integer(kind=c_int) Returns cudaSuccess if the device count was retrieved successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudagetdevicecount.html"},{"title":"cudaSetDevice – dtFFT","text":"interface Sets the current device. public  function cudaSetDevice(num) result(cudaError_t) bind(C, name=\"cudaSetDevice\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: num Device number Return Value integer(kind=c_int) Returns cudaSuccess if the device was set successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudasetdevice.html"},{"title":"get_cuda_architecture – dtFFT","text":"interface Returns the CUDA architecture for a given device. Called by interface~~get_cuda_architecture~~CalledByGraph interface~get_cuda_architecture get_cuda_architecture proc~compile_and_cache compile_and_cache proc~compile_and_cache->interface~get_cuda_architecture proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine get_cuda_architecture(device, major, minor) bind(C, name=\"get_cuda_architecture\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: device Device number integer(kind=c_int) :: major Major compute capability integer(kind=c_int) :: minor Minor compute capability","tags":"","loc":"interface/get_cuda_architecture.html"},{"title":"cudaMemGetInfo – dtFFT","text":"interface Returns the amount of free and total memory on the device. Called by interface~~cudamemgetinfo~~CalledByGraph interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem alloc_mem proc~alloc_mem->interface~cudamemgetinfo proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaMemGetInfo(free, total) result(cudaError_t) bind(C, name=\"cudaMemGetInfo\") Arguments Type Intent Optional Attributes Name integer(kind=c_size_t) :: free Free memory in bytes integer(kind=c_size_t) :: total Total memory in bytes Return Value integer(kind=c_int) Returns cudaSuccess if the memory information was retrieved successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudamemgetinfo.html"},{"title":"cudaDeviceSynchronize – dtFFT","text":"interface Synchronizes the device, blocking until all preceding tasks in all streams have completed. public  function cudaDeviceSynchronize() result(cudaError_t) bind(C, name=\"cudaDeviceSynchronize\") Arguments None Return Value integer(kind=c_int) Returns cudaSuccess if the device was set successfully, \nor an error code if there was an issue.","tags":"","loc":"interface/cudadevicesynchronize.html"},{"title":"cudaGetErrorString_c – dtFFT","text":"interface Returns the string representation of an error code. Called by interface~~cudageterrorstring_c~~CalledByGraph interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring cudaGetErrorString proc~cudageterrorstring->interface~cudageterrorstring_c proc~alloc_mem alloc_mem proc~alloc_mem->proc~cudageterrorstring proc~clean_unused_cache clean_unused_cache proc~clean_unused_cache->proc~cudageterrorstring proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~cudageterrorstring proc~create_device_pointer create_device_pointer proc~create_device_pointer->proc~cudageterrorstring proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~cudageterrorstring proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~create~5 abstract_backend%create proc~create~5->proc~cudageterrorstring proc~destroy_stream destroy_stream proc~destroy_stream->proc~cudageterrorstring proc~destroy~10 nvrtc_kernel%destroy proc~destroy~10->proc~cudageterrorstring proc~destroy~5 abstract_backend%destroy proc~destroy~5->proc~cudageterrorstring proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~cudageterrorstring proc~execute~9 nvrtc_kernel%execute proc~execute_mpi->proc~execute~9 proc~execute~2 backend_cufftmp%execute proc~execute~2->proc~cudageterrorstring proc~execute~5 abstract_backend%execute proc~execute~5->proc~cudageterrorstring proc~execute~5->proc~execute~9 proc~execute~9->proc~cudageterrorstring proc~get_user_stream->proc~cudageterrorstring proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~cudageterrorstring proc~run_autotune_backend->proc~alloc_mem proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~clean_unused_cache proc~create_cuda->proc~get_user_stream proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_stream proc~create~7 cufft_executor%create proc~create~7->proc~get_user_stream proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~8->proc~create_device_pointer proc~create~8->proc~destroy~10 proc~destroy~11->proc~destroy~10 proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~clean_unused_cache proc~destroy~9->proc~destroy_stream proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~9 proc~execute~10->proc~execute~9 proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function cudaGetErrorString_c(errcode) result(string) bind(C, name=\"cudaGetErrorString\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: errcode Error code Return Value type(c_ptr) Pointer to the error string","tags":"","loc":"interface/cudageterrorstring_c.html"},{"title":"is_nvshmem_ptr – dtFFT","text":"public  function is_nvshmem_ptr(ptr) result(bool) Checks if pointer is a symmetric nvshmem allocated pointer Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr Device pointer Return Value logical Result Calls proc~~is_nvshmem_ptr~~CallsGraph proc~is_nvshmem_ptr is_nvshmem_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr is_null_ptr is_null_ptr proc~is_nvshmem_ptr->is_null_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_nvshmem_ptr~~CalledByGraph proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers check_device_pointers proc~check_device_pointers->proc~is_nvshmem_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_device_pointers proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~check_device_pointers proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_nvshmem_ptr.html"},{"title":"nvshmem_malloc – dtFFT","text":"interface Called by interface~~nvshmem_malloc~~CalledByGraph interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem alloc_mem proc~alloc_mem->interface~nvshmem_malloc proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function nvshmem_malloc(size) result(ptr) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: size Size of the allocation in bytes. Return Value type(c_ptr) Pointer to the allocated memory. Description Allocates symmetric memory in the NVSHMEM heap.","tags":"","loc":"interface/nvshmem_malloc.html"},{"title":"nvshmemx_float_alltoall_on_stream – dtFFT","text":"interface public  function nvshmemx_float_alltoall_on_stream(team, dest, source, nelems, stream) result(ierr) bind(C) Arguments Type Intent Optional Attributes Name type( nvshmem_team_t ), intent(in), value :: team NVSHMEM team. type(c_ptr), value :: dest Destination buffer. type(c_ptr), value :: source Source buffer. integer(kind=c_size_t), intent(in), value :: nelems Number of elements to exchange. type( dtfft_stream_t ), intent(in), value :: stream CUDA stream for the operation. Return Value integer(kind=c_int) Completion status. Description Performs an all-to-all exchange of floating-point data on the specified stream.","tags":"","loc":"interface/nvshmemx_float_alltoall_on_stream.html"},{"title":"nvshmem_ptr – dtFFT","text":"interface Called by interface~~nvshmem_ptr~~CalledByGraph interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr is_nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr proc~check_device_pointers check_device_pointers proc~check_device_pointers->proc~is_nvshmem_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_device_pointers proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~check_device_pointers proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function nvshmem_ptr(ptr, pe) result(pe_ptr) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Local pointer to the symmetric memory. integer(kind=c_int), value :: pe PE (Processing Element) number. Return Value type(c_ptr) Pointer to the symmetric memory on the specified PE. Description Returns a pointer to a symmetric memory location on a specified PE.","tags":"","loc":"interface/nvshmem_ptr.html"},{"title":"nvshmem_my_pe – dtFFT","text":"interface Called by interface~~nvshmem_my_pe~~CalledByGraph interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr is_nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_my_pe proc~check_device_pointers check_device_pointers proc~check_device_pointers->proc~is_nvshmem_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_device_pointers proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~check_device_pointers proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function nvshmem_my_pe() result(pe) bind(C) Arguments None Return Value integer(kind=c_int) PE number of the calling thread. Description Returns the PE (Processing Element) number of the calling thread.","tags":"","loc":"interface/nvshmem_my_pe.html"},{"title":"nvshmemx_init_status – dtFFT","text":"interface public  function nvshmemx_init_status() result(status) bind(C) Arguments None Return Value integer(kind=c_int) Completion status.","tags":"","loc":"interface/nvshmemx_init_status.html"},{"title":"nvshmem_free – dtFFT","text":"interface Called by interface~~nvshmem_free~~CalledByGraph interface~nvshmem_free nvshmem_free proc~free_mem free_mem proc~free_mem->interface~nvshmem_free proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine nvshmem_free(ptr) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to the memory to free. Description Frees symmetric memory allocated by nvshmem_malloc.","tags":"","loc":"interface/nvshmem_free.html"},{"title":"nvshmemx_sync_all_on_stream – dtFFT","text":"interface public  subroutine nvshmemx_sync_all_on_stream(stream) bind(C) Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), intent(in), value :: stream CUDA stream for synchronization. Description Synchronizes all PEs (Processing Elements) on the specified stream.","tags":"","loc":"interface/nvshmemx_sync_all_on_stream.html"},{"title":"get_aux_size – dtFFT","text":"private  function get_aux_size(self) Returns number of bytes required by aux buffer Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract GPU backend Return Value integer(kind=int64) Called by proc~~get_aux_size~2~~CalledByGraph proc~get_aux_size~2 abstract_backend%get_aux_size proc~get_aux_size~3 transpose_handle_cuda%get_aux_size proc~get_aux_size~3->proc~get_aux_size~2 proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~get_aux_size~3 proc~get_aux_size transpose_plan_cuda%get_aux_size proc~get_aux_size->proc~get_aux_size~3 proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_aux_size~2.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, backend, tranpose_type, helper, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Uses iso_c_binding iso_fortran_env proc~~create~5~~UsesGraph proc~create~5 abstract_backend%create iso_c_binding iso_c_binding proc~create~5->iso_c_binding iso_fortran_env iso_fortran_env proc~create~5->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates Abstract GPU Backend Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend type( dtfft_backend_t ), intent(in) :: backend GPU Backend type type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element Calls proc~~create~5~~CallsGraph proc~create~5 abstract_backend%create create_private create_private proc~create~5->create_private interface~cudaeventcreatewithflags cudaEventCreateWithFlags proc~create~5->interface~cudaeventcreatewithflags interface~cudastreamcreate cudaStreamCreate proc~create~5->interface~cudastreamcreate interface~int_to_str int_to_str proc~create~5->interface~int_to_str mpi_abort mpi_abort proc~create~5->mpi_abort mpi_comm_rank mpi_comm_rank proc~create~5->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create~5->mpi_comm_size proc~cudageterrorstring cudaGetErrorString proc~create~5->proc~cudageterrorstring proc~is_backend_mpi is_backend_mpi proc~create~5->proc~is_backend_mpi proc~is_backend_pipelined is_backend_pipelined proc~create~5->proc~is_backend_pipelined proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~5.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, stream, aux) Uses iso_c_binding iso_fortran_env proc~~execute~5~~UsesGraph proc~execute~5 abstract_backend%execute iso_c_binding iso_c_binding proc~execute~5->iso_c_binding iso_fortran_env iso_fortran_env proc~execute~5->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes GPU Backend Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer Calls proc~~execute~5~~CallsGraph proc~execute~5 abstract_backend%execute execute_private execute_private proc~execute~5->execute_private interface~cudaeventrecord cudaEventRecord proc~execute~5->interface~cudaeventrecord interface~cudamemcpyasync cudaMemcpyAsync proc~execute~5->interface~cudamemcpyasync interface~cudastreamwaitevent cudaStreamWaitEvent proc~execute~5->interface~cudastreamwaitevent interface~int_to_str int_to_str proc~execute~5->interface~int_to_str mpi_abort mpi_abort proc~execute~5->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~execute~5->proc~cudageterrorstring proc~execute~9 nvrtc_kernel%execute proc~execute~5->proc~execute~9 proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~execute~9->interface~cudamemcpyasync proc~execute~9->interface~int_to_str proc~execute~9->mpi_abort proc~execute~9->proc~cudageterrorstring mpi_comm_rank mpi_comm_rank proc~execute~9->mpi_comm_rank proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~5.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Uses iso_c_binding iso_fortran_env proc~~destroy~5~~UsesGraph proc~destroy~5 abstract_backend%destroy iso_c_binding iso_c_binding proc~destroy~5->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy~5->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys Abstract GPU Backend Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU backend Calls proc~~destroy~5~~CallsGraph proc~destroy~5 abstract_backend%destroy destroy_private destroy_private proc~destroy~5->destroy_private interface~cudaeventdestroy cudaEventDestroy proc~destroy~5->interface~cudaeventdestroy interface~cudastreamdestroy cudaStreamDestroy proc~destroy~5->interface~cudastreamdestroy interface~int_to_str int_to_str proc~destroy~5->interface~int_to_str mpi_abort mpi_abort proc~destroy~5->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy~5->proc~cudageterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~5.html"},{"title":"set_unpack_kernel – dtFFT","text":"private  subroutine set_unpack_kernel(self, unpack_kernel, unpack_kernel2) Sets unpack kernel for pipelined backend Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend type( nvrtc_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), intent(in), optional, target :: unpack_kernel2 Kernel for unpacking data Called by proc~~set_unpack_kernel~~CalledByGraph proc~set_unpack_kernel abstract_backend%set_unpack_kernel proc~create~9 transpose_handle_cuda%create proc~create~9->proc~set_unpack_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_unpack_kernel.html"},{"title":"create_helper – dtFFT","text":"private  subroutine create_helper(self, base_comm, comms, is_nccl_needed, pencils) Uses iso_c_binding iso_fortran_env proc~~create_helper~~UsesGraph proc~create_helper backend_helper%create_helper iso_c_binding iso_c_binding proc~create_helper->iso_c_binding iso_fortran_env iso_fortran_env proc~create_helper->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates helper Type Bound backend_helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper type(MPI_Comm), intent(in) :: base_comm MPI communicator type(MPI_Comm), intent(in) :: comms (:) 1D Communicators logical, intent(in) :: is_nccl_needed If nccl communicator will be needed type( pencil ), intent(in), target :: pencils (:) Pencils Calls proc~~create_helper~~CallsGraph proc~create_helper backend_helper%create_helper interface~get_env get_env proc~create_helper->interface~get_env interface~int_to_str int_to_str proc~create_helper->interface~int_to_str interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid mpi_abort mpi_abort proc~create_helper->mpi_abort mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast mpi_comm_rank mpi_comm_rank proc~create_helper->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_helper->mpi_comm_size proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~ncclgeterrorstring ncclGetErrorString proc~create_helper->proc~ncclgeterrorstring proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~destroy_helper->interface~int_to_str proc~destroy_helper->mpi_abort proc~destroy_helper->proc~ncclgeterrorstring interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy proc~get_log_enabled get_log_enabled proc~destroy_helper->proc~get_log_enabled proc~write_message write_message proc~destroy_helper->proc~write_message interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f proc~get_env_int32->interface~get_env proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_helper~~CalledByGraph proc~create_helper backend_helper%create_helper proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_helper.html"},{"title":"destroy_helper – dtFFT","text":"private  subroutine destroy_helper(self) Uses iso_c_binding iso_fortran_env proc~~destroy_helper~~UsesGraph proc~destroy_helper backend_helper%destroy_helper iso_c_binding iso_c_binding proc~destroy_helper->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy_helper->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys helper Type Bound backend_helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper Calls proc~~destroy_helper~~CallsGraph proc~destroy_helper backend_helper%destroy_helper interface~int_to_str int_to_str proc~destroy_helper->interface~int_to_str interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy mpi_abort mpi_abort proc~destroy_helper->mpi_abort proc~get_log_enabled get_log_enabled proc~destroy_helper->proc~get_log_enabled proc~ncclgeterrorstring ncclGetErrorString proc~destroy_helper->proc~ncclgeterrorstring proc~write_message write_message proc~destroy_helper->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_helper~~CalledByGraph proc~destroy_helper backend_helper%destroy_helper proc~create_helper backend_helper%create_helper proc~create_helper->proc~destroy_helper proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_helper.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via vkFFT Interface Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Calls proc~~create~6~~CallsGraph proc~create~6 vkfft_executor%create proc~get_user_platform get_user_platform proc~create~6->proc~get_user_platform proc~get_user_stream get_user_stream proc~create~6->proc~get_user_stream proc~load_vkfft load_vkfft proc~create~6->proc~load_vkfft proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate interface~int_to_str int_to_str proc~get_user_stream->interface~int_to_str mpi_abort mpi_abort proc~get_user_stream->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~get_user_stream->proc~cudageterrorstring proc~load load proc~load_vkfft->proc~load proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy_strings destroy_strings proc~load->proc~destroy_strings proc~dynamic_load dynamic_load proc~load->proc~dynamic_load interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~dl_error->proc~string_c2f interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~6.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, a, b, sign) Executes vkFFT plan Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(in) :: self vkFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform","tags":"","loc":"proc/execute~6.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys vkFFT plan Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor","tags":"","loc":"proc/destroy~6.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(alloc_bytes, ptr) Dummy method. Raises error stop Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer","tags":"","loc":"proc/mem_alloc~3.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(ptr) Dummy method. Raises error stop Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"proc/mem_free~3.html"},{"title":"create_private – dtFFT","text":"private  function create_private(self, dims, transposed_dims, base_comm, comm_dims, effort, base_dtype, base_storage, is_custom_cart_comm, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plans Type Bound transpose_plan_host Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator integer(kind=int32), intent(in) :: comm_dims (:) Number of MPI Processes in all directions type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_custom_cart_comm Is custom Cartesian communicator provided by user type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Pencils type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code Calls proc~~create_private~~CallsGraph proc~create_private transpose_plan_host%create_private back_ids back_ids proc~create_private->back_ids dummy_decomp dummy_decomp proc~create_private->dummy_decomp dummy_timer dummy_timer proc~create_private->dummy_timer forw_ids forw_ids proc~create_private->forw_ids interface~int_to_str int_to_str proc~create_private->interface~int_to_str mpi_comm_size mpi_comm_size proc~create_private->mpi_comm_size proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~create_pencils_and_comm create_pencils_and_comm proc~create_private->proc~create_pencils_and_comm proc~create~11 transpose_handle_host%create proc~create_private->proc~create~11 proc~get_datatype_from_env get_datatype_from_env proc~create_private->proc~get_datatype_from_env proc~get_log_enabled get_log_enabled proc~create_private->proc~get_log_enabled proc~write_message write_message proc~create_private->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~autotune_grid_decomposition~2->interface~int_to_str proc~autotune_grid_decomposition~2->mpi_comm_size proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_grid_decomposition~2->proc~get_log_enabled proc~autotune_grid_decomposition~2->proc~write_message proc~autotune_grid~2->interface~int_to_str proc~autotune_grid~2->proc~create_pencils_and_comm proc~autotune_grid~2->proc~get_log_enabled proc~autotune_grid~2->proc~write_message mpi_comm_free mpi_comm_free proc~autotune_grid~2->mpi_comm_free proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~destroy~12 pencil%destroy proc~autotune_grid~2->proc~destroy~12 proc~double_to_str double_to_str proc~autotune_grid~2->proc~double_to_str proc~get_local_sizes~2 get_local_sizes proc~autotune_grid~2->proc~get_local_sizes~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~autotune_grid~2->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~autotune_grid~2->proc~push_nvtx_domain_range lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~10 pencil%create proc~create_pencils_and_comm->proc~create~10 proc~create~11->mpi_comm_size mpi_allgather mpi_allgather proc~create~11->mpi_allgather proc~create_handle handle_t%create_handle proc~create~11->proc~create_handle proc~create_transpose_2d transpose_handle_host%create_transpose_2d proc~create~11->proc~create_transpose_2d proc~create_transpose_xy transpose_handle_host%create_transpose_XY proc~create~11->proc~create_transpose_xy proc~create_transpose_xz transpose_handle_host%create_transpose_XZ proc~create~11->proc~create_transpose_xz proc~create_transpose_yz transpose_handle_host%create_transpose_YZ proc~create~11->proc~create_transpose_yz proc~create_transpose_zx transpose_handle_host%create_transpose_ZX proc~create~11->proc~create_transpose_zx proc~get_transpose_type get_transpose_type proc~create~11->proc~get_transpose_type interface~get_env get_env proc~get_datatype_from_env->interface~get_env mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_mpi_datatypes->proc~autotune_transpose_id mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~destroy_handle handle_t%destroy_handle proc~create_handle->proc~destroy_handle mpi_type_commit mpi_type_commit proc~create_transpose_2d->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_2d->mpi_type_contiguous mpi_type_create_resized mpi_type_create_resized proc~create_transpose_2d->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_2d->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xy->mpi_type_commit proc~create_transpose_xy->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_resized proc~create_transpose_xy->mpi_type_vector proc~create_transpose_xy->proc~free_datatypes proc~create_transpose_xz->mpi_type_commit proc~create_transpose_xz->mpi_type_contiguous proc~create_transpose_xz->mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_resized proc~create_transpose_xz->mpi_type_vector proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_yz->mpi_type_commit proc~create_transpose_yz->mpi_type_contiguous proc~create_transpose_yz->mpi_type_create_hvector proc~create_transpose_yz->mpi_type_create_resized proc~create_transpose_yz->mpi_type_vector proc~create_transpose_yz->proc~free_datatypes proc~create_transpose_zx->mpi_type_commit proc~create_transpose_zx->mpi_type_contiguous proc~create_transpose_zx->mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_resized proc~create_transpose_zx->mpi_type_vector proc~create_transpose_zx->proc~free_datatypes proc~create~10->proc~destroy~12 proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~get_local_size get_local_size proc~create~10->proc~get_local_size proc~get_plan_execution_time->interface~int_to_str proc~get_plan_execution_time->mpi_comm_size proc~get_plan_execution_time->proc~create~11 proc~get_plan_execution_time->proc~get_log_enabled proc~get_plan_execution_time->proc~write_message proc~get_plan_execution_time->proc~double_to_str proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range mpi_allreduce mpi_allreduce proc~get_plan_execution_time->mpi_allreduce mpi_wtime mpi_wtime proc~get_plan_execution_time->mpi_wtime proc~destroy~13 transpose_handle_host%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_host%execute proc~get_plan_execution_time->proc~execute~11 proc~get_iters_from_env get_iters_from_env proc~get_plan_execution_time->proc~get_iters_from_env interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~autotune_transpose_id->proc~get_plan_execution_time proc~check_if_even->mpi_comm_size proc~check_if_even->mpi_allgather proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free proc~destroy~13->proc~destroy_handle mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_start mpi_start proc~execute~11->mpi_start mpi_wait mpi_wait proc~execute~11->mpi_wait proc~free_datatypes->mpi_type_free proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_iters_from_env->interface~get_env proc~get_local_size->mpi_comm_size proc~get_local_size->mpi_allgather proc~get_local_size->mpi_comm_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_private.html"},{"title":"autotune_transpose_id – dtFFT","text":"private  function autotune_transpose_id(self, comm, cart_comm, from, to, base_dtype, base_storage, transpose_name_id, a, b, forward_id, backward_id) result(elapsed_time) Creates forward and backward transpose plans bases on source and target data distributing,\nexecutes them DTFFT_MEASURE_ITERS times ( 4 * DTFFT_MEASURE_ITERS iterations total ) Returns elapsed time for best plans selected Type Bound transpose_plan_host Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Abstract plan type(MPI_Comm), intent(in) :: comm 1D comm in case of pencils, 3D comm in case of z_slabs type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer integer(kind=int8), intent(out) :: forward_id Best forward plan ID integer(kind=int8), intent(out) :: backward_id Best backward plan ID Return Value real(kind=real64) Elapsed time for best plans selected Calls proc~~autotune_transpose_id~~CallsGraph proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_transpose_id->proc~get_plan_execution_time interface~int_to_str int_to_str proc~get_plan_execution_time->interface~int_to_str mpi_allreduce mpi_allreduce proc~get_plan_execution_time->mpi_allreduce mpi_comm_size mpi_comm_size proc~get_plan_execution_time->mpi_comm_size mpi_wtime mpi_wtime proc~get_plan_execution_time->mpi_wtime proc~create~11 transpose_handle_host%create proc~get_plan_execution_time->proc~create~11 proc~destroy~13 transpose_handle_host%destroy proc~get_plan_execution_time->proc~destroy~13 proc~double_to_str double_to_str proc~get_plan_execution_time->proc~double_to_str proc~execute~11 transpose_handle_host%execute proc~get_plan_execution_time->proc~execute~11 proc~get_iters_from_env get_iters_from_env proc~get_plan_execution_time->proc~get_iters_from_env proc~get_log_enabled get_log_enabled proc~get_plan_execution_time->proc~get_log_enabled proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~write_message write_message proc~get_plan_execution_time->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~create~11->mpi_comm_size mpi_allgather mpi_allgather proc~create~11->mpi_allgather proc~create_handle handle_t%create_handle proc~create~11->proc~create_handle proc~create_transpose_2d transpose_handle_host%create_transpose_2d proc~create~11->proc~create_transpose_2d proc~create_transpose_xy transpose_handle_host%create_transpose_XY proc~create~11->proc~create_transpose_xy proc~create_transpose_xz transpose_handle_host%create_transpose_XZ proc~create~11->proc~create_transpose_xz proc~create_transpose_yz transpose_handle_host%create_transpose_YZ proc~create~11->proc~create_transpose_yz proc~create_transpose_zx transpose_handle_host%create_transpose_ZX proc~create~11->proc~create_transpose_zx proc~get_transpose_type get_transpose_type proc~create~11->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_start mpi_start proc~execute~11->mpi_start mpi_wait mpi_wait proc~execute~11->mpi_wait interface~get_env get_env proc~get_iters_from_env->interface~get_env interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_handle->proc~destroy_handle proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c mpi_type_commit mpi_type_commit proc~create_transpose_2d->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_2d->mpi_type_contiguous mpi_type_create_resized mpi_type_create_resized proc~create_transpose_2d->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_2d->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xy->mpi_type_commit proc~create_transpose_xy->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_resized proc~create_transpose_xy->mpi_type_vector proc~create_transpose_xy->proc~free_datatypes proc~create_transpose_xz->mpi_type_commit proc~create_transpose_xz->mpi_type_contiguous proc~create_transpose_xz->mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_resized proc~create_transpose_xz->mpi_type_vector proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_yz->mpi_type_commit proc~create_transpose_yz->mpi_type_contiguous proc~create_transpose_yz->mpi_type_create_hvector proc~create_transpose_yz->mpi_type_create_resized proc~create_transpose_yz->mpi_type_vector proc~create_transpose_yz->proc~free_datatypes proc~create_transpose_zx->mpi_type_commit proc~create_transpose_zx->mpi_type_contiguous proc~create_transpose_zx->mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_resized proc~create_transpose_zx->mpi_type_vector proc~create_transpose_zx->proc~free_datatypes mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free proc~free_datatypes->mpi_type_free proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~autotune_transpose_id~~CalledByGraph proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autotune_transpose_id.html"},{"title":"get_plan_execution_time – dtFFT","text":"private  function get_plan_execution_time(comm, cart_comm, from, to, base_dtype, base_storage, datatype_id, transpose_name_id, a, b) result(elapsed_time) Creates transpose plan and executes it DTFFT_MEASURE_WARMUP_ITERS + DTFFT_MEASURE_ITERS times Returns elapsed time Type Bound transpose_plan_host Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm 1D comm in case of pencils, 3D comm in case of z_slabs type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: datatype_id ID of transpose (1 or 2) integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer Return Value real(kind=real64) Execution time Calls proc~~get_plan_execution_time~~CallsGraph proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time interface~int_to_str int_to_str proc~get_plan_execution_time->interface~int_to_str mpi_allreduce mpi_allreduce proc~get_plan_execution_time->mpi_allreduce mpi_comm_size mpi_comm_size proc~get_plan_execution_time->mpi_comm_size mpi_wtime mpi_wtime proc~get_plan_execution_time->mpi_wtime proc~create~11 transpose_handle_host%create proc~get_plan_execution_time->proc~create~11 proc~destroy~13 transpose_handle_host%destroy proc~get_plan_execution_time->proc~destroy~13 proc~double_to_str double_to_str proc~get_plan_execution_time->proc~double_to_str proc~execute~11 transpose_handle_host%execute proc~get_plan_execution_time->proc~execute~11 proc~get_iters_from_env get_iters_from_env proc~get_plan_execution_time->proc~get_iters_from_env proc~get_log_enabled get_log_enabled proc~get_plan_execution_time->proc~get_log_enabled proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~write_message write_message proc~get_plan_execution_time->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~create~11->mpi_comm_size mpi_allgather mpi_allgather proc~create~11->mpi_allgather proc~create_handle handle_t%create_handle proc~create~11->proc~create_handle proc~create_transpose_2d transpose_handle_host%create_transpose_2d proc~create~11->proc~create_transpose_2d proc~create_transpose_xy transpose_handle_host%create_transpose_XY proc~create~11->proc~create_transpose_xy proc~create_transpose_xz transpose_handle_host%create_transpose_XZ proc~create~11->proc~create_transpose_xz proc~create_transpose_yz transpose_handle_host%create_transpose_YZ proc~create~11->proc~create_transpose_yz proc~create_transpose_zx transpose_handle_host%create_transpose_ZX proc~create~11->proc~create_transpose_zx proc~get_transpose_type get_transpose_type proc~create~11->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_start mpi_start proc~execute~11->mpi_start mpi_wait mpi_wait proc~execute~11->mpi_wait interface~get_env get_env proc~get_iters_from_env->interface~get_env interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_handle->proc~destroy_handle proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c mpi_type_commit mpi_type_commit proc~create_transpose_2d->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_2d->mpi_type_contiguous mpi_type_create_resized mpi_type_create_resized proc~create_transpose_2d->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_2d->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xy->mpi_type_commit proc~create_transpose_xy->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_resized proc~create_transpose_xy->mpi_type_vector proc~create_transpose_xy->proc~free_datatypes proc~create_transpose_xz->mpi_type_commit proc~create_transpose_xz->mpi_type_contiguous proc~create_transpose_xz->mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_resized proc~create_transpose_xz->mpi_type_vector proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_yz->mpi_type_commit proc~create_transpose_yz->mpi_type_contiguous proc~create_transpose_yz->mpi_type_create_hvector proc~create_transpose_yz->mpi_type_create_resized proc~create_transpose_yz->mpi_type_vector proc~create_transpose_yz->proc~free_datatypes proc~create_transpose_zx->mpi_type_commit proc~create_transpose_zx->mpi_type_contiguous proc~create_transpose_zx->mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_resized proc~create_transpose_zx->mpi_type_vector proc~create_transpose_zx->proc~free_datatypes mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free proc~free_datatypes->mpi_type_free proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_plan_execution_time~~CalledByGraph proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_plan_execution_time.html"},{"title":"execute_private – dtFFT","text":"private  subroutine execute_private(self, in, out, transpose_type) Executes single transposition Type Bound transpose_plan_host Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(inout) :: self Transposition class real(kind=real32), intent(inout) :: in (:) Incoming buffer real(kind=real32), intent(inout) :: out (:) Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to execute Calls proc~~execute_private~~CallsGraph proc~execute_private transpose_plan_host%execute_private proc~execute~11 transpose_handle_host%execute proc~execute_private->proc~execute~11 mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_start mpi_start proc~execute~11->mpi_start mpi_wait mpi_wait proc~execute~11->mpi_wait Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_private.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys transposition plans Type Bound transpose_plan_host Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(inout) :: self Transposition class Calls proc~~destroy~7~~CallsGraph proc~destroy~7 transpose_plan_host%destroy proc~destroy~13 transpose_handle_host%destroy proc~destroy~7->proc~destroy~13 mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~7.html"},{"title":"autotune_grid_decomposition – dtFFT","text":"private  subroutine autotune_grid_decomposition(self, dims, transposed_dims, base_comm, effort, n_transpose_plans, base_dtype, base_storage, best_comm_dims, best_forward_ids, best_backward_ids) Runs through all possible grid decompositions and selects the best one based on the lowest average execution time Type Bound transpose_plan_host Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dims (:) Global dims integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dims type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int8), intent(in) :: n_transpose_plans Number of transpose plans to test type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(out) :: best_comm_dims (:) Best communicator dimensions integer(kind=int8), intent(inout) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(inout) :: best_backward_ids (:) Best Datatype ids for backward plan Calls proc~~autotune_grid_decomposition~2~~CallsGraph proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition interface~int_to_str int_to_str proc~autotune_grid_decomposition~2->interface~int_to_str mpi_comm_size mpi_comm_size proc~autotune_grid_decomposition~2->mpi_comm_size proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~get_log_enabled get_log_enabled proc~autotune_grid_decomposition~2->proc~get_log_enabled proc~write_message write_message proc~autotune_grid_decomposition~2->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~autotune_grid~2->interface~int_to_str proc~autotune_grid~2->proc~get_log_enabled proc~autotune_grid~2->proc~write_message mpi_comm_free mpi_comm_free proc~autotune_grid~2->mpi_comm_free proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid~2->proc~create_pencils_and_comm proc~destroy~12 pencil%destroy proc~autotune_grid~2->proc~destroy~12 proc~double_to_str double_to_str proc~autotune_grid~2->proc~double_to_str proc~get_local_sizes~2 get_local_sizes proc~autotune_grid~2->proc~get_local_sizes~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~autotune_grid~2->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~autotune_grid~2->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_mpi_datatypes->proc~autotune_transpose_id lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~10 pencil%create proc~create_pencils_and_comm->proc~create~10 proc~get_plan_execution_time->interface~int_to_str proc~get_plan_execution_time->mpi_comm_size proc~get_plan_execution_time->proc~get_log_enabled proc~get_plan_execution_time->proc~write_message proc~get_plan_execution_time->proc~double_to_str proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range mpi_allreduce mpi_allreduce proc~get_plan_execution_time->mpi_allreduce mpi_wtime mpi_wtime proc~get_plan_execution_time->mpi_wtime proc~create~11 transpose_handle_host%create proc~get_plan_execution_time->proc~create~11 proc~destroy~13 transpose_handle_host%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_host%execute proc~get_plan_execution_time->proc~execute~11 proc~get_iters_from_env get_iters_from_env proc~get_plan_execution_time->proc~get_iters_from_env interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~autotune_transpose_id->proc~get_plan_execution_time mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create~10->proc~destroy~12 proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~get_local_size get_local_size proc~create~10->proc~get_local_size proc~create~11->mpi_comm_size mpi_allgather mpi_allgather proc~create~11->mpi_allgather proc~create_handle handle_t%create_handle proc~create~11->proc~create_handle proc~create_transpose_2d transpose_handle_host%create_transpose_2d proc~create~11->proc~create_transpose_2d proc~create_transpose_xy transpose_handle_host%create_transpose_XY proc~create~11->proc~create_transpose_xy proc~create_transpose_xz transpose_handle_host%create_transpose_XZ proc~create~11->proc~create_transpose_xz proc~create_transpose_yz transpose_handle_host%create_transpose_YZ proc~create~11->proc~create_transpose_yz proc~create_transpose_zx transpose_handle_host%create_transpose_ZX proc~create~11->proc~create_transpose_zx proc~get_transpose_type get_transpose_type proc~create~11->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_start mpi_start proc~execute~11->mpi_start mpi_wait mpi_wait proc~execute~11->mpi_wait interface~get_env get_env proc~get_iters_from_env->interface~get_env proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~check_if_even->mpi_comm_size proc~check_if_even->mpi_allgather proc~create_handle->proc~destroy_handle mpi_type_commit mpi_type_commit proc~create_transpose_2d->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_2d->mpi_type_contiguous mpi_type_create_resized mpi_type_create_resized proc~create_transpose_2d->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_2d->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xy->mpi_type_commit proc~create_transpose_xy->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_resized proc~create_transpose_xy->mpi_type_vector proc~create_transpose_xy->proc~free_datatypes proc~create_transpose_xz->mpi_type_commit proc~create_transpose_xz->mpi_type_contiguous proc~create_transpose_xz->mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_resized proc~create_transpose_xz->mpi_type_vector proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_yz->mpi_type_commit proc~create_transpose_yz->mpi_type_contiguous proc~create_transpose_yz->mpi_type_create_hvector proc~create_transpose_yz->mpi_type_create_resized proc~create_transpose_yz->mpi_type_vector proc~create_transpose_yz->proc~free_datatypes proc~create_transpose_zx->mpi_type_commit proc~create_transpose_zx->mpi_type_contiguous proc~create_transpose_zx->mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_resized proc~create_transpose_zx->mpi_type_vector proc~create_transpose_zx->proc~free_datatypes mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free proc~get_local_size->mpi_comm_size proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_allgather proc~free_datatypes->mpi_type_free proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~autotune_grid_decomposition~2~~CalledByGraph proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid_decomposition~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autotune_grid_decomposition~2.html"},{"title":"autotune_grid – dtFFT","text":"private  subroutine autotune_grid(self, base_comm, comm_dims, dims, transposed_dims, effort, base_dtype, base_storage, latest_timer_id, timers, decomps, forw_ids, back_ids, ipencil) Creates cartesian communicator and executes various datatypes on it Type Bound transpose_plan_host Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Abstract plan type(MPI_Comm), intent(in) :: base_comm Base communicator integer(kind=int32), intent(in) :: comm_dims (:) Number of MPI Processes in Y and Z directions integer(kind=int32), intent(in) :: dims (:) Global dims integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dims type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int32), intent(inout) :: latest_timer_id Current timer id real(kind=real64), intent(inout) :: timers (:) Time of current function execution is stored in timers(latest_timer_id) integer(kind=int32), intent(inout) :: decomps (:,:) Current decomposition is stored in decomps(:, latest_timer_id) integer(kind=int8), intent(inout) :: forw_ids (:,:) Best Forward ids are stored in forw_ids(:, latest_timer_id) integer(kind=int8), intent(inout) :: back_ids (:,:) Best Backward ids are stored in back_ids(:, latest_timer_id) type( pencil_init ), intent(in), optional :: ipencil Calls proc~~autotune_grid~2~~CallsGraph proc~autotune_grid~2 transpose_plan_host%autotune_grid interface~int_to_str int_to_str proc~autotune_grid~2->interface~int_to_str mpi_comm_free mpi_comm_free proc~autotune_grid~2->mpi_comm_free proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid~2->proc~create_pencils_and_comm proc~destroy~12 pencil%destroy proc~autotune_grid~2->proc~destroy~12 proc~double_to_str double_to_str proc~autotune_grid~2->proc~double_to_str proc~get_local_sizes~2 get_local_sizes proc~autotune_grid~2->proc~get_local_sizes~2 proc~get_log_enabled get_log_enabled proc~autotune_grid~2->proc~get_log_enabled proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~autotune_grid~2->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~autotune_grid~2->proc~push_nvtx_domain_range proc~write_message write_message proc~autotune_grid~2->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_mpi_datatypes->proc~autotune_transpose_id lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~10 pencil%create proc~create_pencils_and_comm->proc~create~10 proc~get_plan_execution_time->interface~int_to_str proc~get_plan_execution_time->proc~double_to_str proc~get_plan_execution_time->proc~get_log_enabled proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~write_message mpi_allreduce mpi_allreduce proc~get_plan_execution_time->mpi_allreduce mpi_comm_size mpi_comm_size proc~get_plan_execution_time->mpi_comm_size mpi_wtime mpi_wtime proc~get_plan_execution_time->mpi_wtime proc~create~11 transpose_handle_host%create proc~get_plan_execution_time->proc~create~11 proc~destroy~13 transpose_handle_host%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_host%execute proc~get_plan_execution_time->proc~execute~11 proc~get_iters_from_env get_iters_from_env proc~get_plan_execution_time->proc~get_iters_from_env interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~autotune_transpose_id->proc~get_plan_execution_time mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create~10->proc~destroy~12 proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~get_local_size get_local_size proc~create~10->proc~get_local_size proc~create~11->mpi_comm_size mpi_allgather mpi_allgather proc~create~11->mpi_allgather proc~create_handle handle_t%create_handle proc~create~11->proc~create_handle proc~create_transpose_2d transpose_handle_host%create_transpose_2d proc~create~11->proc~create_transpose_2d proc~create_transpose_xy transpose_handle_host%create_transpose_XY proc~create~11->proc~create_transpose_xy proc~create_transpose_xz transpose_handle_host%create_transpose_XZ proc~create~11->proc~create_transpose_xz proc~create_transpose_yz transpose_handle_host%create_transpose_YZ proc~create~11->proc~create_transpose_yz proc~create_transpose_zx transpose_handle_host%create_transpose_ZX proc~create~11->proc~create_transpose_zx proc~get_transpose_type get_transpose_type proc~create~11->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_start mpi_start proc~execute~11->mpi_start mpi_wait mpi_wait proc~execute~11->mpi_wait interface~get_env get_env proc~get_iters_from_env->interface~get_env proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~check_if_even->mpi_comm_size proc~check_if_even->mpi_allgather proc~create_handle->proc~destroy_handle mpi_type_commit mpi_type_commit proc~create_transpose_2d->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_2d->mpi_type_contiguous mpi_type_create_resized mpi_type_create_resized proc~create_transpose_2d->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_2d->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xy->mpi_type_commit proc~create_transpose_xy->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_resized proc~create_transpose_xy->mpi_type_vector proc~create_transpose_xy->proc~free_datatypes proc~create_transpose_xz->mpi_type_commit proc~create_transpose_xz->mpi_type_contiguous proc~create_transpose_xz->mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_resized proc~create_transpose_xz->mpi_type_vector proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_yz->mpi_type_commit proc~create_transpose_yz->mpi_type_contiguous proc~create_transpose_yz->mpi_type_create_hvector proc~create_transpose_yz->mpi_type_create_resized proc~create_transpose_yz->mpi_type_vector proc~create_transpose_yz->proc~free_datatypes proc~create_transpose_zx->mpi_type_commit proc~create_transpose_zx->mpi_type_contiguous proc~create_transpose_zx->mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_resized proc~create_transpose_zx->mpi_type_vector proc~create_transpose_zx->proc~free_datatypes mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_comm_size proc~get_local_size->mpi_allgather proc~free_datatypes->mpi_type_free proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~autotune_grid~2~~CalledByGraph proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autotune_grid~2.html"},{"title":"autotune_mpi_datatypes – dtFFT","text":"private  subroutine autotune_mpi_datatypes(self, pencils, cart_comm, comms, base_dtype, base_storage, a, b, forward_ids, backward_ids, elapsed_time) Type Bound transpose_plan_host Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Host plan type( pencil ), intent(in) :: pencils (:) Array of pencils type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type(MPI_Comm), intent(in) :: comms (:) Array of 1d communicators type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype real(kind=real32), intent(inout) :: a (:) Work buffer real(kind=real32), intent(inout) :: b (:) Work buffer integer(kind=int8), intent(inout) :: forward_ids (:) Forward plan IDs integer(kind=int8), intent(inout) :: backward_ids (:) Backward plan IDs real(kind=real64), intent(out) :: elapsed_time Elapsed time Calls proc~~autotune_mpi_datatypes~~CallsGraph proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_transpose_id->proc~get_plan_execution_time interface~int_to_str int_to_str proc~get_plan_execution_time->interface~int_to_str mpi_allreduce mpi_allreduce proc~get_plan_execution_time->mpi_allreduce mpi_comm_size mpi_comm_size proc~get_plan_execution_time->mpi_comm_size mpi_wtime mpi_wtime proc~get_plan_execution_time->mpi_wtime proc~create~11 transpose_handle_host%create proc~get_plan_execution_time->proc~create~11 proc~destroy~13 transpose_handle_host%destroy proc~get_plan_execution_time->proc~destroy~13 proc~double_to_str double_to_str proc~get_plan_execution_time->proc~double_to_str proc~execute~11 transpose_handle_host%execute proc~get_plan_execution_time->proc~execute~11 proc~get_iters_from_env get_iters_from_env proc~get_plan_execution_time->proc~get_iters_from_env proc~get_log_enabled get_log_enabled proc~get_plan_execution_time->proc~get_log_enabled proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~write_message write_message proc~get_plan_execution_time->proc~write_message proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~create~11->mpi_comm_size mpi_allgather mpi_allgather proc~create~11->mpi_allgather proc~create_handle handle_t%create_handle proc~create~11->proc~create_handle proc~create_transpose_2d transpose_handle_host%create_transpose_2d proc~create~11->proc~create_transpose_2d proc~create_transpose_xy transpose_handle_host%create_transpose_XY proc~create~11->proc~create_transpose_xy proc~create_transpose_xz transpose_handle_host%create_transpose_XZ proc~create~11->proc~create_transpose_xz proc~create_transpose_yz transpose_handle_host%create_transpose_YZ proc~create~11->proc~create_transpose_yz proc~create_transpose_zx transpose_handle_host%create_transpose_ZX proc~create~11->proc~create_transpose_zx proc~get_transpose_type get_transpose_type proc~create~11->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_start mpi_start proc~execute~11->mpi_start mpi_wait mpi_wait proc~execute~11->mpi_wait interface~get_env get_env proc~get_iters_from_env->interface~get_env interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_handle->proc~destroy_handle proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c mpi_type_commit mpi_type_commit proc~create_transpose_2d->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_2d->mpi_type_contiguous mpi_type_create_resized mpi_type_create_resized proc~create_transpose_2d->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_2d->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xy->mpi_type_commit proc~create_transpose_xy->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_resized proc~create_transpose_xy->mpi_type_vector proc~create_transpose_xy->proc~free_datatypes proc~create_transpose_xz->mpi_type_commit proc~create_transpose_xz->mpi_type_contiguous proc~create_transpose_xz->mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_resized proc~create_transpose_xz->mpi_type_vector proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_yz->mpi_type_commit proc~create_transpose_yz->mpi_type_contiguous proc~create_transpose_yz->mpi_type_create_hvector proc~create_transpose_yz->mpi_type_create_resized proc~create_transpose_yz->mpi_type_vector proc~create_transpose_yz->proc~free_datatypes proc~create_transpose_zx->mpi_type_commit proc~create_transpose_zx->mpi_type_contiguous proc~create_transpose_zx->mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_resized proc~create_transpose_zx->mpi_type_vector proc~create_transpose_zx->proc~free_datatypes mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free proc~free_datatypes->mpi_type_free proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~autotune_mpi_datatypes~~CalledByGraph proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autotune_mpi_datatypes.html"},{"title":"fftw_plan_many_dft – dtFFT","text":"interface public  function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2C plan, double precision.","tags":"","loc":"interface/fftw_plan_many_dft.html"},{"title":"fftwf_plan_many_dft – dtFFT","text":"interface public  function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2C plan, single precision.","tags":"","loc":"interface/fftwf_plan_many_dft.html"},{"title":"fftw_plan_many_dft_r2c – dtFFT","text":"interface public  function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2C plan, double precision.","tags":"","loc":"interface/fftw_plan_many_dft_r2c.html"},{"title":"fftwf_plan_many_dft_r2c – dtFFT","text":"interface public  function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2C plan, single precision.","tags":"","loc":"interface/fftwf_plan_many_dft_r2c.html"},{"title":"fftw_plan_many_dft_c2r – dtFFT","text":"interface public  function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2R plan, double precision.","tags":"","loc":"interface/fftw_plan_many_dft_c2r.html"},{"title":"fftwf_plan_many_dft_c2r – dtFFT","text":"interface public  function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2R plan, single precision.","tags":"","loc":"interface/fftwf_plan_many_dft_c2r.html"},{"title":"fftw_plan_many_r2r – dtFFT","text":"interface public  function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kind (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2R plan, double precision.","tags":"","loc":"interface/fftw_plan_many_r2r.html"},{"title":"fftwf_plan_many_r2r – dtFFT","text":"interface public  function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kind (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2R plan, single precision.","tags":"","loc":"interface/fftwf_plan_many_r2r.html"},{"title":"fftw_execute_dft – dtFFT","text":"interface public  subroutine fftw_execute_dft(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes C2C plan, double precision.","tags":"","loc":"interface/fftw_execute_dft.html"},{"title":"fftwf_execute_dft – dtFFT","text":"interface public  subroutine fftwf_execute_dft(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes C2C plan, single precision.","tags":"","loc":"interface/fftwf_execute_dft.html"},{"title":"fftw_execute_dft_r2c – dtFFT","text":"interface public  subroutine fftw_execute_dft_r2c(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes R2C plan, double precision.","tags":"","loc":"interface/fftw_execute_dft_r2c.html"},{"title":"fftwf_execute_dft_r2c – dtFFT","text":"interface public  subroutine fftwf_execute_dft_r2c(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes R2C plan, single precision.","tags":"","loc":"interface/fftwf_execute_dft_r2c.html"},{"title":"fftw_execute_dft_c2r – dtFFT","text":"interface public  subroutine fftw_execute_dft_c2r(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes C2R plan, double precision.","tags":"","loc":"interface/fftw_execute_dft_c2r.html"},{"title":"fftwf_execute_dft_c2r – dtFFT","text":"interface public  subroutine fftwf_execute_dft_c2r(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes C2R plan, single precision.","tags":"","loc":"interface/fftwf_execute_dft_c2r.html"},{"title":"fftw_execute_r2r – dtFFT","text":"interface public  subroutine fftw_execute_r2r(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes R2R plan, double precision.","tags":"","loc":"interface/fftw_execute_r2r.html"},{"title":"fftwf_execute_r2r – dtFFT","text":"interface public  subroutine fftwf_execute_r2r(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes R2R plan, single precision.","tags":"","loc":"interface/fftwf_execute_r2r.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Uses iso_c_binding iso_fortran_env proc~~create~7~~UsesGraph proc~create~7 cufft_executor%create iso_c_binding iso_c_binding proc~create~7->iso_c_binding iso_fortran_env iso_fortran_env proc~create~7->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates FFT plan via cuFFT Interface Type Bound cufft_executor Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Calls proc~~create~7~~CallsGraph proc~create~7 cufft_executor%create interface~cufftplanmany cufftPlanMany proc~create~7->interface~cufftplanmany interface~cufftsetstream cufftSetStream proc~create~7->interface~cufftsetstream interface~int_to_str int_to_str proc~create~7->interface~int_to_str mpi_abort mpi_abort proc~create~7->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~create~7->proc~cufftgeterrorstring proc~get_user_stream get_user_stream proc~create~7->proc~get_user_stream proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~cudageterrorstring cudaGetErrorString proc~get_user_stream->proc~cudageterrorstring interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~7.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, a, b, sign) Uses iso_c_binding iso_fortran_env proc~~execute~7~~UsesGraph proc~execute~7 cufft_executor%execute iso_c_binding iso_c_binding proc~execute~7->iso_c_binding iso_fortran_env iso_fortran_env proc~execute~7->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes cuFFT plan Type Bound cufft_executor Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(in) :: self cuFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform Calls proc~~execute~7~~CallsGraph proc~execute~7 cufft_executor%execute interface~cufftxtexec cufftXtExec proc~execute~7->interface~cufftxtexec interface~int_to_str int_to_str proc~execute~7->interface~int_to_str mpi_abort mpi_abort proc~execute~7->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~execute~7->proc~cufftgeterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~7.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Uses iso_c_binding iso_fortran_env proc~~destroy~8~~UsesGraph proc~destroy~8 cufft_executor%destroy iso_c_binding iso_c_binding proc~destroy~8->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy~8->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys cuFFT plan Type Bound cufft_executor Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor Calls proc~~destroy~8~~CallsGraph proc~destroy~8 cufft_executor%destroy interface~cufftdestroy cufftDestroy proc~destroy~8->interface~cufftdestroy interface~int_to_str int_to_str proc~destroy~8->interface~int_to_str mpi_abort mpi_abort proc~destroy~8->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~destroy~8->proc~cufftgeterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~8.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(alloc_bytes, ptr) Dummy method. Raises error stop Type Bound cufft_executor Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer","tags":"","loc":"proc/mem_alloc~4.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(ptr) Dummy method. Raises error stop Type Bound cufft_executor Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"proc/mem_free~4.html"},{"title":"create_helper – dtFFT","text":"private  subroutine create_helper(self, counts, displs, max_requests) Creates MPI helper Type Bound mpi_backend_helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper integer(kind=int64), intent(in) :: counts (:) Counts of data to send or recv integer(kind=int64), intent(in) :: displs (:) Displacements of data to send or recv integer(kind=int32), intent(in) :: max_requests Maximum number of requests required Called by proc~~create_helper~2~~CalledByGraph proc~create_helper~2 mpi_backend_helper%create_helper proc~create_mpi backend_mpi%create_mpi proc~create_mpi->proc~create_helper~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_helper~2.html"},{"title":"destoy_helper – dtFFT","text":"private  subroutine destoy_helper(self) Destroys MPI helper Type Bound mpi_backend_helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper Calls proc~~destoy_helper~~CallsGraph proc~destoy_helper mpi_backend_helper%destoy_helper mpi_request_free mpi_request_free proc~destoy_helper->mpi_request_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destoy_helper~~CalledByGraph proc~destoy_helper mpi_backend_helper%destoy_helper proc~destroy_mpi backend_mpi%destroy_mpi proc~destroy_mpi->proc~destoy_helper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destoy_helper.html"},{"title":"create_mpi – dtFFT","text":"private  subroutine create_mpi(self, helper, tranpose_type, base_storage) Creates MPI backend Type Bound backend_mpi Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI GPU Backend type( backend_helper ), intent(in) :: helper Backend helper (unused) type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create (unused) integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) Calls proc~~create_mpi~~CallsGraph proc~create_mpi backend_mpi%create_mpi proc~create_helper~2 mpi_backend_helper%create_helper proc~create_mpi->proc~create_helper~2 proc~is_backend_mpi is_backend_mpi proc~create_mpi->proc~is_backend_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_mpi.html"},{"title":"destroy_mpi – dtFFT","text":"private  subroutine destroy_mpi(self) Destroys MPI backend Type Bound backend_mpi Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI GPU Backend Calls proc~~destroy_mpi~~CallsGraph proc~destroy_mpi backend_mpi%destroy_mpi proc~destoy_helper mpi_backend_helper%destoy_helper proc~destroy_mpi->proc~destoy_helper mpi_request_free mpi_request_free proc~destoy_helper->mpi_request_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_mpi.html"},{"title":"execute_mpi – dtFFT","text":"private  subroutine execute_mpi(self, in, out, stream, aux) Uses iso_c_binding iso_fortran_env proc~~execute_mpi~~UsesGraph proc~execute_mpi backend_mpi%execute_mpi iso_c_binding iso_c_binding proc~execute_mpi->iso_c_binding iso_fortran_env iso_fortran_env proc~execute_mpi->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes MPI backend Type Bound backend_mpi Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer Calls proc~~execute_mpi~~CallsGraph proc~execute_mpi backend_mpi%execute_mpi interface~cudastreamsynchronize cudaStreamSynchronize proc~execute_mpi->interface~cudastreamsynchronize interface~int_to_str int_to_str proc~execute_mpi->interface~int_to_str mpi_abort mpi_abort proc~execute_mpi->mpi_abort mpi_wait mpi_wait proc~execute_mpi->mpi_wait mpi_waitall mpi_waitall proc~execute_mpi->mpi_waitall proc~cudageterrorstring cudaGetErrorString proc~execute_mpi->proc~cudageterrorstring proc~execute~9 nvrtc_kernel%execute proc~execute_mpi->proc~execute~9 proc~run_mpi_a2a run_mpi_a2a proc~execute_mpi->proc~run_mpi_a2a proc~run_mpi_p2p run_mpi_p2p proc~execute_mpi->proc~run_mpi_p2p proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~execute~9->interface~int_to_str proc~execute~9->mpi_abort proc~execute~9->proc~cudageterrorstring interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync mpi_comm_rank mpi_comm_rank proc~execute~9->mpi_comm_rank proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks mpi_alltoallv_init mpi_alltoallv_init proc~run_mpi_a2a->mpi_alltoallv_init mpi_start mpi_start proc~run_mpi_a2a->mpi_start mpi_comm_size mpi_comm_size proc~run_mpi_p2p->mpi_comm_size mpi_recv_init mpi_recv_init proc~run_mpi_p2p->mpi_recv_init mpi_send_init mpi_send_init proc~run_mpi_p2p->mpi_send_init mpi_startall mpi_startall proc~run_mpi_p2p->mpi_startall interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_mpi.html"},{"title":"run_mpi_p2p – dtFFT","text":"private  subroutine run_mpi_p2p(comm, send, recv, in, out) Executes MPI point-to-point communication Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI communicator type( mpi_backend_helper ), intent(inout) :: send MPI Helper for send data type( mpi_backend_helper ), intent(inout) :: recv MPI Helper for recv data real(kind=real32), intent(in) :: in (:) Data to be sent real(kind=real32), intent(inout) :: out (:) Data to be received Calls proc~~run_mpi_p2p~~CallsGraph proc~run_mpi_p2p run_mpi_p2p mpi_comm_size mpi_comm_size proc~run_mpi_p2p->mpi_comm_size mpi_recv_init mpi_recv_init proc~run_mpi_p2p->mpi_recv_init mpi_send_init mpi_send_init proc~run_mpi_p2p->mpi_send_init mpi_startall mpi_startall proc~run_mpi_p2p->mpi_startall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_mpi_p2p~~CalledByGraph proc~run_mpi_p2p run_mpi_p2p proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~run_mpi_p2p Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/run_mpi_p2p.html"},{"title":"run_mpi_a2a – dtFFT","text":"private  subroutine run_mpi_a2a(comm, send, recv, in, out) Executes MPI all-to-all communication Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI communicator type( mpi_backend_helper ), intent(inout) :: send MPI Helper for send data type( mpi_backend_helper ), intent(inout) :: recv MPI Helper for recv data real(kind=real32), intent(in) :: in (:) Data to be sent real(kind=real32), intent(inout) :: out (:) Data to be received Calls proc~~run_mpi_a2a~~CallsGraph proc~run_mpi_a2a run_mpi_a2a mpi_alltoallv_init mpi_alltoallv_init proc~run_mpi_a2a->mpi_alltoallv_init mpi_start mpi_start proc~run_mpi_a2a->mpi_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_mpi_a2a~~CalledByGraph proc~run_mpi_a2a run_mpi_a2a proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~run_mpi_a2a Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/run_mpi_a2a.html"},{"title":"push_nvtx_domain_range – dtFFT","text":"public  subroutine push_nvtx_domain_range(message, color) Pushes a range to the NVTX domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to push integer(kind=c_int), intent(in) :: color Color of the range Calls proc~~push_nvtx_domain_range~~CallsGraph proc~push_nvtx_domain_range push_nvtx_domain_range interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~push_nvtx_domain_range~~CalledByGraph proc~push_nvtx_domain_range push_nvtx_domain_range proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~push_nvtx_domain_range proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~push_nvtx_domain_range proc~create abstract_executor%create proc~create->proc~push_nvtx_domain_range proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~push_nvtx_domain_range proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~push_nvtx_domain_range proc~execute abstract_executor%execute proc~execute->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~execute~12 abstract_transpose_plan%execute proc~execute~12->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_ptr->proc~execute~12 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute_private~2->proc~execute~12 proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/push_nvtx_domain_range.html"},{"title":"pop_nvtx_domain_range – dtFFT","text":"public  subroutine pop_nvtx_domain_range() Pops a range from the NVTX domain Arguments None Calls proc~~pop_nvtx_domain_range~~CallsGraph proc~pop_nvtx_domain_range pop_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pop_nvtx_domain_range~~CalledByGraph proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~autotune_grid autotune_grid proc~autotune_grid->proc~pop_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~pop_nvtx_domain_range proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~pop_nvtx_domain_range proc~create abstract_executor%create proc~create->proc~pop_nvtx_domain_range proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~pop_nvtx_domain_range proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~pop_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~pop_nvtx_domain_range proc~execute abstract_executor%execute proc~execute->proc~pop_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~pop_nvtx_domain_range proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~execute~12 abstract_transpose_plan%execute proc~execute~12->proc~pop_nvtx_domain_range proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~pop_nvtx_domain_range proc~transpose_ptr->proc~execute~12 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute_private~2->proc~execute~12 proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/pop_nvtx_domain_range.html"},{"title":"create_nvtx_domain – dtFFT","text":"private  subroutine create_nvtx_domain() Creates a new NVTX domain Arguments None Calls proc~~create_nvtx_domain~~CallsGraph proc~create_nvtx_domain create_nvtx_domain interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~astring_f2c astring_f2c proc~create_nvtx_domain->proc~astring_f2c proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_nvtx_domain~~CalledByGraph proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range push_nvtx_domain_range proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~push_nvtx_domain_range proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~push_nvtx_domain_range proc~create abstract_executor%create proc~create->proc~push_nvtx_domain_range proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~push_nvtx_domain_range proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~push_nvtx_domain_range proc~execute abstract_executor%execute proc~execute->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~execute~12 abstract_transpose_plan%execute proc~execute~12->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_ptr->proc~execute~12 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute_private~2->proc~execute~12 proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_nvtx_domain.html"},{"title":"nvtxDomainCreate_c – dtFFT","text":"interface Creates an NVTX domain with the specified name. Called by interface~~nvtxdomaincreate_c~~CalledByGraph interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain create_nvtx_domain proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~push_nvtx_domain_range push_nvtx_domain_range proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~push_nvtx_domain_range proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~push_nvtx_domain_range proc~create abstract_executor%create proc~create->proc~push_nvtx_domain_range proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~push_nvtx_domain_range proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~push_nvtx_domain_range proc~execute abstract_executor%execute proc~execute->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~execute~12 abstract_transpose_plan%execute proc~execute~12->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_ptr->proc~execute~12 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute_private~2->proc~execute~12 proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine nvtxDomainCreate_c(name, domain) bind(C, name=\"nvtxDomainCreate_c\") Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: name (*) Name of the NVTX domain. type( nvtxDomainHandle ) :: domain Handle to the created NVTX domain.","tags":"","loc":"interface/nvtxdomaincreate_c.html"},{"title":"nvtxDomainRangePushEx_c – dtFFT","text":"interface Pushes a range with a custom message and color onto the specified NVTX domain. Called by interface~~nvtxdomainrangepushex_c~~CalledByGraph interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range push_nvtx_domain_range proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~push_nvtx_domain_range proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~push_nvtx_domain_range proc~create abstract_executor%create proc~create->proc~push_nvtx_domain_range proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~push_nvtx_domain_range proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~push_nvtx_domain_range proc~execute abstract_executor%execute proc~execute->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~execute~12 abstract_transpose_plan%execute proc~execute~12->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_ptr->proc~execute~12 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute_private~2->proc~execute~12 proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine nvtxDomainRangePushEx_c(domain, message, color) bind(C, name=\"nvtxDomainRangePushEx_c\") Arguments Type Intent Optional Attributes Name type( nvtxDomainHandle ), value :: domain NVTX domain handle. character(len=c_char), intent(in) :: message (*) Custom message for the range. integer(kind=c_int), intent(in), value :: color Color for the range.","tags":"","loc":"interface/nvtxdomainrangepushex_c.html"},{"title":"nvtxDomainRangePop_c – dtFFT","text":"interface Pops a range from the specified NVTX domain. Called by interface~~nvtxdomainrangepop_c~~CalledByGraph interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c proc~autotune_grid autotune_grid proc~autotune_grid->proc~pop_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~pop_nvtx_domain_range proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~pop_nvtx_domain_range proc~create abstract_executor%create proc~create->proc~pop_nvtx_domain_range proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~pop_nvtx_domain_range proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~pop_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~pop_nvtx_domain_range proc~execute abstract_executor%execute proc~execute->proc~pop_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~pop_nvtx_domain_range proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~execute~12 abstract_transpose_plan%execute proc~execute~12->proc~pop_nvtx_domain_range proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~pop_nvtx_domain_range proc~transpose_ptr->proc~execute~12 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute_private~2->proc~execute~12 proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine nvtxDomainRangePop_c(domain) bind(C, name=\"nvtxDomainRangePop_c\") Arguments Type Intent Optional Attributes Name type( nvtxDomainHandle ), value :: domain NVTX domain handle.","tags":"","loc":"interface/nvtxdomainrangepop_c.html"},{"title":"get_z_slab_enabled – dtFFT","text":"private  function get_z_slab_enabled(self, error_code) Returns logical value is Z-slab optimization enabled internally Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical Called by proc~~get_z_slab_enabled~~CalledByGraph proc~get_z_slab_enabled dtfft_plan_t%get_z_slab_enabled proc~dtfft_get_z_slab_enabled_c dtfft_get_z_slab_enabled_c proc~dtfft_get_z_slab_enabled_c->proc~get_z_slab_enabled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_z_slab_enabled.html"},{"title":"get_pencil – dtFFT","text":"private  function get_pencil(self, dim, error_code) Returns pencil decomposition Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dim Required dimension: 0 for XYZ layout (real space, R2C only) 1 for XYZ layout 2 for YXZ layout 3 for ZXY layout integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) Calls proc~~get_pencil~~CallsGraph proc~get_pencil dtfft_plan_t%get_pencil make_public make_public proc~get_pencil->make_public proc~dtfft_get_error_string dtfft_get_error_string proc~get_pencil->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_pencil->proc~get_log_enabled proc~write_message write_message proc~get_pencil->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_pencil~~CalledByGraph proc~get_pencil dtfft_plan_t%get_pencil proc~dtfft_get_pencil_c dtfft_get_pencil_c proc~dtfft_get_pencil_c->proc~get_pencil Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_pencil.html"},{"title":"get_element_size – dtFFT","text":"private  function get_element_size(self, error_code) Returns number of bytes required to store single element. Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Calls proc~~get_element_size~~CallsGraph proc~get_element_size dtfft_plan_t%get_element_size proc~dtfft_get_error_string dtfft_get_error_string proc~get_element_size->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_element_size->proc~get_log_enabled proc~write_message write_message proc~get_element_size->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_element_size~~CalledByGraph proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_element_size proc~dtfft_get_element_size_c dtfft_get_element_size_c proc~dtfft_get_element_size_c->proc~get_element_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_element_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_element_size.html"},{"title":"get_alloc_bytes – dtFFT","text":"private  function get_alloc_bytes(self, error_code) Returns minimum number of bytes required to execute plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Calls proc~~get_alloc_bytes~~CallsGraph proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~dtfft_get_error_string dtfft_get_error_string proc~get_alloc_bytes->proc~dtfft_get_error_string proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_bytes->proc~get_alloc_size proc~get_element_size dtfft_plan_t%get_element_size proc~get_alloc_bytes->proc~get_element_size proc~get_log_enabled get_log_enabled proc~get_alloc_bytes->proc~get_log_enabled proc~write_message write_message proc~get_alloc_bytes->proc~write_message proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~get_log_enabled proc~get_element_size->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_local_sizes->proc~dtfft_get_error_string proc~get_local_sizes->proc~get_log_enabled proc~get_local_sizes->proc~write_message counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_backend~2 abstract_transpose_plan%get_backend proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes->proc~is_backend_nvshmem starts starts proc~get_local_sizes->starts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_alloc_bytes~~CalledByGraph proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_alloc_bytes.html"},{"title":"get_executor – dtFFT","text":"private  function get_executor(self, error_code) Returns FFT Executor associated with plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) Calls proc~~get_executor~~CallsGraph proc~get_executor dtfft_plan_t%get_executor proc~dtfft_get_error_string dtfft_get_error_string proc~get_executor->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_executor->proc~get_log_enabled proc~write_message write_message proc~get_executor->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_executor~~CalledByGraph proc~get_executor dtfft_plan_t%get_executor proc~dtfft_get_executor_c dtfft_get_executor_c proc~dtfft_get_executor_c->proc~get_executor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_executor.html"},{"title":"get_precision – dtFFT","text":"private  function get_precision(self, error_code) Returns precision of the plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) Calls proc~~get_precision~~CallsGraph proc~get_precision dtfft_plan_t%get_precision proc~dtfft_get_error_string dtfft_get_error_string proc~get_precision->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_precision->proc~get_log_enabled proc~write_message write_message proc~get_precision->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_precision~~CalledByGraph proc~get_precision dtfft_plan_t%get_precision proc~dtfft_get_precision_c dtfft_get_precision_c proc~dtfft_get_precision_c->proc~get_precision Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_precision.html"},{"title":"get_platform – dtFFT","text":"private  function get_platform(self, error_code) Returns execution platform of the plan (HOST or CUDA) Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) Called by proc~~get_platform~~CalledByGraph proc~get_platform dtfft_plan_t%get_platform proc~dtfft_get_platform_c dtfft_get_platform_c proc~dtfft_get_platform_c->proc~get_platform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_platform.html"},{"title":"get_backend – dtFFT","text":"private  function get_backend(self, error_code) Returns selected GPU backend during autotuning Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) Calls proc~~get_backend~~CallsGraph proc~get_backend dtfft_plan_t%get_backend proc~get_backend~2 abstract_transpose_plan%get_backend proc~get_backend->proc~get_backend~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_backend~~CalledByGraph proc~get_backend dtfft_plan_t%get_backend proc~dtfft_get_backend_c dtfft_get_backend_c proc~dtfft_get_backend_c->proc~get_backend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_backend.html"},{"title":"check_device_pointers – dtFFT","text":"private  function check_device_pointers(in, out, backend, aux) result(error_code) Checks if device pointers are provided by user Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: in First pointer type(c_ptr), intent(in) :: out Second pointer type( dtfft_backend_t ), intent(in) :: backend Backend. Required to check for nvshmem pointer type(c_ptr), intent(in) :: aux Optional auxiliary pointer. Return Value integer(kind=int32) Calls proc~~check_device_pointers~~CallsGraph proc~check_device_pointers check_device_pointers interface~is_device_ptr is_device_ptr proc~check_device_pointers->interface~is_device_ptr is_null_ptr is_null_ptr proc~check_device_pointers->is_null_ptr proc~is_backend_nvshmem is_backend_nvshmem proc~check_device_pointers->proc~is_backend_nvshmem proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers->proc~is_nvshmem_ptr proc~is_nvshmem_ptr->is_null_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_device_pointers~~CalledByGraph proc~check_device_pointers check_device_pointers proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_device_pointers proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~check_device_pointers proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_device_pointers.html"},{"title":"get_alloc_size – dtFFT","text":"private  function get_alloc_size(self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan Calls proc~~get_alloc_size~~CallsGraph proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~dtfft_get_error_string dtfft_get_error_string proc~get_local_sizes->proc~dtfft_get_error_string proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_backend~2 abstract_transpose_plan%get_backend proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 proc~get_log_enabled get_log_enabled proc~get_local_sizes->proc~get_log_enabled proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes->proc~is_backend_nvshmem proc~write_message write_message proc~get_local_sizes->proc~write_message starts starts proc~get_local_sizes->starts mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_alloc_size~~CalledByGraph proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_alloc_size.html"},{"title":"create_private – dtFFT","text":"private  function create_private(self, sngl_type, sngl_storage_size, dbl_type, dbl_storage_size, dims, pencil, comm, precision, effort, executor, kinds) Uses iso_c_binding iso_fortran_env proc~~create_private~2~~UsesGraph proc~create_private~2 dtfft_plan_t%create_private iso_c_binding iso_c_binding proc~create_private~2->iso_c_binding iso_fortran_env iso_fortran_env proc~create_private~2->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates core Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(MPI_Datatype), intent(in) :: sngl_type MPI_Datatype for single precision plan integer(kind=int64), intent(in) :: sngl_storage_size Number of bytes needed to store single element (single precision) type(MPI_Datatype), intent(in) :: dbl_type MPI_Datatype for double precision plan integer(kind=int64), intent(in) :: dbl_storage_size Number of bytes needed to store single element (double precision) integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm User-defined communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) Calls proc~~create_private~2~~CallsGraph proc~create_private~2 dtfft_plan_t%create_private counts counts proc~create_private~2->counts create create proc~create_private~2->create fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort mpi_allgather mpi_allgather proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private~2->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~destroy~12 pencil%destroy proc~create_private~2->proc~destroy~12 proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_private~2~~CalledByGraph proc~create_private~2 dtfft_plan_t%create_private proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_private~2.html"},{"title":"check_create_args – dtFFT","text":"private  function check_create_args(self, dims, pencil, comm, precision, effort, executor, kinds) Check arguments provided by user and sets private variables Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm Optional MPI Communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) Calls proc~~check_create_args~~CallsGraph proc~check_create_args dtfft_plan_t%check_create_args mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_create_args~~CalledByGraph proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_create_args.html"},{"title":"create_r2r_internal – dtFFT","text":"private  function create_r2r_internal(self, dims, pencil, kinds, comm, precision, effort, executor) Creates plan for R2R plans Type Bound dtfft_plan_r2r_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) Calls proc~~create_r2r_internal~~CallsGraph proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal create create proc~create_r2r_internal->create fft_mapping fft_mapping proc~create_r2r_internal->fft_mapping pencils pencils proc~create_r2r_internal->pencils proc~create_private~2 dtfft_plan_t%create_private proc~create_r2r_internal->proc~create_private~2 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create_private~2->create counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort mpi_allgather mpi_allgather proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private~2->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~destroy~12 pencil%destroy proc~create_private~2->proc~destroy~12 proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_r2r_internal~~CalledByGraph proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2r_internal.html"},{"title":"create_c2c_internal – dtFFT","text":"private  function create_c2c_internal(self, dims, pencil, comm, precision, effort, executor) Private method that combines common logic for C2C plan creation Type Bound dtfft_plan_c2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) Calls proc~~create_c2c_internal~~CallsGraph proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_internal->proc~create_c2c_core proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_c2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_c2c_internal->proc~push_nvtx_domain_range create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping pencils pencils proc~create_c2c_core->pencils proc~create_private~2 dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private~2 interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private~2->create counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort mpi_allgather mpi_allgather proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private~2->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~destroy~12 pencil%destroy proc~create_private~2->proc~destroy~12 proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_c2c_internal~~CalledByGraph proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_c2c_internal.html"},{"title":"create_c2c_core – dtFFT","text":"private  function create_c2c_core(self, dims, pencil, comm, precision, effort, executor) Creates plan for both C2C and R2C Type Bound dtfft_core_c2c Arguments Type Intent Optional Attributes Name class( dtfft_core_c2c ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) Calls proc~~create_c2c_core~~CallsGraph proc~create_c2c_core dtfft_core_c2c%create_c2c_core create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping pencils pencils proc~create_c2c_core->pencils proc~create_private~2 dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private~2 proc~create_private~2->create counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort mpi_allgather mpi_allgather proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private~2->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~destroy~12 pencil%destroy proc~create_private~2->proc~destroy~12 proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_c2c_core~~CalledByGraph proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_c2c_core.html"},{"title":"create_r2c_internal – dtFFT","text":"private  function create_r2c_internal(self, executor, dims, pencil, comm, precision, effort) Private method that combines common logic for R2C plan creation Type Bound dtfft_plan_r2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan Return Value integer(kind=int32) Calls proc~~create_r2c_internal~~CallsGraph proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal pencils pencils proc~create_r2c_internal->pencils proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_r2c_internal->proc~create_c2c_core proc~create~10 pencil%create proc~create_r2c_internal->proc~create~10 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_c2c_core->pencils create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping proc~create_private~2 dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private~2 proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~destroy~12 pencil%destroy proc~create~10->proc~destroy~12 proc~get_local_size get_local_size proc~create~10->proc~get_local_size interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private~2->create proc~create_private~2->proc~destroy~12 counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private~2->mpi_comm_rank proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~get_local_size->mpi_allgather proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_comm_size proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_r2c_internal~~CalledByGraph proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2c_internal.html"},{"title":"transpose – dtFFT","text":"private  subroutine transpose(self, in, out, transpose_type, error_code) Performs single transposition Note Buffers in and out cannot be the same Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~transpose~~CallsGraph proc~transpose dtfft_plan_t%transpose proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose->proc~transpose_ptr proc~check_device_pointers check_device_pointers proc~transpose_ptr->proc~check_device_pointers proc~dtfft_get_error_string dtfft_get_error_string proc~transpose_ptr->proc~dtfft_get_error_string proc~execute~12 abstract_transpose_plan%execute proc~transpose_ptr->proc~execute~12 proc~get_backend~2 abstract_transpose_plan%get_backend proc~transpose_ptr->proc~get_backend~2 proc~get_log_enabled get_log_enabled proc~transpose_ptr->proc~get_log_enabled proc~is_same_ptr is_same_ptr proc~transpose_ptr->proc~is_same_ptr proc~is_valid_transpose_type is_valid_transpose_type proc~transpose_ptr->proc~is_valid_transpose_type proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_ptr->proc~push_nvtx_domain_range proc~write_message write_message proc~transpose_ptr->proc~write_message interface~is_device_ptr is_device_ptr proc~check_device_pointers->interface~is_device_ptr is_null_ptr is_null_ptr proc~check_device_pointers->is_null_ptr proc~is_backend_nvshmem is_backend_nvshmem proc~check_device_pointers->proc~is_backend_nvshmem proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers->proc~is_nvshmem_ptr proc~execute~12->proc~pop_nvtx_domain_range proc~execute~12->proc~push_nvtx_domain_range execute_private execute_private proc~execute~12->execute_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~is_nvshmem_ptr->is_null_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose.html"},{"title":"transpose_ptr – dtFFT","text":"private  subroutine transpose_ptr(self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Note Buffers in and out cannot be the same Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~transpose_ptr~~CallsGraph proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~check_device_pointers check_device_pointers proc~transpose_ptr->proc~check_device_pointers proc~dtfft_get_error_string dtfft_get_error_string proc~transpose_ptr->proc~dtfft_get_error_string proc~execute~12 abstract_transpose_plan%execute proc~transpose_ptr->proc~execute~12 proc~get_backend~2 abstract_transpose_plan%get_backend proc~transpose_ptr->proc~get_backend~2 proc~get_log_enabled get_log_enabled proc~transpose_ptr->proc~get_log_enabled proc~is_same_ptr is_same_ptr proc~transpose_ptr->proc~is_same_ptr proc~is_valid_transpose_type is_valid_transpose_type proc~transpose_ptr->proc~is_valid_transpose_type proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_ptr->proc~push_nvtx_domain_range proc~write_message write_message proc~transpose_ptr->proc~write_message interface~is_device_ptr is_device_ptr proc~check_device_pointers->interface~is_device_ptr is_null_ptr is_null_ptr proc~check_device_pointers->is_null_ptr proc~is_backend_nvshmem is_backend_nvshmem proc~check_device_pointers->proc~is_backend_nvshmem proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers->proc~is_nvshmem_ptr proc~execute~12->proc~pop_nvtx_domain_range proc~execute~12->proc~push_nvtx_domain_range execute_private execute_private proc~execute~12->execute_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~is_nvshmem_ptr->is_null_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transpose_ptr~~CalledByGraph proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_ptr.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, execute_type, aux, error_code) Executes plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~execute~8~~CallsGraph proc~execute~8 dtfft_plan_t%execute proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute~8->proc~execute_ptr is_null_ptr is_null_ptr proc~execute_ptr->is_null_ptr proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~check_device_pointers check_device_pointers proc~execute_ptr->proc~check_device_pointers proc~dtfft_get_error_string dtfft_get_error_string proc~execute_ptr->proc~dtfft_get_error_string proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~get_backend~2 abstract_transpose_plan%get_backend proc~execute_ptr->proc~get_backend~2 proc~get_log_enabled get_log_enabled proc~execute_ptr->proc~get_log_enabled proc~is_same_ptr is_same_ptr proc~execute_ptr->proc~is_same_ptr proc~is_valid_execute_type is_valid_execute_type proc~execute_ptr->proc~is_valid_execute_type proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute_ptr->proc~push_nvtx_domain_range proc~write_message write_message proc~execute_ptr->proc~write_message proc~check_aux->is_null_ptr proc~check_aux->proc~dtfft_get_error_string mpi_abort mpi_abort proc~check_aux->mpi_abort proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~check_device_pointers->is_null_ptr interface~is_device_ptr is_device_ptr proc~check_device_pointers->interface~is_device_ptr proc~is_backend_nvshmem is_backend_nvshmem proc~check_device_pointers->proc~is_backend_nvshmem proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers->proc~is_nvshmem_ptr proc~execute~12 abstract_transpose_plan%execute proc~execute_private~2->proc~execute~12 interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~12->proc~pop_nvtx_domain_range proc~execute~12->proc~push_nvtx_domain_range execute_private execute_private proc~execute~12->execute_private proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~get_log_enabled proc~get_element_size->proc~write_message proc~is_nvshmem_ptr->is_null_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr proc~mem_alloc_ptr->is_null_ptr proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_ptr->proc~get_log_enabled proc~mem_alloc_ptr->proc~write_message interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~get_local_sizes->proc~dtfft_get_error_string proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes->proc~get_log_enabled proc~get_local_sizes->proc~write_message proc~get_local_sizes->proc~is_backend_nvshmem counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 starts starts proc~get_local_sizes->starts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~8.html"},{"title":"execute_ptr – dtFFT","text":"private  subroutine execute_ptr(self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~execute_ptr~~CallsGraph proc~execute_ptr dtfft_plan_t%execute_ptr is_null_ptr is_null_ptr proc~execute_ptr->is_null_ptr proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~check_device_pointers check_device_pointers proc~execute_ptr->proc~check_device_pointers proc~dtfft_get_error_string dtfft_get_error_string proc~execute_ptr->proc~dtfft_get_error_string proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~get_backend~2 abstract_transpose_plan%get_backend proc~execute_ptr->proc~get_backend~2 proc~get_log_enabled get_log_enabled proc~execute_ptr->proc~get_log_enabled proc~is_same_ptr is_same_ptr proc~execute_ptr->proc~is_same_ptr proc~is_valid_execute_type is_valid_execute_type proc~execute_ptr->proc~is_valid_execute_type proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute_ptr->proc~push_nvtx_domain_range proc~write_message write_message proc~execute_ptr->proc~write_message proc~check_aux->is_null_ptr proc~check_aux->proc~dtfft_get_error_string mpi_abort mpi_abort proc~check_aux->mpi_abort proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~check_device_pointers->is_null_ptr interface~is_device_ptr is_device_ptr proc~check_device_pointers->interface~is_device_ptr proc~is_backend_nvshmem is_backend_nvshmem proc~check_device_pointers->proc~is_backend_nvshmem proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers->proc~is_nvshmem_ptr proc~execute~12 abstract_transpose_plan%execute proc~execute_private~2->proc~execute~12 interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~12->proc~pop_nvtx_domain_range proc~execute~12->proc~push_nvtx_domain_range execute_private execute_private proc~execute~12->execute_private proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~get_log_enabled proc~get_element_size->proc~write_message proc~is_nvshmem_ptr->is_null_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr proc~mem_alloc_ptr->is_null_ptr proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_ptr->proc~get_log_enabled proc~mem_alloc_ptr->proc~write_message interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~get_local_sizes->proc~dtfft_get_error_string proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes->proc~get_log_enabled proc~get_local_sizes->proc~write_message proc~get_local_sizes->proc~is_backend_nvshmem counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 starts starts proc~get_local_sizes->starts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_ptr~~CalledByGraph proc~execute_ptr dtfft_plan_t%execute_ptr proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_ptr.html"},{"title":"execute_private – dtFFT","text":"private  subroutine execute_private(self, in, out, execute_type, aux, inplace) Executes plan with specified auxiliary buffer Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. logical, intent(in) :: inplace Inplace execution flag Calls proc~~execute_private~2~~CallsGraph proc~execute_private~2 dtfft_plan_t%execute_private proc~execute~12 abstract_transpose_plan%execute proc~execute_private~2->proc~execute~12 execute_private execute_private proc~execute~12->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~12->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~12->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_private~2~~CalledByGraph proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~execute_private~2 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_private~2.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self, error_code) Destroys plan, frees all memory Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~destroy~9~~CallsGraph proc~destroy~9 dtfft_plan_t%destroy destroy destroy proc~destroy~9->destroy mpi_comm_free mpi_comm_free proc~destroy~9->mpi_comm_free mpi_finalized mpi_finalized proc~destroy~9->mpi_finalized proc~clean_unused_cache clean_unused_cache proc~destroy~9->proc~clean_unused_cache proc~destroy_stream destroy_stream proc~destroy~9->proc~destroy_stream proc~dtfft_get_error_string dtfft_get_error_string proc~destroy~9->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~destroy~9->proc~get_log_enabled proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~9->proc~mem_free_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~destroy~9->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~destroy~9->proc~push_nvtx_domain_range proc~write_message write_message proc~destroy~9->proc~write_message interface~int_to_str int_to_str proc~clean_unused_cache->interface~int_to_str is_null_ptr is_null_ptr proc~clean_unused_cache->is_null_ptr mpi_abort mpi_abort proc~clean_unused_cache->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~clean_unused_cache->proc~cudageterrorstring interface~cudastreamdestroy cudaStreamDestroy proc~destroy_stream->interface~cudastreamdestroy proc~destroy_stream->interface~int_to_str proc~destroy_stream->mpi_abort proc~destroy_stream->proc~cudageterrorstring proc~mem_free_ptr->proc~dtfft_get_error_string proc~mem_free_ptr->proc~get_log_enabled proc~mem_free_ptr->proc~write_message interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~write_message->mpi_finalized mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy~9~~CalledByGraph proc~destroy~9 dtfft_plan_t%destroy proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~9.html"},{"title":"get_dims – dtFFT","text":"private  subroutine get_dims(self, dims, error_code) Returns global dimensions Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~get_dims~~CallsGraph proc~get_dims dtfft_plan_t%get_dims proc~dtfft_get_error_string dtfft_get_error_string proc~get_dims->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_dims->proc~get_log_enabled proc~write_message write_message proc~get_dims->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_dims~~CalledByGraph proc~get_dims dtfft_plan_t%get_dims proc~dtfft_get_dims_c dtfft_get_dims_c proc~dtfft_get_dims_c->proc~get_dims Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_dims.html"},{"title":"report – dtFFT","text":"private  subroutine report(self, error_code) Prints plan-related information to stdout Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~report~~CallsGraph proc~report dtfft_plan_t%report interface~dtfft_get_version dtfft_get_version proc~report->interface~dtfft_get_version interface~int_to_str int_to_str proc~report->interface~int_to_str mpi_comm_size mpi_comm_size proc~report->mpi_comm_size proc~dtfft_get_backend_string dtfft_get_backend_string proc~report->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~report->proc~dtfft_get_error_string proc~dtfft_get_executor_string dtfft_get_executor_string proc~report->proc~dtfft_get_executor_string proc~dtfft_get_precision_string dtfft_get_precision_string proc~report->proc~dtfft_get_precision_string proc~get_backend~2 abstract_transpose_plan%get_backend proc~report->proc~get_backend~2 proc~get_log_enabled get_log_enabled proc~report->proc~get_log_enabled proc~write_message write_message proc~report->proc~write_message proc~dtfft_get_version_current dtfft_get_version_current interface~dtfft_get_version->proc~dtfft_get_version_current proc~dtfft_get_version_required dtfft_get_version_required interface~dtfft_get_version->proc~dtfft_get_version_required proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~report~~CalledByGraph proc~report dtfft_plan_t%report proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/report.html"},{"title":"get_stream_ptr – dtFFT","text":"private  subroutine get_stream_ptr(self, stream, error_code) Returns CUDA stream associated with plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~get_stream_ptr~~CallsGraph proc~get_stream_ptr dtfft_plan_t%get_stream_ptr proc~dtfft_get_error_string dtfft_get_error_string proc~get_stream_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_stream_ptr->proc~get_log_enabled proc~write_message write_message proc~get_stream_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_stream_ptr~~CalledByGraph proc~get_stream_ptr dtfft_plan_t%get_stream_ptr none~get_stream dtfft_plan_t%get_stream none~get_stream->proc~get_stream_ptr proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream->proc~get_stream_int64 proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream proc~get_stream_int64->none~get_stream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_stream_ptr.html"},{"title":"get_stream_int64 – dtFFT","text":"private  subroutine get_stream_int64(self, stream, error_code) Returns CUDA stream associated with plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~get_stream_int64~~CallsGraph proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream dtfft_plan_t%get_stream proc~get_stream_int64->none~get_stream proc~dtfft_get_cuda_stream dtfft_get_cuda_stream proc~get_stream_int64->proc~dtfft_get_cuda_stream none~get_stream->proc~get_stream_int64 proc~get_stream_ptr dtfft_plan_t%get_stream_ptr none~get_stream->proc~get_stream_ptr proc~dtfft_get_error_string dtfft_get_error_string proc~get_stream_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_stream_ptr->proc~get_log_enabled proc~write_message write_message proc~get_stream_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_stream_int64~~CalledByGraph proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream dtfft_plan_t%get_stream proc~get_stream_int64->none~get_stream none~get_stream->proc~get_stream_int64 proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_stream_int64.html"},{"title":"get_local_sizes – dtFFT","text":"private  subroutine get_local_sizes(self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~get_local_sizes~~CallsGraph proc~get_local_sizes dtfft_plan_t%get_local_sizes counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~dtfft_get_error_string dtfft_get_error_string proc~get_local_sizes->proc~dtfft_get_error_string proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_backend~2 abstract_transpose_plan%get_backend proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 proc~get_log_enabled get_log_enabled proc~get_local_sizes->proc~get_log_enabled proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes->proc~is_backend_nvshmem proc~write_message write_message proc~get_local_sizes->proc~write_message starts starts proc~get_local_sizes->starts mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_local_sizes~~CalledByGraph proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_local_sizes.html"},{"title":"alloc_fft_plans – dtFFT","text":"private  subroutine alloc_fft_plans(self, kinds) Allocates abstract_executor with required FFT class\nand populates fft_mapping with similar FFT ids Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Called by proc~~alloc_fft_plans~~CalledByGraph proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~alloc_fft_plans proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/alloc_fft_plans.html"},{"title":"check_aux – dtFFT","text":"private  subroutine check_aux(self, aux) Uses iso_fortran_env proc~~check_aux~~UsesGraph proc~check_aux dtfft_plan_t%check_aux iso_fortran_env iso_fortran_env proc~check_aux->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Checks if aux buffer was passed by user and if not will allocate one internally Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: aux Optional auxiliary buffer. Calls proc~~check_aux~~CallsGraph proc~check_aux dtfft_plan_t%check_aux is_null_ptr is_null_ptr proc~check_aux->is_null_ptr mpi_abort mpi_abort proc~check_aux->mpi_abort proc~dtfft_get_error_string dtfft_get_error_string proc~check_aux->proc~dtfft_get_error_string proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes proc~get_element_size->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_element_size->proc~get_log_enabled proc~write_message write_message proc~get_element_size->proc~write_message proc~mem_alloc_ptr->is_null_ptr proc~mem_alloc_ptr->proc~dtfft_get_error_string interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~mem_alloc_ptr->proc~get_log_enabled proc~mem_alloc_ptr->proc~write_message proc~get_local_sizes->proc~dtfft_get_error_string proc~get_local_sizes->proc~get_log_enabled proc~get_local_sizes->proc~write_message counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_backend~2 abstract_transpose_plan%get_backend proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes->proc~is_backend_nvshmem starts starts proc~get_local_sizes->starts mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_aux~~CalledByGraph proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_aux.html"},{"title":"create_r2r – dtFFT","text":"private  subroutine create_r2r(self, dims, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Type Bound dtfft_plan_r2r_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_r2r~~CallsGraph proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r->proc~create_r2r_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_r2r->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~create_r2r->proc~get_log_enabled proc~write_message write_message proc~create_r2r->proc~write_message create create proc~create_r2r_internal->create fft_mapping fft_mapping proc~create_r2r_internal->fft_mapping pencils pencils proc~create_r2r_internal->pencils proc~create_private~2 dtfft_plan_t%create_private proc~create_r2r_internal->proc~create_private~2 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2r_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~create_private~2->create proc~create_private~2->mpi_comm_rank counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort mpi_allgather mpi_allgather proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free mpi_comm_size mpi_comm_size proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~destroy~12 pencil%destroy proc~create_private~2->proc~destroy~12 proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2r.html"},{"title":"create_r2r_pencil – dtFFT","text":"private  subroutine create_r2r_pencil(self, pencil, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Type Bound dtfft_plan_r2r_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_r2r_pencil~~CallsGraph proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_pencil->proc~create_r2r_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_r2r_pencil->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~create_r2r_pencil->proc~get_log_enabled proc~write_message write_message proc~create_r2r_pencil->proc~write_message create create proc~create_r2r_internal->create fft_mapping fft_mapping proc~create_r2r_internal->fft_mapping pencils pencils proc~create_r2r_internal->pencils proc~create_private~2 dtfft_plan_t%create_private proc~create_r2r_internal->proc~create_private~2 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2r_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~create_private~2->create proc~create_private~2->mpi_comm_rank counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort mpi_allgather mpi_allgather proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free mpi_comm_size mpi_comm_size proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~destroy~12 pencil%destroy proc~create_private~2->proc~destroy~12 proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2r_pencil.html"},{"title":"create_c2c – dtFFT","text":"private  subroutine create_c2c(self, dims, comm, precision, effort, executor, error_code) C2C Plan Constructor Type Bound dtfft_plan_c2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_c2c~~CallsGraph proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c->proc~create_c2c_core proc~dtfft_get_error_string dtfft_get_error_string proc~create_c2c->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~create_c2c->proc~get_log_enabled proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_c2c->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_c2c->proc~push_nvtx_domain_range proc~write_message write_message proc~create_c2c->proc~write_message create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping pencils pencils proc~create_c2c_core->pencils proc~create_private~2 dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private~2 interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private~2->create proc~create_private~2->mpi_comm_rank counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort mpi_allgather mpi_allgather proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free mpi_comm_size mpi_comm_size proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~destroy~12 pencil%destroy proc~create_private~2->proc~destroy~12 proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_c2c.html"},{"title":"create_c2c_pencil – dtFFT","text":"private  subroutine create_c2c_pencil(self, pencil, comm, precision, effort, executor, error_code) C2C Plan Constructor Type Bound dtfft_plan_c2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_c2c_pencil~~CallsGraph proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_pencil->proc~create_c2c_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_c2c_pencil->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~create_c2c_pencil->proc~get_log_enabled proc~write_message write_message proc~create_c2c_pencil->proc~write_message proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_internal->proc~create_c2c_core proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_c2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_c2c_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping pencils pencils proc~create_c2c_core->pencils proc~create_private~2 dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private~2 interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private~2->mpi_comm_rank proc~create_private~2->create counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort mpi_allgather mpi_allgather proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free mpi_comm_size mpi_comm_size proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~destroy~12 pencil%destroy proc~create_private~2->proc~destroy~12 proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_c2c_pencil.html"},{"title":"create_r2c – dtFFT","text":"private  subroutine create_r2c(self, dims, executor, comm, precision, effort, error_code) R2C Generic Plan Constructor Type Bound dtfft_plan_r2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_r2c~~CallsGraph proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c->proc~create_r2c_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_r2c->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~create_r2c->proc~get_log_enabled proc~write_message write_message proc~create_r2c->proc~write_message pencils pencils proc~create_r2c_internal->pencils proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_r2c_internal->proc~create_c2c_core proc~create~10 pencil%create proc~create_r2c_internal->proc~create~10 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2c_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~create_c2c_core->pencils create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping proc~create_private~2 dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private~2 proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~destroy~12 pencil%destroy proc~create~10->proc~destroy~12 proc~get_local_size get_local_size proc~create~10->proc~get_local_size interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private~2->mpi_comm_rank proc~create_private~2->create proc~create_private~2->proc~destroy~12 counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_allgather proc~get_local_size->mpi_comm_size proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2c.html"},{"title":"create_r2c_pencil – dtFFT","text":"private  subroutine create_r2c_pencil(self, pencil, executor, comm, precision, effort, error_code) R2C Plan Constructor with pencil Type Bound dtfft_plan_r2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_r2c_pencil~~CallsGraph proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_pencil->proc~create_r2c_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_r2c_pencil->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~create_r2c_pencil->proc~get_log_enabled proc~write_message write_message proc~create_r2c_pencil->proc~write_message pencils pencils proc~create_r2c_internal->pencils proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_r2c_internal->proc~create_c2c_core proc~create~10 pencil%create proc~create_r2c_internal->proc~create~10 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2c_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~create_c2c_core->pencils create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping proc~create_private~2 dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private~2 proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~destroy~12 pencil%destroy proc~create~10->proc~destroy~12 proc~get_local_size get_local_size proc~create~10->proc~get_local_size interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private~2->mpi_comm_rank proc~create_private~2->create proc~create_private~2->proc~destroy~12 counts counts proc~create_private~2->counts fixed_dims fixed_dims proc~create_private~2->fixed_dims interface~cudagetdevice cudaGetDevice proc~create_private~2->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private~2->interface~cudagetdevicecount interface~int_to_str int_to_str proc~create_private~2->interface~int_to_str local_devices local_devices proc~create_private~2->local_devices mpi_abort mpi_abort proc~create_private~2->mpi_abort proc~create_private~2->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private~2->mpi_comm_free proc~create_private~2->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private~2->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private~2->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private~2->proc~check_create_args proc~count_unique count_unique proc~create_private~2->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private~2->proc~cudageterrorstring proc~get_user_gpu_backend get_user_gpu_backend proc~create_private~2->proc~get_user_gpu_backend proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_allgather proc~get_local_size->mpi_comm_size proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_user_platform get_user_platform proc~check_create_args->proc~get_user_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env proc~get_user_stream->interface~int_to_str proc~get_user_stream->mpi_abort proc~get_user_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2c_pencil.html"},{"title":"mem_alloc_ptr – dtFFT","text":"private  subroutine mem_alloc_ptr(self, alloc_bytes, ptr, error_code) Allocates memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_ptr~~CallsGraph proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mem_alloc_ptr~~CalledByGraph proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~mem_alloc_ptr proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_ptr.html"},{"title":"mem_free_ptr – dtFFT","text":"private  subroutine mem_free_ptr(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_ptr~~CallsGraph proc~mem_free_ptr dtfft_plan_t%mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mem_free_ptr~~CalledByGraph proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~mem_free_ptr proc~dtfft_mem_free_c dtfft_mem_free_c proc~dtfft_mem_free_c->proc~mem_free_ptr proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_c32_1d->proc~mem_free_ptr proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_c32_2d->proc~mem_free_ptr proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_c32_3d->proc~mem_free_ptr proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_c64_1d->proc~mem_free_ptr proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_c64_2d->proc~mem_free_ptr proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_c64_3d->proc~mem_free_ptr proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_r32_1d->proc~mem_free_ptr proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_r32_2d->proc~mem_free_ptr proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_r32_3d->proc~mem_free_ptr proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_r64_1d->proc~mem_free_ptr proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_r64_2d->proc~mem_free_ptr proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_r64_3d->proc~mem_free_ptr proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_ptr.html"},{"title":"mem_alloc_r32_1d – dtFFT","text":"private  subroutine mem_alloc_r32_1d(self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r32_1d~~CallsGraph proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r32_1d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r32_1d.html"},{"title":"mem_alloc_r32_2d – dtFFT","text":"private  subroutine mem_alloc_r32_2d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r32_2d~~CallsGraph proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r32_2d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r32_2d.html"},{"title":"mem_alloc_r32_3d – dtFFT","text":"private  subroutine mem_alloc_r32_3d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r32_3d~~CallsGraph proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r32_3d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r32_3d.html"},{"title":"mem_free_r32_1d – dtFFT","text":"private  subroutine mem_free_r32_1d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r32_1d~~CallsGraph proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r32_1d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r32_1d.html"},{"title":"mem_free_r32_2d – dtFFT","text":"private  subroutine mem_free_r32_2d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r32_2d~~CallsGraph proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r32_2d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r32_2d.html"},{"title":"mem_free_r32_3d – dtFFT","text":"private  subroutine mem_free_r32_3d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r32_3d~~CallsGraph proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r32_3d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r32_3d.html"},{"title":"mem_alloc_r64_1d – dtFFT","text":"private  subroutine mem_alloc_r64_1d(self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r64_1d~~CallsGraph proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r64_1d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r64_1d.html"},{"title":"mem_alloc_r64_2d – dtFFT","text":"private  subroutine mem_alloc_r64_2d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r64_2d~~CallsGraph proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r64_2d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r64_2d.html"},{"title":"mem_alloc_r64_3d – dtFFT","text":"private  subroutine mem_alloc_r64_3d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r64_3d~~CallsGraph proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r64_3d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r64_3d.html"},{"title":"mem_free_r64_1d – dtFFT","text":"private  subroutine mem_free_r64_1d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r64_1d~~CallsGraph proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r64_1d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r64_1d.html"},{"title":"mem_free_r64_2d – dtFFT","text":"private  subroutine mem_free_r64_2d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r64_2d~~CallsGraph proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r64_2d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r64_2d.html"},{"title":"mem_free_r64_3d – dtFFT","text":"private  subroutine mem_free_r64_3d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r64_3d~~CallsGraph proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r64_3d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r64_3d.html"},{"title":"mem_alloc_c32_1d – dtFFT","text":"private  subroutine mem_alloc_c32_1d(self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c32_1d~~CallsGraph proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c32_1d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c32_1d.html"},{"title":"mem_alloc_c32_2d – dtFFT","text":"private  subroutine mem_alloc_c32_2d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c32_2d~~CallsGraph proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c32_2d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c32_2d.html"},{"title":"mem_alloc_c32_3d – dtFFT","text":"private  subroutine mem_alloc_c32_3d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c32_3d~~CallsGraph proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c32_3d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c32_3d.html"},{"title":"mem_free_c32_1d – dtFFT","text":"private  subroutine mem_free_c32_1d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c32_1d~~CallsGraph proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c32_1d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c32_1d.html"},{"title":"mem_free_c32_2d – dtFFT","text":"private  subroutine mem_free_c32_2d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c32_2d~~CallsGraph proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c32_2d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c32_2d.html"},{"title":"mem_free_c32_3d – dtFFT","text":"private  subroutine mem_free_c32_3d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c32_3d~~CallsGraph proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c32_3d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c32_3d.html"},{"title":"mem_alloc_c64_1d – dtFFT","text":"private  subroutine mem_alloc_c64_1d(self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c64_1d~~CallsGraph proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c64_1d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c64_1d.html"},{"title":"mem_alloc_c64_2d – dtFFT","text":"private  subroutine mem_alloc_c64_2d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c64_2d~~CallsGraph proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c64_2d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c64_2d.html"},{"title":"mem_alloc_c64_3d – dtFFT","text":"private  subroutine mem_alloc_c64_3d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c64_3d~~CallsGraph proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c64_3d->proc~mem_alloc_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c64_3d.html"},{"title":"mem_free_c64_1d – dtFFT","text":"private  subroutine mem_free_c64_1d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c64_1d~~CallsGraph proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c64_1d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c64_1d.html"},{"title":"mem_free_c64_2d – dtFFT","text":"private  subroutine mem_free_c64_2d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c64_2d~~CallsGraph proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c64_2d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c64_2d.html"},{"title":"mem_free_c64_3d – dtFFT","text":"private  subroutine mem_free_c64_3d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c64_3d~~CallsGraph proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c64_3d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c64_3d.html"},{"title":"get_tile_size – dtFFT","text":"private  function get_tile_size(x, y) Returns tile size to use in a tranpose kernel Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x Number of elements in x direction integer(kind=int32), intent(in) :: y Number of elements in y direction Return Value integer(kind=int32) Called by proc~~get_tile_size~~CalledByGraph proc~get_tile_size get_tile_size proc~create~8 nvrtc_kernel%create proc~create~8->proc~get_tile_size proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_tile_size.html"},{"title":"get_cached_kernel – dtFFT","text":"private  function get_cached_kernel(transpose_type, kernel_type, base_storage, tile_size, has_inner_loop) result(kernel) Returns cached kernel if it exists.\nIf not returns null pointer. Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition to perform integer(kind=int8), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Tile size logical, intent(in) :: has_inner_loop If kernel has inner loop Return Value type( CUfunction ) Cached kernel Calls proc~~get_cached_kernel~~CallsGraph proc~get_cached_kernel get_cached_kernel proc~get_true_transpose_type get_true_transpose_type proc~get_cached_kernel->proc~get_true_transpose_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_cached_kernel~~CalledByGraph proc~get_cached_kernel get_cached_kernel proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~get_cached_kernel proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_cached_kernel.html"},{"title":"get_true_transpose_type – dtFFT","text":"private  function get_true_transpose_type(transpose_type) result(transpose_type_) Returns generic transpose id.\nSince X-Y and Y-Z transpositions are symmectric, it returns only one of them.\nX-Z and Z-X are not symmetric Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition to perform Return Value type( dtfft_transpose_t ) Fixed id of transposition Called by proc~~get_true_transpose_type~~CalledByGraph proc~get_true_transpose_type get_true_transpose_type proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~get_true_transpose_type proc~get_cached_kernel get_cached_kernel proc~compile_and_cache->proc~get_cached_kernel proc~get_cached_kernel->proc~get_true_transpose_type proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_true_transpose_type.html"},{"title":"compile_and_cache – dtFFT","text":"private  function compile_and_cache(comm, dims, transpose_type, kernel_type, base_storage, tile_size, has_inner_loop) result(kernel) Uses iso_c_binding iso_fortran_env proc~~compile_and_cache~~UsesGraph proc~compile_and_cache compile_and_cache iso_c_binding iso_c_binding proc~compile_and_cache->iso_c_binding iso_fortran_env iso_fortran_env proc~compile_and_cache->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compiles kernel and caches it. Returns compiled kernel. Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI Communicator integer(kind=int32), intent(in), target :: dims (:) Global dimensions to process type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition to perform integer(kind=int8), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Tile size logical, intent(in) :: has_inner_loop If kernel has inner loop Return Value type( CUfunction ) Compiled kernel to return Calls proc~~compile_and_cache~~CallsGraph proc~compile_and_cache compile_and_cache interface~cudagetdevice cudaGetDevice proc~compile_and_cache->interface~cudagetdevice interface~get_cuda_architecture get_cuda_architecture proc~compile_and_cache->interface~get_cuda_architecture interface~int_to_str int_to_str proc~compile_and_cache->interface~int_to_str is_null_ptr is_null_ptr proc~compile_and_cache->is_null_ptr mpi_abort mpi_abort proc~compile_and_cache->mpi_abort mpi_allreduce mpi_allreduce proc~compile_and_cache->mpi_allreduce mpi_comm_rank mpi_comm_rank proc~compile_and_cache->mpi_comm_rank proc~astring_f2c astring_f2c proc~compile_and_cache->proc~astring_f2c proc~cudageterrorstring cudaGetErrorString proc~compile_and_cache->proc~cudageterrorstring proc~destroy_code kernel_code%destroy_code proc~compile_and_cache->proc~destroy_code proc~get_cached_kernel get_cached_kernel proc~compile_and_cache->proc~get_cached_kernel proc~get_transpose_kernel_code get_transpose_kernel_code proc~compile_and_cache->proc~get_transpose_kernel_code proc~get_true_transpose_type get_true_transpose_type proc~compile_and_cache->proc~get_true_transpose_type proc~get_unpack_kernel_code get_unpack_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_and_cache->proc~nvrtcgeterrorstring proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~compile_and_cache->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~compile_and_cache->proc~push_nvtx_domain_range proc~string_c2f string_c2f proc~compile_and_cache->proc~string_c2f proc~to_cstr kernel_code%to_cstr proc~compile_and_cache->proc~to_cstr proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~cudageterrorstring->proc~string_c2f interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~get_cached_kernel->proc~get_true_transpose_type proc~add_line kernel_code%add_line proc~get_transpose_kernel_code->proc~add_line proc~get_code_init get_code_init proc~get_transpose_kernel_code->proc~get_code_init proc~get_neighbor_function_code get_neighbor_function_code proc~get_transpose_kernel_code->proc~get_neighbor_function_code proc~get_unpack_kernel_code->proc~add_line proc~get_unpack_kernel_code->proc~get_code_init proc~get_unpack_kernel_code->proc~get_neighbor_function_code proc~get_unpack_pipelined_kernel_code->mpi_comm_rank proc~get_unpack_pipelined_kernel_code->proc~add_line proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~nvrtcgeterrorstring->proc~string_c2f interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c proc~push_nvtx_domain_range->proc~astring_f2c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~to_cstr->proc~astring_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~get_code_init->interface~int_to_str proc~get_code_init->proc~add_line proc~get_neighbor_function_code->proc~add_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compile_and_cache~~CalledByGraph proc~compile_and_cache compile_and_cache proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compile_and_cache.html"},{"title":"get_transpose_kernel_code – dtFFT","text":"private  function get_transpose_kernel_code(kernel_name, ndims, base_storage, transpose_type, enable_packing, enable_multiprocess) result(code) Generates code that will be used to locally tranpose data and prepares to send it to other processes\nndims == 2 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int8), intent(in) :: ndims Number of dimensions integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_transpose_t ), intent(in) :: transpose_type Transpose id logical, intent(in) :: enable_packing If data should be manually packed or not logical, intent(in) :: enable_multiprocess If thread should process more then one element Return Value type( kernel_code ) Resulting code Calls proc~~get_transpose_kernel_code~~CallsGraph proc~get_transpose_kernel_code get_transpose_kernel_code proc~add_line kernel_code%add_line proc~get_transpose_kernel_code->proc~add_line proc~get_code_init get_code_init proc~get_transpose_kernel_code->proc~get_code_init proc~get_neighbor_function_code get_neighbor_function_code proc~get_transpose_kernel_code->proc~get_neighbor_function_code proc~get_code_init->proc~add_line interface~int_to_str int_to_str proc~get_code_init->interface~int_to_str proc~get_neighbor_function_code->proc~add_line proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_transpose_kernel_code~~CalledByGraph proc~get_transpose_kernel_code get_transpose_kernel_code proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~get_transpose_kernel_code proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_transpose_kernel_code.html"},{"title":"get_unpack_kernel_code – dtFFT","text":"private  function get_unpack_kernel_code(kernel_name, base_storage, is_partial) result(code) Generates code that will be used to unpack data when it is recieved Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_partial Return Value type( kernel_code ) Resulting code Calls proc~~get_unpack_kernel_code~~CallsGraph proc~get_unpack_kernel_code get_unpack_kernel_code proc~add_line kernel_code%add_line proc~get_unpack_kernel_code->proc~add_line proc~get_code_init get_code_init proc~get_unpack_kernel_code->proc~get_code_init proc~get_neighbor_function_code get_neighbor_function_code proc~get_unpack_kernel_code->proc~get_neighbor_function_code proc~get_code_init->proc~add_line interface~int_to_str int_to_str proc~get_code_init->interface~int_to_str proc~get_neighbor_function_code->proc~add_line proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_unpack_kernel_code~~CalledByGraph proc~get_unpack_kernel_code get_unpack_kernel_code proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~get_unpack_kernel_code proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_unpack_kernel_code.html"},{"title":"get_unpack_pipelined_kernel_code – dtFFT","text":"private  function get_unpack_pipelined_kernel_code(kernel_name, base_storage) result(code) Generates code that will be used to partially unpack data when it is recieved from other process Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value type( kernel_code ) Resulting code Calls proc~~get_unpack_pipelined_kernel_code~~CallsGraph proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code mpi_comm_rank mpi_comm_rank proc~get_unpack_pipelined_kernel_code->mpi_comm_rank proc~add_line kernel_code%add_line proc~get_unpack_pipelined_kernel_code->proc~add_line proc~get_code_init get_code_init proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~get_code_init->proc~add_line interface~int_to_str int_to_str proc~get_code_init->interface~int_to_str proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_unpack_pipelined_kernel_code~~CalledByGraph proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_unpack_pipelined_kernel_code.html"},{"title":"clean_unused_cache – dtFFT","text":"public  subroutine clean_unused_cache() Uses iso_c_binding iso_fortran_env proc~~clean_unused_cache~~UsesGraph proc~clean_unused_cache clean_unused_cache iso_c_binding iso_c_binding proc~clean_unused_cache->iso_c_binding iso_fortran_env iso_fortran_env proc~clean_unused_cache->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Removes unused modules from cuda context Arguments None Calls proc~~clean_unused_cache~~CallsGraph proc~clean_unused_cache clean_unused_cache interface~int_to_str int_to_str proc~clean_unused_cache->interface~int_to_str is_null_ptr is_null_ptr proc~clean_unused_cache->is_null_ptr mpi_abort mpi_abort proc~clean_unused_cache->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~clean_unused_cache->proc~cudageterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~clean_unused_cache~~CalledByGraph proc~clean_unused_cache clean_unused_cache proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~clean_unused_cache proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~clean_unused_cache proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/clean_unused_cache.html"},{"title":"to_cstr – dtFFT","text":"private  subroutine to_cstr(self, c_code) Converts Fortran CUDA code to C pointer Type Bound kernel_code Arguments Type Intent Optional Attributes Name class( kernel_code ), intent(in) :: self Kernel code character(len=c_char), intent(out), allocatable :: c_code (:) C pointer to code Calls proc~~to_cstr~~CallsGraph proc~to_cstr kernel_code%to_cstr proc~astring_f2c astring_f2c proc~to_cstr->proc~astring_f2c proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~to_cstr~~CalledByGraph proc~to_cstr kernel_code%to_cstr proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~to_cstr proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_cstr.html"},{"title":"add_line – dtFFT","text":"private  subroutine add_line(self, line) Adds new line to CUDA code Type Bound kernel_code Arguments Type Intent Optional Attributes Name class( kernel_code ), intent(inout) :: self Kernel code character(len=*), intent(in) :: line Line to add Called by proc~~add_line~~CalledByGraph proc~add_line kernel_code%add_line proc~get_code_init get_code_init proc~get_code_init->proc~add_line proc~get_neighbor_function_code get_neighbor_function_code proc~get_neighbor_function_code->proc~add_line proc~get_transpose_kernel_code get_transpose_kernel_code proc~get_transpose_kernel_code->proc~add_line proc~get_transpose_kernel_code->proc~get_code_init proc~get_transpose_kernel_code->proc~get_neighbor_function_code proc~get_unpack_kernel_code get_unpack_kernel_code proc~get_unpack_kernel_code->proc~add_line proc~get_unpack_kernel_code->proc~get_code_init proc~get_unpack_kernel_code->proc~get_neighbor_function_code proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~get_unpack_pipelined_kernel_code->proc~add_line proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~get_transpose_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/add_line.html"},{"title":"destroy_code – dtFFT","text":"private  subroutine destroy_code(self) Frees all memory Type Bound kernel_code Arguments Type Intent Optional Attributes Name class( kernel_code ), intent(inout) :: self Kernel code Called by proc~~destroy_code~~CalledByGraph proc~destroy_code kernel_code%destroy_code proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~destroy_code proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_code.html"},{"title":"create_device_pointer – dtFFT","text":"private  subroutine create_device_pointer(ptr, values) Uses iso_c_binding iso_fortran_env proc~~create_device_pointer~~UsesGraph proc~create_device_pointer create_device_pointer iso_c_binding iso_c_binding proc~create_device_pointer->iso_c_binding iso_fortran_env iso_fortran_env proc~create_device_pointer->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Allocates memory on a device and copies values to it. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(inout) :: ptr Device pointer integer(kind=c_int), intent(in), target :: values (:) Values to copy Calls proc~~create_device_pointer~~CallsGraph proc~create_device_pointer create_device_pointer interface~cudamalloc cudaMalloc proc~create_device_pointer->interface~cudamalloc interface~cudamemcpy cudaMemcpy proc~create_device_pointer->interface~cudamemcpy interface~int_to_str int_to_str proc~create_device_pointer->interface~int_to_str mpi_abort mpi_abort proc~create_device_pointer->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~create_device_pointer->proc~cudageterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_device_pointer~~CalledByGraph proc~create_device_pointer create_device_pointer proc~create~8 nvrtc_kernel%create proc~create~8->proc~create_device_pointer proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_device_pointer.html"},{"title":"get_contiguous_execution_blocks – dtFFT","text":"private  subroutine get_contiguous_execution_blocks(size, num_blocks, block_sizes) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: size Total amount of iterations required type( dim3 ), intent(out) :: num_blocks Grid of blocks. type( dim3 ), intent(out) :: block_sizes Thread block. Called by proc~~get_contiguous_execution_blocks~~CalledByGraph proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~create~8 nvrtc_kernel%create proc~create~8->proc~get_contiguous_execution_blocks proc~execute~9 nvrtc_kernel%execute proc~execute~9->proc~get_contiguous_execution_blocks proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~9 proc~execute~10 transpose_handle_cuda%execute proc~execute~10->proc~execute~9 proc~execute~5 abstract_backend%execute proc~execute~5->proc~execute~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~execute~10 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_contiguous_execution_blocks.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, comm, dims, base_storage, transpose_type, kernel_type, pointers) Creates kernel Type Bound nvrtc_kernel Arguments Type Intent Optional Attributes Name class( nvrtc_kernel ), intent(inout) :: self nvRTC Compiled kernel class type(MPI_Comm), intent(in) :: comm MPI Communicator integer(kind=int32), intent(in), target :: dims (0:) Global dimensions to process integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition to perform integer(kind=int8), intent(in) :: kernel_type Type of kernel to build integer(kind=int32), intent(in), optional :: pointers (:,:) Optional pointers to unpack kernels Calls proc~~create~8~~CallsGraph proc~create~8 nvrtc_kernel%create mpi_comm_rank mpi_comm_rank proc~create~8->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create~8->mpi_comm_size proc~compile_and_cache compile_and_cache proc~create~8->proc~compile_and_cache proc~create_device_pointer create_device_pointer proc~create~8->proc~create_device_pointer proc~destroy~10 nvrtc_kernel%destroy proc~create~8->proc~destroy~10 proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~create~8->proc~get_contiguous_execution_blocks proc~get_tile_size get_tile_size proc~create~8->proc~get_tile_size proc~compile_and_cache->mpi_comm_rank interface~cudagetdevice cudaGetDevice proc~compile_and_cache->interface~cudagetdevice interface~get_cuda_architecture get_cuda_architecture proc~compile_and_cache->interface~get_cuda_architecture interface~int_to_str int_to_str proc~compile_and_cache->interface~int_to_str is_null_ptr is_null_ptr proc~compile_and_cache->is_null_ptr mpi_abort mpi_abort proc~compile_and_cache->mpi_abort mpi_allreduce mpi_allreduce proc~compile_and_cache->mpi_allreduce proc~astring_f2c astring_f2c proc~compile_and_cache->proc~astring_f2c proc~cudageterrorstring cudaGetErrorString proc~compile_and_cache->proc~cudageterrorstring proc~destroy_code kernel_code%destroy_code proc~compile_and_cache->proc~destroy_code proc~get_cached_kernel get_cached_kernel proc~compile_and_cache->proc~get_cached_kernel proc~get_transpose_kernel_code get_transpose_kernel_code proc~compile_and_cache->proc~get_transpose_kernel_code proc~get_true_transpose_type get_true_transpose_type proc~compile_and_cache->proc~get_true_transpose_type proc~get_unpack_kernel_code get_unpack_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_and_cache->proc~nvrtcgeterrorstring proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~compile_and_cache->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~compile_and_cache->proc~push_nvtx_domain_range proc~string_c2f string_c2f proc~compile_and_cache->proc~string_c2f proc~to_cstr kernel_code%to_cstr proc~compile_and_cache->proc~to_cstr interface~cudamalloc cudaMalloc proc~create_device_pointer->interface~cudamalloc interface~cudamemcpy cudaMemcpy proc~create_device_pointer->interface~cudamemcpy proc~create_device_pointer->interface~int_to_str proc~create_device_pointer->mpi_abort proc~create_device_pointer->proc~cudageterrorstring interface~cudafree cudaFree proc~destroy~10->interface~cudafree proc~destroy~10->interface~int_to_str proc~destroy~10->mpi_abort proc~destroy~10->proc~cudageterrorstring proc~mark_unused mark_unused proc~destroy~10->proc~mark_unused proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~cudageterrorstring->proc~string_c2f interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~get_cached_kernel->proc~get_true_transpose_type proc~add_line kernel_code%add_line proc~get_transpose_kernel_code->proc~add_line proc~get_code_init get_code_init proc~get_transpose_kernel_code->proc~get_code_init proc~get_neighbor_function_code get_neighbor_function_code proc~get_transpose_kernel_code->proc~get_neighbor_function_code proc~get_unpack_kernel_code->proc~add_line proc~get_unpack_kernel_code->proc~get_code_init proc~get_unpack_kernel_code->proc~get_neighbor_function_code proc~get_unpack_pipelined_kernel_code->mpi_comm_rank proc~get_unpack_pipelined_kernel_code->proc~add_line proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~is_same_ptr is_same_ptr proc~mark_unused->proc~is_same_ptr proc~nvrtcgeterrorstring->proc~string_c2f interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c proc~push_nvtx_domain_range->proc~astring_f2c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~to_cstr->proc~astring_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~get_code_init->interface~int_to_str proc~get_code_init->proc~add_line proc~get_neighbor_function_code->proc~add_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~8~~CalledByGraph proc~create~8 nvrtc_kernel%create proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~8.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, stream, source) Uses iso_c_binding iso_fortran_env proc~~execute~9~~UsesGraph proc~execute~9 nvrtc_kernel%execute iso_c_binding iso_c_binding proc~execute~9->iso_c_binding iso_fortran_env iso_fortran_env proc~execute~9->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes kernel on stream Type Bound nvrtc_kernel Arguments Type Intent Optional Attributes Name class( nvrtc_kernel ), intent(inout) :: self nvRTC Compiled kernel class real(kind=real32), intent(in), target :: in (:) Source pointer real(kind=real32), intent(in), target :: out (:) Target pointer type( dtfft_stream_t ), intent(in) :: stream CUDA Stream integer(kind=int32), intent(in), optional :: source Source rank for pipelined unpacking Calls proc~~execute~9~~CallsGraph proc~execute~9 nvrtc_kernel%execute interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync interface~int_to_str int_to_str proc~execute~9->interface~int_to_str mpi_abort mpi_abort proc~execute~9->mpi_abort mpi_comm_rank mpi_comm_rank proc~execute~9->mpi_comm_rank proc~cudageterrorstring cudaGetErrorString proc~execute~9->proc~cudageterrorstring proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute~9~~CalledByGraph proc~execute~9 nvrtc_kernel%execute proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~9 proc~execute~10 transpose_handle_cuda%execute proc~execute~10->proc~execute~9 proc~execute~5 abstract_backend%execute proc~execute~5->proc~execute~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~execute~10 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~9.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Uses iso_c_binding iso_fortran_env proc~~destroy~10~~UsesGraph proc~destroy~10 nvrtc_kernel%destroy iso_c_binding iso_c_binding proc~destroy~10->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy~10->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys kernel Type Bound nvrtc_kernel Arguments Type Intent Optional Attributes Name class( nvrtc_kernel ), intent(inout) :: self nvRTC Compiled kernel class Calls proc~~destroy~10~~CallsGraph proc~destroy~10 nvrtc_kernel%destroy interface~cudafree cudaFree proc~destroy~10->interface~cudafree interface~int_to_str int_to_str proc~destroy~10->interface~int_to_str mpi_abort mpi_abort proc~destroy~10->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy~10->proc~cudageterrorstring proc~mark_unused mark_unused proc~destroy~10->proc~mark_unused proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~is_same_ptr is_same_ptr proc~mark_unused->proc~is_same_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy~10~~CalledByGraph proc~destroy~10 nvrtc_kernel%destroy proc~create~8 nvrtc_kernel%create proc~create~8->proc~destroy~10 proc~destroy~11 transpose_handle_cuda%destroy proc~destroy~11->proc~destroy~10 proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~destroy~11 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~10.html"},{"title":"mark_unused – dtFFT","text":"private  subroutine mark_unused(kernel) Takes CUDA kernel as an argument and searches for it in cache\nIf kernel is found than reduces ref_count and return null pointer Arguments Type Intent Optional Attributes Name type( CUfunction ), intent(inout) :: kernel CUDA kernel to search for Calls proc~~mark_unused~~CallsGraph proc~mark_unused mark_unused proc~is_same_ptr is_same_ptr proc~mark_unused->proc~is_same_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mark_unused~~CalledByGraph proc~mark_unused mark_unused proc~destroy~10 nvrtc_kernel%destroy proc~destroy~10->proc~mark_unused proc~create~8 nvrtc_kernel%create proc~create~8->proc~destroy~10 proc~destroy~11 transpose_handle_cuda%destroy proc~destroy~11->proc~destroy~10 proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~destroy~11 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mark_unused.html"},{"title":"get_neighbor_function_code – dtFFT","text":"private  subroutine get_neighbor_function_code(code) Generated device function that is used to determite id of process that to which data is being sent or from which data has been recieved\nbased on local element coordinate Arguments Type Intent Optional Attributes Name type( kernel_code ), intent(inout) :: code Resulting code Calls proc~~get_neighbor_function_code~~CallsGraph proc~get_neighbor_function_code get_neighbor_function_code proc~add_line kernel_code%add_line proc~get_neighbor_function_code->proc~add_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_neighbor_function_code~~CalledByGraph proc~get_neighbor_function_code get_neighbor_function_code proc~get_transpose_kernel_code get_transpose_kernel_code proc~get_transpose_kernel_code->proc~get_neighbor_function_code proc~get_unpack_kernel_code get_unpack_kernel_code proc~get_unpack_kernel_code->proc~get_neighbor_function_code proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~get_transpose_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_neighbor_function_code.html"},{"title":"get_code_init – dtFFT","text":"private  subroutine get_code_init(kernel_name, base_storage, code, buffer_type) Generates basic code that is used in all other kernels Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_code ), intent(inout) :: code Resulting code character(len=:), intent(out), optional, allocatable :: buffer_type Type of buffer that should be used Calls proc~~get_code_init~~CallsGraph proc~get_code_init get_code_init interface~int_to_str int_to_str proc~get_code_init->interface~int_to_str proc~add_line kernel_code%add_line proc~get_code_init->proc~add_line proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_code_init~~CalledByGraph proc~get_code_init get_code_init proc~get_transpose_kernel_code get_transpose_kernel_code proc~get_transpose_kernel_code->proc~get_code_init proc~get_unpack_kernel_code get_unpack_kernel_code proc~get_unpack_kernel_code->proc~get_code_init proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~get_transpose_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_code_init.html"},{"title":"init_internal – dtFFT","text":"public  function init_internal() Checks if MPI is initialized and loads environment variables Arguments None Return Value integer(kind=int32) Calls proc~~init_internal~~CallsGraph proc~init_internal init_internal backends backends proc~init_internal->backends interface~get_env get_env proc~init_internal->interface~get_env mpi_initialized mpi_initialized proc~init_internal->mpi_initialized platforms platforms proc~init_internal->platforms proc~destroy_strings destroy_strings proc~init_internal->proc~destroy_strings proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_internal~~CalledByGraph proc~init_internal init_internal proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/init_internal.html"},{"title":"get_platform_from_env – dtFFT","text":"public pure function get_platform_from_env() Returns execution platform set by environment variable Arguments None Return Value type( dtfft_platform_t ) Called by proc~~get_platform_from_env~~CalledByGraph proc~get_platform_from_env get_platform_from_env proc~get_user_platform get_user_platform proc~get_user_platform->proc~get_platform_from_env proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~get_user_platform proc~create~12 abstract_transpose_plan%create proc~create~12->proc~get_user_platform proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_platform proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_platform_from_env.html"},{"title":"get_z_slab_from_env – dtFFT","text":"public pure function get_z_slab_from_env() Returns Z-slab to be used set by environment variable Arguments None Return Value integer(kind=int32) Called by proc~~get_z_slab_from_env~~CalledByGraph proc~get_z_slab_from_env get_z_slab_from_env proc~get_z_slab get_z_slab proc~get_z_slab->proc~get_z_slab_from_env proc~create~12 abstract_transpose_plan%create proc~create~12->proc~get_z_slab Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_z_slab_from_env.html"},{"title":"get_backend_from_env – dtFFT","text":"public pure function get_backend_from_env() Returns GPU backend to use set by environment variable Arguments None Return Value type( dtfft_backend_t ) Called by proc~~get_backend_from_env~~CalledByGraph proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend get_user_gpu_backend proc~get_user_gpu_backend->proc~get_backend_from_env proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_user_gpu_backend proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~get_user_gpu_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_backend_from_env.html"},{"title":"get_mpi_enabled_from_env – dtFFT","text":"public pure function get_mpi_enabled_from_env() Returns usage of MPI Backends during autotune set by environment variable Arguments None Return Value integer(kind=int32) Called by proc~~get_mpi_enabled_from_env~~CalledByGraph proc~get_mpi_enabled_from_env get_mpi_enabled_from_env proc~get_mpi_enabled get_mpi_enabled proc~get_mpi_enabled->proc~get_mpi_enabled_from_env proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_mpi_enabled proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~get_mpi_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_mpi_enabled_from_env.html"},{"title":"get_nccl_enabled_from_env – dtFFT","text":"public pure function get_nccl_enabled_from_env() Returns usage of NCCL Backends during autotune set by environment variable Arguments None Return Value integer(kind=int32) Called by proc~~get_nccl_enabled_from_env~~CalledByGraph proc~get_nccl_enabled_from_env get_nccl_enabled_from_env proc~get_nccl_enabled get_nccl_enabled proc~get_nccl_enabled->proc~get_nccl_enabled_from_env proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_nccl_enabled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nccl_enabled_from_env.html"},{"title":"get_nvshmem_enabled_from_env – dtFFT","text":"public pure function get_nvshmem_enabled_from_env() Returns usage of NVSHMEM Backends during autotune set by environment variable Arguments None Return Value integer(kind=int32) Called by proc~~get_nvshmem_enabled_from_env~~CalledByGraph proc~get_nvshmem_enabled_from_env get_nvshmem_enabled_from_env proc~get_nvshmem_enabled get_nvshmem_enabled proc~get_nvshmem_enabled->proc~get_nvshmem_enabled_from_env proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_nvshmem_enabled proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~get_nvshmem_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nvshmem_enabled_from_env.html"},{"title":"get_pipe_enabled_from_env – dtFFT","text":"public pure function get_pipe_enabled_from_env() Returns usage of Pipelined Backends during autotune set by environment variable Arguments None Return Value integer(kind=int32) Called by proc~~get_pipe_enabled_from_env~~CalledByGraph proc~get_pipe_enabled_from_env get_pipe_enabled_from_env proc~get_pipelined_enabled get_pipelined_enabled proc~get_pipelined_enabled->proc~get_pipe_enabled_from_env proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~get_pipelined_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_pipe_enabled_from_env.html"},{"title":"get_iters_from_env – dtFFT","text":"public  function get_iters_from_env(is_warmup) result(n_iters) Obtains number of iterations from environment variable Arguments Type Intent Optional Attributes Name logical, intent(in) :: is_warmup Warmup variable flag Return Value integer(kind=int32) Calls proc~~get_iters_from_env~~CallsGraph proc~get_iters_from_env get_iters_from_env interface~get_env get_env proc~get_iters_from_env->interface~get_env proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_iters_from_env~~CalledByGraph proc~get_iters_from_env get_iters_from_env proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~get_iters_from_env proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~get_iters_from_env proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_iters_from_env.html"},{"title":"get_datatype_from_env – dtFFT","text":"public  function get_datatype_from_env(name) result(env) Obtains datatype id from environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value integer(kind=int8) Calls proc~~get_datatype_from_env~~CallsGraph proc~get_datatype_from_env get_datatype_from_env interface~get_env get_env proc~get_datatype_from_env->interface~get_env proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_datatype_from_env~~CalledByGraph proc~get_datatype_from_env get_datatype_from_env proc~create_private transpose_plan_host%create_private proc~create_private->proc~get_datatype_from_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_datatype_from_env.html"},{"title":"get_log_enabled – dtFFT","text":"public pure function get_log_enabled() result(log) Returns the value of the log_enabled variable Arguments None Return Value logical Value of the log_enabled variable Called by proc~~get_log_enabled~~CalledByGraph proc~get_log_enabled get_log_enabled proc~alloc_mem alloc_mem proc~alloc_mem->proc~get_log_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~get_log_enabled proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~get_log_enabled proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_grid~2->proc~get_log_enabled proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~get_log_enabled proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c->proc~create_c2c_core proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~get_log_enabled proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_log_enabled proc~create_cuda->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_helper backend_helper%create_helper proc~create_cuda->proc~create_helper proc~load_cuda load_cuda proc~create_cuda->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create_cuda->proc~load_nvrtc proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~get_log_enabled proc~create_private transpose_plan_host%create_private proc~create_private->proc~get_log_enabled proc~create_private->proc~autotune_grid_decomposition~2 proc~create_private->proc~autotune_grid~2 proc~get_datatype_from_env get_datatype_from_env proc~create_private->proc~get_datatype_from_env proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~get_log_enabled proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~get_log_enabled proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~get_log_enabled proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~get_log_enabled proc~create_r2r_pencil->proc~create_r2r_internal proc~create~12 abstract_transpose_plan%create proc~create~12->proc~get_log_enabled proc~destroy_helper backend_helper%destroy_helper proc~destroy_helper->proc~get_log_enabled proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~get_log_enabled proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~9->proc~mem_free_ptr proc~dl_error dl_error proc~dl_error->proc~get_log_enabled proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~get_log_enabled proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_log_enabled proc~get_element_size dtfft_plan_t%get_element_size proc~get_alloc_bytes->proc~get_element_size proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_bytes->proc~get_alloc_size proc~get_dims dtfft_plan_t%get_dims proc~get_dims->proc~get_log_enabled proc~get_element_size->proc~get_log_enabled proc~get_env_int32 get_env_int32 proc~get_env_int32->proc~get_log_enabled interface~get_env get_env proc~get_env_int32->interface~get_env proc~get_env_string get_env_string proc~get_env_string->proc~get_log_enabled proc~get_env_string->interface~get_env proc~get_executor dtfft_plan_t%get_executor proc~get_executor->proc~get_log_enabled proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_local_sizes->proc~get_log_enabled proc~get_pencil dtfft_plan_t%get_pencil proc~get_pencil->proc~get_log_enabled proc~get_plan_execution_time->proc~get_log_enabled proc~get_iters_from_env get_iters_from_env proc~get_plan_execution_time->proc~get_iters_from_env proc~get_precision dtfft_plan_t%get_precision proc~get_precision->proc~get_log_enabled proc~get_stream_ptr dtfft_plan_t%get_stream_ptr proc~get_stream_ptr->proc~get_log_enabled proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_ptr->proc~get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~report dtfft_plan_t%report proc~report->proc~get_log_enabled proc~run_autotune_backend->proc~get_log_enabled proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~get_iters_from_env proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~get_log_enabled interface~get_env->proc~get_env_int32 interface~get_env->proc~get_env_string proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical none~get_stream dtfft_plan_t%get_stream none~get_stream->proc~get_stream_ptr proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream->proc~get_stream_int64 proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~check_aux->proc~get_element_size proc~check_aux->proc~mem_alloc_ptr proc~check_aux->proc~get_alloc_size proc~create_helper->proc~destroy_helper proc~create_helper->interface~get_env proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~dtfft_get_dims_c dtfft_get_dims_c proc~dtfft_get_dims_c->proc~get_dims proc~dtfft_get_element_size_c dtfft_get_element_size_c proc~dtfft_get_element_size_c->proc~get_element_size proc~dtfft_get_executor_c dtfft_get_executor_c proc~dtfft_get_executor_c->proc~get_executor proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes proc~dtfft_get_pencil_c dtfft_get_pencil_c proc~dtfft_get_pencil_c->proc~get_pencil proc~dtfft_get_precision_c dtfft_get_precision_c proc~dtfft_get_precision_c->proc~get_precision proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~dtfft_mem_free_c dtfft_mem_free_c proc~dtfft_mem_free_c->proc~mem_free_ptr proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~get_alloc_size->proc~get_local_sizes proc~load_library load_library proc~load_library->proc~dl_error proc~load_symbol load_symbol proc~load_symbol->proc~dl_error proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_c32_1d->proc~mem_free_ptr proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_c32_2d->proc~mem_free_ptr proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_c32_3d->proc~mem_free_ptr proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_c64_1d->proc~mem_free_ptr proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_c64_2d->proc~mem_free_ptr proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_c64_3d->proc~mem_free_ptr proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_r32_1d->proc~mem_free_ptr proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_r32_2d->proc~mem_free_ptr proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_r32_3d->proc~mem_free_ptr proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_r64_1d->proc~mem_free_ptr proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_r64_2d->proc~mem_free_ptr proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_r64_3d->proc~mem_free_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~unload_library unload_library proc~unload_library->proc~dl_error proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~dynamic_load->proc~unload_library proc~get_datatype_from_env->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_iters_from_env->interface~get_env proc~get_stream_int64->none~get_stream proc~init_internal init_internal proc~init_internal->interface~get_env proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~load load proc~load->proc~dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~dynamic_load proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal->proc~create_private~2 proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal->proc~create_c2c_core Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_log_enabled.html"},{"title":"load_library – dtFFT","text":"public  function load_library(name) result(lib_handle) Dynamically loads library Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of library to load Return Value type(c_ptr) Loaded handle Calls proc~~load_library~~CallsGraph proc~load_library load_library interface~dlopen dlopen proc~load_library->interface~dlopen interface~is_null_ptr is_null_ptr proc~load_library->interface~is_null_ptr proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_library~~CalledByGraph proc~load_library load_library proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_library.html"},{"title":"load_symbol – dtFFT","text":"public  function load_symbol(handle, name) result(symbol_handle) Dynamically loads symbol from library Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: handle Loaded handle character(len=*), intent(in) :: name Name of function to load Return Value type(c_funptr) Function pointer Calls proc~~load_symbol~~CallsGraph proc~load_symbol load_symbol interface~dlsym dlsym proc~load_symbol->interface~dlsym interface~is_null_ptr is_null_ptr proc~load_symbol->interface~is_null_ptr proc~astring_f2c astring_f2c proc~load_symbol->proc~astring_f2c proc~dl_error dl_error proc~load_symbol->proc~dl_error interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_symbol~~CalledByGraph proc~load_symbol load_symbol proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_symbol proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_symbol.html"},{"title":"dynamic_load – dtFFT","text":"public  function dynamic_load(name, symbol_names, handle, symbols) result(error_code) Dynamically loads library and its symbols Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of library to load type( string ), intent(in) :: symbol_names (:) Names of functions to load type(c_ptr), intent(out) :: handle Loaded handle type(c_funptr), intent(out) :: symbols (:) Function pointers Return Value integer(kind=int32) Error code Calls proc~~dynamic_load~~CallsGraph proc~dynamic_load dynamic_load interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dynamic_load~~CalledByGraph proc~dynamic_load dynamic_load proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dynamic_load.html"},{"title":"double_to_str – dtFFT","text":"public  function double_to_str(n) result(string) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string Called by proc~~double_to_str~~CalledByGraph proc~double_to_str double_to_str proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~double_to_str proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~double_to_str proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~get_plan_execution_time->proc~double_to_str proc~run_autotune_backend->proc~double_to_str proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_to_str.html"},{"title":"get_inverse_kind – dtFFT","text":"public elemental function get_inverse_kind(r2r_kind) result(result_kind) Get the inverse R2R kind of transform for the given R2R kind Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: r2r_kind R2R kind Return Value type( dtfft_r2r_kind_t ) Called by proc~~get_inverse_kind~~CalledByGraph proc~get_inverse_kind get_inverse_kind proc~create~3 fftw_executor%create proc~create~3->proc~get_inverse_kind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_inverse_kind.html"},{"title":"is_null_ptr – dtFFT","text":"public elemental function is_null_ptr(ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to check Return Value logical","tags":"","loc":"proc/is_null_ptr.html"},{"title":"is_same_ptr – dtFFT","text":"public elemental function is_same_ptr(ptr1, ptr2) Checks if two pointer are the same Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr1 First pointer type(c_ptr), intent(in) :: ptr2 Second pointer Return Value logical Called by proc~~is_same_ptr~~CalledByGraph proc~is_same_ptr is_same_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~is_same_ptr proc~free_mem free_mem proc~free_mem->proc~is_same_ptr proc~mark_unused mark_unused proc~mark_unused->proc~is_same_ptr proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~is_same_ptr proc~destroy~10 nvrtc_kernel%destroy proc~destroy~10->proc~mark_unused proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create~8 nvrtc_kernel%create proc~create~8->proc~destroy~10 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 proc~destroy_cuda->proc~destroy~11 proc~destroy~11->proc~destroy~10 proc~autotune_grid_decomposition->proc~autotune_grid proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_same_ptr.html"},{"title":"count_unique – dtFFT","text":"public  function count_unique(x) result(n) Count the number of unique elements in the array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) Array of integers Return Value integer(kind=int32) Called by proc~~count_unique~~CalledByGraph proc~count_unique count_unique proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~count_unique proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/count_unique.html"},{"title":"string_constructor – dtFFT","text":"private  function string_constructor(str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string ) Called by proc~~string_constructor~~CalledByGraph proc~string_constructor string_constructor interface~string string interface~string->proc~string_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/string_constructor.html"},{"title":"get_env_base – dtFFT","text":"private  function get_env_base(name) result(env) Base function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value character(len=:), allocatable Environment variable value Called by proc~~get_env_base~~CalledByGraph proc~get_env_base get_env_base interface~get_env get_env interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_iters_from_env get_iters_from_env proc~get_iters_from_env->interface~get_env proc~init_internal init_internal proc~init_internal->interface~get_env proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~get_datatype_from_env proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~get_iters_from_env proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~get_iters_from_env proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_base.html"},{"title":"get_env_string – dtFFT","text":"private  function get_env_string(name, default, valid_values) result(env) Obtains string environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix character(len=*), intent(in) :: default Name of environment variable without prefix type( string ), intent(in) :: valid_values (:) List of valid variable values Return Value character(len=:), allocatable Environment variable value Calls proc~~get_env_string~~CallsGraph proc~get_env_string get_env_string interface~get_env get_env proc~get_env_string->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_string->proc~get_log_enabled proc~write_message write_message proc~get_env_string->proc~write_message interface~get_env->proc~get_env_string proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_int32->interface~get_env proc~get_env_int32->proc~get_log_enabled proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_env_string~~CalledByGraph proc~get_env_string get_env_string interface~get_env get_env proc~get_env_string->interface~get_env interface~get_env->proc~get_env_string proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_iters_from_env get_iters_from_env proc~get_iters_from_env->interface~get_env proc~init_internal init_internal proc~init_internal->interface~get_env proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~get_datatype_from_env proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~get_iters_from_env proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~get_iters_from_env proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_string.html"},{"title":"get_env_int32 – dtFFT","text":"private  function get_env_int32(name, default, valid_values, min_valid_value) result(env) Base Integer function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int32), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in), optional :: valid_values (:) List of valid values integer(kind=int32), intent(in), optional :: min_valid_value Mininum valid value. Usually 0 or 1 Return Value integer(kind=int32) Calls proc~~get_env_int32~~CallsGraph proc~get_env_int32 get_env_int32 interface~get_env get_env proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message interface~get_env->proc~get_env_int32 proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_env_int32~~CalledByGraph proc~get_env_int32 get_env_int32 interface~get_env get_env proc~get_env_int32->interface~get_env interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_iters_from_env get_iters_from_env proc~get_iters_from_env->interface~get_env proc~init_internal init_internal proc~init_internal->interface~get_env proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~get_datatype_from_env proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~get_iters_from_env proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~get_iters_from_env proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_int32.html"},{"title":"get_env_int8 – dtFFT","text":"private  function get_env_int8(name, default, valid_values) result(env) Obtains int8 environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int8), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in) :: valid_values (:) List of valid values Return Value integer(kind=int8) Calls proc~~get_env_int8~~CallsGraph proc~get_env_int8 get_env_int8 interface~get_env get_env proc~get_env_int8->interface~get_env interface~get_env->proc~get_env_int8 proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_env_int8~~CalledByGraph proc~get_env_int8 get_env_int8 interface~get_env get_env proc~get_env_int8->interface~get_env interface~get_env->proc~get_env_int8 proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_iters_from_env get_iters_from_env proc~get_iters_from_env->interface~get_env proc~init_internal init_internal proc~init_internal->interface~get_env proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~get_datatype_from_env proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~get_iters_from_env proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~get_iters_from_env proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_int8.html"},{"title":"get_env_logical – dtFFT","text":"private  function get_env_logical(name, default) result(env) Obtains logical environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix logical, intent(in) :: default Default value in case env is not set or it has wrong value Return Value logical Calls proc~~get_env_logical~~CallsGraph proc~get_env_logical get_env_logical interface~get_env get_env proc~get_env_logical->interface~get_env interface~get_env->proc~get_env_logical proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_env_logical~~CalledByGraph proc~get_env_logical get_env_logical interface~get_env get_env proc~get_env_logical->interface~get_env interface~get_env->proc~get_env_logical proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_string->interface~get_env proc~get_iters_from_env get_iters_from_env proc~get_iters_from_env->interface~get_env proc~init_internal init_internal proc~init_internal->interface~get_env proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~get_datatype_from_env proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~get_iters_from_env proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~get_iters_from_env proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_logical.html"},{"title":"int_to_str_int8 – dtFFT","text":"private  function int_to_str_int8(n) result(string) Convert 8-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string Called by proc~~int_to_str_int8~~CalledByGraph proc~int_to_str_int8 int_to_str_int8 interface~int_to_str int_to_str interface~int_to_str->proc~int_to_str_int8 proc~alloc_mem alloc_mem proc~alloc_mem->interface~int_to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~int_to_str proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->interface~int_to_str proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_grid~2->interface~int_to_str proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~clean_unused_cache clean_unused_cache proc~clean_unused_cache->interface~int_to_str proc~compile_and_cache compile_and_cache proc~compile_and_cache->interface~int_to_str proc~get_transpose_kernel_code get_transpose_kernel_code proc~compile_and_cache->proc~get_transpose_kernel_code proc~get_unpack_kernel_code get_unpack_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->interface~int_to_str proc~create_cuda->proc~clean_unused_cache proc~create_helper backend_helper%create_helper proc~create_cuda->proc~create_helper proc~get_user_stream get_user_stream proc~create_cuda->proc~get_user_stream proc~create_cuda->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_device_pointer create_device_pointer proc~create_device_pointer->interface~int_to_str proc~create_helper->interface~int_to_str proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_private transpose_plan_host%create_private proc~create_private->interface~int_to_str proc~create_private->proc~autotune_grid_decomposition~2 proc~create_private->proc~autotune_grid~2 proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->interface~int_to_str proc~create_private~2->proc~get_user_stream proc~create~12 abstract_transpose_plan%create proc~create~12->interface~int_to_str proc~create~2 backend_cufftmp%create proc~create~2->interface~int_to_str proc~create~5 abstract_backend%create proc~create~5->interface~int_to_str proc~create~7 cufft_executor%create proc~create~7->interface~int_to_str proc~create~7->proc~get_user_stream proc~destroy_helper->interface~int_to_str proc~destroy_stream destroy_stream proc~destroy_stream->interface~int_to_str proc~destroy~10 nvrtc_kernel%destroy proc~destroy~10->interface~int_to_str proc~destroy~2 backend_cufftmp%destroy proc~destroy~2->interface~int_to_str proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~int_to_str proc~destroy~5 abstract_backend%destroy proc~destroy~5->interface~int_to_str proc~destroy~8 cufft_executor%destroy proc~destroy~8->interface~int_to_str proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->interface~int_to_str proc~execute~9 nvrtc_kernel%execute proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~int_to_str proc~execute_nccl->proc~execute~9 proc~execute~2 backend_cufftmp%execute proc~execute~2->interface~int_to_str proc~execute~4 mkl_executor%execute proc~execute~4->interface~int_to_str proc~execute~5 abstract_backend%execute proc~execute~5->interface~int_to_str proc~execute~5->proc~execute~9 proc~execute~7 cufft_executor%execute proc~execute~7->interface~int_to_str proc~execute~9->interface~int_to_str proc~free_mem free_mem proc~free_mem->interface~int_to_str proc~get_code_init get_code_init proc~get_code_init->interface~int_to_str proc~get_plan_execution_time->interface~int_to_str proc~get_user_stream->interface~int_to_str proc~make_plan make_plan proc~make_plan->interface~int_to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~int_to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~int_to_str proc~report dtfft_plan_t%report proc~report->interface~int_to_str proc~run_autotune_backend->interface~int_to_str proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_stream proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~8->proc~create_device_pointer proc~create~8->proc~destroy~10 proc~destroy~11->proc~destroy~10 proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~clean_unused_cache proc~destroy~9->proc~destroy_stream proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute~10->proc~execute~9 proc~get_transpose_kernel_code->proc~get_code_init proc~get_unpack_kernel_code->proc~get_code_init proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~destroy_cuda->proc~mem_free~5 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/int_to_str_int8.html"},{"title":"int_to_str_int32 – dtFFT","text":"private  function int_to_str_int32(n) result(string) Convert 32-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string Called by proc~~int_to_str_int32~~CalledByGraph proc~int_to_str_int32 int_to_str_int32 interface~int_to_str int_to_str interface~int_to_str->proc~int_to_str_int32 proc~alloc_mem alloc_mem proc~alloc_mem->interface~int_to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~int_to_str proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->interface~int_to_str proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_grid~2->interface~int_to_str proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~clean_unused_cache clean_unused_cache proc~clean_unused_cache->interface~int_to_str proc~compile_and_cache compile_and_cache proc~compile_and_cache->interface~int_to_str proc~get_transpose_kernel_code get_transpose_kernel_code proc~compile_and_cache->proc~get_transpose_kernel_code proc~get_unpack_kernel_code get_unpack_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->interface~int_to_str proc~create_cuda->proc~clean_unused_cache proc~create_helper backend_helper%create_helper proc~create_cuda->proc~create_helper proc~get_user_stream get_user_stream proc~create_cuda->proc~get_user_stream proc~create_cuda->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_device_pointer create_device_pointer proc~create_device_pointer->interface~int_to_str proc~create_helper->interface~int_to_str proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_private transpose_plan_host%create_private proc~create_private->interface~int_to_str proc~create_private->proc~autotune_grid_decomposition~2 proc~create_private->proc~autotune_grid~2 proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->interface~int_to_str proc~create_private~2->proc~get_user_stream proc~create~12 abstract_transpose_plan%create proc~create~12->interface~int_to_str proc~create~2 backend_cufftmp%create proc~create~2->interface~int_to_str proc~create~5 abstract_backend%create proc~create~5->interface~int_to_str proc~create~7 cufft_executor%create proc~create~7->interface~int_to_str proc~create~7->proc~get_user_stream proc~destroy_helper->interface~int_to_str proc~destroy_stream destroy_stream proc~destroy_stream->interface~int_to_str proc~destroy~10 nvrtc_kernel%destroy proc~destroy~10->interface~int_to_str proc~destroy~2 backend_cufftmp%destroy proc~destroy~2->interface~int_to_str proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~int_to_str proc~destroy~5 abstract_backend%destroy proc~destroy~5->interface~int_to_str proc~destroy~8 cufft_executor%destroy proc~destroy~8->interface~int_to_str proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->interface~int_to_str proc~execute~9 nvrtc_kernel%execute proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~int_to_str proc~execute_nccl->proc~execute~9 proc~execute~2 backend_cufftmp%execute proc~execute~2->interface~int_to_str proc~execute~4 mkl_executor%execute proc~execute~4->interface~int_to_str proc~execute~5 abstract_backend%execute proc~execute~5->interface~int_to_str proc~execute~5->proc~execute~9 proc~execute~7 cufft_executor%execute proc~execute~7->interface~int_to_str proc~execute~9->interface~int_to_str proc~free_mem free_mem proc~free_mem->interface~int_to_str proc~get_code_init get_code_init proc~get_code_init->interface~int_to_str proc~get_plan_execution_time->interface~int_to_str proc~get_user_stream->interface~int_to_str proc~make_plan make_plan proc~make_plan->interface~int_to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~int_to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~int_to_str proc~report dtfft_plan_t%report proc~report->interface~int_to_str proc~run_autotune_backend->interface~int_to_str proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_stream proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~8->proc~create_device_pointer proc~create~8->proc~destroy~10 proc~destroy~11->proc~destroy~10 proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~clean_unused_cache proc~destroy~9->proc~destroy_stream proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute~10->proc~execute~9 proc~get_transpose_kernel_code->proc~get_code_init proc~get_unpack_kernel_code->proc~get_code_init proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~destroy_cuda->proc~mem_free~5 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/int_to_str_int32.html"},{"title":"int_to_str_int64 – dtFFT","text":"private  function int_to_str_int64(n) result(string) Convert 64-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string Called by proc~~int_to_str_int64~~CalledByGraph proc~int_to_str_int64 int_to_str_int64 interface~int_to_str int_to_str interface~int_to_str->proc~int_to_str_int64 proc~alloc_mem alloc_mem proc~alloc_mem->interface~int_to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~int_to_str proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->interface~int_to_str proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_grid~2->interface~int_to_str proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~clean_unused_cache clean_unused_cache proc~clean_unused_cache->interface~int_to_str proc~compile_and_cache compile_and_cache proc~compile_and_cache->interface~int_to_str proc~get_transpose_kernel_code get_transpose_kernel_code proc~compile_and_cache->proc~get_transpose_kernel_code proc~get_unpack_kernel_code get_unpack_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->interface~int_to_str proc~create_cuda->proc~clean_unused_cache proc~create_helper backend_helper%create_helper proc~create_cuda->proc~create_helper proc~get_user_stream get_user_stream proc~create_cuda->proc~get_user_stream proc~create_cuda->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_device_pointer create_device_pointer proc~create_device_pointer->interface~int_to_str proc~create_helper->interface~int_to_str proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_private transpose_plan_host%create_private proc~create_private->interface~int_to_str proc~create_private->proc~autotune_grid_decomposition~2 proc~create_private->proc~autotune_grid~2 proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->interface~int_to_str proc~create_private~2->proc~get_user_stream proc~create~12 abstract_transpose_plan%create proc~create~12->interface~int_to_str proc~create~2 backend_cufftmp%create proc~create~2->interface~int_to_str proc~create~5 abstract_backend%create proc~create~5->interface~int_to_str proc~create~7 cufft_executor%create proc~create~7->interface~int_to_str proc~create~7->proc~get_user_stream proc~destroy_helper->interface~int_to_str proc~destroy_stream destroy_stream proc~destroy_stream->interface~int_to_str proc~destroy~10 nvrtc_kernel%destroy proc~destroy~10->interface~int_to_str proc~destroy~2 backend_cufftmp%destroy proc~destroy~2->interface~int_to_str proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~int_to_str proc~destroy~5 abstract_backend%destroy proc~destroy~5->interface~int_to_str proc~destroy~8 cufft_executor%destroy proc~destroy~8->interface~int_to_str proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->interface~int_to_str proc~execute~9 nvrtc_kernel%execute proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~int_to_str proc~execute_nccl->proc~execute~9 proc~execute~2 backend_cufftmp%execute proc~execute~2->interface~int_to_str proc~execute~4 mkl_executor%execute proc~execute~4->interface~int_to_str proc~execute~5 abstract_backend%execute proc~execute~5->interface~int_to_str proc~execute~5->proc~execute~9 proc~execute~7 cufft_executor%execute proc~execute~7->interface~int_to_str proc~execute~9->interface~int_to_str proc~free_mem free_mem proc~free_mem->interface~int_to_str proc~get_code_init get_code_init proc~get_code_init->interface~int_to_str proc~get_plan_execution_time->interface~int_to_str proc~get_user_stream->interface~int_to_str proc~make_plan make_plan proc~make_plan->interface~int_to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~int_to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~int_to_str proc~report dtfft_plan_t%report proc~report->interface~int_to_str proc~run_autotune_backend->interface~int_to_str proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_stream proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~8->proc~create_device_pointer proc~create~8->proc~destroy~10 proc~destroy~11->proc~destroy~10 proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~clean_unused_cache proc~destroy~9->proc~destroy_stream proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute~10->proc~execute~9 proc~get_transpose_kernel_code->proc~get_code_init proc~get_unpack_kernel_code->proc~get_code_init proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~destroy_cuda->proc~mem_free~5 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/int_to_str_int64.html"},{"title":"is_null_funptr – dtFFT","text":"private elemental function is_null_funptr(ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_funptr), intent(in) :: ptr Pointer to check Return Value logical Called by proc~~is_null_funptr~~CalledByGraph proc~is_null_funptr is_null_funptr interface~is_null_ptr is_null_ptr interface~is_null_ptr->proc~is_null_funptr interface~is_null_ptr->interface~is_null_ptr proc~dynamic_load dynamic_load proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~load_library->interface~is_null_ptr proc~load_symbol->interface~is_null_ptr proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_null_funptr.html"},{"title":"destroy_strings – dtFFT","text":"public  subroutine destroy_strings(strings) Destroys array of string objects Arguments Type Intent Optional Attributes Name type( string ), intent(inout), allocatable :: strings (:) Array of strings Called by proc~~destroy_strings~~CalledByGraph proc~destroy_strings destroy_strings proc~init_internal init_internal proc~init_internal->proc~destroy_strings proc~load load proc~load->proc~destroy_strings proc~load_cuda load_cuda proc~load_cuda->proc~destroy_strings proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~destroy_strings proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_strings.html"},{"title":"string_f2c – dtFFT","text":"public  subroutine string_f2c(fstring, cstring, string_size) Convert Fortran string to C string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstring Fortran string character(kind=c_char, len=1), intent(inout) :: cstring (*) C string integer(kind=int64), intent(out), optional :: string_size Size of the C string Called by proc~~string_f2c~~CalledByGraph proc~string_f2c string_f2c proc~astring_f2c astring_f2c proc~astring_f2c->proc~string_f2c proc~dtfft_get_backend_string_c dtfft_get_backend_string_c proc~dtfft_get_backend_string_c->proc~string_f2c proc~dtfft_get_error_string_c dtfft_get_error_string_c proc~dtfft_get_error_string_c->proc~string_f2c proc~dtfft_get_executor_string_c dtfft_get_executor_string_c proc~dtfft_get_executor_string_c->proc~string_f2c proc~dtfft_get_precision_string_c dtfft_get_precision_string_c proc~dtfft_get_precision_string_c->proc~string_f2c proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~astring_f2c proc~push_nvtx_domain_range push_nvtx_domain_range proc~compile_and_cache->proc~push_nvtx_domain_range proc~to_cstr kernel_code%to_cstr proc~compile_and_cache->proc~to_cstr proc~create_nvtx_domain create_nvtx_domain proc~create_nvtx_domain->proc~astring_f2c proc~load_library load_library proc~load_library->proc~astring_f2c proc~load_symbol load_symbol proc~load_symbol->proc~astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~to_cstr->proc~astring_f2c proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~push_nvtx_domain_range proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~create abstract_executor%create proc~create->proc~push_nvtx_domain_range proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~push_nvtx_domain_range proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~push_nvtx_domain_range proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~execute abstract_executor%execute proc~execute->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~execute~12 abstract_transpose_plan%execute proc~execute~12->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_ptr->proc~execute~12 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~autotune_grid_decomposition proc~load_cuda load_cuda proc~create_cuda->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create_cuda->proc~load_nvrtc proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute_private~2->proc~execute~12 proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~load load proc~load->proc~dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~dynamic_load proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/string_f2c.html"},{"title":"string_c2f – dtFFT","text":"public  subroutine string_c2f(cstring, string) Convert C string to Fortran string Arguments Type Intent Optional Attributes Name type(c_ptr) :: cstring C string character(len=:), allocatable :: string Fortran string Called by proc~~string_c2f~~CalledByGraph proc~string_c2f string_c2f proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~string_c2f proc~cudageterrorstring cudaGetErrorString proc~compile_and_cache->proc~cudageterrorstring proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_and_cache->proc~nvrtcgeterrorstring proc~cudageterrorstring->proc~string_c2f proc~dftierrormessage DftiErrorMessage proc~dftierrormessage->proc~string_c2f proc~dl_error dl_error proc~dl_error->proc~string_c2f proc~ncclgeterrorstring ncclGetErrorString proc~ncclgeterrorstring->proc~string_c2f proc~nvrtcgeterrorstring->proc~string_c2f proc~alloc_mem alloc_mem proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~ncclgeterrorstring proc~clean_unused_cache clean_unused_cache proc~clean_unused_cache->proc~cudageterrorstring proc~create_device_pointer create_device_pointer proc~create_device_pointer->proc~cudageterrorstring proc~create_helper backend_helper%create_helper proc~create_helper->proc~ncclgeterrorstring proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~cudageterrorstring proc~get_user_stream get_user_stream proc~create_private~2->proc~get_user_stream proc~create~5 abstract_backend%create proc~create~5->proc~cudageterrorstring proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~8->proc~create_device_pointer proc~destroy~10 nvrtc_kernel%destroy proc~create~8->proc~destroy~10 proc~destroy_helper->proc~ncclgeterrorstring proc~destroy_stream destroy_stream proc~destroy_stream->proc~cudageterrorstring proc~destroy~10->proc~cudageterrorstring proc~destroy~4 mkl_executor%destroy proc~destroy~4->proc~dftierrormessage proc~destroy~5 abstract_backend%destroy proc~destroy~5->proc~cudageterrorstring proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~cudageterrorstring proc~execute~9 nvrtc_kernel%execute proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~ncclgeterrorstring proc~execute_nccl->proc~execute~9 proc~execute~2 backend_cufftmp%execute proc~execute~2->proc~cudageterrorstring proc~execute~4 mkl_executor%execute proc~execute~4->proc~dftierrormessage proc~execute~5 abstract_backend%execute proc~execute~5->proc~cudageterrorstring proc~execute~5->proc~execute~9 proc~execute~9->proc~cudageterrorstring proc~free_mem free_mem proc~free_mem->proc~ncclgeterrorstring proc~get_user_stream->proc~cudageterrorstring proc~load_library load_library proc~load_library->proc~dl_error proc~load_symbol load_symbol proc~load_symbol->proc~dl_error proc~make_plan make_plan proc~make_plan->proc~dftierrormessage proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->proc~dftierrormessage proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->proc~dftierrormessage proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~cudageterrorstring proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~free_mem proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~unload_library unload_library proc~unload_library->proc~dl_error proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~clean_unused_cache proc~create_cuda->proc~create_helper proc~create_cuda->proc~get_user_stream proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~load_cuda load_cuda proc~create_cuda->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create_cuda->proc~load_nvrtc proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_stream proc~load_vkfft load_vkfft proc~create~6->proc~load_vkfft proc~create~7 cufft_executor%create proc~create~7->proc~get_user_stream proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy~11->proc~destroy~10 proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~clean_unused_cache proc~destroy~9->proc~destroy_stream proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~dynamic_load->proc~unload_library proc~execute~10->proc~execute~9 proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~destroy_cuda->proc~mem_free~5 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~load load proc~load->proc~dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~dynamic_load proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~load_vkfft->proc~load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/string_c2f.html"},{"title":"astring_f2c – dtFFT","text":"public  subroutine astring_f2c(fstring, cstring, string_size) Convert Fortran string to C allocatable string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstring Fortran string character(kind=c_char, len=1), intent(out), allocatable :: cstring (:) C string integer(kind=int64), intent(out), optional :: string_size Size of the C string Calls proc~~astring_f2c~~CallsGraph proc~astring_f2c astring_f2c proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~astring_f2c~~CalledByGraph proc~astring_f2c astring_f2c proc~compile_and_cache compile_and_cache proc~compile_and_cache->proc~astring_f2c proc~push_nvtx_domain_range push_nvtx_domain_range proc~compile_and_cache->proc~push_nvtx_domain_range proc~to_cstr kernel_code%to_cstr proc~compile_and_cache->proc~to_cstr proc~create_nvtx_domain create_nvtx_domain proc~create_nvtx_domain->proc~astring_f2c proc~load_library load_library proc~load_library->proc~astring_f2c proc~load_symbol load_symbol proc~load_symbol->proc~astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~to_cstr->proc~astring_f2c proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~push_nvtx_domain_range proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~create abstract_executor%create proc~create->proc~push_nvtx_domain_range proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~push_nvtx_domain_range proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~push_nvtx_domain_range proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~execute abstract_executor%execute proc~execute->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~execute~12 abstract_transpose_plan%execute proc~execute~12->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_ptr->proc~execute~12 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~create_cuda->proc~autotune_grid_decomposition proc~load_cuda load_cuda proc~create_cuda->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create_cuda->proc~load_nvrtc proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute_private~2->proc~execute~12 proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~load load proc~load->proc~dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~dynamic_load proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/astring_f2c.html"},{"title":"unload_library – dtFFT","text":"public  subroutine unload_library(handle) Unloads library Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: handle Loaded handle Calls proc~~unload_library~~CallsGraph proc~unload_library unload_library interface~dlclose dlclose proc~unload_library->interface~dlclose proc~dl_error dl_error proc~unload_library->proc~dl_error interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unload_library~~CalledByGraph proc~unload_library unload_library proc~dynamic_load dynamic_load proc~dynamic_load->proc~unload_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unload_library.html"},{"title":"write_message – dtFFT","text":"public  subroutine write_message(unit, message, prefix) Write message to the specified unit Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: unit Unit number character(len=*), intent(in) :: message Message to write character(len=*), intent(in), optional :: prefix Prefix to the message Calls proc~~write_message~~CallsGraph proc~write_message write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_message~~CalledByGraph proc~write_message write_message proc~alloc_mem alloc_mem proc~alloc_mem->proc~write_message proc~autotune_grid autotune_grid proc~autotune_grid->proc~write_message proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~write_message proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_grid~2->proc~write_message proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~write_message proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c->proc~create_c2c_core proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~write_message proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_pencil->proc~create_c2c_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~write_message proc~create_cuda->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_helper backend_helper%create_helper proc~create_cuda->proc~create_helper proc~load_cuda load_cuda proc~create_cuda->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create_cuda->proc~load_nvrtc proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~write_message proc~create_private transpose_plan_host%create_private proc~create_private->proc~write_message proc~create_private->proc~autotune_grid_decomposition~2 proc~create_private->proc~autotune_grid~2 proc~get_datatype_from_env get_datatype_from_env proc~create_private->proc~get_datatype_from_env proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~write_message proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~write_message proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~write_message proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~write_message proc~create_r2r_pencil->proc~create_r2r_internal proc~create~12 abstract_transpose_plan%create proc~create~12->proc~write_message proc~destroy_helper backend_helper%destroy_helper proc~destroy_helper->proc~write_message proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~write_message proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~9->proc~mem_free_ptr proc~dl_error dl_error proc~dl_error->proc~write_message proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~write_message proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~write_message proc~get_element_size dtfft_plan_t%get_element_size proc~get_alloc_bytes->proc~get_element_size proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_bytes->proc~get_alloc_size proc~get_dims dtfft_plan_t%get_dims proc~get_dims->proc~write_message proc~get_element_size->proc~write_message proc~get_env_int32 get_env_int32 proc~get_env_int32->proc~write_message interface~get_env get_env proc~get_env_int32->interface~get_env proc~get_env_string get_env_string proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_executor dtfft_plan_t%get_executor proc~get_executor->proc~write_message proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_local_sizes->proc~write_message proc~get_pencil dtfft_plan_t%get_pencil proc~get_pencil->proc~write_message proc~get_plan_execution_time->proc~write_message proc~get_iters_from_env get_iters_from_env proc~get_plan_execution_time->proc~get_iters_from_env proc~get_precision dtfft_plan_t%get_precision proc~get_precision->proc~write_message proc~get_stream_ptr dtfft_plan_t%get_stream_ptr proc~get_stream_ptr->proc~write_message proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_ptr->proc~write_message proc~mem_free_ptr->proc~write_message proc~report dtfft_plan_t%report proc~report->proc~write_message proc~run_autotune_backend->proc~write_message proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~get_iters_from_env proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~write_message interface~get_env->proc~get_env_int32 interface~get_env->proc~get_env_string proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical none~get_stream dtfft_plan_t%get_stream none~get_stream->proc~get_stream_ptr proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream->proc~get_stream_int64 proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~check_aux->proc~get_element_size proc~check_aux->proc~mem_alloc_ptr proc~check_aux->proc~get_alloc_size proc~create_helper->proc~destroy_helper proc~create_helper->interface~get_env proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~dtfft_get_dims_c dtfft_get_dims_c proc~dtfft_get_dims_c->proc~get_dims proc~dtfft_get_element_size_c dtfft_get_element_size_c proc~dtfft_get_element_size_c->proc~get_element_size proc~dtfft_get_executor_c dtfft_get_executor_c proc~dtfft_get_executor_c->proc~get_executor proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes proc~dtfft_get_pencil_c dtfft_get_pencil_c proc~dtfft_get_pencil_c->proc~get_pencil proc~dtfft_get_precision_c dtfft_get_precision_c proc~dtfft_get_precision_c->proc~get_precision proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~dtfft_mem_free_c dtfft_mem_free_c proc~dtfft_mem_free_c->proc~mem_free_ptr proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~get_alloc_size->proc~get_local_sizes proc~load_library load_library proc~load_library->proc~dl_error proc~load_symbol load_symbol proc~load_symbol->proc~dl_error proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_c32_1d->proc~mem_free_ptr proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_c32_2d->proc~mem_free_ptr proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_c32_3d->proc~mem_free_ptr proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_c64_1d->proc~mem_free_ptr proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_c64_2d->proc~mem_free_ptr proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_c64_3d->proc~mem_free_ptr proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_r32_1d->proc~mem_free_ptr proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_r32_2d->proc~mem_free_ptr proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_r32_3d->proc~mem_free_ptr proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_r64_1d->proc~mem_free_ptr proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_r64_2d->proc~mem_free_ptr proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_r64_3d->proc~mem_free_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~unload_library unload_library proc~unload_library->proc~dl_error proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~dynamic_load->proc~unload_library proc~get_datatype_from_env->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_iters_from_env->interface~get_env proc~get_stream_int64->none~get_stream proc~init_internal init_internal proc~init_internal->interface~get_env proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~load load proc~load->proc~dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~dynamic_load proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal->proc~create_private~2 proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal->proc~create_c2c_core Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/write_message.html"},{"title":"dl_error – dtFFT","text":"private  subroutine dl_error(message) Writes error message to the error unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to write Calls proc~~dl_error~~CallsGraph proc~dl_error dl_error interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dl_error~~CalledByGraph proc~dl_error dl_error proc~load_library load_library proc~load_library->proc~dl_error proc~load_symbol load_symbol proc~load_symbol->proc~dl_error proc~unload_library unload_library proc~unload_library->proc~dl_error proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~dynamic_load->proc~unload_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dl_error.html"},{"title":"int_to_str – dtFFT","text":"public interface int_to_str Converts integer to string Calls interface~~int_to_str~~CallsGraph interface~int_to_str int_to_str proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~int_to_str~~CalledByGraph interface~int_to_str int_to_str proc~alloc_mem alloc_mem proc~alloc_mem->interface~int_to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~int_to_str proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->interface~int_to_str proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_grid~2->interface~int_to_str proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~clean_unused_cache clean_unused_cache proc~clean_unused_cache->interface~int_to_str proc~compile_and_cache compile_and_cache proc~compile_and_cache->interface~int_to_str proc~get_transpose_kernel_code get_transpose_kernel_code proc~compile_and_cache->proc~get_transpose_kernel_code proc~get_unpack_kernel_code get_unpack_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->interface~int_to_str proc~create_cuda->proc~clean_unused_cache proc~create_helper backend_helper%create_helper proc~create_cuda->proc~create_helper proc~get_user_stream get_user_stream proc~create_cuda->proc~get_user_stream proc~create_cuda->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create_cuda->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_device_pointer create_device_pointer proc~create_device_pointer->interface~int_to_str proc~create_helper->interface~int_to_str proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_private transpose_plan_host%create_private proc~create_private->interface~int_to_str proc~create_private->proc~autotune_grid_decomposition~2 proc~create_private->proc~autotune_grid~2 proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->interface~int_to_str proc~create_private~2->proc~get_user_stream proc~create~12 abstract_transpose_plan%create proc~create~12->interface~int_to_str proc~create~2 backend_cufftmp%create proc~create~2->interface~int_to_str proc~create~5 abstract_backend%create proc~create~5->interface~int_to_str proc~create~7 cufft_executor%create proc~create~7->interface~int_to_str proc~create~7->proc~get_user_stream proc~destroy_helper->interface~int_to_str proc~destroy_stream destroy_stream proc~destroy_stream->interface~int_to_str proc~destroy~10 nvrtc_kernel%destroy proc~destroy~10->interface~int_to_str proc~destroy~2 backend_cufftmp%destroy proc~destroy~2->interface~int_to_str proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~int_to_str proc~destroy~5 abstract_backend%destroy proc~destroy~5->interface~int_to_str proc~destroy~8 cufft_executor%destroy proc~destroy~8->interface~int_to_str proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->interface~int_to_str proc~execute~9 nvrtc_kernel%execute proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~int_to_str proc~execute_nccl->proc~execute~9 proc~execute~2 backend_cufftmp%execute proc~execute~2->interface~int_to_str proc~execute~4 mkl_executor%execute proc~execute~4->interface~int_to_str proc~execute~5 abstract_backend%execute proc~execute~5->interface~int_to_str proc~execute~5->proc~execute~9 proc~execute~7 cufft_executor%execute proc~execute~7->interface~int_to_str proc~execute~9->interface~int_to_str proc~free_mem free_mem proc~free_mem->interface~int_to_str proc~get_code_init get_code_init proc~get_code_init->interface~int_to_str proc~get_plan_execution_time->interface~int_to_str proc~get_user_stream->interface~int_to_str proc~make_plan make_plan proc~make_plan->interface~int_to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~int_to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~int_to_str proc~report dtfft_plan_t%report proc~report->interface~int_to_str proc~run_autotune_backend->interface~int_to_str proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~destroy~11 transpose_handle_cuda%destroy proc~run_autotune_backend->proc~destroy~11 proc~execute~10 transpose_handle_cuda%execute proc~run_autotune_backend->proc~execute~10 proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_stream proc~create~8 nvrtc_kernel%create proc~create~8->proc~compile_and_cache proc~create~8->proc~create_device_pointer proc~create~8->proc~destroy~10 proc~destroy~11->proc~destroy~10 proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~clean_unused_cache proc~destroy~9->proc~destroy_stream proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute~10->proc~execute~9 proc~get_transpose_kernel_code->proc~get_code_init proc~get_unpack_kernel_code->proc~get_code_init proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~9 transpose_handle_cuda%create proc~create~9->proc~create~8 proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~destroy_cuda->proc~mem_free~5 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function int_to_str_int8 (n) result(string) Convert 8-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int_to_str_int32 (n) result(string) Convert 32-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int_to_str_int64 (n) result(string) Convert 64-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string","tags":"","loc":"interface/int_to_str.html"},{"title":"get_env – dtFFT","text":"public interface get_env Obtains environment variable Calls interface~~get_env~~CallsGraph interface~get_env get_env proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_env_int32->interface~get_env proc~get_log_enabled get_log_enabled proc~get_env_int32->proc~get_log_enabled proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~get_log_enabled proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~get_env~~CalledByGraph interface~get_env get_env proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_iters_from_env get_iters_from_env proc~get_iters_from_env->interface~get_env proc~init_internal init_internal proc~init_internal->interface~get_env proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~get_datatype_from_env proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~get_iters_from_env proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~get_iters_from_env proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function get_env_base (name) result(env) Base function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value character(len=:), allocatable Environment variable value private  function get_env_string (name, default, valid_values) result(env) Obtains string environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix character(len=*), intent(in) :: default Name of environment variable without prefix type( string ), intent(in) :: valid_values (:) List of valid variable values Return Value character(len=:), allocatable Environment variable value private  function get_env_int32 (name, default, valid_values, min_valid_value) result(env) Base Integer function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int32), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in), optional :: valid_values (:) List of valid values integer(kind=int32), intent(in), optional :: min_valid_value Mininum valid value. Usually 0 or 1 Return Value integer(kind=int32) private  function get_env_int8 (name, default, valid_values) result(env) Obtains int8 environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int8), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in) :: valid_values (:) List of valid values Return Value integer(kind=int8) private  function get_env_logical (name, default) result(env) Obtains logical environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix logical, intent(in) :: default Default value in case env is not set or it has wrong value Return Value logical","tags":"","loc":"interface/get_env.html"},{"title":"string – dtFFT","text":"public interface string Creates string object Calls interface~~string~~CallsGraph interface~string string proc~string_constructor string_constructor interface~string->proc~string_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function string_constructor (str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string )","tags":"","loc":"interface/string.html"},{"title":"mem_alloc_host – dtFFT","text":"interface Allocates memory using C11 Standard alloc_align with 16 bytes alignment Called by interface~~mem_alloc_host~~CalledByGraph interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_ptr->interface~mem_alloc_host proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~mem_alloc_ptr proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine mem_alloc_host(alloc_size, ptr) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: alloc_size Number of bytes to allocate type(c_ptr) :: ptr Pointer to allocate","tags":"","loc":"interface/mem_alloc_host.html"},{"title":"mem_free_host – dtFFT","text":"interface Frees memory allocated with mem_alloc_host Called by interface~~mem_free_host~~CalledByGraph interface~mem_free_host mem_free_host proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_ptr->interface~mem_free_host proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~mem_free_ptr proc~dtfft_mem_free_c dtfft_mem_free_c proc~dtfft_mem_free_c->proc~mem_free_ptr proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_c32_1d->proc~mem_free_ptr proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_c32_2d->proc~mem_free_ptr proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_c32_3d->proc~mem_free_ptr proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_c64_1d->proc~mem_free_ptr proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_c64_2d->proc~mem_free_ptr proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_c64_3d->proc~mem_free_ptr proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_r32_1d->proc~mem_free_ptr proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_r32_2d->proc~mem_free_ptr proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_r32_3d->proc~mem_free_ptr proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_r64_1d->proc~mem_free_ptr proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_r64_2d->proc~mem_free_ptr proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_r64_3d->proc~mem_free_ptr proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine mem_free_host(ptr) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to free","tags":"","loc":"interface/mem_free_host.html"},{"title":"Comm_f2c – dtFFT","text":"interface Converts Fortran communicator to C Called by interface~~comm_f2c~~CalledByGraph interface~comm_f2c Comm_f2c proc~create~2 backend_cufftmp%create proc~create~2->interface~comm_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function Comm_f2c(fcomm) bind(C, name=\"Comm_f2c\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: fcomm Fortran communicator Return Value type(c_ptr)","tags":"","loc":"interface/comm_f2c.html"},{"title":"is_device_ptr – dtFFT","text":"interface Checks if pointer can be accessed from device Called by interface~~is_device_ptr~~CalledByGraph interface~is_device_ptr is_device_ptr proc~check_device_pointers check_device_pointers proc~check_device_pointers->interface~is_device_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_device_pointers proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~check_device_pointers proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function is_device_ptr(ptr) result(bool) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Device pointer Return Value logical(kind=c_bool) Result","tags":"","loc":"interface/is_device_ptr.html"},{"title":"is_null_ptr – dtFFT","text":"private interface is_null_ptr Checks if pointer is NULL Calls interface~~is_null_ptr~~CallsGraph interface~is_null_ptr is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~is_null_ptr~~CalledByGraph interface~is_null_ptr is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~dynamic_load dynamic_load proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~load_library->interface~is_null_ptr proc~load_symbol->interface~is_null_ptr proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  interface is_null_ptr () Checks if pointer is NULL Arguments None private elemental function is_null_funptr (ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_funptr), intent(in) :: ptr Pointer to check Return Value logical","tags":"","loc":"interface/is_null_ptr.html"},{"title":"dlopen – dtFFT","text":"interface Load and link a dynamic library or bundle Called by interface~~dlopen~~CalledByGraph interface~dlopen dlopen proc~load_library load_library proc~load_library->interface~dlopen proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function dlopen(filename, mode) bind(C) Arguments Type Intent Optional Attributes Name character(len=c_char) :: filename (*) Name of the library integer(kind=c_int), value :: mode Options to dlopen Return Value type(c_ptr) Handle to the library","tags":"","loc":"interface/dlopen.html"},{"title":"dlsym – dtFFT","text":"interface Get address of a symbol Called by interface~~dlsym~~CalledByGraph interface~dlsym dlsym proc~load_symbol load_symbol proc~load_symbol->interface~dlsym proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_symbol proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function dlsym(handle, name) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Handle to the library character(len=c_char) :: name (*) Name of the symbol Return Value type(c_funptr) Address of the symbol","tags":"","loc":"interface/dlsym.html"},{"title":"dlclose – dtFFT","text":"interface Close a dynamic library or bundle Called by interface~~dlclose~~CalledByGraph interface~dlclose dlclose proc~unload_library unload_library proc~unload_library->interface~dlclose proc~dynamic_load dynamic_load proc~dynamic_load->proc~unload_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function dlclose(handle) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Handle to the library Return Value integer(kind=c_int) Result of the operation","tags":"","loc":"interface/dlclose.html"},{"title":"dlerror – dtFFT","text":"interface Get diagnostic information Called by interface~~dlerror~~CalledByGraph interface~dlerror dlerror proc~dl_error dl_error proc~dl_error->interface~dlerror proc~load_library load_library proc~load_library->proc~dl_error proc~load_symbol load_symbol proc~load_symbol->proc~dl_error proc~unload_library unload_library proc~unload_library->proc~dl_error proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~dynamic_load->proc~unload_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda proc~create_cuda->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~6 vkfft_executor%create proc~create~6->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function dlerror() bind(C) Arguments None Return Value type(c_ptr) Error message","tags":"","loc":"interface/dlerror.html"},{"title":"load_cuda – dtFFT","text":"public  function load_cuda() result(error_code) Loads the CUDA Driver library and needed symbols Arguments None Return Value integer(kind=int32) Error code Calls proc~~load_cuda~~CallsGraph proc~load_cuda load_cuda proc~destroy_strings destroy_strings proc~load_cuda->proc~destroy_strings proc~dynamic_load dynamic_load proc~load_cuda->proc~dynamic_load interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_log_enabled get_log_enabled proc~dl_error->proc~get_log_enabled proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_cuda~~CalledByGraph proc~load_cuda load_cuda proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~load_cuda Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_cuda.html"},{"title":"cuLaunchKernel – dtFFT","text":"public  function cuLaunchKernel(func, in, out, blocks, threads, stream, args) result(cuResult) Launches a CUDA function CUfunction or a CUDA kernel CUkernel. Arguments Type Intent Optional Attributes Name type( CUfunction ) :: func Function CUfunction or Kernel CUkernel to launch type(c_ptr) :: in Input pointer type(c_ptr) :: out Output pointer type( dim3 ) :: blocks Grid in blocks type( dim3 ) :: threads Thread block type( dtfft_stream_t ) :: stream Stream identifier type( kernelArgs ) :: args Kernel parameters Return Value integer(kind=c_int) Driver result code Calls proc~~culaunchkernel~~CallsGraph proc~culaunchkernel cuLaunchKernel interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~culaunchkernel~~CalledByGraph proc~culaunchkernel cuLaunchKernel proc~execute~9 nvrtc_kernel%execute proc~execute~9->proc~culaunchkernel proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~9 proc~execute~10 transpose_handle_cuda%execute proc~execute~10->proc~execute~9 proc~execute~5 abstract_backend%execute proc~execute~5->proc~execute~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~execute~10 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/culaunchkernel.html"},{"title":"run_cuda_kernel – dtFFT","text":"interface Launches a CUDA function CUfunction or a CUDA kernel CUkernel. Called by interface~~run_cuda_kernel~~CalledByGraph interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel cuLaunchKernel proc~culaunchkernel->interface~run_cuda_kernel proc~execute~9 nvrtc_kernel%execute proc~execute~9->proc~culaunchkernel proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~9 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~9 proc~execute~10 transpose_handle_cuda%execute proc~execute~10->proc~execute~9 proc~execute~5 abstract_backend%execute proc~execute~5->proc~execute~9 proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~execute~10 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function run_cuda_kernel(func, in, out, blocks, threads, stream, args, funptr) result(cuResult) bind(C, name=\"run_cuda_kernel\") Arguments Type Intent Optional Attributes Name type( CUfunction ), value :: func Function CUfunction or Kernel CUkernel to launch type(c_ptr), value :: in Input pointer type(c_ptr), value :: out Output pointer type( dim3 ) :: blocks Grid in blocks type( dim3 ) :: threads Thread block type( dtfft_stream_t ), value :: stream Stream identifier type( kernelArgs ) :: args Kernel parameters type(c_funptr), value :: funptr Pointer to cuLaunchKernel Return Value integer(kind=c_int) Driver result code Description Wrapper around cuLaunchKernel , since I have to idea how to pass array of pointers to cuLaunchKernel . Launches a CUDA function CUfunction or a CUDA kernel CUkernel.","tags":"","loc":"interface/run_cuda_kernel.html"},{"title":"ncclGetErrorString – dtFFT","text":"public  function ncclGetErrorString(ncclResult_t) result(string) Generates an error message. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ncclResult_t Completion status of a function. Return Value character(len=:), allocatable Error message Calls proc~~ncclgeterrorstring~~CallsGraph proc~ncclgeterrorstring ncclGetErrorString interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ncclgeterrorstring~~CalledByGraph proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem alloc_mem proc~alloc_mem->proc~ncclgeterrorstring proc~create_helper backend_helper%create_helper proc~create_helper->proc~ncclgeterrorstring proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~destroy_helper->proc~ncclgeterrorstring proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~ncclgeterrorstring proc~free_mem free_mem proc~free_mem->proc~ncclgeterrorstring proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~create_cuda->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ncclgeterrorstring.html"},{"title":"ncclGetUniqueId – dtFFT","text":"interface Generates an Id to be used in ncclCommInitRank. \nncclGetUniqueId should be called once when creating a communicator and the Id should be \ndistributed to all ranks in the communicator before calling ncclCommInitRank. \nuniqueId should point to a ncclUniqueId object allocated by the user. Called by interface~~ncclgetuniqueid~~CalledByGraph interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper backend_helper%create_helper proc~create_helper->interface~ncclgetuniqueid proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclGetUniqueId(uniqueId) result(ncclResult_t) bind(C, name=\"ncclGetUniqueId\") Arguments Type Intent Optional Attributes Name type( ncclUniqueId ), intent(out) :: uniqueId Unique ID Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclgetuniqueid.html"},{"title":"ncclMemAlloc – dtFFT","text":"interface Allocate a GPU buffer with size.\nAllocated buffer head address will be returned by ptr, and the actual allocated size can be larger \nthan requested because of the buffer granularity requirements from all types of NCCL optimizations. Called by interface~~ncclmemalloc~~CalledByGraph interface~ncclmemalloc ncclMemAlloc proc~alloc_mem alloc_mem proc~alloc_mem->interface~ncclmemalloc proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclMemAlloc(ptr, alloc_bytes) result(ncclResult_t) bind(C, name=\"ncclMemAlloc\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: ptr Buffer address integer(kind=c_size_t), intent(in), value :: alloc_bytes Number of bytes to allocate Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclmemalloc.html"},{"title":"ncclMemFree – dtFFT","text":"interface Free memory allocated by ncclMemAlloc(). Called by interface~~ncclmemfree~~CalledByGraph interface~ncclmemfree ncclMemFree proc~free_mem free_mem proc~free_mem->interface~ncclmemfree proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclMemFree(ptr) result(ncclResult_t) bind(C, name=\"ncclMemFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: ptr Buffer address Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclmemfree.html"},{"title":"ncclCommInitRank – dtFFT","text":"interface Creates a new communicator (multi thread/process version). rank must be between 0 and nranks-1 and unique within a communicator clique.\nEach rank is associated to a CUDA device, which has to be set before calling ncclCommInitRank. ncclCommInitRank implicitly synchronizes with other ranks, hence it must be called by different\nthreads/processes or used within ncclGroupStart/ncclGroupEnd. Called by interface~~ncclcomminitrank~~CalledByGraph interface~ncclcomminitrank ncclCommInitRank proc~create_helper backend_helper%create_helper proc~create_helper->interface~ncclcomminitrank proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclCommInitRank(comm, nranks, uniqueId, rank) result(ncclResult_t) bind(C, name=\"ncclCommInitRank\") Arguments Type Intent Optional Attributes Name type( ncclComm ) :: comm Communicator integer(kind=c_int), value :: nranks Number of ranks in communicator type( ncclUniqueId ), value :: uniqueId Unique ID integer(kind=c_int), value :: rank Calling rank Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclcomminitrank.html"},{"title":"ncclSend – dtFFT","text":"interface Send data from sendbuff to rank peer. Rank peer needs to call ncclRecv with the same datatype and the same count as this rank. This operation is blocking for the GPU.\nIf multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, \nthey must be fused within a ncclGroupStart()/ ncclGroupEnd() section. Called by interface~~ncclsend~~CalledByGraph interface~ncclsend ncclSend proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~ncclsend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclSend(sendbuff, count, datatype, peer, comm, stream) result(ncclResult_t) bind(c, name='ncclSend') Arguments Type Intent Optional Attributes Name real(kind=c_float) :: sendbuff Buffer to send data from integer(kind=c_size_t), value :: count Number of elements to send type( ncclDataType ), value :: datatype Datatype to send integer(kind=c_int), value :: peer Target GPU type( ncclComm ), value :: comm Communicator type( dtfft_stream_t ), value :: stream CUDA Stream Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclsend.html"},{"title":"ncclRecv – dtFFT","text":"interface Receive data from rank peer into recvbuff. Rank peer needs to call ncclSend with the same datatype and the same count as this rank. This operation is blocking for the GPU.\nIf multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, \nthey must be fused within a ncclGroupStart()/ ncclGroupEnd() section. Called by interface~~ncclrecv~~CalledByGraph interface~ncclrecv ncclRecv proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~ncclrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclRecv(recvbuff, count, datatype, peer, comm, stream) result(ncclResult_t) bind(c, name='ncclRecv') Arguments Type Intent Optional Attributes Name real(kind=c_float) :: recvbuff Buffer to recv data into integer(kind=c_size_t), value :: count Number of elements to recv type( ncclDataType ), value :: datatype Datatype to recv integer(kind=c_int), value :: peer Source GPU type( ncclComm ), value :: comm Communicator type( dtfft_stream_t ), value :: stream CUDA Stream Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclrecv.html"},{"title":"ncclGroupStart – dtFFT","text":"interface Start a group call. All subsequent calls to NCCL until ncclGroupEnd will not block due to inter-CPU synchronization. Called by interface~~ncclgroupstart~~CalledByGraph interface~ncclgroupstart ncclGroupStart proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~ncclgroupstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclGroupStart() result(ncclResult_t) bind(C, name=\"ncclGroupStart\") Arguments None Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclgroupstart.html"},{"title":"ncclGroupEnd – dtFFT","text":"interface End a group call. Returns when all operations since ncclGroupStart have been processed.\nThis means the communication primitives have been enqueued to the provided streams, \nbut are not necessarily complete. Called by interface~~ncclgroupend~~CalledByGraph interface~ncclgroupend ncclGroupEnd proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~ncclgroupend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclGroupEnd() result(ncclResult_t) bind(C, name=\"ncclGroupEnd\") Arguments None Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclgroupend.html"},{"title":"ncclCommDestroy – dtFFT","text":"interface Destroy a communicator object comm. Called by interface~~ncclcommdestroy~~CalledByGraph interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper backend_helper%destroy_helper proc~destroy_helper->interface~ncclcommdestroy proc~create_helper backend_helper%create_helper proc~create_helper->proc~destroy_helper proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclCommDestroy(comm) result(ncclResult_t) bind(C, name=\"ncclCommDestroy\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclcommdestroy.html"},{"title":"ncclCommRegister – dtFFT","text":"interface Register a buffer for collective communication. Called by interface~~ncclcommregister~~CalledByGraph interface~ncclcommregister ncclCommRegister proc~alloc_mem alloc_mem proc~alloc_mem->interface~ncclcommregister proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclCommRegister(comm, buff, size, handle) result(ncclResult_t) bind(C, name=\"ncclCommRegister\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator type(c_ptr), value :: buff Buffer to register integer(kind=c_size_t), value :: size Size of the buffer in bytes type(c_ptr) :: handle Handle to the registered buffer Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclcommregister.html"},{"title":"ncclCommDeregister – dtFFT","text":"interface Deregister a buffer for collective communication. Called by interface~~ncclcommderegister~~CalledByGraph interface~ncclcommderegister ncclCommDeregister proc~free_mem free_mem proc~free_mem->interface~ncclcommderegister proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclCommDeregister(comm, handle) result(ncclResult_t) bind(C, name=\"ncclCommDeregister\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator type(c_ptr), value :: handle Handle to the registered buffer Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclcommderegister.html"},{"title":"ncclGetErrorString_c – dtFFT","text":"interface Returns a human-readable string corresponding to the passed error code. Called by interface~~ncclgeterrorstring_c~~CalledByGraph interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring ncclGetErrorString proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~alloc_mem alloc_mem proc~alloc_mem->proc~ncclgeterrorstring proc~create_helper backend_helper%create_helper proc~create_helper->proc~ncclgeterrorstring proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~destroy_helper->proc~ncclgeterrorstring proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~ncclgeterrorstring proc~free_mem free_mem proc~free_mem->proc~ncclgeterrorstring proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_helper proc~create_cuda->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function ncclGetErrorString_c(ncclResult_t) result(message) bind(C, name=\"ncclGetErrorString\") Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in), value :: ncclResult_t Completion status of a NCCL function. Return Value type(c_ptr) Pointer to message","tags":"","loc":"interface/ncclgeterrorstring_c.html"},{"title":"create_nccl – dtFFT","text":"private  subroutine create_nccl(self, helper, tranpose_type, base_storage) Creates NCCL backend Type Bound backend_nccl Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create (unused) integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) Calls proc~~create_nccl~~CallsGraph proc~create_nccl backend_nccl%create_nccl proc~is_backend_nccl is_backend_nccl proc~create_nccl->proc~is_backend_nccl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_nccl.html"},{"title":"execute_nccl – dtFFT","text":"private  subroutine execute_nccl(self, in, out, stream, aux) Uses iso_c_binding iso_fortran_env proc~~execute_nccl~~UsesGraph proc~execute_nccl backend_nccl%execute_nccl iso_c_binding iso_c_binding proc~execute_nccl->iso_c_binding iso_fortran_env iso_fortran_env proc~execute_nccl->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes NCCL backend Type Bound backend_nccl Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Auxiliary pointer Calls proc~~execute_nccl~~CallsGraph proc~execute_nccl backend_nccl%execute_nccl interface~int_to_str int_to_str proc~execute_nccl->interface~int_to_str interface~ncclgroupend ncclGroupEnd proc~execute_nccl->interface~ncclgroupend interface~ncclgroupstart ncclGroupStart proc~execute_nccl->interface~ncclgroupstart interface~ncclrecv ncclRecv proc~execute_nccl->interface~ncclrecv interface~ncclsend ncclSend proc~execute_nccl->interface~ncclsend mpi_abort mpi_abort proc~execute_nccl->mpi_abort proc~execute~9 nvrtc_kernel%execute proc~execute_nccl->proc~execute~9 proc~ncclgeterrorstring ncclGetErrorString proc~execute_nccl->proc~ncclgeterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~execute~9->interface~int_to_str proc~execute~9->mpi_abort interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync mpi_comm_rank mpi_comm_rank proc~execute~9->mpi_comm_rank proc~cudageterrorstring cudaGetErrorString proc~execute~9->proc~cudageterrorstring proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f proc~cudageterrorstring->proc~string_c2f interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_nccl.html"},{"title":"destroy_nccl – dtFFT","text":"private  subroutine destroy_nccl(self) Destroys NCCL backend Type Bound backend_nccl Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend","tags":"","loc":"proc/destroy_nccl.html"},{"title":"get_aux_size – dtFFT","text":"private  function get_aux_size(self) Returns number of bytes required by aux buffer Type Bound transpose_handle_cuda Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(in) :: self CUDA Transpose Handle Return Value integer(kind=int64) Calls proc~~get_aux_size~3~~CallsGraph proc~get_aux_size~3 transpose_handle_cuda%get_aux_size proc~get_aux_size~2 abstract_backend%get_aux_size proc~get_aux_size~3->proc~get_aux_size~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_aux_size~3~~CalledByGraph proc~get_aux_size~3 transpose_handle_cuda%get_aux_size proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~get_aux_size~3 proc~get_aux_size transpose_plan_cuda%get_aux_size proc~get_aux_size->proc~get_aux_size~3 proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_aux_size~3.html"},{"title":"get_tranpose_type – dtFFT","text":"private  function get_tranpose_type(self) result(tranpose_type) Returns transpose_type, associated with handle Type Bound transpose_handle_cuda Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(in) :: self CUDA Transpose Handle Return Value type( dtfft_transpose_t )","tags":"","loc":"proc/get_tranpose_type.html"},{"title":"create_data_handle – dtFFT","text":"private  subroutine create_data_handle(self, info, comm, comm_size) Creates handle Type Bound data_handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class type( pencil ), intent(in) :: info Pencil info type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int32), intent(in) :: comm_size Size of comm Calls proc~~create_data_handle~~CallsGraph proc~create_data_handle data_handle%create_data_handle mpi_allgather mpi_allgather proc~create_data_handle->mpi_allgather Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_data_handle.html"},{"title":"destroy_data_handle – dtFFT","text":"private  subroutine destroy_data_handle(self) Destroys handle Type Bound data_handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class Called by proc~~destroy_data_handle~~CalledByGraph proc~destroy_data_handle data_handle%destroy_data_handle proc~create~9 transpose_handle_cuda%create proc~create~9->proc~destroy_data_handle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_data_handle.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, helper, send, recv, base_storage, backend) Creates CUDA Transpose Handle Type Bound transpose_handle_cuda Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(inout) :: self CUDA Transpose Handle type( backend_helper ), intent(in) :: helper Backend helper type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_backend_t ), intent(in) :: backend Backend type Calls proc~~create~9~~CallsGraph proc~create~9 transpose_handle_cuda%create mpi_comm_rank mpi_comm_rank proc~create~9->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create~9->mpi_comm_size mpi_irecv mpi_irecv proc~create~9->mpi_irecv mpi_isend mpi_isend proc~create~9->mpi_isend mpi_wait mpi_wait proc~create~9->mpi_wait proc~create~8 nvrtc_kernel%create proc~create~9->proc~create~8 proc~destroy_data_handle data_handle%destroy_data_handle proc~create~9->proc~destroy_data_handle proc~get_transpose_type get_transpose_type proc~create~9->proc~get_transpose_type proc~is_backend_cufftmp is_backend_cufftmp proc~create~9->proc~is_backend_cufftmp proc~is_backend_mpi is_backend_mpi proc~create~9->proc~is_backend_mpi proc~is_backend_nccl is_backend_nccl proc~create~9->proc~is_backend_nccl proc~is_backend_pipelined is_backend_pipelined proc~create~9->proc~is_backend_pipelined proc~set_unpack_kernel abstract_backend%set_unpack_kernel proc~create~9->proc~set_unpack_kernel proc~create~8->mpi_comm_rank proc~create~8->mpi_comm_size proc~compile_and_cache compile_and_cache proc~create~8->proc~compile_and_cache proc~create_device_pointer create_device_pointer proc~create~8->proc~create_device_pointer proc~destroy~10 nvrtc_kernel%destroy proc~create~8->proc~destroy~10 proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~create~8->proc~get_contiguous_execution_blocks proc~get_tile_size get_tile_size proc~create~8->proc~get_tile_size proc~compile_and_cache->mpi_comm_rank interface~cudagetdevice cudaGetDevice proc~compile_and_cache->interface~cudagetdevice interface~get_cuda_architecture get_cuda_architecture proc~compile_and_cache->interface~get_cuda_architecture interface~int_to_str int_to_str proc~compile_and_cache->interface~int_to_str is_null_ptr is_null_ptr proc~compile_and_cache->is_null_ptr mpi_abort mpi_abort proc~compile_and_cache->mpi_abort mpi_allreduce mpi_allreduce proc~compile_and_cache->mpi_allreduce proc~astring_f2c astring_f2c proc~compile_and_cache->proc~astring_f2c proc~cudageterrorstring cudaGetErrorString proc~compile_and_cache->proc~cudageterrorstring proc~destroy_code kernel_code%destroy_code proc~compile_and_cache->proc~destroy_code proc~get_cached_kernel get_cached_kernel proc~compile_and_cache->proc~get_cached_kernel proc~get_transpose_kernel_code get_transpose_kernel_code proc~compile_and_cache->proc~get_transpose_kernel_code proc~get_true_transpose_type get_true_transpose_type proc~compile_and_cache->proc~get_true_transpose_type proc~get_unpack_kernel_code get_unpack_kernel_code proc~compile_and_cache->proc~get_unpack_kernel_code proc~get_unpack_pipelined_kernel_code get_unpack_pipelined_kernel_code proc~compile_and_cache->proc~get_unpack_pipelined_kernel_code proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_and_cache->proc~nvrtcgeterrorstring proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~compile_and_cache->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~compile_and_cache->proc~push_nvtx_domain_range proc~string_c2f string_c2f proc~compile_and_cache->proc~string_c2f proc~to_cstr kernel_code%to_cstr proc~compile_and_cache->proc~to_cstr interface~cudamalloc cudaMalloc proc~create_device_pointer->interface~cudamalloc interface~cudamemcpy cudaMemcpy proc~create_device_pointer->interface~cudamemcpy proc~create_device_pointer->interface~int_to_str proc~create_device_pointer->mpi_abort proc~create_device_pointer->proc~cudageterrorstring interface~cudafree cudaFree proc~destroy~10->interface~cudafree proc~destroy~10->interface~int_to_str proc~destroy~10->mpi_abort proc~destroy~10->proc~cudageterrorstring proc~mark_unused mark_unused proc~destroy~10->proc~mark_unused proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~cudageterrorstring->proc~string_c2f interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~get_cached_kernel->proc~get_true_transpose_type proc~add_line kernel_code%add_line proc~get_transpose_kernel_code->proc~add_line proc~get_code_init get_code_init proc~get_transpose_kernel_code->proc~get_code_init proc~get_neighbor_function_code get_neighbor_function_code proc~get_transpose_kernel_code->proc~get_neighbor_function_code proc~get_unpack_kernel_code->proc~add_line proc~get_unpack_kernel_code->proc~get_code_init proc~get_unpack_kernel_code->proc~get_neighbor_function_code proc~get_unpack_pipelined_kernel_code->mpi_comm_rank proc~get_unpack_pipelined_kernel_code->proc~add_line proc~get_unpack_pipelined_kernel_code->proc~get_code_init proc~is_same_ptr is_same_ptr proc~mark_unused->proc~is_same_ptr proc~nvrtcgeterrorstring->proc~string_c2f interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c proc~push_nvtx_domain_range->proc~astring_f2c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~to_cstr->proc~astring_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~get_code_init->interface~int_to_str proc~get_code_init->proc~add_line proc~get_neighbor_function_code->proc~add_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~9.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, stream, aux) Executes transpose - exchange - unpack Type Bound transpose_handle_cuda Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(inout) :: self CUDA Transpose Handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer Calls proc~~execute~10~~CallsGraph proc~execute~10 transpose_handle_cuda%execute proc~execute~9 nvrtc_kernel%execute proc~execute~10->proc~execute~9 interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync interface~int_to_str int_to_str proc~execute~9->interface~int_to_str mpi_abort mpi_abort proc~execute~9->mpi_abort mpi_comm_rank mpi_comm_rank proc~execute~9->mpi_comm_rank proc~cudageterrorstring cudaGetErrorString proc~execute~9->proc~cudageterrorstring proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_contiguous_execution_blocks get_contiguous_execution_blocks proc~execute~9->proc~get_contiguous_execution_blocks proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~run_cuda_kernel run_cuda_kernel proc~culaunchkernel->interface~run_cuda_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute~10~~CalledByGraph proc~execute~10 transpose_handle_cuda%execute proc~execute_cuda transpose_plan_cuda%execute_cuda proc~execute_cuda->proc~execute~10 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~execute~10 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~10.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys CUDA Transpose Handle Type Bound transpose_handle_cuda Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(inout) :: self CUDA Transpose Handle Calls proc~~destroy~11~~CallsGraph proc~destroy~11 transpose_handle_cuda%destroy proc~destroy~10 nvrtc_kernel%destroy proc~destroy~11->proc~destroy~10 interface~cudafree cudaFree proc~destroy~10->interface~cudafree interface~int_to_str int_to_str proc~destroy~10->interface~int_to_str mpi_abort mpi_abort proc~destroy~10->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy~10->proc~cudageterrorstring proc~mark_unused mark_unused proc~destroy~10->proc~mark_unused proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~is_same_ptr is_same_ptr proc~mark_unused->proc~is_same_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy~11~~CalledByGraph proc~destroy~11 transpose_handle_cuda%destroy proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~destroy~11 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~destroy~11 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~11.html"},{"title":"DftiErrorMessage – dtFFT","text":"public  function DftiErrorMessage(error_code) result(string) Generates an error message. Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in) :: error_code Completion status of a function. Return Value character(len=:), allocatable Error message Calls proc~~dftierrormessage~~CallsGraph proc~dftierrormessage DftiErrorMessage interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dftierrormessage~~CalledByGraph proc~dftierrormessage DftiErrorMessage proc~destroy~4 mkl_executor%destroy proc~destroy~4->proc~dftierrormessage proc~execute~4 mkl_executor%execute proc~execute~4->proc~dftierrormessage proc~make_plan make_plan proc~make_plan->proc~dftierrormessage proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->proc~dftierrormessage proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->proc~dftierrormessage proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dftierrormessage.html"},{"title":"mkl_dfti_set_value – dtFFT","text":"public interface mkl_dfti_set_value Sets one particular configuration parameter with the specified configuration value. Called by interface~~mkl_dfti_set_value~~CalledByGraph interface~mkl_dfti_set_value mkl_dfti_set_value proc~execute~4 mkl_executor%execute proc~execute~4->interface~mkl_dfti_set_value proc~make_plan make_plan proc~make_plan->interface~mkl_dfti_set_value proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function mkl_dfti_set_integer(desc, param, value) result(status) bind(C) Sets one particular configuration parameter with integer value. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. integer(kind=c_int), intent(in), value :: param Configuration parameter. integer(kind=c_int), intent(in), value :: value Configuration value. Return Value integer(kind=c_long) Function completion status. private  function mkl_dfti_set_pointer(desc, param, value) result(status) bind(C) Sets one particular configuration parameter with pointer value. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. integer(kind=c_int), intent(in), value :: param Configuration parameter. integer(kind=c_long), intent(in) :: value (*) Configuration value. Return Value integer(kind=c_long) Function completion status.","tags":"","loc":"interface/mkl_dfti_set_value.html"},{"title":"mkl_dfti_create_desc – dtFFT","text":"interface Allocates the descriptor data structure and initializes it with default configuration values. Called by interface~~mkl_dfti_create_desc~~CalledByGraph interface~mkl_dfti_create_desc mkl_dfti_create_desc proc~make_plan make_plan proc~make_plan->interface~mkl_dfti_create_desc proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_create_desc(precision, domain, dim, length, desc) result(status) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: precision Precision of the transform: DFTI_SINGLE or DFTI_DOUBLE. integer(kind=c_int), intent(in), value :: domain Forward domain of the transform: DFTI_COMPLEX or DFTI_REAL. integer(kind=c_long), intent(in), value :: dim Dimension of the transform. integer(kind=c_long), intent(in) :: length (*) Length of the transform for a one-dimensional transform.\nLengths of each dimension for a multi-dimensional transform. type(c_ptr) :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status.","tags":"","loc":"interface/mkl_dfti_create_desc.html"},{"title":"mkl_dfti_commit_desc – dtFFT","text":"interface Performs all initialization for the actual FFT computation. Called by interface~~mkl_dfti_commit_desc~~CalledByGraph interface~mkl_dfti_commit_desc mkl_dfti_commit_desc proc~execute~4 mkl_executor%execute proc~execute~4->interface~mkl_dfti_commit_desc proc~make_plan make_plan proc~make_plan->interface~mkl_dfti_commit_desc proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_commit_desc(desc) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status.","tags":"","loc":"interface/mkl_dfti_commit_desc.html"},{"title":"mkl_dfti_execute – dtFFT","text":"interface Computes FFT. Called by interface~~mkl_dfti_execute~~CalledByGraph interface~mkl_dfti_execute mkl_dfti_execute proc~execute~4 mkl_executor%execute proc~execute~4->interface~mkl_dfti_execute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_execute(desc, in, out, sign) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. type(c_ptr), value :: in Data to be transformed type(c_ptr), value :: out The transformed data integer(kind=c_int), intent(in), value :: sign Sign of transform Return Value integer(kind=c_long) Function completion status.","tags":"","loc":"interface/mkl_dfti_execute.html"},{"title":"mkl_dfti_free_desc – dtFFT","text":"interface Frees the memory allocated for a descriptor. Called by interface~~mkl_dfti_free_desc~~CalledByGraph interface~mkl_dfti_free_desc mkl_dfti_free_desc proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~mkl_dfti_free_desc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_free_desc(desc) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status.","tags":"","loc":"interface/mkl_dfti_free_desc.html"},{"title":"mkl_dfti_mem_alloc – dtFFT","text":"interface Allocates pointer via mkl_malloc Called by interface~~mkl_dfti_mem_alloc~~CalledByGraph interface~mkl_dfti_mem_alloc mkl_dfti_mem_alloc proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~mkl_dfti_mem_alloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_mem_alloc(alloc_bytes, ptr) result(status) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: alloc_bytes Number of bytes to allocate. type(c_ptr) :: ptr Pointer to allocated memory. Return Value integer(kind=c_long) Function completion status.","tags":"","loc":"interface/mkl_dfti_mem_alloc.html"},{"title":"mkl_dfti_mem_free – dtFFT","text":"interface Frees pointer via mkl_free Called by interface~~mkl_dfti_mem_free~~CalledByGraph interface~mkl_dfti_mem_free mkl_dfti_mem_free proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~mkl_dfti_mem_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_mem_free(ptr) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to allocated memory. Return Value integer(kind=c_long) Function completion status.","tags":"","loc":"interface/mkl_dfti_mem_free.html"},{"title":"DftiErrorMessage_c – dtFFT","text":"interface Generates an error message. Called by interface~~dftierrormessage_c~~CalledByGraph interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage DftiErrorMessage proc~dftierrormessage->interface~dftierrormessage_c proc~destroy~4 mkl_executor%destroy proc~destroy~4->proc~dftierrormessage proc~execute~4 mkl_executor%execute proc~execute~4->proc~dftierrormessage proc~make_plan make_plan proc~make_plan->proc~dftierrormessage proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->proc~dftierrormessage proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->proc~dftierrormessage proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function DftiErrorMessage_c(error_code) result(message) bind(C, name=\"DftiErrorMessage\") Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in), value :: error_code Completion status of a function. Return Value type(c_ptr) Pointer to message","tags":"","loc":"interface/dftierrormessage_c.html"},{"title":"get_transpose_type – dtFFT","text":"public pure function get_transpose_type(send, recv) result(transpose_type) Determines transpose ID based on pencils Arguments Type Intent Optional Attributes Name type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Receive pencil Return Value type( dtfft_transpose_t ) Transpose ID Called by proc~~get_transpose_type~~CalledByGraph proc~get_transpose_type get_transpose_type proc~create~11 transpose_handle_host%create proc~create~11->proc~get_transpose_type proc~create~9 transpose_handle_cuda%create proc~create~9->proc~get_transpose_type proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_transpose_type.html"},{"title":"check_if_even – dtFFT","text":"private  function check_if_even(count, comm) Checks if data is evenly distributed across processes Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: count Local count type(MPI_Comm), intent(in) :: comm Grid communicator Return Value logical Calls proc~~check_if_even~~CallsGraph proc~check_if_even check_if_even mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_if_even~~CalledByGraph proc~check_if_even check_if_even proc~create~10 pencil%create proc~create~10->proc~check_if_even proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create~10 proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create~10 proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~create_pencils_and_comm proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~create_pencils_and_comm proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_if_even.html"},{"title":"make_public – dtFFT","text":"private  function make_public(self) Creates public object that users can use to create own FFT backends Type Bound pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: self Pencil Return Value type( dtfft_pencil_t )","tags":"","loc":"proc/make_public.html"},{"title":"create_pencil_t – dtFFT","text":"private  function create_pencil_t(starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t ) Calls proc~~create_pencil_t~~CallsGraph proc~create_pencil_t create_pencil_t proc~destroy_pencil_t_private dtfft_pencil_t%destroy_pencil_t_private proc~create_pencil_t->proc~destroy_pencil_t_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_pencil_t~~CalledByGraph proc~create_pencil_t create_pencil_t interface~dtfft_pencil_t dtfft_pencil_t interface~dtfft_pencil_t->proc~create_pencil_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_pencil_t.html"},{"title":"create_pencil_init – dtFFT","text":"private  function create_pencil_init(self, pencil, comm) result(error_code) Creates and validates pencil passed by user to plan constructors Type Bound pencil_init Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t type( dtfft_pencil_t ), intent(in) :: pencil Pencil passed by user to plan constructors type(MPI_Comm), intent(in) :: comm MPI Communicator passed to plan constructors Return Value integer(kind=int32) Error code Calls proc~~create_pencil_init~~CallsGraph proc~create_pencil_init pencil_init%create_pencil_init mpi_allgather mpi_allgather proc~create_pencil_init->mpi_allgather mpi_allreduce mpi_allreduce proc~create_pencil_init->mpi_allreduce mpi_comm_rank mpi_comm_rank proc~create_pencil_init->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_pencil_init->mpi_comm_size proc~check_continuity check_continuity proc~create_pencil_init->proc~check_continuity proc~check_overlap check_overlap proc~create_pencil_init->proc~check_overlap proc~create_1d_comm create_1d_comm proc~create_pencil_init->proc~create_1d_comm proc~dtfft_get_error_string dtfft_get_error_string proc~create_pencil_init->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~create_pencil_init->proc~get_log_enabled proc~write_message write_message proc~create_pencil_init->proc~write_message proc~create_1d_comm->mpi_comm_size mpi_comm_create mpi_comm_create proc~create_1d_comm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_1d_comm->mpi_comm_group mpi_group_free mpi_group_free proc~create_1d_comm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_1d_comm->mpi_group_incl proc~get_varying_dim get_varying_dim proc~create_1d_comm->proc~get_varying_dim proc~sort_by_varying_dim sort_by_varying_dim proc~create_1d_comm->proc~sort_by_varying_dim proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_pencil_init.html"},{"title":"check_overlap – dtFFT","text":"private pure function check_overlap(lbounds1, sizes1, lbounds2, sizes2, ndims) Check if two pencols overlap in ndims-dimensional space Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lbounds1 (:) Lower bounds of first pencil integer(kind=int32), intent(in) :: sizes1 (:) Sizes of first pencil integer(kind=int32), intent(in) :: lbounds2 (:) Lower bounds of second pencil integer(kind=int32), intent(in) :: sizes2 (:) Sizes of second pencil integer(kind=int32), intent(in) :: ndims Number of dimensions Return Value logical Called by proc~~check_overlap~~CalledByGraph proc~check_overlap check_overlap proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~check_overlap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_overlap.html"},{"title":"check_continuity – dtFFT","text":"private  function check_continuity(all_lbounds, all_sizes, global_dims, comm_size) Check if the local pencils cover the global space without gaps Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: all_lbounds (:,:) Lower bounds of local pencils for each process integer(kind=int32), intent(in) :: all_sizes (:,:) Sizes of local pencils for each process integer(kind=int32), intent(in) :: global_dims (:) Global dimensions of the problem integer(kind=int32), intent(in) :: comm_size Number of processes in the communicator Return Value logical Called by proc~~check_continuity~~CalledByGraph proc~check_continuity check_continuity proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~check_continuity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_continuity.html"},{"title":"get_varying_dim – dtFFT","text":"private  function get_varying_dim(fixed_dims, total_dims) result(varying_dim) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: fixed_dims (:) integer(kind=int32), intent(in) :: total_dims Return Value integer(kind=int32) Called by proc~~get_varying_dim~~CalledByGraph proc~get_varying_dim get_varying_dim proc~create_1d_comm create_1d_comm proc~create_1d_comm->proc~get_varying_dim proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~create_1d_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_varying_dim.html"},{"title":"pencil_f2c – dtFFT","text":"public  subroutine pencil_f2c(pencil, c_pencil) Converts Fortran pencil to C pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_t ), intent(in) :: pencil Fortran pencil type( dtfft_pencil_c ), intent(out) :: c_pencil C pencil Called by proc~~pencil_f2c~~CalledByGraph proc~pencil_f2c pencil_f2c proc~dtfft_get_pencil_c dtfft_get_pencil_c proc~dtfft_get_pencil_c->proc~pencil_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/pencil_f2c.html"},{"title":"pencil_c2f – dtFFT","text":"public  subroutine pencil_c2f(c_pencil, pencil) Converts C pencil to Fortran pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: c_pencil C pencil type( dtfft_pencil_t ), intent(out) :: pencil Fortran pencil Called by proc~~pencil_c2f~~CalledByGraph proc~pencil_c2f pencil_c2f proc~dtfft_create_plan_c2c_pencil_c dtfft_create_plan_c2c_pencil_c proc~dtfft_create_plan_c2c_pencil_c->proc~pencil_c2f proc~dtfft_create_plan_r2r_pencil_c dtfft_create_plan_r2r_pencil_c proc~dtfft_create_plan_r2r_pencil_c->proc~pencil_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/pencil_c2f.html"},{"title":"get_local_sizes – dtFFT","text":"public  subroutine get_local_sizes(pencils, in_starts, in_counts, out_starts, out_counts, alloc_size) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name type( pencil ), intent(in) :: pencils (:) Array of pencils integer(kind=int32), intent(out), optional :: in_starts (:) Start indexes in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements in real space integer(kind=int32), intent(out), optional :: out_starts (:) Start indexes in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan Called by proc~~get_local_sizes~2~~CalledByGraph proc~get_local_sizes~2 get_local_sizes proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~get_local_sizes~2 proc~create~12 abstract_transpose_plan%create proc~create~12->proc~get_local_sizes~2 proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~get_local_sizes~2 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes proc~autotune_grid_decomposition->proc~autotune_grid proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_local_sizes~2.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, rank, aligned_dim, counts, comms, lstarts, lcounts) Creates pencil Type Bound pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil integer(kind=int8), intent(in) :: rank Rank of buffer integer(kind=int8), intent(in) :: aligned_dim Position of aligned dimension integer(kind=int32), intent(in) :: counts (:) Global counts type(MPI_Comm), intent(in) :: comms (:) Grid communicators integer(kind=int32), intent(in), optional :: lstarts (:) Local starts integer(kind=int32), intent(in), optional :: lcounts (:) Local counts Calls proc~~create~10~~CallsGraph proc~create~10 pencil%create proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~destroy~12 pencil%destroy proc~create~10->proc~destroy~12 proc~get_local_size get_local_size proc~create~10->proc~get_local_size mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~get_local_size->mpi_allgather mpi_comm_rank mpi_comm_rank proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_comm_size Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~10~~CalledByGraph proc~create~10 pencil%create proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create~10 proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create~10 proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~create_pencils_and_comm proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~create_pencils_and_comm proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~10.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys pencil Type Bound pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil Called by proc~~destroy~12~~CalledByGraph proc~destroy~12 pencil%destroy proc~autotune_grid autotune_grid proc~autotune_grid->proc~destroy~12 proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~destroy~12 proc~autotune_grid~2->proc~create_pencils_and_comm proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~destroy~12 proc~create~10 pencil%create proc~create~10->proc~destroy~12 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_pencils_and_comm->proc~create~10 proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 proc~create_private->proc~create_pencils_and_comm proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create~10 proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~autotune_grid_decomposition proc~create_cuda->proc~create_pencils_and_comm proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~12.html"},{"title":"get_local_size – dtFFT","text":"private  subroutine get_local_size(n_global, comm, start, count, start_to_keep, size_to_keep) Computes local portions of data based on global count and position inside grid communicator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_global Global number of points type(MPI_Comm), intent(in) :: comm Grid communicator integer(kind=int32), intent(out) :: start Local start integer(kind=int32), intent(out) :: count Local count integer(kind=int32), intent(in), optional :: start_to_keep Start to keep in case of user defined decomposition integer(kind=int32), intent(in), optional :: size_to_keep Size to keep in case of user defined decomposition Calls proc~~get_local_size~~CallsGraph proc~get_local_size get_local_size mpi_allgather mpi_allgather proc~get_local_size->mpi_allgather mpi_comm_rank mpi_comm_rank proc~get_local_size->mpi_comm_rank mpi_comm_size mpi_comm_size proc~get_local_size->mpi_comm_size Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_local_size~~CalledByGraph proc~get_local_size get_local_size proc~create~10 pencil%create proc~create~10->proc~get_local_size proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create~10 proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create~10 proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~create_pencils_and_comm proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~create_pencils_and_comm proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_local_size.html"},{"title":"destroy_pencil_t_private – dtFFT","text":"private  subroutine destroy_pencil_t_private(self) Destroys pencil Type Bound dtfft_pencil_t Arguments Type Intent Optional Attributes Name class( dtfft_pencil_t ), intent(inout) :: self Public pencil Called by proc~~destroy_pencil_t_private~~CalledByGraph proc~destroy_pencil_t_private dtfft_pencil_t%destroy_pencil_t_private proc~create_pencil_t create_pencil_t proc~create_pencil_t->proc~destroy_pencil_t_private proc~destroy_pencil_t destroy_pencil_t proc~destroy_pencil_t->proc~destroy_pencil_t_private interface~dtfft_pencil_t dtfft_pencil_t interface~dtfft_pencil_t->proc~create_pencil_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_pencil_t_private.html"},{"title":"destroy_pencil_t – dtFFT","text":"private  subroutine destroy_pencil_t(self) Destroys pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_t ), intent(inout) :: self Public pencil Calls proc~~destroy_pencil_t~~CallsGraph proc~destroy_pencil_t destroy_pencil_t proc~destroy_pencil_t_private dtfft_pencil_t%destroy_pencil_t_private proc~destroy_pencil_t->proc~destroy_pencil_t_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_pencil_t.html"},{"title":"destroy_pencil_init – dtFFT","text":"private  subroutine destroy_pencil_init(self) Destroys pencil_init Type Bound pencil_init Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t Calls proc~~destroy_pencil_init~~CallsGraph proc~destroy_pencil_init pencil_init%destroy_pencil_init mpi_comm_free mpi_comm_free proc~destroy_pencil_init->mpi_comm_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_pencil_init.html"},{"title":"sort_by_varying_dim – dtFFT","text":"private  subroutine sort_by_varying_dim(ranks, coords) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: ranks (:) integer(kind=int32), intent(in) :: coords (:) Called by proc~~sort_by_varying_dim~~CalledByGraph proc~sort_by_varying_dim sort_by_varying_dim proc~create_1d_comm create_1d_comm proc~create_1d_comm->proc~sort_by_varying_dim proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~create_1d_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/sort_by_varying_dim.html"},{"title":"create_1d_comm – dtFFT","text":"private  subroutine create_1d_comm(lbounds, all_lbounds, fixed_dims, comm, new_comm) Creates a new 1D communicator based on the fixed dimensions of the current pencil Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lbounds (:) Local starts of the current pencil integer(kind=int32), intent(in) :: all_lbounds (:,:) Local starts of all processes integer(kind=int32), intent(in) :: fixed_dims (:) Indices of fixed coordinates type(MPI_Comm), intent(in) :: comm Original MPI communicator type(MPI_Comm), intent(out) :: new_comm New 1D MPI communicator Calls proc~~create_1d_comm~~CallsGraph proc~create_1d_comm create_1d_comm mpi_comm_create mpi_comm_create proc~create_1d_comm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_1d_comm->mpi_comm_group mpi_comm_size mpi_comm_size proc~create_1d_comm->mpi_comm_size mpi_group_free mpi_group_free proc~create_1d_comm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_1d_comm->mpi_group_incl proc~get_varying_dim get_varying_dim proc~create_1d_comm->proc~get_varying_dim proc~sort_by_varying_dim sort_by_varying_dim proc~create_1d_comm->proc~sort_by_varying_dim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_1d_comm~~CalledByGraph proc~create_1d_comm create_1d_comm proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~create_1d_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_1d_comm.html"},{"title":"dtfft_pencil_t – dtFFT","text":"public interface dtfft_pencil_t Type bound constuctor for dtfft_pencil_t Calls interface~~dtfft_pencil_t~~CallsGraph interface~dtfft_pencil_t dtfft_pencil_t proc~create_pencil_t create_pencil_t interface~dtfft_pencil_t->proc~create_pencil_t proc~destroy_pencil_t_private dtfft_pencil_t%destroy_pencil_t_private proc~create_pencil_t->proc~destroy_pencil_t_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t )","tags":"","loc":"interface/dtfft_pencil_t.html"},{"title":"create_handle – dtFFT","text":"private  subroutine create_handle(self, n) Creates transposition handle Type Bound handle_t Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle integer(kind=int32), intent(in) :: n Number of datatypes to be created Calls proc~~create_handle~~CallsGraph proc~create_handle handle_t%create_handle proc~destroy_handle handle_t%destroy_handle proc~create_handle->proc~destroy_handle mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_handle~~CalledByGraph proc~create_handle handle_t%create_handle proc~create~11 transpose_handle_host%create proc~create~11->proc~create_handle proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_handle.html"},{"title":"destroy_handle – dtFFT","text":"private  subroutine destroy_handle(self) Destroys transposition handle Type Bound handle_t Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle Calls proc~~destroy_handle~~CallsGraph proc~destroy_handle handle_t%destroy_handle mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_handle~~CalledByGraph proc~destroy_handle handle_t%destroy_handle proc~create_handle handle_t%create_handle proc~create_handle->proc~destroy_handle proc~destroy~13 transpose_handle_host%destroy proc~destroy~13->proc~destroy_handle proc~create~11 transpose_handle_host%create proc~create~11->proc~create_handle proc~destroy~7 transpose_plan_host%destroy proc~destroy~7->proc~destroy~13 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~destroy~13 proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_handle.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, comm, send, recv, base_type, base_storage, datatype_id) Creates transpose_handle_host class Type Bound transpose_handle_host Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm 1d communicator class( pencil ), intent(in) :: send Information about send buffer class( pencil ), intent(in) :: recv Information about recv buffer type(MPI_Datatype), intent(in) :: base_type Base MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int8), intent(in) :: datatype_id Type of datatype to use Calls proc~~create~11~~CallsGraph proc~create~11 transpose_handle_host%create mpi_allgather mpi_allgather proc~create~11->mpi_allgather mpi_comm_size mpi_comm_size proc~create~11->mpi_comm_size proc~create_handle handle_t%create_handle proc~create~11->proc~create_handle proc~create_transpose_2d transpose_handle_host%create_transpose_2d proc~create~11->proc~create_transpose_2d proc~create_transpose_xy transpose_handle_host%create_transpose_XY proc~create~11->proc~create_transpose_xy proc~create_transpose_xz transpose_handle_host%create_transpose_XZ proc~create~11->proc~create_transpose_xz proc~create_transpose_yz transpose_handle_host%create_transpose_YZ proc~create~11->proc~create_transpose_yz proc~create_transpose_zx transpose_handle_host%create_transpose_ZX proc~create~11->proc~create_transpose_zx proc~get_transpose_type get_transpose_type proc~create~11->proc~get_transpose_type proc~destroy_handle handle_t%destroy_handle proc~create_handle->proc~destroy_handle mpi_type_commit mpi_type_commit proc~create_transpose_2d->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_2d->mpi_type_contiguous mpi_type_create_resized mpi_type_create_resized proc~create_transpose_2d->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_2d->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xy->mpi_type_commit proc~create_transpose_xy->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_resized proc~create_transpose_xy->mpi_type_vector proc~create_transpose_xy->proc~free_datatypes proc~create_transpose_xz->mpi_type_commit proc~create_transpose_xz->mpi_type_contiguous proc~create_transpose_xz->mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_resized proc~create_transpose_xz->mpi_type_vector proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_yz->mpi_type_commit proc~create_transpose_yz->mpi_type_contiguous proc~create_transpose_yz->mpi_type_create_hvector proc~create_transpose_yz->mpi_type_create_resized proc~create_transpose_yz->mpi_type_vector proc~create_transpose_yz->proc~free_datatypes proc~create_transpose_zx->mpi_type_commit proc~create_transpose_zx->mpi_type_contiguous proc~create_transpose_zx->mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_resized proc~create_transpose_zx->mpi_type_vector proc~create_transpose_zx->proc~free_datatypes mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~11~~CalledByGraph proc~create~11 transpose_handle_host%create proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~11.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, send, recv) Executes transposition Type Bound transpose_handle_host Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class real(kind=real32), intent(in) :: send (:) Incoming buffer real(kind=real32), intent(inout) :: recv (:) Resulting buffer Calls proc~~execute~11~~CallsGraph proc~execute~11 transpose_handle_host%execute mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_start mpi_start proc~execute~11->mpi_start mpi_wait mpi_wait proc~execute~11->mpi_wait Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute~11~~CalledByGraph proc~execute~11 transpose_handle_host%execute proc~execute_private transpose_plan_host%execute_private proc~execute_private->proc~execute~11 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~execute~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~11.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys transpose_handle_host class Type Bound transpose_handle_host Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class Calls proc~~destroy~13~~CallsGraph proc~destroy~13 transpose_handle_host%destroy mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy~13~~CalledByGraph proc~destroy~13 transpose_handle_host%destroy proc~destroy~7 transpose_plan_host%destroy proc~destroy~7->proc~destroy~13 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~destroy~13 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id proc~create_private transpose_plan_host%create_private proc~create_private->proc~autotune_grid~2 proc~create_private->proc~autotune_grid_decomposition~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~13.html"},{"title":"create_transpose_2d – dtFFT","text":"private  subroutine create_transpose_2d(self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates two-dimensional transposition datatypes Type Bound transpose_handle_host Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Calls proc~~create_transpose_2d~~CallsGraph proc~create_transpose_2d transpose_handle_host%create_transpose_2d mpi_type_commit mpi_type_commit proc~create_transpose_2d->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_2d->mpi_type_contiguous mpi_type_create_resized mpi_type_create_resized proc~create_transpose_2d->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_2d->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_2d->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_transpose_2d~~CalledByGraph proc~create_transpose_2d transpose_handle_host%create_transpose_2d proc~create~11 transpose_handle_host%create proc~create~11->proc~create_transpose_2d proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_transpose_2d.html"},{"title":"create_transpose_XY – dtFFT","text":"private  subroutine create_transpose_XY(self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional X –> Y, Y –> X transposition datatypes Type Bound transpose_handle_host Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Calls proc~~create_transpose_xy~~CallsGraph proc~create_transpose_xy transpose_handle_host%create_transpose_XY mpi_type_commit mpi_type_commit proc~create_transpose_xy->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_xy->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xy->mpi_type_create_hvector mpi_type_create_resized mpi_type_create_resized proc~create_transpose_xy->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_xy->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_xy->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_transpose_xy~~CalledByGraph proc~create_transpose_xy transpose_handle_host%create_transpose_XY proc~create~11 transpose_handle_host%create proc~create~11->proc~create_transpose_xy proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_transpose_xy.html"},{"title":"create_transpose_YZ – dtFFT","text":"private  subroutine create_transpose_YZ(self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional Y –> Z, Z –> Y transposition datatypes Type Bound transpose_handle_host Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Calls proc~~create_transpose_yz~~CallsGraph proc~create_transpose_yz transpose_handle_host%create_transpose_YZ mpi_type_commit mpi_type_commit proc~create_transpose_yz->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_yz->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_yz->mpi_type_create_hvector mpi_type_create_resized mpi_type_create_resized proc~create_transpose_yz->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_yz->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_yz->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_transpose_yz~~CalledByGraph proc~create_transpose_yz transpose_handle_host%create_transpose_YZ proc~create~11 transpose_handle_host%create proc~create~11->proc~create_transpose_yz proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_transpose_yz.html"},{"title":"create_transpose_XZ – dtFFT","text":"private  subroutine create_transpose_XZ(self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional X –> Z transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Type Bound transpose_handle_host Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Calls proc~~create_transpose_xz~~CallsGraph proc~create_transpose_xz transpose_handle_host%create_transpose_XZ mpi_type_commit mpi_type_commit proc~create_transpose_xz->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_xz->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_hvector mpi_type_create_resized mpi_type_create_resized proc~create_transpose_xz->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_xz->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_xz->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_transpose_xz~~CalledByGraph proc~create_transpose_xz transpose_handle_host%create_transpose_XZ proc~create~11 transpose_handle_host%create proc~create~11->proc~create_transpose_xz proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_transpose_xz.html"},{"title":"create_transpose_ZX – dtFFT","text":"private  subroutine create_transpose_ZX(self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional Z –> X transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Type Bound transpose_handle_host Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Calls proc~~create_transpose_zx~~CallsGraph proc~create_transpose_zx transpose_handle_host%create_transpose_ZX mpi_type_commit mpi_type_commit proc~create_transpose_zx->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_zx->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_hvector mpi_type_create_resized mpi_type_create_resized proc~create_transpose_zx->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_zx->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_zx->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_transpose_zx~~CalledByGraph proc~create_transpose_zx transpose_handle_host%create_transpose_ZX proc~create~11 transpose_handle_host%create proc~create~11->proc~create_transpose_zx proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_transpose_zx.html"},{"title":"free_datatypes – dtFFT","text":"private  subroutine free_datatypes(t1, t2, t3, t4) Frees temporary datatypes Arguments Type Intent Optional Attributes Name type(MPI_Datatype), intent(inout), optional :: t1 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t2 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t3 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t4 Temporary datatype Calls proc~~free_datatypes~~CallsGraph proc~free_datatypes free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~free_datatypes~~CalledByGraph proc~free_datatypes free_datatypes proc~create_transpose_2d transpose_handle_host%create_transpose_2d proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xy transpose_handle_host%create_transpose_XY proc~create_transpose_xy->proc~free_datatypes proc~create_transpose_xz transpose_handle_host%create_transpose_XZ proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_yz transpose_handle_host%create_transpose_YZ proc~create_transpose_yz->proc~free_datatypes proc~create_transpose_zx transpose_handle_host%create_transpose_ZX proc~create_transpose_zx->proc~free_datatypes proc~create~11 transpose_handle_host%create proc~create~11->proc~create_transpose_2d proc~create~11->proc~create_transpose_xy proc~create~11->proc~create_transpose_xz proc~create~11->proc~create_transpose_yz proc~create~11->proc~create_transpose_zx proc~create_private transpose_plan_host%create_private proc~create_private->proc~create~11 proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~get_plan_execution_time transpose_plan_host%get_plan_execution_time proc~get_plan_execution_time->proc~create~11 proc~autotune_grid~2->proc~get_plan_execution_time proc~autotune_mpi_datatypes transpose_plan_host%autotune_mpi_datatypes proc~autotune_grid~2->proc~autotune_mpi_datatypes proc~autotune_transpose_id transpose_plan_host%autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~autotune_grid_decomposition~2->proc~autotune_grid~2 proc~autotune_mpi_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/free_datatypes.html"},{"title":"create – dtFFT","text":"private  function create(self, dims, base_comm, effort, base_dtype, base_storage, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plans Type Bound abstract_transpose_plan Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code Calls proc~~create~12~~CallsGraph proc~create~12 abstract_transpose_plan%create create_private create_private proc~create~12->create_private interface~int_to_str int_to_str proc~create~12->interface~int_to_str mpi_cart_get mpi_cart_get proc~create~12->mpi_cart_get mpi_cartdim_get mpi_cartdim_get proc~create~12->mpi_cartdim_get mpi_comm_size mpi_comm_size proc~create~12->mpi_comm_size mpi_dims_create mpi_dims_create proc~create~12->mpi_dims_create mpi_topo_test mpi_topo_test proc~create~12->mpi_topo_test proc~get_local_sizes~2 get_local_sizes proc~create~12->proc~get_local_sizes~2 proc~get_log_enabled get_log_enabled proc~create~12->proc~get_log_enabled proc~get_user_platform get_user_platform proc~create~12->proc~get_user_platform proc~get_z_slab get_z_slab proc~create~12->proc~get_z_slab proc~write_message write_message proc~create~12->proc~write_message temp_coords temp_coords proc~create~12->temp_coords temp_dims temp_dims proc~create~12->temp_dims temp_periods temp_periods proc~create~12->temp_periods proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env proc~get_z_slab_from_env get_z_slab_from_env proc~get_z_slab->proc~get_z_slab_from_env mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~12.html"},{"title":"get_aux_size – dtFFT","text":"private  function get_aux_size(self) result(aux_size) Type Bound abstract_transpose_plan Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(in) :: self Transposition class Return Value integer(kind=int64) Called by proc~~get_aux_size~4~~CalledByGraph proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_local_sizes->proc~get_aux_size~4 proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_aux_size~4.html"},{"title":"get_backend – dtFFT","text":"private  function get_backend(self) Returns plan GPU backend Type Bound abstract_transpose_plan Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(in) :: self Transposition class Return Value type( dtfft_backend_t ) Called by proc~~get_backend~2~~CalledByGraph proc~get_backend~2 abstract_transpose_plan%get_backend proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~get_backend~2 proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~get_backend dtfft_plan_t%get_backend proc~get_backend->proc~get_backend~2 proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_local_sizes->proc~get_backend~2 proc~report dtfft_plan_t%report proc~report->proc~get_backend~2 proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~get_backend~2 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_get_backend_c dtfft_get_backend_c proc~dtfft_get_backend_c->proc~get_backend proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_backend~2.html"},{"title":"alloc_mem – dtFFT","text":"public  subroutine alloc_mem(helper, backend, comm, alloc_bytes, ptr, error_code) Uses iso_c_binding iso_fortran_env proc~~alloc_mem~~UsesGraph proc~alloc_mem alloc_mem iso_c_binding iso_c_binding proc~alloc_mem->iso_c_binding iso_fortran_env iso_fortran_env proc~alloc_mem->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Allocates memory based on backend Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code Calls proc~~alloc_mem~~CallsGraph proc~alloc_mem alloc_mem interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~int_to_str int_to_str proc~alloc_mem->interface~int_to_str interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr mpi_abort mpi_abort proc~alloc_mem->mpi_abort mpi_allreduce mpi_allreduce proc~alloc_mem->mpi_allreduce proc~cudageterrorstring cudaGetErrorString proc~alloc_mem->proc~cudageterrorstring proc~dtfft_get_backend_string dtfft_get_backend_string proc~alloc_mem->proc~dtfft_get_backend_string proc~get_log_enabled get_log_enabled proc~alloc_mem->proc~get_log_enabled proc~is_backend_nccl is_backend_nccl proc~alloc_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~alloc_mem->proc~is_backend_nvshmem proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring proc~write_message write_message proc~alloc_mem->proc~write_message temp temp proc~alloc_mem->temp proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_mem~~CalledByGraph proc~alloc_mem alloc_mem proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~mem_alloc~5->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~alloc_and_set_aux proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/alloc_mem.html"},{"title":"free_mem – dtFFT","text":"public  subroutine free_mem(helper, backend, ptr, error_code) Uses iso_c_binding iso_fortran_env proc~~free_mem~~UsesGraph proc~free_mem free_mem iso_c_binding iso_c_binding proc~free_mem->iso_c_binding iso_fortran_env iso_fortran_env proc~free_mem->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Frees memory based on backend Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code Calls proc~~free_mem~~CallsGraph proc~free_mem free_mem interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~int_to_str int_to_str proc~free_mem->interface~int_to_str interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~nvshmem_free nvshmem_free proc~free_mem->interface~nvshmem_free mpi_abort mpi_abort proc~free_mem->mpi_abort proc~is_backend_nccl is_backend_nccl proc~free_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~free_mem->proc~is_backend_nvshmem proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~ncclgeterrorstring ncclGetErrorString proc~free_mem->proc~ncclgeterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~free_mem~~CalledByGraph proc~free_mem free_mem proc~mem_free~5 abstract_transpose_plan%mem_free proc~mem_free~5->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/free_mem.html"},{"title":"create_pencils_and_comm – dtFFT","text":"public  subroutine create_pencils_and_comm(transposed_dims, old_comm, comm_dims, comm, local_comms, pencils, ipencil) Creates cartesian communicator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: transposed_dims (:,:) Global counts in transposed coordinates type(MPI_Comm), intent(in) :: old_comm Communicator to create cartesian from integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type(MPI_Comm), intent(out) :: comm Cartesian communicator type(MPI_Comm), intent(out) :: local_comms (:) 1d communicators in cartesian communicator type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Calls proc~~create_pencils_and_comm~~CallsGraph proc~create_pencils_and_comm create_pencils_and_comm lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~10 pencil%create proc~create_pencils_and_comm->proc~create~10 mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~check_if_even check_if_even proc~create~10->proc~check_if_even proc~destroy~12 pencil%destroy proc~create~10->proc~destroy~12 proc~get_local_size get_local_size proc~create~10->proc~get_local_size mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~get_local_size->mpi_allgather mpi_comm_rank mpi_comm_rank proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_comm_size Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_pencils_and_comm~~CalledByGraph proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~create_pencils_and_comm proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~create_pencils_and_comm proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_pencils_and_comm.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, transpose_type) Executes single transposition Type Bound abstract_transpose_plan Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming pointer type(c_ptr), intent(in) :: out Result pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose Calls proc~~execute~12~~CallsGraph proc~execute~12 abstract_transpose_plan%execute execute_private execute_private proc~execute~12->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~12->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~12->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute~12~~CalledByGraph proc~execute~12 abstract_transpose_plan%execute proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_private~2->proc~execute~12 proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~execute~12 proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~execute_private~2 proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~8 dtfft_plan_t%execute proc~execute~8->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~12.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(self, comm, alloc_bytes, ptr, error_code) Allocates memory based on selected backend Type Bound abstract_transpose_plan Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code Calls proc~~mem_alloc~5~~CallsGraph proc~mem_alloc~5 abstract_transpose_plan%mem_alloc proc~alloc_mem alloc_mem proc~mem_alloc~5->proc~alloc_mem interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~int_to_str int_to_str proc~alloc_mem->interface~int_to_str interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr mpi_abort mpi_abort proc~alloc_mem->mpi_abort mpi_allreduce mpi_allreduce proc~alloc_mem->mpi_allreduce proc~cudageterrorstring cudaGetErrorString proc~alloc_mem->proc~cudageterrorstring proc~dtfft_get_backend_string dtfft_get_backend_string proc~alloc_mem->proc~dtfft_get_backend_string proc~get_log_enabled get_log_enabled proc~alloc_mem->proc~get_log_enabled proc~is_backend_nccl is_backend_nccl proc~alloc_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~alloc_mem->proc~is_backend_nvshmem proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring proc~write_message write_message proc~alloc_mem->proc~write_message temp temp proc~alloc_mem->temp proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc~5.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(self, ptr, error_code) Frees memory allocated with mem_alloc Type Bound abstract_transpose_plan Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code Calls proc~~mem_free~5~~CallsGraph proc~mem_free~5 abstract_transpose_plan%mem_free proc~free_mem free_mem proc~mem_free~5->proc~free_mem interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~int_to_str int_to_str proc~free_mem->interface~int_to_str interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~nvshmem_free nvshmem_free proc~free_mem->interface~nvshmem_free mpi_abort mpi_abort proc~free_mem->mpi_abort proc~is_backend_nccl is_backend_nccl proc~free_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~free_mem->proc~is_backend_nvshmem proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~ncclgeterrorstring ncclGetErrorString proc~free_mem->proc~ncclgeterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mem_free~5~~CalledByGraph proc~mem_free~5 abstract_transpose_plan%mem_free proc~destroy_cuda transpose_plan_cuda%destroy_cuda proc~destroy_cuda->proc~mem_free~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free~5.html"},{"title":"create_cart_comm – dtFFT","text":"private  subroutine create_cart_comm(old_comm, comm_dims, comm, local_comms, ipencil) Creates cartesian communicator Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: old_comm Communicator to create cartesian from integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type(MPI_Comm), intent(out) :: comm Cartesian communicator type(MPI_Comm), intent(out) :: local_comms (:) 1d communicators in cartesian communicator type( pencil_init ), intent(in), optional :: ipencil Calls proc~~create_cart_comm~~CallsGraph proc~create_cart_comm create_cart_comm mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_cart_comm~~CalledByGraph proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~autotune_grid~2 transpose_plan_host%autotune_grid proc~autotune_grid~2->proc~create_pencils_and_comm proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~create_private transpose_plan_host%create_private proc~create_private->proc~create_pencils_and_comm proc~create_private->proc~autotune_grid~2 proc~autotune_grid_decomposition~2 transpose_plan_host%autotune_grid_decomposition proc~create_private->proc~autotune_grid_decomposition~2 proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_grid_decomposition~2->proc~autotune_grid~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_cart_comm.html"},{"title":"get_z_slab – dtFFT","text":"public pure function get_z_slab() Whether Z-slab optimization is enabled or not Arguments None Return Value logical Calls proc~~get_z_slab~~CallsGraph proc~get_z_slab get_z_slab proc~get_z_slab_from_env get_z_slab_from_env proc~get_z_slab->proc~get_z_slab_from_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_z_slab~~CalledByGraph proc~get_z_slab get_z_slab proc~create~12 abstract_transpose_plan%create proc~create~12->proc~get_z_slab Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_z_slab.html"},{"title":"get_user_platform – dtFFT","text":"public pure function get_user_platform() Returns platform set by the user or default one Arguments None Return Value type( dtfft_platform_t ) Calls proc~~get_user_platform~~CallsGraph proc~get_user_platform get_user_platform proc~get_platform_from_env get_platform_from_env proc~get_user_platform->proc~get_platform_from_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_user_platform~~CalledByGraph proc~get_user_platform get_user_platform proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~get_user_platform proc~create~12 abstract_transpose_plan%create proc~create~12->proc~get_user_platform proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_platform proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_user_platform.html"},{"title":"get_user_stream – dtFFT","text":"public  function get_user_stream() result(stream) Uses iso_c_binding iso_fortran_env proc~~get_user_stream~~UsesGraph proc~get_user_stream get_user_stream iso_c_binding iso_c_binding proc~get_user_stream->iso_c_binding iso_fortran_env iso_fortran_env proc~get_user_stream->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Returns either the custom provided by user or creates a new one Arguments None Return Value type( dtfft_stream_t ) Calls proc~~get_user_stream~~CallsGraph proc~get_user_stream get_user_stream interface~cudastreamcreate cudaStreamCreate proc~get_user_stream->interface~cudastreamcreate interface~int_to_str int_to_str proc~get_user_stream->interface~int_to_str mpi_abort mpi_abort proc~get_user_stream->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~get_user_stream->proc~cudageterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_user_stream~~CalledByGraph proc~get_user_stream get_user_stream proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_user_stream proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~get_user_stream proc~create~6 vkfft_executor%create proc~create~6->proc~get_user_stream proc~create~7 cufft_executor%create proc~create~7->proc~get_user_stream proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_user_stream.html"},{"title":"get_user_gpu_backend – dtFFT","text":"public pure function get_user_gpu_backend() Returns GPU backend set by the user or default one Arguments None Return Value type( dtfft_backend_t ) Calls proc~~get_user_gpu_backend~~CallsGraph proc~get_user_gpu_backend get_user_gpu_backend proc~get_backend_from_env get_backend_from_env proc~get_user_gpu_backend->proc~get_backend_from_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_user_gpu_backend~~CalledByGraph proc~get_user_gpu_backend get_user_gpu_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_user_gpu_backend proc~create_private~2 dtfft_plan_t%create_private proc~create_private~2->proc~get_user_gpu_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private~2 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private~2 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_user_gpu_backend.html"},{"title":"get_pipelined_enabled – dtFFT","text":"public pure function get_pipelined_enabled() Whether pipelined backends are enabled or not Arguments None Return Value logical Calls proc~~get_pipelined_enabled~~CallsGraph proc~get_pipelined_enabled get_pipelined_enabled proc~get_pipe_enabled_from_env get_pipe_enabled_from_env proc~get_pipelined_enabled->proc~get_pipe_enabled_from_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_pipelined_enabled~~CalledByGraph proc~get_pipelined_enabled get_pipelined_enabled proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~get_pipelined_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_pipelined_enabled.html"},{"title":"get_mpi_enabled – dtFFT","text":"public pure function get_mpi_enabled() Whether MPI backends are enabled or not Arguments None Return Value logical Calls proc~~get_mpi_enabled~~CallsGraph proc~get_mpi_enabled get_mpi_enabled proc~get_mpi_enabled_from_env get_mpi_enabled_from_env proc~get_mpi_enabled->proc~get_mpi_enabled_from_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_mpi_enabled~~CalledByGraph proc~get_mpi_enabled get_mpi_enabled proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_mpi_enabled proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~get_mpi_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_mpi_enabled.html"},{"title":"get_nccl_enabled – dtFFT","text":"public pure function get_nccl_enabled() Whether NCCL backends are enabled or not Arguments None Return Value logical Calls proc~~get_nccl_enabled~~CallsGraph proc~get_nccl_enabled get_nccl_enabled proc~get_nccl_enabled_from_env get_nccl_enabled_from_env proc~get_nccl_enabled->proc~get_nccl_enabled_from_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nccl_enabled~~CalledByGraph proc~get_nccl_enabled get_nccl_enabled proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_nccl_enabled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nccl_enabled.html"},{"title":"get_nvshmem_enabled – dtFFT","text":"public pure function get_nvshmem_enabled() Whether nvshmem backends are enabled or not Arguments None Return Value logical Calls proc~~get_nvshmem_enabled~~CallsGraph proc~get_nvshmem_enabled get_nvshmem_enabled proc~get_nvshmem_enabled_from_env get_nvshmem_enabled_from_env proc~get_nvshmem_enabled->proc~get_nvshmem_enabled_from_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nvshmem_enabled~~CalledByGraph proc~get_nvshmem_enabled get_nvshmem_enabled proc~create_cuda transpose_plan_cuda%create_cuda proc~create_cuda->proc~get_nvshmem_enabled proc~run_autotune_backend run_autotune_backend proc~create_cuda->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create_cuda->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~get_nvshmem_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nvshmem_enabled.html"},{"title":"config_constructor – dtFFT","text":"private pure function config_constructor(enable_z_slab, platform, stream, backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config Called by proc~~config_constructor~~CalledByGraph proc~config_constructor config_constructor interface~dtfft_config_t dtfft_config_t interface~dtfft_config_t->proc~config_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/config_constructor.html"},{"title":"dtfft_create_config – dtFFT","text":"public pure subroutine dtfft_create_config(config) bind(C, name=\"dtfft_create_config_c\") Creates a new configuration with default values. C interface Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(out) :: config Configuration to create","tags":"","loc":"proc/dtfft_create_config.html"},{"title":"dtfft_set_config – dtFFT","text":"public  subroutine dtfft_set_config(config, error_code) Sets configuration parameters Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(in) :: config Configuration to set integer(kind=int32), intent(out), optional :: error_code Error code Calls proc~~dtfft_set_config~~CallsGraph proc~dtfft_set_config dtfft_set_config interface~cudastreamquery cudaStreamQuery proc~dtfft_set_config->interface~cudastreamquery is_null_ptr is_null_ptr proc~dtfft_set_config->is_null_ptr proc~is_valid_gpu_backend is_valid_gpu_backend proc~dtfft_set_config->proc~is_valid_gpu_backend proc~is_valid_platform is_valid_platform proc~dtfft_set_config->proc~is_valid_platform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dtfft_set_config~~CalledByGraph proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_set_config.html"},{"title":"destroy_stream – dtFFT","text":"public  subroutine destroy_stream() Uses iso_c_binding iso_fortran_env proc~~destroy_stream~~UsesGraph proc~destroy_stream destroy_stream iso_c_binding iso_c_binding proc~destroy_stream->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy_stream->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroy the default stream if it was created Arguments None Calls proc~~destroy_stream~~CallsGraph proc~destroy_stream destroy_stream interface~cudastreamdestroy cudaStreamDestroy proc~destroy_stream->interface~cudastreamdestroy interface~int_to_str int_to_str proc~destroy_stream->interface~int_to_str mpi_abort mpi_abort proc~destroy_stream->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy_stream->proc~cudageterrorstring proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_stream~~CalledByGraph proc~destroy_stream destroy_stream proc~destroy~9 dtfft_plan_t%destroy proc~destroy~9->proc~destroy_stream proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_stream.html"},{"title":"dtfft_config_t – dtFFT","text":"public interface dtfft_config_t Interface to create a new configuration Calls interface~~dtfft_config_t~~CallsGraph interface~dtfft_config_t dtfft_config_t proc~config_constructor config_constructor interface~dtfft_config_t->proc~config_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function config_constructor (enable_z_slab, platform, stream, backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config","tags":"","loc":"interface/dtfft_config_t.html"},{"title":"get_comm – dtFFT","text":"private pure function get_comm(c_comm) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: c_comm Return Value type(mpi_comm) Called by proc~~get_comm~~CalledByGraph proc~get_comm get_comm proc~dtfft_create_plan_c2c_c dtfft_create_plan_c2c_c proc~dtfft_create_plan_c2c_c->proc~get_comm proc~dtfft_create_plan_c2c_pencil_c dtfft_create_plan_c2c_pencil_c proc~dtfft_create_plan_c2c_pencil_c->proc~get_comm proc~dtfft_create_plan_r2r_c dtfft_create_plan_r2r_c proc~dtfft_create_plan_r2r_c->proc~get_comm proc~dtfft_create_plan_r2r_pencil_c dtfft_create_plan_r2r_pencil_c proc~dtfft_create_plan_r2r_pencil_c->proc~get_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_comm.html"},{"title":"dtfft_create_plan_r2r_c – dtFFT","text":"private  function dtfft_create_plan_r2r_c(ndims, dims, kinds, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates R2R dtFFT Plan, allocates all structures and prepares FFT, C/C++/Python interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: ndims Rank of transform. Can be 2 or 3. type(c_ptr), intent(in), value :: dims Global sizes of transform type(c_ptr), intent(in), value :: kinds FFT R2R kinds integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_create_plan_r2r_c~~CallsGraph proc~dtfft_create_plan_r2r_c dtfft_create_plan_r2r_c create create proc~dtfft_create_plan_r2r_c->create proc~get_comm get_comm proc~dtfft_create_plan_r2r_c->proc~get_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_create_plan_r2r_c.html"},{"title":"dtfft_create_plan_r2r_pencil_c – dtFFT","text":"private  function dtfft_create_plan_r2r_pencil_c(pencil, kinds, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates R2R dtFFT Plan from Pencil, allocates all structures and prepares FFT, C/C++/Python interface Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: pencil C pointer to Fortran pencil type(c_ptr), intent(in), value :: kinds FFT R2R kinds integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_create_plan_r2r_pencil_c~~CallsGraph proc~dtfft_create_plan_r2r_pencil_c dtfft_create_plan_r2r_pencil_c create create proc~dtfft_create_plan_r2r_pencil_c->create proc~get_comm get_comm proc~dtfft_create_plan_r2r_pencil_c->proc~get_comm proc~pencil_c2f pencil_c2f proc~dtfft_create_plan_r2r_pencil_c->proc~pencil_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_create_plan_r2r_pencil_c.html"},{"title":"dtfft_create_plan_c2c_c – dtFFT","text":"private  function dtfft_create_plan_c2c_c(ndims, dims, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates C2C dtFFT Plan, allocates all structures and prepares FFT, C/C++ interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: ndims Rank of transform. Can be 2 or 3. type(c_ptr), intent(in), value :: dims Global sizes of transform integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_create_plan_c2c_c~~CallsGraph proc~dtfft_create_plan_c2c_c dtfft_create_plan_c2c_c create create proc~dtfft_create_plan_c2c_c->create proc~get_comm get_comm proc~dtfft_create_plan_c2c_c->proc~get_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_create_plan_c2c_c.html"},{"title":"dtfft_create_plan_c2c_pencil_c – dtFFT","text":"private  function dtfft_create_plan_c2c_pencil_c(pencil, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates C2C dtFFT plan from Pencil, allocates all structures and prepares FFT, C/C++/Python interface Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: pencil C pointer to Fortran pencil integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_create_plan_c2c_pencil_c~~CallsGraph proc~dtfft_create_plan_c2c_pencil_c dtfft_create_plan_c2c_pencil_c create create proc~dtfft_create_plan_c2c_pencil_c->create proc~get_comm get_comm proc~dtfft_create_plan_c2c_pencil_c->proc~get_comm proc~pencil_c2f pencil_c2f proc~dtfft_create_plan_c2c_pencil_c->proc~pencil_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_create_plan_c2c_pencil_c.html"},{"title":"dtfft_get_z_slab_enabled_c – dtFFT","text":"private  function dtfft_get_z_slab_enabled_c(plan_ptr, is_z_slab_enabled) result(error_code) bind(C) Checks if dtFFT Plan is using Z-slab optimization Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan logical(kind=c_bool), intent(out) :: is_z_slab_enabled Is plan internally using Z-slab optimization Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_z_slab_enabled_c~~CallsGraph proc~dtfft_get_z_slab_enabled_c dtfft_get_z_slab_enabled_c is_null_ptr is_null_ptr proc~dtfft_get_z_slab_enabled_c->is_null_ptr proc~get_z_slab_enabled dtfft_plan_t%get_z_slab_enabled proc~dtfft_get_z_slab_enabled_c->proc~get_z_slab_enabled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_z_slab_enabled_c.html"},{"title":"dtfft_execute_c – dtFFT","text":"private  function dtfft_execute_c(plan_ptr, in, out, execute_type, aux) result(error_code) bind(C) Executes dtFFT Plan, C/C++ interface. aux can be NULL. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_execute_t ), intent(in) :: execute_type Type of execution type(c_ptr), intent(in), value :: aux Aux buffer, can be NULL Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_execute_c~~CallsGraph proc~dtfft_execute_c dtfft_execute_c is_null_ptr is_null_ptr proc~dtfft_execute_c->is_null_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~dtfft_execute_c->proc~execute_ptr proc~execute_ptr->is_null_ptr proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~check_device_pointers check_device_pointers proc~execute_ptr->proc~check_device_pointers proc~dtfft_get_error_string dtfft_get_error_string proc~execute_ptr->proc~dtfft_get_error_string proc~execute_private~2 dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private~2 proc~get_backend~2 abstract_transpose_plan%get_backend proc~execute_ptr->proc~get_backend~2 proc~get_log_enabled get_log_enabled proc~execute_ptr->proc~get_log_enabled proc~is_same_ptr is_same_ptr proc~execute_ptr->proc~is_same_ptr proc~is_valid_execute_type is_valid_execute_type proc~execute_ptr->proc~is_valid_execute_type proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute_ptr->proc~push_nvtx_domain_range proc~write_message write_message proc~execute_ptr->proc~write_message proc~check_aux->is_null_ptr proc~check_aux->proc~dtfft_get_error_string mpi_abort mpi_abort proc~check_aux->mpi_abort proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~check_device_pointers->is_null_ptr interface~is_device_ptr is_device_ptr proc~check_device_pointers->interface~is_device_ptr proc~is_backend_nvshmem is_backend_nvshmem proc~check_device_pointers->proc~is_backend_nvshmem proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers->proc~is_nvshmem_ptr proc~execute~12 abstract_transpose_plan%execute proc~execute_private~2->proc~execute~12 interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~12->proc~pop_nvtx_domain_range proc~execute~12->proc~push_nvtx_domain_range execute_private execute_private proc~execute~12->execute_private proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~get_log_enabled proc~get_element_size->proc~write_message proc~is_nvshmem_ptr->is_null_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr proc~mem_alloc_ptr->is_null_ptr proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_ptr->proc~get_log_enabled proc~mem_alloc_ptr->proc~write_message interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~get_local_sizes->proc~dtfft_get_error_string proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes->proc~get_log_enabled proc~get_local_sizes->proc~write_message proc~get_local_sizes->proc~is_backend_nvshmem counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 starts starts proc~get_local_sizes->starts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_execute_c.html"},{"title":"dtfft_transpose_c – dtFFT","text":"private  function dtfft_transpose_c(plan_ptr, in, out, transpose_type) result(error_code) bind(C) Executes single transposition, C/C++ interface. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_transpose_c~~CallsGraph proc~dtfft_transpose_c dtfft_transpose_c is_null_ptr is_null_ptr proc~dtfft_transpose_c->is_null_ptr proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~dtfft_transpose_c->proc~transpose_ptr proc~check_device_pointers check_device_pointers proc~transpose_ptr->proc~check_device_pointers proc~dtfft_get_error_string dtfft_get_error_string proc~transpose_ptr->proc~dtfft_get_error_string proc~execute~12 abstract_transpose_plan%execute proc~transpose_ptr->proc~execute~12 proc~get_backend~2 abstract_transpose_plan%get_backend proc~transpose_ptr->proc~get_backend~2 proc~get_log_enabled get_log_enabled proc~transpose_ptr->proc~get_log_enabled proc~is_same_ptr is_same_ptr proc~transpose_ptr->proc~is_same_ptr proc~is_valid_transpose_type is_valid_transpose_type proc~transpose_ptr->proc~is_valid_transpose_type proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_ptr->proc~push_nvtx_domain_range proc~write_message write_message proc~transpose_ptr->proc~write_message proc~check_device_pointers->is_null_ptr interface~is_device_ptr is_device_ptr proc~check_device_pointers->interface~is_device_ptr proc~is_backend_nvshmem is_backend_nvshmem proc~check_device_pointers->proc~is_backend_nvshmem proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers->proc~is_nvshmem_ptr proc~execute~12->proc~pop_nvtx_domain_range proc~execute~12->proc~push_nvtx_domain_range execute_private execute_private proc~execute~12->execute_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~is_nvshmem_ptr->is_null_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_transpose_c.html"},{"title":"dtfft_destroy_c – dtFFT","text":"private  function dtfft_destroy_c(plan_ptr) result(error_code) bind(C) Destroys dtFFT Plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_destroy_c~~CallsGraph proc~dtfft_destroy_c dtfft_destroy_c is_null_ptr is_null_ptr proc~dtfft_destroy_c->is_null_ptr proc~destroy~9 dtfft_plan_t%destroy proc~dtfft_destroy_c->proc~destroy~9 destroy destroy proc~destroy~9->destroy mpi_comm_free mpi_comm_free proc~destroy~9->mpi_comm_free mpi_finalized mpi_finalized proc~destroy~9->mpi_finalized proc~clean_unused_cache clean_unused_cache proc~destroy~9->proc~clean_unused_cache proc~destroy_stream destroy_stream proc~destroy~9->proc~destroy_stream proc~dtfft_get_error_string dtfft_get_error_string proc~destroy~9->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~destroy~9->proc~get_log_enabled proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~9->proc~mem_free_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~destroy~9->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~destroy~9->proc~push_nvtx_domain_range proc~write_message write_message proc~destroy~9->proc~write_message proc~clean_unused_cache->is_null_ptr interface~int_to_str int_to_str proc~clean_unused_cache->interface~int_to_str mpi_abort mpi_abort proc~clean_unused_cache->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~clean_unused_cache->proc~cudageterrorstring interface~cudastreamdestroy cudaStreamDestroy proc~destroy_stream->interface~cudastreamdestroy proc~destroy_stream->interface~int_to_str proc~destroy_stream->mpi_abort proc~destroy_stream->proc~cudageterrorstring proc~mem_free_ptr->proc~dtfft_get_error_string proc~mem_free_ptr->proc~get_log_enabled proc~mem_free_ptr->proc~write_message interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~write_message->mpi_finalized mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_destroy_c.html"},{"title":"dtfft_get_local_sizes_c – dtFFT","text":"private  function dtfft_get_local_sizes_c(plan_ptr, in_starts, in_counts, out_starts, out_counts, alloc_size) result(error_code) bind(C) Returns local sizes, counts in real and Fourier spaces and number of elements to be allocated for in and out buffers,\nC/C++ interface. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int32_t), intent(out), optional :: in_starts (3) Starts of local portion of data in ‘real’ space integer(kind=c_int32_t), intent(out), optional :: in_counts (3) Counts of local portion of data in ‘real’ space integer(kind=c_int32_t), intent(out), optional :: out_starts (3) Starts of local portion of data in ‘fourier’ space integer(kind=c_int32_t), intent(out), optional :: out_counts (3) Counts of local portion of data in ‘fourier’ space integer(kind=c_size_t), intent(out), optional :: alloc_size Minimum data needs to be allocated Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_local_sizes_c~~CallsGraph proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c is_null_ptr is_null_ptr proc~dtfft_get_local_sizes_c->is_null_ptr proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~dtfft_get_local_sizes_c->proc~get_local_sizes counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~dtfft_get_error_string dtfft_get_error_string proc~get_local_sizes->proc~dtfft_get_error_string proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_backend~2 abstract_transpose_plan%get_backend proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 proc~get_log_enabled get_log_enabled proc~get_local_sizes->proc~get_log_enabled proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes->proc~is_backend_nvshmem proc~write_message write_message proc~get_local_sizes->proc~write_message starts starts proc~get_local_sizes->starts mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_local_sizes_c.html"},{"title":"dtfft_get_alloc_size_c – dtFFT","text":"private  function dtfft_get_alloc_size_c(plan_ptr, alloc_size) result(error_code) bind(C) Returns minimum number of bytes to be allocated for in and out buffers, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: alloc_size Minimum data needs to be allocated Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_alloc_size_c~~CallsGraph proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c is_null_ptr is_null_ptr proc~dtfft_get_alloc_size_c->is_null_ptr proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~dtfft_get_error_string dtfft_get_error_string proc~get_local_sizes->proc~dtfft_get_error_string proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_backend~2 abstract_transpose_plan%get_backend proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 proc~get_log_enabled get_log_enabled proc~get_local_sizes->proc~get_log_enabled proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes->proc~is_backend_nvshmem proc~write_message write_message proc~get_local_sizes->proc~write_message starts starts proc~get_local_sizes->starts mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_alloc_size_c.html"},{"title":"dtfft_get_pencil_c – dtFFT","text":"private  function dtfft_get_pencil_c(plan_ptr, dim, pencil) result(error_code) bind(C) Returns pencil decomposition info, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int32_t), intent(in) :: dim Dimension requested type( dtfft_pencil_c ) :: pencil Pencil pointer Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_pencil_c~~CallsGraph proc~dtfft_get_pencil_c dtfft_get_pencil_c is_null_ptr is_null_ptr proc~dtfft_get_pencil_c->is_null_ptr proc~get_pencil dtfft_plan_t%get_pencil proc~dtfft_get_pencil_c->proc~get_pencil proc~pencil_f2c pencil_f2c proc~dtfft_get_pencil_c->proc~pencil_f2c make_public make_public proc~get_pencil->make_public proc~dtfft_get_error_string dtfft_get_error_string proc~get_pencil->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_pencil->proc~get_log_enabled proc~write_message write_message proc~get_pencil->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_pencil_c.html"},{"title":"dtfft_get_element_size_c – dtFFT","text":"private  function dtfft_get_element_size_c(plan_ptr, element_size) result(error_code) bind(C) Returns size of element in bytes, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: element_size Size of element in bytes Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_element_size_c~~CallsGraph proc~dtfft_get_element_size_c dtfft_get_element_size_c is_null_ptr is_null_ptr proc~dtfft_get_element_size_c->is_null_ptr proc~get_element_size dtfft_plan_t%get_element_size proc~dtfft_get_element_size_c->proc~get_element_size proc~dtfft_get_error_string dtfft_get_error_string proc~get_element_size->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_element_size->proc~get_log_enabled proc~write_message write_message proc~get_element_size->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_element_size_c.html"},{"title":"dtfft_get_alloc_bytes_c – dtFFT","text":"private  function dtfft_get_alloc_bytes_c(plan_ptr, alloc_bytes) result(error_code) bind(C) Returns minimum number of bytes required to execute plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: alloc_bytes Number of bytes required Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_alloc_bytes_c~~CallsGraph proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c is_null_ptr is_null_ptr proc~dtfft_get_alloc_bytes_c->is_null_ptr proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~dtfft_get_error_string dtfft_get_error_string proc~get_alloc_bytes->proc~dtfft_get_error_string proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_bytes->proc~get_alloc_size proc~get_element_size dtfft_plan_t%get_element_size proc~get_alloc_bytes->proc~get_element_size proc~get_log_enabled get_log_enabled proc~get_alloc_bytes->proc~get_log_enabled proc~write_message write_message proc~get_alloc_bytes->proc~write_message proc~get_local_sizes dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~get_log_enabled proc~get_element_size->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_local_sizes->proc~dtfft_get_error_string proc~get_local_sizes->proc~get_log_enabled proc~get_local_sizes->proc~write_message counts counts proc~get_local_sizes->counts mpi_allreduce mpi_allreduce proc~get_local_sizes->mpi_allreduce proc~get_aux_size~4 abstract_transpose_plan%get_aux_size proc~get_local_sizes->proc~get_aux_size~4 proc~get_backend~2 abstract_transpose_plan%get_backend proc~get_local_sizes->proc~get_backend~2 proc~get_local_sizes~2 get_local_sizes proc~get_local_sizes->proc~get_local_sizes~2 proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes->proc~is_backend_nvshmem starts starts proc~get_local_sizes->starts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_alloc_bytes_c.html"},{"title":"dtfft_get_executor_c – dtFFT","text":"private  function dtfft_get_executor_c(plan_ptr, executor) result(error_code) bind(C) Returns executor type used in plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_executor_t ), intent(out) :: executor The enumerated type dtfft_executor_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_executor_c~~CallsGraph proc~dtfft_get_executor_c dtfft_get_executor_c is_null_ptr is_null_ptr proc~dtfft_get_executor_c->is_null_ptr proc~get_executor dtfft_plan_t%get_executor proc~dtfft_get_executor_c->proc~get_executor proc~dtfft_get_error_string dtfft_get_error_string proc~get_executor->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_executor->proc~get_log_enabled proc~write_message write_message proc~get_executor->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_executor_c.html"},{"title":"dtfft_get_precision_c – dtFFT","text":"private  function dtfft_get_precision_c(plan_ptr, precision) result(error_code) bind(C) Returns precision used in plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_precision_t ), intent(out) :: precision The enumerated type dtfft_precision_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_precision_c~~CallsGraph proc~dtfft_get_precision_c dtfft_get_precision_c is_null_ptr is_null_ptr proc~dtfft_get_precision_c->is_null_ptr proc~get_precision dtfft_plan_t%get_precision proc~dtfft_get_precision_c->proc~get_precision proc~dtfft_get_error_string dtfft_get_error_string proc~get_precision->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_precision->proc~get_log_enabled proc~write_message write_message proc~get_precision->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_precision_c.html"},{"title":"dtfft_get_dims_c – dtFFT","text":"private  function dtfft_get_dims_c(plan_ptr, ndims, dims) result(error_code) bind(C) Returns dimensions of plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int8_t), intent(out) :: ndims Number of dimensions type(c_ptr), intent(out) :: dims Array of dimensions Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_dims_c~~CallsGraph proc~dtfft_get_dims_c dtfft_get_dims_c is_null_ptr is_null_ptr proc~dtfft_get_dims_c->is_null_ptr proc~get_dims dtfft_plan_t%get_dims proc~dtfft_get_dims_c->proc~get_dims proc~dtfft_get_error_string dtfft_get_error_string proc~get_dims->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_dims->proc~get_log_enabled proc~write_message write_message proc~get_dims->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_dims_c.html"},{"title":"dtfft_set_config_c – dtFFT","text":"private  function dtfft_set_config_c(config) result(error_code) bind(C) Sets dtFFT configuration, C/C++ interface Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(in) :: config Configuration to set Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_set_config_c~~CallsGraph proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config_c->proc~dtfft_set_config interface~cudastreamquery cudaStreamQuery proc~dtfft_set_config->interface~cudastreamquery is_null_ptr is_null_ptr proc~dtfft_set_config->is_null_ptr proc~is_valid_gpu_backend is_valid_gpu_backend proc~dtfft_set_config->proc~is_valid_gpu_backend proc~is_valid_platform is_valid_platform proc~dtfft_set_config->proc~is_valid_platform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_set_config_c.html"},{"title":"dtfft_report_c – dtFFT","text":"private  function dtfft_report_c(plan_ptr) result(error_code) bind(C) Reports dtFFT Plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_report_c~~CallsGraph proc~dtfft_report_c dtfft_report_c is_null_ptr is_null_ptr proc~dtfft_report_c->is_null_ptr proc~report dtfft_plan_t%report proc~dtfft_report_c->proc~report interface~dtfft_get_version dtfft_get_version proc~report->interface~dtfft_get_version interface~int_to_str int_to_str proc~report->interface~int_to_str mpi_comm_size mpi_comm_size proc~report->mpi_comm_size proc~dtfft_get_backend_string dtfft_get_backend_string proc~report->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~report->proc~dtfft_get_error_string proc~dtfft_get_executor_string dtfft_get_executor_string proc~report->proc~dtfft_get_executor_string proc~dtfft_get_precision_string dtfft_get_precision_string proc~report->proc~dtfft_get_precision_string proc~get_backend~2 abstract_transpose_plan%get_backend proc~report->proc~get_backend~2 proc~get_log_enabled get_log_enabled proc~report->proc~get_log_enabled proc~write_message write_message proc~report->proc~write_message proc~dtfft_get_version_current dtfft_get_version_current interface~dtfft_get_version->proc~dtfft_get_version_current proc~dtfft_get_version_required dtfft_get_version_required interface~dtfft_get_version->proc~dtfft_get_version_required proc~int_to_str_int32 int_to_str_int32 interface~int_to_str->proc~int_to_str_int32 proc~int_to_str_int64 int_to_str_int64 interface~int_to_str->proc~int_to_str_int64 proc~int_to_str_int8 int_to_str_int8 interface~int_to_str->proc~int_to_str_int8 mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_report_c.html"},{"title":"dtfft_mem_alloc_c – dtFFT","text":"private  function dtfft_mem_alloc_c(plan_ptr, alloc_bytes, ptr) result(error_code) bind(C) Allocates memory for dtFFT Plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), value :: alloc_bytes Number of bytes to allocate type(c_ptr) :: ptr Allocated pointer Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_mem_alloc_c~~CallsGraph proc~dtfft_mem_alloc_c dtfft_mem_alloc_c is_null_ptr is_null_ptr proc~dtfft_mem_alloc_c->is_null_ptr proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~mem_alloc_ptr->is_null_ptr interface~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->interface~mem_alloc_host mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_alloc_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_alloc_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_mem_alloc_c.html"},{"title":"dtfft_mem_free_c – dtFFT","text":"private  function dtfft_mem_free_c(plan_ptr, ptr) result(error_code) bind(C) Frees memory for dtFFT Plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type(c_ptr), value :: ptr Pointer to deallocate Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_mem_free_c~~CallsGraph proc~dtfft_mem_free_c dtfft_mem_free_c is_null_ptr is_null_ptr proc~dtfft_mem_free_c->is_null_ptr proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~dtfft_mem_free_c->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~mem_free_ptr->proc~get_log_enabled proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_mem_free_c.html"},{"title":"dtfft_get_stream_c – dtFFT","text":"private  function dtfft_get_stream_c(plan_ptr, stream) result(error_code) bind(C) Returns Stream associated with plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_stream_t ), intent(out) :: stream CUDA stream Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_stream_c~~CallsGraph proc~dtfft_get_stream_c dtfft_get_stream_c is_null_ptr is_null_ptr proc~dtfft_get_stream_c->is_null_ptr none~get_stream dtfft_plan_t%get_stream proc~dtfft_get_stream_c->none~get_stream proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream->proc~get_stream_int64 proc~get_stream_ptr dtfft_plan_t%get_stream_ptr none~get_stream->proc~get_stream_ptr proc~get_stream_int64->none~get_stream proc~dtfft_get_cuda_stream dtfft_get_cuda_stream proc~get_stream_int64->proc~dtfft_get_cuda_stream proc~dtfft_get_error_string dtfft_get_error_string proc~get_stream_ptr->proc~dtfft_get_error_string proc~get_log_enabled get_log_enabled proc~get_stream_ptr->proc~get_log_enabled proc~write_message write_message proc~get_stream_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_stream_c.html"},{"title":"dtfft_get_backend_c – dtFFT","text":"private  function dtfft_get_backend_c(plan_ptr, backend) result(error_code) bind(C) Returns selected dtfft_backend_t during autotuning Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_backend_t ), intent(out) :: backend The enumerated type dtfft_backend_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_backend_c~~CallsGraph proc~dtfft_get_backend_c dtfft_get_backend_c is_null_ptr is_null_ptr proc~dtfft_get_backend_c->is_null_ptr proc~get_backend dtfft_plan_t%get_backend proc~dtfft_get_backend_c->proc~get_backend proc~get_backend~2 abstract_transpose_plan%get_backend proc~get_backend->proc~get_backend~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_backend_c.html"},{"title":"dtfft_get_platform_c – dtFFT","text":"private  function dtfft_get_platform_c(plan_ptr, platform) result(error_code) bind(C) Returns selected dtfft_platform_t during autotuning Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_platform_t ), intent(out) :: platform The enumerated type dtfft_platform_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_platform_c~~CallsGraph proc~dtfft_get_platform_c dtfft_get_platform_c is_null_ptr is_null_ptr proc~dtfft_get_platform_c->is_null_ptr proc~get_platform dtfft_plan_t%get_platform proc~dtfft_get_platform_c->proc~get_platform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_platform_c.html"},{"title":"dtfft_get_error_string_c – dtFFT","text":"private  subroutine dtfft_get_error_string_c(error_code, error_string, error_string_size) bind(C) Returns an explaination of error_code that could have been previously returned by one of dtFFT API calls,\nC/C++ interface Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: error_code The enumerated type dtfft_error_t\ndefines API call result codes. character(len=c_char), intent(out) :: error_string (*) Explanation of error integer(kind=c_size_t), intent(out) :: error_string_size Size of error_string Calls proc~~dtfft_get_error_string_c~~CallsGraph proc~dtfft_get_error_string_c dtfft_get_error_string_c proc~dtfft_get_error_string dtfft_get_error_string proc~dtfft_get_error_string_c->proc~dtfft_get_error_string proc~string_f2c string_f2c proc~dtfft_get_error_string_c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_error_string_c.html"},{"title":"dtfft_get_precision_string_c – dtFFT","text":"private  subroutine dtfft_get_precision_string_c(precision, precision_string, precision_string_size) bind(C) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: precision The enumerated type dtfft_precision_t character(len=c_char), intent(out) :: precision_string (*) Resulting string integer(kind=c_size_t), intent(out) :: precision_string_size Size of string Calls proc~~dtfft_get_precision_string_c~~CallsGraph proc~dtfft_get_precision_string_c dtfft_get_precision_string_c proc~dtfft_get_precision_string dtfft_get_precision_string proc~dtfft_get_precision_string_c->proc~dtfft_get_precision_string proc~string_f2c string_f2c proc~dtfft_get_precision_string_c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_precision_string_c.html"},{"title":"dtfft_get_executor_string_c – dtFFT","text":"private  subroutine dtfft_get_executor_string_c(executor, executor_string, executor_string_size) bind(C) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: executor The enumerated type dtfft_executor_t character(len=c_char), intent(out) :: executor_string (*) Resulting string integer(kind=c_size_t), intent(out) :: executor_string_size Size of string Calls proc~~dtfft_get_executor_string_c~~CallsGraph proc~dtfft_get_executor_string_c dtfft_get_executor_string_c proc~dtfft_get_executor_string dtfft_get_executor_string proc~dtfft_get_executor_string_c->proc~dtfft_get_executor_string proc~string_f2c string_f2c proc~dtfft_get_executor_string_c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_executor_string_c.html"},{"title":"dtfft_get_backend_string_c – dtFFT","text":"private  subroutine dtfft_get_backend_string_c(backend, backend_string, backend_string_size) bind(C) Returns string representation of dtfft_backend_t Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: backend The enumerated type dtfft_backend_t character(len=c_char), intent(out) :: backend_string (*) Resulting string integer(kind=c_size_t), intent(out) :: backend_string_size Size of string Calls proc~~dtfft_get_backend_string_c~~CallsGraph proc~dtfft_get_backend_string_c dtfft_get_backend_string_c proc~dtfft_get_backend_string dtfft_get_backend_string proc~dtfft_get_backend_string_c->proc~dtfft_get_backend_string proc~string_f2c string_f2c proc~dtfft_get_backend_string_c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_backend_string_c.html"},{"title":"dtfft_abstract_executor – dtFFT","text":"This module describes Abstraction for all FFT Executors: abstract_executor Uses dtfft_parameters iso_fortran_env iso_c_binding dtfft_interface_nvtx dtfft_pencil dtfft_utils dtfft_errors module~~dtfft_abstract_executor~~UsesGraph module~dtfft_abstract_executor dtfft_abstract_executor iso_c_binding iso_c_binding module~dtfft_abstract_executor->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_abstract_executor->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_abstract_executor~~UsedByGraph module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int8), public, parameter :: FFT_C2C = 0 Complex to complex FFT integer(kind=int8), public, parameter :: FFT_R2C = 1 Real to complex FFT integer(kind=int8), public, parameter :: FFT_R2R = 2 Real to real FFT integer(kind=int8), public, parameter :: FFT_1D = 1 1D FFT integer(kind=int8), public, parameter :: FFT_2D = 2 2D FFT Abstract Interfaces abstract interface private  subroutine create_interface(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform abstract interface private  subroutine execute_interface(self, a, b, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform abstract interface private  subroutine destroy_interface(self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor abstract interface private  subroutine mem_alloc_interface(alloc_bytes, ptr) Allocates aligned memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer abstract interface private  subroutine mem_free_interface(ptr) Frees aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free Derived Types type, public, abstract :: abstract_executor The “most” abstract executor.\nAll FFT executors are extending this class. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? logical, private :: is_created = .false. Is plan created? Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure( mem_alloc_interface ), public, deferred, nopass :: mem_alloc ../../ Allocates aligned memory procedure( mem_free_interface ), public, deferred, nopass :: mem_free ../../ Frees aligned memory procedure( create_interface ), public, deferred, pass(self) :: create_private ../../ Creates FFT plan procedure( execute_interface ), public, deferred, pass(self) :: execute_private ../../ Executes plan procedure( destroy_interface ), public, deferred, pass(self) :: destroy_private ../../ Destroys plan Functions private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) Subroutines private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor","tags":"","loc":"module/dtfft_abstract_executor.html"},{"title":"dtfft_interface_mkl_native_m – dtFFT","text":"This module creates native interface with MKL library Uses MKL_DFTI module~~dtfft_interface_mkl_native_m~~UsesGraph module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_mkl_native_m~~UsedByGraph module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/dtfft_interface_mkl_native_m.html"},{"title":"dtfft_backend_cufftmp_m – dtFFT","text":"cuFFTMp GPU Backend backend_cufftmp Uses dtfft_parameters dtfft_interface_nvshmem dtfft_interface_cuda_runtime iso_c_binding iso_fortran_env dtfft_interface_cufft dtfft_pencil dtfft_utils dtfft_abstract_backend mpi_f08 module~~dtfft_backend_cufftmp_m~~UsesGraph module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m iso_c_binding iso_c_binding module~dtfft_backend_cufftmp_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_parameters dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_backend_cufftmp_m->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_errors dtfft_errors module~dtfft_pencil->module~dtfft_errors module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_backend_cufftmp_m~~UsedByGraph module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_backend ) :: backend_cufftmp cuFFTMp GPU Backend Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer type( nvrtc_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), public, pointer :: unpack_kernel2 Kernel for unpacking data type( cufftReshapeHandle ), private :: plan Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates Abstract GPU Backend procedure, public, non_overridable, pass(self) :: execute ../../ Executes GPU Backend procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys Abstract GPU Backend procedure, public, non_overridable, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, non_overridable, pass(self) :: set_unpack_kernel ../../ Sets unpack kernel for pipelined backend procedure, public :: create_private => create procedure, public :: execute_private => execute procedure, public :: destroy_private => destroy type, private :: Box3D Components Type Visibility Attributes Name Initial integer(kind=c_long_long), public :: lower (3) integer(kind=c_long_long), public :: upper (3) integer(kind=c_long_long), public :: strides (3) Subroutines private  subroutine create (self, helper, tranpose_type, base_storage) Creates cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element private  subroutine execute (self, in, out, stream, aux) Executes cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer private  subroutine destroy (self) Destroys cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend","tags":"","loc":"module/dtfft_backend_cufftmp_m.html"},{"title":"dtfft_parameters – dtFFT","text":"This module defines common dtFFT parameters Uses iso_fortran_env iso_c_binding mpi_f08 module~~dtfft_parameters~~UsesGraph module~dtfft_parameters dtfft_parameters iso_c_binding iso_c_binding module~dtfft_parameters->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_parameters~~UsedByGraph module~dtfft_parameters dtfft_parameters module~dtfft dtfft module~dtfft->module~dtfft_parameters module~dtfft_config dtfft_config module~dtfft->module~dtfft_config module~dtfft_pencil dtfft_pencil module~dtfft->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_parameters module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_abstract_transpose_plan->module~dtfft_utils module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_parameters module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_pencil module~dtfft_api->module~dtfft_plan module~dtfft_api->module~dtfft_utils module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_utils module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_utils module~dtfft_plan->module~dtfft_parameters module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_utils module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_parameters module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_transpose_handle_cuda->module~dtfft_utils module~dtfft_transpose_handle_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_handle_host->module~dtfft_parameters module~dtfft_transpose_handle_host->module~dtfft_pencil module~dtfft_transpose_handle_host->module~dtfft_interface_nvtx module~dtfft_transpose_plan_cuda->module~dtfft_parameters module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_config module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvrtc module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda->module~dtfft_utils module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_plan_host->module~dtfft_parameters module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_pencil module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft_transpose_plan_host->module~dtfft_utils module~dtfft_transpose_plan_host->module~dtfft_interface_nvtx module~dtfft_utils->module~dtfft_parameters module~dtfft_interface_mkl_m->module~dtfft_utils module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DTFFT_VERSION_MAJOR = 2 dtFFT Major Version integer(kind=int32), public, parameter :: DTFFT_VERSION_MINOR = 1 dtFFT Minor Version integer(kind=int32), public, parameter :: DTFFT_VERSION_PATCH = 0 dtFFT Patch Version integer(kind=int32), public, parameter :: DTFFT_VERSION_CODE = 201000 dtFFT Version Code. Can be used in Version comparison type( dtfft_execute_t ), public, parameter :: DTFFT_EXECUTE_FORWARD = dtfft_execute_t(11) Perform XYZ –> YXZ –> ZXY plan execution (Forward) type( dtfft_execute_t ), public, parameter :: DTFFT_EXECUTE_BACKWARD = dtfft_execute_t(12) Perform ZXY –> YXZ –> XYZ plan execution (Backward) type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_X_TO_Y = dtfft_transpose_t(+1) Perform single transposition, from X aligned to Y aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_Y_TO_X = dtfft_transpose_t((-1)) Perform single transposition, from Y aligned to X aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_X_TO_Z = dtfft_transpose_t(+3) Perform single transposition, from X aligned to Z aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_Y_TO_Z = dtfft_transpose_t(+2) Perform single transposition, from Y aligned to Z aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_Z_TO_Y = dtfft_transpose_t((-2)) Perform single transposition, from Z aligned to Y aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_Z_TO_X = dtfft_transpose_t((-3)) Perform single transposition, from Z aligned to X aligned character(len=*), public, parameter :: TRANSPOSE_NAMES (-3:3) = [\"Z2X\", \"Z2Y\", \"Y2X\", \"NUL\", \"X2Y\", \"Y2Z\", \"X2Z\"] String representation of dtfft_transpose_t type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_NONE = dtfft_executor_t(0) Do not setup any executor. If this type is provided, then execute method should not be called.\nUse transpose method instead type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_FFTW3 = dtfft_executor_t(1) FFTW3 executor type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_MKL = dtfft_executor_t(2) MKL executor type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_CUFFT = dtfft_executor_t(3) cuFFT GPU executor type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_VKFFT = dtfft_executor_t(4) VkFFT GPU executor integer(kind=int8), public, parameter :: FFT_FORWARD = (-1) Forward c2c transform integer(kind=int8), public, parameter :: FFT_BACKWARD = (+1) Backward c2c transform type( dtfft_effort_t ), public, parameter :: DTFFT_ESTIMATE = dtfft_effort_t(0) Estimate flag. dtFFT will use default decomposition provided by MPI_Dims_create type( dtfft_effort_t ), public, parameter :: DTFFT_MEASURE = dtfft_effort_t(+1) Measure flag. dtFFT will run transpose routines to find the best grid decomposition.\nPassing this flag and MPI Communicator with Cartesian topology to plan%create makes dtFFT do nothing. type( dtfft_effort_t ), public, parameter :: DTFFT_PATIENT = dtfft_effort_t(+2) Patient flag. Same as DTFFT_MEASURE , but different MPI datatypes will also be tested type( dtfft_precision_t ), public, parameter :: DTFFT_SINGLE = dtfft_precision_t(0) Use single precision type( dtfft_precision_t ), public, parameter :: DTFFT_DOUBLE = dtfft_precision_t(+1) Use double precision type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DCT_1 = dtfft_r2r_kind_t(+3) DCT-I (Logical N=2*(n-1), inverse is DTFFT_DCT_1 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DCT_2 = dtfft_r2r_kind_t(+5) DCT-II (Logical N=2*n, inverse is DTFFT_DCT_3 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DCT_3 = dtfft_r2r_kind_t(+4) DCT-III (Logical N=2*n, inverse is DTFFT_DCT_2 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DCT_4 = dtfft_r2r_kind_t(+6) DCT-IV (Logical N=2*n, inverse is DTFFT_DCT_4 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DST_1 = dtfft_r2r_kind_t(+7) DST-I (Logical N=2*(n+1), inverse is DTFFT_DST_1 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DST_2 = dtfft_r2r_kind_t(+9) DST-II (Logical N=2*n, inverse is DTFFT_DST_3 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DST_3 = dtfft_r2r_kind_t(+8) DST-III (Logical N=2*n, inverse is DTFFT_DST_2 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DST_4 = dtfft_r2r_kind_t(+10) DST-IV (Logical N=2*n, inverse is DTFFT_DST_4 ) integer(kind=int64), public, parameter :: DOUBLE_COMPLEX_STORAGE_SIZE = storage_size((1._real64, 1._real64))/8_int64 Number of bytes to store single double precision complex element integer(kind=int64), public, parameter :: COMPLEX_STORAGE_SIZE = storage_size((1._real32, 1._real32))/8_int64 Number of bytes to store single float precision complex element integer(kind=int64), public, parameter :: DOUBLE_STORAGE_SIZE = storage_size(1._real64)/8_int64 Number of bytes to store single double precision real element integer(kind=int64), public, parameter :: FLOAT_STORAGE_SIZE = storage_size(1._real32)/8_int64 Number of bytes to store single single precision real element integer(kind=int32), public, parameter :: COLOR_CREATE = int(Z'00FAB53C') Color for plan.create integer(kind=int32), public, parameter :: COLOR_EXECUTE = int(Z'00E25DFC') Color for plan.execute integer(kind=int32), public, parameter :: COLOR_TRANSPOSE = int(Z'00B175BD') Color for plan.transpose integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_XY = int(Z'005DFCCA') Color for DTFFT_TRANSPOSE_X_TO_Y integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_YX = int(Z'0076A797') Color for DTFFT_TRANSPOSE_Y_TO_X integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_YZ = int(Z'00E3CF9F') Color for DTFFT_TRANSPOSE_Y_TO_Z integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_ZY = int(Z'008C826A') Color for DTFFT_TRANSPOSE_Z_TO_Y integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_XZ = int(Z'00546F66') Color for DTFFT_TRANSPOSE_X_TO_Z integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_ZX = int(Z'007A6D7D') Color for DTFFT_TRANSPOSE_Z_TO_X integer(kind=int32), public, parameter :: COLOR_FFT = int(Z'00FCD05D') Color for FFT integer(kind=int32), public, parameter :: COLOR_AUTOTUNE = int(Z'006075FF') Color for Autotune integer(kind=int32), public, parameter :: COLOR_AUTOTUNE2 = int(Z'0056E874') Color for Autotune2 integer(kind=int32), public, parameter :: COLOR_DESTROY = int(Z'00000000') Color for plan.destroy integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_PALLETTE (-3:3) = [COLOR_TRANSPOSE_ZX, COLOR_TRANSPOSE_ZY, COLOR_TRANSPOSE_YX, 0, COLOR_TRANSPOSE_XY, COLOR_TRANSPOSE_YZ, COLOR_TRANSPOSE_XZ] Color pallete for plan.transpose integer(kind=int32), public, parameter :: VARIABLE_NOT_SET = -111 Default value when environ is not set type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_DATATYPE = dtfft_backend_t(21) Backend that uses MPI datatypes\nNot really recommended to use, since it is a million times slower than other backends\nLeft here just to show how slow MPI Datatypes are for GPU usage type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_P2P = dtfft_backend_t(22) MPI peer-to-peer algorithm type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_A2A = dtfft_backend_t(23) MPI backend using MPI_Alltoallv type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_NCCL = dtfft_backend_t(24) NCCL backend type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_P2P_PIPELINED = dtfft_backend_t(26) MPI peer-to-peer algorithm with overlapping data copying and unpacking type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_NCCL_PIPELINED = dtfft_backend_t(27) NCCL backend with overlapping data copying and unpacking type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_CUFFTMP = dtfft_backend_t(25) cuFFTMp backend type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_CUFFTMP_PIPELINED = dtfft_backend_t(28) cuFFTMp backend that uses extra buffer to gain performance type( dtfft_backend_t ), public, parameter :: BACKEND_NOT_SET = dtfft_backend_t(VARIABLE_NOT_SET) Backend is not used type( dtfft_backend_t ), public, parameter :: VALID_GPU_BACKENDS (*) = [DTFFT_BACKEND_MPI_DATATYPE, DTFFT_BACKEND_MPI_P2P, DTFFT_BACKEND_MPI_A2A, DTFFT_BACKEND_MPI_P2P_PIPELINED, DTFFT_BACKEND_NCCL_PIPELINED, DTFFT_BACKEND_NCCL, DTFFT_BACKEND_CUFFTMP, DTFFT_BACKEND_CUFFTMP_PIPELINED] List of valid GPU backends type( dtfft_stream_t ), public, parameter :: NULL_STREAM = dtfft_stream_t(c_null_ptr) type( dtfft_platform_t ), public, parameter :: DTFFT_PLATFORM_HOST = dtfft_platform_t(1) Host platform type( dtfft_platform_t ), public, parameter :: DTFFT_PLATFORM_CUDA = dtfft_platform_t(2) CUDA platform type( dtfft_platform_t ), public, parameter :: PLATFORM_NOT_SET = dtfft_platform_t(VARIABLE_NOT_SET) type( dtfft_execute_t ), private, parameter :: VALID_EXECUTE_TYPES (*) = [DTFFT_EXECUTE_FORWARD, DTFFT_EXECUTE_BACKWARD] Valid execute types type( dtfft_transpose_t ), private, parameter :: VALID_TRANSPOSE_TYPES (*) = [DTFFT_TRANSPOSE_X_TO_Y, DTFFT_TRANSPOSE_Y_TO_X, DTFFT_TRANSPOSE_Y_TO_Z, DTFFT_TRANSPOSE_Z_TO_Y, DTFFT_TRANSPOSE_X_TO_Z, DTFFT_TRANSPOSE_Z_TO_X] Types of transpose that are valid to pass to transpose method type( dtfft_executor_t ), private, parameter :: VALID_EXECUTORS (*) = [DTFFT_EXECUTOR_NONE, DTFFT_EXECUTOR_FFTW3, DTFFT_EXECUTOR_MKL, DTFFT_EXECUTOR_CUFFT, DTFFT_EXECUTOR_VKFFT] List of valid executors type( dtfft_executor_t ), private, parameter :: HOST_EXECUTORS (*) = [DTFFT_EXECUTOR_NONE, DTFFT_EXECUTOR_FFTW3, DTFFT_EXECUTOR_MKL] List of host executors type( dtfft_executor_t ), private, parameter :: CUDA_EXECUTORS (*) = [DTFFT_EXECUTOR_NONE, DTFFT_EXECUTOR_CUFFT, DTFFT_EXECUTOR_VKFFT] List of CUDA executors type( dtfft_effort_t ), private, parameter :: VALID_EFFORTS (*) = [DTFFT_ESTIMATE, DTFFT_MEASURE, DTFFT_PATIENT] Valid effort flags type( dtfft_precision_t ), private, parameter :: VALID_PRECISIONS (*) = [DTFFT_SINGLE, DTFFT_DOUBLE] Valid precision flags type( dtfft_r2r_kind_t ), private, parameter :: VALID_R2R_KINDS (*) = [DTFFT_DCT_1, DTFFT_DCT_2, DTFFT_DCT_3, DTFFT_DCT_4, DTFFT_DST_1, DTFFT_DST_2, DTFFT_DST_3, DTFFT_DST_4] Array of valid R2R kinds integer(kind=int8), private, parameter :: VALID_DIMENSIONS (*) = [2_int8, 3_int8] Valid dimensions for plan.create integer(kind=int32), private, parameter :: VALID_COMM_TYPES (*) = [MPI_UNDEFINED, MPI_CART] Valid communicator types for plan.create type( dtfft_backend_t ), private, parameter :: PIPELINED_BACKENDS (*) = [DTFFT_BACKEND_MPI_P2P_PIPELINED, DTFFT_BACKEND_NCCL_PIPELINED, DTFFT_BACKEND_CUFFTMP_PIPELINED] List of pipelined backends type( dtfft_backend_t ), private, parameter :: MPI_BACKENDS (*) = [DTFFT_BACKEND_MPI_P2P, DTFFT_BACKEND_MPI_A2A, DTFFT_BACKEND_MPI_P2P_PIPELINED] List of MPI backends type( dtfft_backend_t ), private, parameter :: NCCL_BACKENDS (*) = [DTFFT_BACKEND_NCCL, DTFFT_BACKEND_NCCL_PIPELINED] List of NCCL backends type( dtfft_backend_t ), private, parameter :: CUFFTMP_BACKENDS (*) = [DTFFT_BACKEND_CUFFTMP, DTFFT_BACKEND_CUFFTMP_PIPELINED] List of cuFFTMp backends type( dtfft_backend_t ), private, parameter :: NVSHMEM_BACKENDS (*) = [DTFFT_BACKEND_CUFFTMP, DTFFT_BACKEND_CUFFTMP_PIPELINED] List of NVSHMEM-based backends type( dtfft_platform_t ), private, parameter :: VALID_PLATFORMS (*) = [DTFFT_PLATFORM_HOST, DTFFT_PLATFORM_CUDA] Valid platforms Interfaces public        interface dtfft_get_version Get dtFFT version private  function dtfft_get_version_current () bind(C) Returns the current version code Arguments None Return Value integer(kind=c_int32_t) private  function dtfft_get_version_required (major, minor, patch) Returns the version code required by the user Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: major Major version integer(kind=int32), intent(in) :: minor Minor version integer(kind=int32), intent(in) :: patch Patch version Return Value integer(kind=int32) public        interface operator(==) private pure elemental function execute_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical public        interface operator(/=) private pure elemental function execute_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical public        interface dtfft_stream_t Creates dtfft_stream_t from integer(cuda_stream_kind) private  function stream_from_int64 (cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream Derived Types type, public, bind(C) :: dtfft_execute_t Type that is used during call to execute method Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_transpose_t Type that is used during call to transpose method Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_executor_t Type that specifies external FFT executor Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_effort_t Type that specifies effort that dtFFT should use when creating plan Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_precision_t Type that specifies precision of dtFFT plan Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_r2r_kind_t Type that specifies various kinds of R2R FFTs Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_backend_t Type that specifies various GPU Backend present in dtFFT Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_stream_t dtFFT stream representation. Components Type Visibility Attributes Name Initial type(c_ptr), public :: stream Actual stream Constructor Creates dtfft_stream_t from integer(cuda_stream_kind) private\n\n                    \n                    function stream_from_int64 (cuda_stream) Creates dtfft_stream_t from integer(cuda_stream_kind) type, public, bind(C) :: dtfft_platform_t Type that specifies runtime platform, e.g. Host, CUDA, HIP Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value Functions public pure elemental function is_valid_execute_type (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_transpose_type (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_executor (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_effort (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_precision (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_r2r_kind (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_dimension (param) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: param Return Value logical public pure elemental function is_valid_comm_type (param) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: param Return Value logical public  function dtfft_get_precision_string (precision) result(string) Gets the string description of a precision Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: precision Precision type Return Value character(len=:), allocatable Precision string public  function dtfft_get_executor_string (executor) result(string) Gets the string description of an executor Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: executor Executor type Return Value character(len=:), allocatable Executor string public pure elemental function is_host_executor (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical public pure elemental function is_cuda_executor (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_platform (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_gpu_backend (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_backend_pipelined (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_backend_mpi (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_backend_nccl (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_backend_cufftmp (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_backend_nvshmem (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public  function dtfft_get_backend_string (backend) result(string) Gets the string description of a GPU backend Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: backend GPU backend Return Value character(len=:), allocatable Backend string public  function dtfft_get_cuda_stream (stream) result(cuda_stream) Returns the CUDA stream from dtfft_stream_t Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), intent(in) :: stream dtfft stream Return Value integer(kind=int64) CUDA stream private pure elemental function execute_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function execute_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private  function dtfft_get_version_current () bind(C) Returns the current version code Arguments None Return Value integer(kind=c_int32_t) private  function dtfft_get_version_required (major, minor, patch) Returns the version code required by the user Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: major Major version integer(kind=int32), intent(in) :: minor Minor version integer(kind=int32), intent(in) :: patch Patch version Return Value integer(kind=int32) private pure elemental function gpu_backend_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical private  function stream_from_int64 (cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream","tags":"","loc":"module/dtfft_parameters.html"},{"title":"dtfft_interface_vkfft_m – dtFFT","text":"This module creates interface with VkFFT library VkFFT is loaded at runtime via dynamic loading. Uses dtfft_parameters iso_fortran_env iso_c_binding dtfft_utils dtfft_errors module~~dtfft_interface_vkfft_m~~UsesGraph module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m iso_c_binding iso_c_binding module~dtfft_interface_vkfft_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_vkfft_m~~UsedByGraph module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( vkfft_wrapper ), public, save, target :: cuda_wrapper VkFFT Wrapper for CUDA platform Abstract Interfaces abstract interface private  subroutine vkfft_create_interface(rank, dims, double_precision, how_many, r2c, c2r, dct, dst, stream, app_handle) bind(C) Creates FFT plan via vkFFT Interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), value :: rank Rank of fft: 1 or 2 integer(kind=c_int) :: dims (*) Dimensions of transform integer(kind=c_int), value :: double_precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=c_int), value :: how_many Number of transforms to create integer(kind=c_int8_t), value :: r2c Is R2C transform required integer(kind=c_int8_t), value :: c2r Is C2R transform required integer(kind=c_int8_t), value :: dct Is DCT transform required integer(kind=c_int8_t), value :: dst Is DST transform required type( dtfft_stream_t ), value :: stream CUDA stream type(c_ptr) :: app_handle vkFFT application handle abstract interface private  subroutine vkfft_execute_interface(app_handle, in, out, sign) bind(C) Executes vkFFT plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: app_handle vkFFT application handle type(c_ptr), value :: in Input data type(c_ptr), value :: out Output data integer(kind=c_int8_t), value :: sign Sign of FFT abstract interface private  subroutine vkfft_destroy_interface(app_handle) bind(C) Destroys vkFFT plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: app_handle vkFFT application handle Derived Types type, public :: vkfft_wrapper VkFFT Wrapper Components Type Visibility Attributes Name Initial procedure( vkfft_create_interface ), public, pointer, nopass :: create Fortran Pointer to vkFFT create function procedure( vkfft_execute_interface ), public, pointer, nopass :: execute Fortran Pointer to vkFFT execute function procedure( vkfft_destroy_interface ), public, pointer, nopass :: destroy Fortran Pointer to vkFFT destroy function logical, private :: is_loaded = .false. Is VkFFT library loaded type(c_ptr), private :: lib_handle Handle to the loaded library type(c_funptr), private :: vkfft_functions (3) Array of VkFFT functions Functions public  function load_vkfft (platform) Loads VkFFT library based on the platform Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to load VkFFT library for Return Value integer(kind=int32) private  function load (wrapper, suffix) result(error_code) Loads VkFFT library Arguments Type Intent Optional Attributes Name class( vkfft_wrapper ), intent(inout) :: wrapper VkFFT Wrapper character(len=*), intent(in) :: suffix Suffix for the library name Return Value integer(kind=int32)","tags":"","loc":"module/dtfft_interface_vkfft_m.html"},{"title":"dtfft_interface_nvrtc – dtFFT","text":"nvRTC Interfaces. nvRTC is loaded at runtime via dynamic loading due to explicit cuda_driver linking by cmake. Uses dtfft_parameters dtfft_interface_cuda_runtime iso_fortran_env iso_c_binding dtfft_utils dtfft_errors module~~dtfft_interface_nvrtc~~UsesGraph module~dtfft_interface_nvrtc dtfft_interface_nvrtc iso_c_binding iso_c_binding module~dtfft_interface_nvrtc->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_parameters dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_nvrtc~~UsedByGraph module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvrtc module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial procedure( nvrtcGetErrorString_interface ), public, pointer :: nvrtcGetErrorString_c Fortran pointer to the nvrtcGetErrorString function procedure( nvrtcCreateProgram_interface ), public, pointer :: nvrtcCreateProgram Fortran pointer to the nvrtcCreateProgram function procedure( nvrtcDestroyProgram_interface ), public, pointer :: nvrtcDestroyProgram Fortran pointer to the nvrtcDestroyProgram function procedure( nvrtcCompileProgram_interface ), public, pointer :: nvrtcCompileProgram Fortran pointer to the nvrtcCompileProgram function procedure( nvrtcGetProgramLog_interface ), public, pointer :: nvrtcGetProgramLog Fortran pointer to the nvrtcGetProgramLog function procedure( nvrtcGetCUBINSize_interface ), public, pointer :: nvrtcGetCUBINSize Fortran pointer to the nvrtcGetCUBINSize function procedure( nvrtcGetCUBIN_interface ), public, pointer :: nvrtcGetCUBIN Fortran pointer to the nvrtcGetCUBIN function logical, private, save :: is_loaded = .false. Flag indicating whether the library is loaded type(c_ptr), private, save :: libnvrtc Handle to the loaded library type(c_funptr), private, save :: nvrtcFunctions (7) Array of pointers to the nvRTC functions Abstract Interfaces abstract interface private  function nvrtcGetErrorString_interface(error_code) result(string) Helper function that returns a string describing the given nvrtcResult code\nFor unrecognized enumeration values, it returns “NVRTC_ERROR unknown” Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: error_code CUDA Runtime Compilation API result code. Return Value type(c_ptr) Pointer to C string abstract interface private  function nvrtcCreateProgram_interface(prog, src, name, numHeaders, headers, includeNames) result(nvrtcResult) Creates an instance of nvrtcProgram with the given input parameters, \nand sets the output parameter prog with it. Arguments Type Intent Optional Attributes Name type( nvrtcProgram ) :: prog CUDA Runtime Compilation program. character(len=c_char) :: src (*) CUDA program source. character(len=c_char) :: name (*) CUDA program name. integer(kind=c_int), value :: numHeaders Number of headers used. Must be greater than or equal to 0. type(c_ptr), value :: headers Sources of the headers type(c_ptr), value :: includeNames Name of each header by which they can be included in the CUDA program source Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcDestroyProgram_interface(prog) result(nvrtcResult) Destroys the given program. Arguments Type Intent Optional Attributes Name type( nvrtcProgram ) :: prog CUDA Runtime Compilation program. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcCompileProgram_interface(prog, numOptions, options) result(nvrtcResult) Compiles the given program. Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_int), value :: numOptions Number of compiler options passed. type(c_ptr) :: options (*) Compiler options in the form of C string array Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcGetProgramLog_interface(prog, log) result(nvrtcResult) Stores the log generated by the previous compilation of prog in the memory pointed by log Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. type(c_ptr), value :: log Compilation log. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcGetCUBINSize_interface(prog, cubinSizeRet) result(nvrtcResult) Sets the value of cubinSizeRet with the size of the cubin generated by the previous compilation of prog . Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_size_t) :: cubinSizeRet Size of the generated cubin. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcGetCUBIN_interface(prog, cubin) result(nvrtcResult) Stores the cubin generated by the previous compilation of prog in the memory pointed by cubin . Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. character(len=c_char) :: cubin (*) Compiled and assembled result. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Derived Types type, public, bind(C) :: nvrtcProgram nvrtcProgram is the unit of compilation, and an opaque handle for a program. Components Type Visibility Attributes Name Initial type(c_ptr), public :: cptr Actual pointer Functions public  function nvrtcGetErrorString (error_code) result(string) Helper function that returns a string describing the given nvrtcResult code\nFor unrecognized enumeration values, it returns “NVRTC_ERROR unknown” Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: error_code CUDA Runtime Compilation API result code. Return Value character(len=:), allocatable Result string public  function load_nvrtc () result(error_code) Dynamically loads nvRTC library and its functions Arguments None Return Value integer(kind=int32) Error code","tags":"","loc":"module/dtfft_interface_nvrtc.html"},{"title":"dtfft_errors – dtFFT","text":"Uses iso_fortran_env module~~dtfft_errors~~UsesGraph module~dtfft_errors dtfft_errors iso_fortran_env iso_fortran_env module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_errors~~UsedByGraph module~dtfft_errors dtfft_errors module~dtfft dtfft module~dtfft->module~dtfft_errors module~dtfft_config dtfft_config module~dtfft->module~dtfft_config module~dtfft_pencil dtfft_pencil module~dtfft->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_errors module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_abstract_transpose_plan->module~dtfft_utils module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_errors module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_pencil module~dtfft_api->module~dtfft_plan module~dtfft_api->module~dtfft_utils module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_utils module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_errors module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_utils module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_errors module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_config module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvrtc module~dtfft_transpose_plan_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_utils module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_host->module~dtfft_errors module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_pencil module~dtfft_transpose_plan_host->module~dtfft_utils module~dtfft_transpose_plan_host->module~dtfft_interface_nvtx module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft_utils->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_mkl_m->module~dtfft_utils module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_transpose_handle_cuda->module~dtfft_utils module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_handle_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_host->module~dtfft_pencil module~dtfft_transpose_handle_host->module~dtfft_interface_nvtx Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DTFFT_SUCCESS = 0 Successful execution integer(kind=int32), public, parameter :: DTFFT_ERROR_MPI_FINALIZED = (-1) MPI_Init is not called or MPI_Finalize has already been called integer(kind=int32), public, parameter :: DTFFT_ERROR_PLAN_NOT_CREATED = 1 Plan not created integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_TRANSPOSE_TYPE = 2 Invalid transpose_type provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_N_DIMENSIONS = 3 Invalid Number of dimensions provided. Valid options are 2 and 3 integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_DIMENSION_SIZE = 4 One or more provided dimension sizes <= 0 integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_COMM_TYPE = 5 Invalid communicator type provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_PRECISION = 6 Invalid precision parameter provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_EFFORT = 7 Invalid effort parameter provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_EXECUTOR = 8 Invalid executor parameter provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_COMM_DIMS = 9 Number of dimensions in provided Cartesian communicator > Number of dimension passed to create subroutine integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_COMM_FAST_DIM = 10 Passed Cartesian communicator with number of processes in 1st (fastest varying) dimension > 1 integer(kind=int32), public, parameter :: DTFFT_ERROR_MISSING_R2R_KINDS = 11 For R2R plan, kinds parameter must be passed if executor != DTFFT_EXECUTOR_NONE integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_R2R_KINDS = 12 Invalid values detected in kinds parameter integer(kind=int32), public, parameter :: DTFFT_ERROR_R2C_TRANSPOSE_PLAN = 13 Transpose plan is not supported in R2C, use R2R or C2C plan instead integer(kind=int32), public, parameter :: DTFFT_ERROR_INPLACE_TRANSPOSE = 14 Inplace transpose is not supported integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_AUX = 15 Invalid aux buffer provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_DIM = 16 Invalid dim passed to plan.get_pencil integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_USAGE = 17 Invalid API Usage. integer(kind=int32), public, parameter :: DTFFT_ERROR_PLAN_IS_CREATED = 18 Trying to create already created plan integer(kind=int32), public, parameter :: DTFFT_ERROR_ALLOC_FAILED = 19 Internal allocation failed integer(kind=int32), public, parameter :: DTFFT_ERROR_FREE_FAILED = 20 Internal memory free failed integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_ALLOC_BYTES = 21 Invalid alloc_bytes provided integer(kind=int32), public, parameter :: DTFFT_ERROR_DLOPEN_FAILED = 22 dlopen failed integer(kind=int32), public, parameter :: DTFFT_ERROR_DLSYM_FAILED = 23 dlsym failed integer(kind=int32), public, parameter :: DTFFT_ERROR_R2C_TRANSPOSE_CALLED = 24 Calling to transpose method for R2C plan is not allowed integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH = 25 Sizes of starts and counts arrays passed to dtfft_pencil_t constructor do not match integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES = 26 Sizes of starts and counts < 2 or > 3 provided to dtfft_pencil_t constructor integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_INVALID_COUNTS = 27 Invalid counts provided to dtfft_pencil_t constructor integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_INVALID_STARTS = 28 Invalid starts provided to dtfft_pencil_t constructor integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_SHAPE_MISMATCH = 29 Processes have same lower bounds but different sizes in some dimensions integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_OVERLAP = 30 Pencil overlap detected, i.e. two processes share same part of global space integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_NOT_CONTINUOUS = 31 Local pencils do not cover the global space without gaps integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_NOT_INITIALIZED = 32 Pencil is not initialized, i.e. constructor subroutine was not called integer(kind=int32), public, parameter :: DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED = 101 Selected executor do not support R2R FFTs integer(kind=int32), public, parameter :: DTFFT_ERROR_GPU_INVALID_STREAM = 201 Invalid stream provided integer(kind=int32), public, parameter :: DTFFT_ERROR_GPU_INVALID_BACKEND = 202 Invalid GPU backend provided integer(kind=int32), public, parameter :: DTFFT_ERROR_GPU_NOT_SET = 203 Multiple MPI Processes located on same host share same GPU which is not supported integer(kind=int32), public, parameter :: DTFFT_ERROR_VKFFT_R2R_2D_PLAN = 204 When using R2R FFT and executor type is vkFFT and plan uses Z-slab optimization, it is required that types of R2R transform are same in X and Y directions integer(kind=int32), public, parameter :: DTFFT_ERROR_GPU_BACKENDS_DISABLED = 205 Passed effort == DTFFT_PATIENT but all GPU Backends has been disabled by dtfft_config_t */ integer(kind=int32), public, parameter :: DTFFT_ERROR_NOT_DEVICE_PTR = 300 One of pointers passed to plan.execute or plan.transpose cannot be accessed from device integer(kind=int32), public, parameter :: DTFFT_ERROR_NOT_NVSHMEM_PTR = 301 One of pointers passed to plan.execute or plan.transpose is not an NVSHMEM pointer integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_PLATFORM = 400 Invalid platform provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR_TYPE = 401 Invalid executor provided for selected platform Functions public pure function dtfft_get_error_string (error_code) result(error_string) Gets the string description of an error code Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: error_code Error code Return Value character(len=:), allocatable Error string","tags":"","loc":"module/dtfft_errors.html"},{"title":"dtfft_executor_fftw_m – dtFFT","text":"This module describes FFTW3 based FFT Executor: fftw_executor http://www.fftw.org Uses dtfft_parameters dtfft_abstract_executor iso_fortran_env iso_c_binding dtfft_pencil dtfft_utils dtfft_interface_fftw_m dtfft_errors module~~dtfft_executor_fftw_m~~UsesGraph module~dtfft_executor_fftw_m dtfft_executor_fftw_m iso_c_binding iso_c_binding module~dtfft_executor_fftw_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_executor_fftw_m->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_errors dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_parameters dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_errors->iso_fortran_env module~dtfft_interface_fftw_m->iso_c_binding dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_executor_fftw_m~~UsedByGraph module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private, parameter :: FFTW3_FLAGS = FFTW_MEASURE+FFTW_DESTROY_INPUT FFTW3 planner flags Abstract Interfaces abstract interface private  function create_c2c_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Creates C2C FFTW3 Plan Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) abstract interface private  function create_r2c_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates R2C FFTW3 Plan Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) abstract interface private  function create_r2r_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kinds, flags) bind(C) Creates R2R FFTW3 Plan Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kinds (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) abstract interface private  subroutine apply_interface(plan, in, out) bind(C) Executes FFTW3 Plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out abstract interface private  subroutine free_interface(plan) bind(C) Destroys FFTW3 Plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Derived Types type, public, extends( abstract_executor ) :: fftw_executor FFTW3 FFT Executor Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? procedure( apply_interface ), private, nopass, pointer :: apply => NULL() Pointer to FFTW3 function that executes FFT plan procedure( free_interface ), private, nopass, pointer :: free => NULL() Pointer to FFTW3 function that destroys FFT plan procedure( apply_interface ), private, nopass, pointer :: apply_inverse => NULL() Pointer to FFTW3 function that executes inverse FFT plan\nUsed in R2C only Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure, public :: create_private => create ../../ Creates FFT plan via FFTW3 Interface procedure, public :: execute_private => execute ../../ Executes FFTW3 plan procedure, public :: destroy_private => destroy ../../ Destroys FFTW3 plan procedure, public, nopass :: mem_alloc ../../ Allocates FFTW3 memory procedure, public, nopass :: mem_free ../../ Frees FFTW3 aligned memory Subroutines private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via FFTW3 Interface Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform private  subroutine execute (self, a, b, sign) Executes FFTW3 plan Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(in) :: self FFTW FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys FFTW3 plan Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor private  subroutine mem_alloc (alloc_bytes, ptr) Allocates FFTW3 memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer private  subroutine mem_free (ptr) Frees FFTW3 aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"module/dtfft_executor_fftw_m.html"},{"title":"dtfft_executor_mkl_m – dtFFT","text":"This module describes MKL based FFT Executor: mkl_executor https://software.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/fourier-transform-functions/fft-functions.html Uses dtfft_parameters dtfft_abstract_executor iso_c_binding dtfft_interface_mkl_m iso_fortran_env dtfft_interface_mkl_native_m dtfft_utils dtfft_errors mpi_f08 module~~dtfft_executor_mkl_m~~UsesGraph module~dtfft_executor_mkl_m dtfft_executor_mkl_m iso_c_binding iso_c_binding module~dtfft_executor_mkl_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_executor_mkl_m->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_errors dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_parameters dtfft_parameters module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_executor_mkl_m->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_executor_mkl_m->mpi_f08 module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_pencil dtfft_pencil module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_errors->iso_fortran_env module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_interface_mkl_m->module~dtfft_utils MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_executor_mkl_m~~UsedByGraph module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_executor ) :: mkl_executor MKL FFT Executor Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? logical, private :: need_reconfigure Needed for R2C plans integer(kind=c_long), private, allocatable :: istrides (:) Input strides. Needed for R2C plans to reconfigure plan integer(kind=c_long), private, allocatable :: ostrides (:) Output strides. Needed for R2C plans to reconfigure plan integer(kind=int32), private :: idist Input distance between the first data elements of consecutive data sets integer(kind=int32), private :: odist Output distance between the first data elements of consecutive data sets Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure, public :: create_private => create ../../ Creates FFT plan via MKL DFTI Interface procedure, public :: execute_private => execute ../../ Executes MKL plan procedure, public :: destroy_private => destroy ../../ Destroys MKL plan procedure, public, nopass :: mem_alloc ../../ Allocates MKL memory procedure, public, nopass :: mem_free ../../ Frees MKL aligned memory Subroutines private  subroutine make_plan (fft_rank, fft_sizes, mkl_precision, forward_domain, how_many, idist, odist, plan) Creates general MKL plan Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=c_long), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: mkl_precision MKL Precision integer(kind=int32), intent(in) :: forward_domain C2C or R2C flag integer(kind=int32), intent(in) :: how_many Sets DFTI_NUMBER_OF_TRANSFORMS integer(kind=int32), intent(in) :: idist Sets DFTI_INPUT_DISTANCE integer(kind=int32), intent(in) :: odist Sets DFTI_OUTPUT_DISTANCE type(c_ptr), intent(inout) :: plan Resulting plan private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via MKL DFTI Interface Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform private  subroutine execute (self, a, b, sign) Executes MKL plan Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(in) :: self MKL FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys MKL plan Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor private  subroutine mem_alloc (alloc_bytes, ptr) Allocates MKL memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer private  subroutine mem_free (ptr) Frees MKL aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"module/dtfft_executor_mkl_m.html"},{"title":"dtfft_interface_cufft – dtFFT","text":"cuFFT Interfaces Uses dtfft_parameters iso_fortran_env dtfft_utils iso_c_binding module~~dtfft_interface_cufft~~UsesGraph module~dtfft_interface_cufft dtfft_interface_cufft iso_c_binding iso_c_binding module~dtfft_interface_cufft->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_cufft->iso_fortran_env module~dtfft_parameters dtfft_parameters module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_cufft~~UsedByGraph module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public, parameter :: CUFFT_COMM_MPI = 0 Enumerations enum, bind(c) Enumerators enumerator :: CUFFT_R2C = 42 enumerator :: CUFFT_C2R = 44 enumerator :: CUFFT_C2C = 41 enumerator :: CUFFT_D2Z = 106 enumerator :: CUFFT_Z2D = 108 enumerator :: CUFFT_Z2Z = 105 enum, bind(c) Enumerators enumerator :: CUFFT_SUCCESS = 0 enumerator :: CUFFT_INVALID_PLAN = 1 enumerator :: CUFFT_ALLOC_FAILED = 2 enumerator :: CUFFT_INVALID_TYPE = 3 enumerator :: CUFFT_INVALID_VALUE = 4 enumerator :: CUFFT_INTERNAL_ERROR = 5 enumerator :: CUFFT_EXEC_FAILED = 6 enumerator :: CUFFT_SETUP_FAILED = 7 enumerator :: CUFFT_INVALID_SIZE = 8 enumerator :: CUFFT_UNALIGNED_DATA = 9 enumerator :: CUFFT_INCOMPLETE_PARAMETER_LIST = 10 enumerator :: CUFFT_INVALID_DEVICE = 11 enumerator :: CUFFT_PARSE_ERROR = 12 enumerator :: CUFFT_NO_WORKSPACE = 13 enumerator :: CUFFT_NOT_IMPLEMENTED = 14 enumerator :: CUFFT_LICENSE_ERROR = 15 enumerator :: CUFFT_NOT_SUPPORTED = 16 Interfaces interface Creates a FFT plan configuration of dimension rank, with sizes specified in the array n. public  function cufftPlanMany(plan, rank, n, inembed, istride, idist, onembed, ostride, odist, ffttype, batch) result(cufftResult) bind(C, name=\"cufftPlanMany\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: plan Pointer to an uninitialized cufftHandle object. integer(kind=c_int), value :: rank Dimensionality of the transform (1, 2, or 3). integer(kind=c_int) :: n (*) Array of size rank, describing the size of each dimension,\nn[0] being the size of the outermost\nand n[rank-1] innermost (contiguous) dimension of a transform. integer(kind=c_int) :: inembed (*) Pointer of size rank that indicates the storage dimensions of the input data in memory.\nIf set to NULL, all other advanced data layout parameters are ignored. integer(kind=c_int), value :: istride Indicates the distance between two successive input elements in the least\nsignificant (i.e., innermost) dimension. integer(kind=c_int), value :: idist Indicates the distance between the first element of two consecutive signals\nin a batch of the input data. integer(kind=c_int) :: onembed (*) Pointer of size rank that indicates the storage dimensions of the output data in memory.\nIf set to NULL, all other advanced data layout parameters are ignored. integer(kind=c_int), value :: ostride Indicates the distance between two successive output elements in the output array\nin the least significant (i.e., innermost) dimension. integer(kind=c_int), value :: odist Indicates the distance between the first element of two consecutive signals\nin a batch of the output data. integer(kind=c_int), value :: ffttype The transform data type (e.g., CUFFT_R2C for single precision real to complex). integer(kind=c_int), value :: batch Batch size for this transform. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Executes any cuFFT transform regardless of precision and type.\nIn case of complex-to-real and real-to-complex transforms, the direction parameter is ignored. public  function cufftXtExec(plan, input, output, direction) result(cufftResult) bind(C, name=\"cufftXtExec\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan cufftHandle returned by cufftCreate. type(c_ptr), value :: input Pointer to the input data (in GPU memory) to transform. type(c_ptr), value :: output Pointer to the output data (in GPU memory). integer(kind=c_int), value :: direction The transform direction: CUFFT_FORWARD or CUFFT_INVERSE.\nIgnored for complex-to-real and real-to-complex transforms. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Frees all GPU resources associated with a cuFFT plan and destroys the internal plan data structure. public  function cufftDestroy(plan) result(cufftResult) bind(C, name=\"cufftDestroy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Object of the plan to be destroyed. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Associates a CUDA stream with a cuFFT plan. public  function cufftSetStream(plan, stream) result(cufftResult) bind(C, name=\"cufftSetStream\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Object to associate with the stream. type( dtfft_stream_t ), value :: stream A valid CUDA stream. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Initializes a reshape handle for future use. This function is not collective. public  function cufftMpCreateReshape(reshapeHandle) result(cufftResult) bind(C, name=\"cufftMpCreateReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ) :: reshapeHandle The reshape handle. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Attaches a communication handle to a reshape. This function is not collective. public  function cufftMpAttachReshapeComm(reshapeHandle, commType, comm) result(cufftResult) bind(C, name=\"cufftMpAttachReshapeComm\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_int), value :: commType An enum describing the communication type of the handle. type(c_ptr) :: comm If commType is CUFFT_COMM_MPI, this should be a pointer to an MPI communicator.\nThe pointer should remain valid until destruction of the handle.\nOtherwise, this should be NULL. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Returns the amount (in bytes) of workspace required to execute the handle. public  function cufftMpGetReshapeSize(reshapeHandle, workSize) result(cufftResult) bind(C, name=\"cufftMpGetReshapeSize\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_size_t) :: workSize The size, in bytes, of the workspace required during reshape execution. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Creates a reshape intended to re-distribute a global array of 3D data. public  function cufftMpMakeReshape(reshapeHandle, elementSize, rank, lower_input, upper_input, lower_output, upper_output, strides_input, strides_output) result(cufftResult) bind(C, name=\"cufftMpMakeReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_long_long), value :: elementSize The size of the individual elements, in bytes. Allowed values are 4, 8, and 16. integer(kind=c_int), value :: rank The length of the lower_input, upper_input, lower_output, upper_output, strides_input, and strides_output arrays. rank should be 3. integer(kind=c_long_long) :: lower_input (*) An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer(kind=c_long_long) :: upper_input (*) An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer(kind=c_long_long) :: lower_output (*) An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer(kind=c_long_long) :: upper_output (*) An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer(kind=c_long_long) :: strides_input (*) An array of length rank, representing the local data layout of the input descriptor in memory. All entries must be decreasing and positive. integer(kind=c_long_long) :: strides_output (*) An array of length rank, representing the local data layout of the output descriptor in memory. All entries must be decreasing and positive. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Executes the reshape, redistributing data_in into data_out using the workspace in workspace. public  function cufftMpExecReshapeAsync(reshapeHandle, dataOut, dataIn, workSpace, stream) result(cufftResult) bind(C, name=\"cufftMpExecReshapeAsync\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. type(c_ptr), value :: dataOut A symmetric-heap pointer to the output data. This memory should be NVSHMEM allocated and identical on all processes. type(c_ptr), value :: dataIn A symmetric-heap pointer to the input data. This memory should be NVSHMEM allocated and identical on all processes. type(c_ptr), value :: workSpace A symmetric-heap pointer to the workspace data. This memory should be NVSHMEM allocated and identical on all processes. type( dtfft_stream_t ), value :: stream The CUDA stream in which to run the reshape operation. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Destroys a reshape and all its associated data. public  function cufftMpDestroyReshape(reshapeHandle) result(cufftResult) bind(C, name=\"cufftMpDestroyReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. Derived Types type, public, bind(C) :: cufftReshapeHandle An opaque handle to a reshape operation. Components Type Visibility Attributes Name Initial type(c_ptr), public :: cptr Functions public  function cufftGetErrorString (error_code) result(string) Returns a string representation of the cuFFT error code. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: error_code cuFFT error code Return Value character(len=:), allocatable String representation of the cuFFT error code","tags":"","loc":"module/dtfft_interface_cufft.html"},{"title":"dtfft_transpose_plan_cuda – dtFFT","text":"This module describes transpose_plan_cuda class Uses dtfft_nvrtc_kernel dtfft_parameters dtfft_interface_cuda dtfft_interface_nvrtc dtfft_interface_cuda_runtime dtfft_transpose_handle_cuda iso_c_binding iso_fortran_env dtfft_interface_nvtx dtfft_pencil dtfft_utils dtfft_abstract_backend dtfft_errors dtfft_config dtfft_abstract_transpose_plan mpi_f08 module~~dtfft_transpose_plan_cuda~~UsesGraph module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda iso_c_binding iso_c_binding module~dtfft_transpose_plan_cuda->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_transpose_plan_cuda->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_config dtfft_config module~dtfft_transpose_plan_cuda->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_transpose_plan_cuda->module~dtfft_errors module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvrtc module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_parameters dtfft_parameters module~dtfft_transpose_plan_cuda->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_pencil module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_utils dtfft_utils module~dtfft_transpose_plan_cuda->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_transpose_plan_cuda->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_transpose_plan->iso_c_binding module~dtfft_abstract_transpose_plan->iso_fortran_env module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_errors module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_parameters module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_abstract_transpose_plan->module~dtfft_utils module~dtfft_abstract_transpose_plan->mpi_f08 module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_transpose_handle_cuda->iso_c_binding module~dtfft_transpose_handle_cuda->iso_fortran_env module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_transpose_handle_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_handle_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_parameters module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_transpose_handle_cuda->module~dtfft_utils module~dtfft_transpose_handle_cuda->mpi_f08 module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_transpose_plan_cuda~~UsedByGraph module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=real32), private, parameter :: MaxR4P = huge(1._real32) Maximum value of real32 Derived Types type, public, extends( abstract_transpose_plan ) :: transpose_plan_cuda CUDA Transpose Plan Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend = DTFFT_BACKEND_MPI_DATATYPE GPU backend type( backend_helper ), public :: helper Backend helper logical, public :: is_z_slab Z-slab optimization flag (for 3D transforms) integer(kind=int64), public :: min_buffer_size Minimal buffer size for transposition type( dtfft_stream_t ), private :: stream CUDA stream type(c_ptr), private :: aux Auxiliary memory real(kind=real32), private, pointer :: paux (:) Pointer to auxiliary memory logical, private :: is_aux_alloc Is auxiliary memory allocated type( transpose_handle_cuda ), private, allocatable :: fplans (:) Forward transposition plans type( transpose_handle_cuda ), private, allocatable :: bplans (:) Backward transposition plans Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Create transposition plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes transposition procedure, public, non_overridable, pass(self) :: get_backend ../../ Returns backend id procedure, public, non_overridable, pass(self) :: mem_alloc ../../ Allocates memory based on selected backend procedure, public, non_overridable, pass(self) :: mem_free ../../ Frees memory allocated with mem_alloc procedure, public :: create_private => create_cuda ../../ Creates CUDA transpose plan procedure, public :: execute_private => execute_cuda ../../ Executes single transposition procedure, public :: destroy => destroy_cuda ../../ Destroys CUDA transpose plan procedure, public :: get_aux_size ../../ Returns auxiliary buffer size Functions private  function create_cuda (self, dims, transposed_dims, base_comm, comm_dims, effort, base_dtype, base_storage, is_custom_cart_comm, cart_comm, comms, pencils, ipencil) Creates CUDA transpose plan Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(inout) :: self GPU transpose plan integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm Base communicator integer(kind=int32), intent(in) :: comm_dims (:) Number of processors in each dimension type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_custom_cart_comm is custom Cartesian communicator provided by user type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) private  function get_aux_size (self) result(aux_size) Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(in) :: self Transposition class Return Value integer(kind=int64) private  function alloc_and_set_aux (helper, backend, cart_comm, aux, paux, plans, bplans) result(is_aux_alloc) Allocates auxiliary memory according to the backend and sets it to the plans Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(MPI_Comm), intent(in) :: cart_comm Cartesian communicator type(c_ptr), intent(inout) :: aux Allocatable auxiliary memory real(kind=real32), intent(inout), pointer :: paux (:) Pointer to auxiliary memory type( transpose_handle_cuda ), intent(inout) :: plans (:) Plans type( transpose_handle_cuda ), intent(inout), optional :: bplans (:) Backward plans Return Value logical Is auxiliary memory allocated Subroutines private  subroutine execute_cuda (self, in, out, transpose_type) Executes single transposition Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(inout) :: self Transposition class real(kind=real32), intent(inout) :: in (:) Incoming buffer real(kind=real32), intent(inout) :: out (:) Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to execute private  subroutine destroy_cuda (self) Destroys transposition plans Arguments Type Intent Optional Attributes Name class( transpose_plan_cuda ), intent(inout) :: self Transposition class private  subroutine autotune_grid_decomposition (dims, transposed_dims, base_comm, base_storage, stream, best_decomposition, backend, min_execution_time, best_backend) Runs through all possible grid decompositions and selects the best one based on the lowest average execution time Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm 3D comm integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use integer(kind=int32), intent(out) :: best_decomposition (:) Best decomposition found type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: min_execution_time Elapsed time for best plan selected type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected private  subroutine autotune_grid (dims, transposed_dims, base_comm, comm_dims, base_storage, is_z_slab, stream, backend, best_time, best_backend) Creates cartesian grid and runs various backends on it. Can return best backend and execution time Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm Basic communicator to create 3d grid from integer(kind=int32), intent(in) :: comm_dims (:) Number of processors in each dimension integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_z_slab Is Z-slab optimization enabled type( dtfft_stream_t ), intent(in) :: stream Stream to use type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: best_time Elapsed time for best plan selected type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected for the grid private  subroutine run_autotune_backend (comms, cart_comm, pencils, base_storage, stream, is_z_slab, backend, best_time, best_backend) Runs autotune for all backends Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comms (:) 1D comms type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( pencil ), intent(in) :: pencils (:) Source meta integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use logical, intent(in) :: is_z_slab Is Z-slab optimization enabled type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: best_time Elapsed time for best backend type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected","tags":"","loc":"module/dtfft_transpose_plan_cuda.html"},{"title":"dtfft_interface_cuda_runtime – dtFFT","text":"CUDA Runtime Interfaces Uses dtfft_parameters dtfft_utils iso_c_binding module~~dtfft_interface_cuda_runtime~~UsesGraph module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime iso_c_binding iso_c_binding module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_parameters dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_parameters->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_cuda_runtime~~UsedByGraph module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_config dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_config module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvrtc module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft dtfft module~dtfft->module~dtfft_config module~dtfft->module~dtfft_pencil module~dtfft->module~dtfft_plan module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_pencil module~dtfft_api->module~dtfft_plan module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_handle_host->module~dtfft_pencil module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_pencil module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft_executor_mkl_m->module~dtfft_abstract_executor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public, parameter :: cudaEventDisableTiming = 2 Enumerations enum, bind(c) Enumerators enumerator :: cudaSuccess = 0 enumerator :: cudaErrorInvalidValue = 1 enumerator :: cudaErrorMemoryAllocation = 2 enumerator :: cudaErrorInitializationError = 3 enumerator :: cudaErrorCudartUnloading = 4 enumerator :: cudaErrorProfilerDisabled = 5 enumerator :: cudaErrorProfilerNotInitialized = 6 enumerator :: cudaErrorProfilerAlreadyStarted = 7 enumerator :: cudaErrorProfilerAlreadyStopped = 8 enumerator :: cudaErrorInvalidConfiguration = 9 enumerator :: cudaErrorInvalidPitchValue = 12 enumerator :: cudaErrorInvalidSymbol = 13 enumerator :: cudaErrorInvalidHostPointer = 16 enumerator :: cudaErrorInvalidDevicePointer = 17 enumerator :: cudaErrorInvalidTexture = 18 enumerator :: cudaErrorInvalidTextureBinding = 19 enumerator :: cudaErrorInvalidChannelDescriptor = 20 enumerator :: cudaErrorInvalidMemcpyDirection = 21 enumerator :: cudaErrorAddressOfConstant = 22 enumerator :: cudaErrorTextureFetchFailed = 23 enumerator :: cudaErrorTextureNotBound = 24 enumerator :: cudaErrorSynchronizationError = 25 enumerator :: cudaErrorInvalidFilterSetting = 26 enumerator :: cudaErrorInvalidNormSetting = 27 enumerator :: cudaErrorMixedDeviceExecution = 28 enumerator :: cudaErrorNotYetImplemented = 31 enumerator :: cudaErrorMemoryValueTooLarge = 32 enumerator :: cudaErrorInsufficientDriver = 35 enumerator :: cudaErrorInvalidSurface = 37 enumerator :: cudaErrorDuplicateVariableName = 43 enumerator :: cudaErrorDuplicateTextureName = 44 enumerator :: cudaErrorDuplicateSurfaceName = 45 enumerator :: cudaErrorDevicesUnavailable = 46 enumerator :: cudaErrorIncompatibleDriverContext = 49 enumerator :: cudaErrorMissingConfiguration = 52 enumerator :: cudaErrorPriorLaunchFailure = 53 enumerator :: cudaErrorLaunchMaxDepthExceeded = 65 enumerator :: cudaErrorLaunchFileScopedTex = 66 enumerator :: cudaErrorLaunchFileScopedSurf = 67 enumerator :: cudaErrorSyncDepthExceeded = 68 enumerator :: cudaErrorLaunchPendingCountExceeded = 69 enumerator :: cudaErrorInvalidDeviceFunction = 98 enumerator :: cudaErrorNoDevice = 100 enumerator :: cudaErrorInvalidDevice = 101 enumerator :: cudaErrorStartupFailure = 127 enumerator :: cudaErrorInvalidKernelImage = 200 enumerator :: cudaErrorDeviceUninitialized = 201 enumerator :: cudaErrorMapBufferObjectFailed = 205 enumerator :: cudaErrorUnmapBufferObjectFailed = 206 enumerator :: cudaErrorArrayIsMapped = 207 enumerator :: cudaErrorAlreadyMapped = 208 enumerator :: cudaErrorNoKernelImageForDevice = 209 enumerator :: cudaErrorAlreadyAcquired = 210 enumerator :: cudaErrorNotMapped = 211 enumerator :: cudaErrorNotMappedAsArray = 212 enumerator :: cudaErrorNotMappedAsPointer = 213 enumerator :: cudaErrorECCUncorrectable = 214 enumerator :: cudaErrorUnsupportedLimit = 215 enumerator :: cudaErrorDeviceAlreadyInUse = 216 enumerator :: cudaErrorPeerAccessUnsupported = 217 enumerator :: cudaErrorInvalidPtx = 218 enumerator :: cudaErrorInvalidGraphicsContext = 219 enumerator :: cudaErrorNvlinkUncorrectable = 220 enumerator :: cudaErrorJitCompilerNotFound = 221 enumerator :: cudaErrorInvalidSource = 300 enumerator :: cudaErrorFileNotFound = 301 enumerator :: cudaErrorSharedObjectSymbolNotFound = 302 enumerator :: cudaErrorSharedObjectInitFailed = 303 enumerator :: cudaErrorOperatingSystem = 304 enumerator :: cudaErrorInvalidResourceHandle = 400 enumerator :: cudaErrorIllegalState = 401 enumerator :: cudaErrorSymbolNotFound = 500 enumerator :: cudaErrorNotReady = 600 enumerator :: cudaErrorIllegalAddress = 700 enumerator :: cudaErrorLaunchOutOfResources = 701 enumerator :: cudaErrorLaunchTimeout = 702 enumerator :: cudaErrorLaunchIncompatibleTexturing = 703 enumerator :: cudaErrorPeerAccessAlreadyEnabled = 704 enumerator :: cudaErrorPeerAccessNotEnabled = 705 enumerator :: cudaErrorSetOnActiveProcess = 708 enumerator :: cudaErrorContextIsDestroyed = 709 enumerator :: cudaErrorAssert = 710 enumerator :: cudaErrorTooManyPeers = 711 enumerator :: cudaErrorHostMemoryAlreadyRegistered = 712 enumerator :: cudaErrorHostMemoryNotRegistered = 713 enumerator :: cudaErrorHardwareStackError = 714 enumerator :: cudaErrorIllegalInstruction = 715 enumerator :: cudaErrorMisalignedAddress = 716 enumerator :: cudaErrorInvalidAddressSpace = 717 enumerator :: cudaErrorInvalidPc = 718 enumerator :: cudaErrorLaunchFailure = 719 enumerator :: cudaErrorCooperativeLaunchTooLarge = 720 enumerator :: cudaErrorNotPermitted = 800 enumerator :: cudaErrorNotSupported = 801 enumerator :: cudaErrorSystemNotReady = 802 enumerator :: cudaErrorSystemDriverMismatch = 803 enumerator :: cudaErrorCompatNotSupportedOnDevice = 804 enumerator :: cudaErrorStreamCaptureUnsupported = 900 enumerator :: cudaErrorStreamCaptureInvalidated = 901 enumerator :: cudaErrorStreamCaptureMerge = 902 enumerator :: cudaErrorStreamCaptureUnmatched = 903 enumerator :: cudaErrorStreamCaptureUnjoined = 904 enumerator :: cudaErrorStreamCaptureIsolation = 905 enumerator :: cudaErrorStreamCaptureImplicit = 906 enumerator :: cudaErrorCapturedEvent = 907 enumerator :: cudaErrorStreamCaptureWrongThread = 908 enumerator :: cudaErrorTimeout = 909 enumerator :: cudaErrorGraphExecUpdateFailure = 910 enumerator :: cudaErrorUnknown = 999 enumerator :: cudaErrorApiFailureBase = 10000 enum, bind(c) Enumerators enumerator :: cudaMemcpyHostToHost = 0 enumerator :: cudaMemcpyHostToDevice = 1 enumerator :: cudaMemcpyDeviceToHost = 2 enumerator :: cudaMemcpyDeviceToDevice = 3 enumerator :: cudaMemcpyDefault = 4 Interfaces interface Queries an asynchronous stream for completion status. public  function cudaStreamQuery(stream) result(cudaError_t) bind(C, name=\"cudaStreamQuery\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if all operations in stream have completed, \nor cudaErrorNotReady if not. interface Creates an asynchronous stream. public  function cudaStreamCreate(stream) result(cudaError_t) bind(C, name=\"cudaStreamCreate\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ) :: stream Pointer to the created stream Return Value integer(kind=c_int) Returns cudaSuccess if the stream was created successfully, \nor an error code if there was an issue. interface Destroys an asynchronous stream. public  function cudaStreamDestroy(stream) result(cudaError_t) bind(C, name=\"cudaStreamDestroy\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the stream was destroyed successfully, \nor an error code if there was an issue. interface Waits for stream tasks to complete. public  function cudaStreamSynchronize(stream) result(cudaError_t) bind(C, name=\"cudaStreamSynchronize\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the stream tasks completed successfully, \nor an error code if there was an issue. interface Allocates memory on the device. public  function cudaMalloc(ptr, count) result(cudaError_t) bind(C, name=\"cudaMalloc\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr Pointer to allocated device memory integer(kind=c_size_t), value :: count Requested allocation size in bytes Return Value integer(kind=c_int) Returns cudaSuccess if memory was allocated successfully, \nor cudaErrorMemoryAllocation if the memory could not be allocated. interface Frees memory on the device. public  function cudaFree(ptr) result(cudaError_t) bind(C, name=\"cudaFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to memory to free Return Value integer(kind=c_int) Returns cudaSuccess if memory was freed successfully, \nor an error code if there was an issue. interface Initializes or sets device memory to a value. public  function cudaMemset(ptr, val, count) result(cudaError_t) bind(C, name=\"cudaMemset\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to device memory integer(kind=c_int), value :: val Value to set integer(kind=c_size_t), value :: count Size in bytes to set Return Value integer(kind=c_int) Returns cudaSuccess if the memory was set successfully, \nor an error code if there was an issue. interface Creates an event with the specified flags. public  function cudaEventCreateWithFlags(event, flags) result(cudaError_t) bind(C, name=\"cudaEventCreateWithFlags\") Arguments Type Intent Optional Attributes Name type( cudaEvent ) :: event Event identifier integer(kind=c_int), value :: flags Flags for event creation Return Value integer(kind=c_int) Returns cudaSuccess if the event was created successfully, \nor an error code if there was an issue. interface Records an event in a stream. public  function cudaEventRecord(event, stream) result(cudaError_t) bind(C, name=\"cudaEventRecord\") Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was recorded successfully, \nor an error code if there was an issue. interface Makes a stream wait on an event. public  function cudaStreamWaitEvent(stream, event, flags) result(cudaError_t) bind(C, name=\"cudaStreamWaitEvent\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier type( cudaEvent ), value :: event Event identifier integer(kind=c_int), value :: flags Flags for the wait operation Return Value integer(kind=c_int) Returns cudaSuccess if the stream is waiting successfully, \nor an error code if there was an issue. interface Destroys an event. public  function cudaEventDestroy(event) result(cudaError_t) bind(C, name=\"cudaEventDestroy\") Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was destroyed successfully, \nor an error code if there was an issue. interface Creates an event. public  function cudaEventCreate(event) result(cudaError_t) bind(C, name=\"cudaEventCreate\") Arguments Type Intent Optional Attributes Name type( cudaEvent ) :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was created successfully, \nor an error code if there was an issue. interface Waits for an event to complete. public  function cudaEventSynchronize(event) result(cudaError_t) bind(C, name=\"cudaEventSynchronize\") Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event completed successfully, \nor an error code if there was an issue. interface Computes the elapsed time between two events. public  function cudaEventElapsedTime(time, start, end) result(cudaError_t) bind(C, name=\"cudaEventElapsedTime\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: time Elapsed time in milliseconds type( cudaEvent ), value :: start Starting event type( cudaEvent ), value :: end Ending event Return Value integer(kind=c_int) Returns cudaSuccess if the elapsed time was computed successfully, \nor an error code if there was an issue. public        interface cudaMemcpyAsync Copies data asynchronously between host and device. private  function cudaMemcpyAsync_ptr(dst, src, count, kdir, stream) result(cudaError_t) bind(C, name=\"cudaMemcpyAsync\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dst Destination pointer type(c_ptr), value :: src Source pointer integer(kind=c_size_t), value :: count Size in bytes to copy integer(kind=c_int), value :: kdir Direction of copy (host-to-device, device-to-host, etc.) type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the copy was initiated successfully, \nor an error code if there was an issue. private  function cudaMemcpyAsync_r32(dst, src, count, kdir, stream) result(cudaError_t) bind(C, name=\"cudaMemcpyAsync\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: dst Destination array (32-bit float) real(kind=c_float) :: src Source array (32-bit float) integer(kind=c_size_t), value :: count Number of elements to copy integer(kind=c_int), value :: kdir Direction of copy type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the copy was initiated successfully, \nor an error code if there was an issue. public        interface cudaMemcpy Copies data synchronously between host and device. private  function cudaMemcpy_ptr(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dst Destination pointer type(c_ptr), value :: src Source pointer integer(kind=c_size_t), value :: count Size in bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully, \nor an error code if there was an issue. private  function cudaMemcpy_r64(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name real(kind=c_double) :: dst (*) Destination array (64-bit float) real(kind=c_double) :: src (*) Source array (64-bit float) integer(kind=c_size_t), value :: count Number of bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully, \nor an error code if there was an issue. private  function cudaMemcpy_r32(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: dst (*) Destination array (32-bit float) real(kind=c_float) :: src (*) Source array (32-bit float) integer(kind=c_size_t), value :: count Number of bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully, \nor an error code if there was an issue. interface Returns the current device. public  function cudaGetDevice(num) result(cudaError_t) bind(C, name=\"cudaGetDevice\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: num Device number Return Value integer(kind=c_int) Returns cudaSuccess if the device was retrieved successfully, \nor an error code if there was an issue. interface Returns the number of available devices. public  function cudaGetDeviceCount(num) result(cudaError_t) bind(C, name=\"cudaGetDeviceCount\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: num Number of devices Return Value integer(kind=c_int) Returns cudaSuccess if the device count was retrieved successfully, \nor an error code if there was an issue. interface Sets the current device. public  function cudaSetDevice(num) result(cudaError_t) bind(C, name=\"cudaSetDevice\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: num Device number Return Value integer(kind=c_int) Returns cudaSuccess if the device was set successfully, \nor an error code if there was an issue. interface Returns the CUDA architecture for a given device. public  subroutine get_cuda_architecture(device, major, minor) bind(C, name=\"get_cuda_architecture\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: device Device number integer(kind=c_int) :: major Major compute capability integer(kind=c_int) :: minor Minor compute capability interface Returns the amount of free and total memory on the device. public  function cudaMemGetInfo(free, total) result(cudaError_t) bind(C, name=\"cudaMemGetInfo\") Arguments Type Intent Optional Attributes Name integer(kind=c_size_t) :: free Free memory in bytes integer(kind=c_size_t) :: total Total memory in bytes Return Value integer(kind=c_int) Returns cudaSuccess if the memory information was retrieved successfully, \nor an error code if there was an issue. interface Synchronizes the device, blocking until all preceding tasks in all streams have completed. public  function cudaDeviceSynchronize() result(cudaError_t) bind(C, name=\"cudaDeviceSynchronize\") Arguments None Return Value integer(kind=c_int) Returns cudaSuccess if the device was set successfully, \nor an error code if there was an issue. interface Returns the string representation of an error code. private  function cudaGetErrorString_c(errcode) result(string) bind(C, name=\"cudaGetErrorString\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: errcode Error code Return Value type(c_ptr) Pointer to the error string Derived Types type, public, bind(C) :: dim3 Dimension specification type Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: x integer(kind=c_int), public :: y integer(kind=c_int), public :: z type, public, bind(C) :: cudaEvent CUDA event types Components Type Visibility Attributes Name Initial type(c_ptr), public :: event Handle Functions public  function cudaGetErrorString (errcode) result(string) Helper function that returns a string describing the given nvrtcResult code\nIf the error code is not recognized, “unrecognized error code” is returned. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: errcode CUDA Runtime Compilation API result code. Return Value character(len=:), allocatable Result string","tags":"","loc":"module/dtfft_interface_cuda_runtime.html"},{"title":"dtfft_interface_nvshmem – dtFFT","text":"NVSHMEM Interfaces Uses dtfft_parameters iso_fortran_env dtfft_utils iso_c_binding module~~dtfft_interface_nvshmem~~UsesGraph module~dtfft_interface_nvshmem dtfft_interface_nvshmem iso_c_binding iso_c_binding module~dtfft_interface_nvshmem->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_parameters dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_nvshmem~~UsedByGraph module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( nvshmem_team_t ), public, parameter :: NVSHMEM_TEAM_WORLD = nvshmem_team_t(0) Interfaces interface public  function nvshmem_malloc(size) result(ptr) bind(C) Allocates symmetric memory in the NVSHMEM heap. Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: size Size of the allocation in bytes. Return Value type(c_ptr) Pointer to the allocated memory. interface public  function nvshmemx_float_alltoall_on_stream(team, dest, source, nelems, stream) result(ierr) bind(C) Performs an all-to-all exchange of floating-point data on the specified stream. Arguments Type Intent Optional Attributes Name type( nvshmem_team_t ), intent(in), value :: team NVSHMEM team. type(c_ptr), value :: dest Destination buffer. type(c_ptr), value :: source Source buffer. integer(kind=c_size_t), intent(in), value :: nelems Number of elements to exchange. type( dtfft_stream_t ), intent(in), value :: stream CUDA stream for the operation. Return Value integer(kind=c_int) Completion status. interface public  function nvshmem_ptr(ptr, pe) result(pe_ptr) bind(C) Returns a pointer to a symmetric memory location on a specified PE. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Local pointer to the symmetric memory. integer(kind=c_int), value :: pe PE (Processing Element) number. Return Value type(c_ptr) Pointer to the symmetric memory on the specified PE. interface public  function nvshmem_my_pe() result(pe) bind(C) Returns the PE (Processing Element) number of the calling thread. Arguments None Return Value integer(kind=c_int) PE number of the calling thread. interface public  function nvshmemx_init_status() result(status) bind(C) Arguments None Return Value integer(kind=c_int) Completion status. interface public  subroutine nvshmem_free(ptr) bind(C) Frees symmetric memory allocated by nvshmem_malloc. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to the memory to free. interface public  subroutine nvshmemx_sync_all_on_stream(stream) bind(C) Synchronizes all PEs (Processing Elements) on the specified stream. Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), intent(in), value :: stream CUDA stream for synchronization. Derived Types type, public, bind(C) :: nvshmem_team_t NVSHMEM team. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal representation of the NVSHMEM team. Functions public  function is_nvshmem_ptr (ptr) result(bool) Checks if pointer is a symmetric nvshmem allocated pointer Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr Device pointer Return Value logical Result","tags":"","loc":"module/dtfft_interface_nvshmem.html"},{"title":"dtfft_abstract_backend – dtFFT","text":"This module describes Abstraction for all GPU Backends: abstract_backend Uses dtfft_nvrtc_kernel dtfft_parameters dtfft_interface_cuda_runtime iso_fortran_env dtfft_interface_nccl iso_c_binding dtfft_pencil dtfft_utils mpi_f08 module~~dtfft_abstract_backend~~UsesGraph module~dtfft_abstract_backend dtfft_abstract_backend iso_c_binding iso_c_binding module~dtfft_abstract_backend->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_abstract_backend->iso_fortran_env module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_parameters dtfft_parameters module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_backend->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_abstract_backend->mpi_f08 module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_errors dtfft_errors module~dtfft_pencil->module~dtfft_errors module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_abstract_backend~~UsedByGraph module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: NCCL_REGISTER_PREALLOC_SIZE = 8 Abstract Interfaces abstract interface private  subroutine create_interface(self, helper, tranpose_type, base_storage) Creates overring class Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element abstract interface private  subroutine execute_interface(self, in, out, stream, aux) Executes GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer abstract interface private  subroutine destroy_interface(self) Destroys overring class Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend Derived Types type, public :: backend_helper Helper with nccl, mpi and nvshmem communicators Components Type Visibility Attributes Name Initial logical, public :: is_nccl_created = .false. Flag is nccl_comm has been created type( ncclComm ), public :: nccl_comm NCCL communicator logical, public :: should_register If NCCL buffer should be registered type(c_ptr), public, allocatable :: nccl_register (:,:) NCCL register cache integer(kind=int32), public :: nccl_register_size Number of elements in nccl_register type(MPI_Comm), public, allocatable :: comms (:) MPI communicators integer(kind=int32), public, allocatable :: comm_mappings (:,:) Mapping of 1d comm ranks to global comm type( dtfft_transpose_t ), public :: tranpose_type Type of transpose to create type( pencil ), public, pointer :: pencils (:) Pencils Type-Bound Procedures procedure, public, pass(self) :: create => create_helper ../../ Creates helper procedure, public, pass(self) :: destroy => destroy_helper ../../ Destroys helper type, public, abstract :: abstract_backend The most Abstract GPU Backend Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer type( nvrtc_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), public, pointer :: unpack_kernel2 Kernel for unpacking data Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates Abstract GPU Backend procedure, public, non_overridable, pass(self) :: execute ../../ Executes GPU Backend procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys Abstract GPU Backend procedure, public, non_overridable, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, non_overridable, pass(self) :: set_unpack_kernel ../../ Sets unpack kernel for pipelined backend procedure( create_interface ), public, deferred, pass(self) :: create_private ../../ Creates overring class procedure( execute_interface ), public, deferred, pass(self) :: execute_private ../../ Executes GPU Backend procedure( destroy_interface ), public, deferred, pass(self) :: destroy_private ../../ Destroys overring class Functions private  function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract GPU backend Return Value integer(kind=int64) Subroutines private  subroutine create (self, backend, tranpose_type, helper, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU Backend type( dtfft_backend_t ), intent(in) :: backend GPU Backend type type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element private  subroutine execute (self, in, out, stream, aux) Executes GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer private  subroutine destroy (self) Destroys Abstract GPU Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract GPU backend private  subroutine set_unpack_kernel (self, unpack_kernel, unpack_kernel2) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend type( nvrtc_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), intent(in), optional, target :: unpack_kernel2 Kernel for unpacking data private  subroutine create_helper (self, base_comm, comms, is_nccl_needed, pencils) Creates helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper type(MPI_Comm), intent(in) :: base_comm MPI communicator type(MPI_Comm), intent(in) :: comms (:) 1D Communicators logical, intent(in) :: is_nccl_needed If nccl communicator will be needed type( pencil ), intent(in), target :: pencils (:) Pencils private  subroutine destroy_helper (self) Destroys helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper","tags":"","loc":"module/dtfft_abstract_backend.html"},{"title":"dtfft_executor_vkfft_m – dtFFT","text":"This module describes VkFFT based FFT Executor: vkfft_executor https://github.com/DTolm/VkFFT/tree/master Uses dtfft_parameters dtfft_abstract_executor dtfft_interface_vkfft_m iso_fortran_env iso_c_binding dtfft_config dtfft_errors module~~dtfft_executor_vkfft_m~~UsesGraph module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m iso_c_binding iso_c_binding module~dtfft_executor_vkfft_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_executor_vkfft_m->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_config dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_parameters dtfft_parameters module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_pencil dtfft_pencil module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_vkfft_m->iso_c_binding module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_executor_vkfft_m~~UsedByGraph module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_executor ) :: vkfft_executor vkFFT FFT Executor Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? type( vkfft_wrapper ), private, pointer :: wrapper => null() VkFFT Wrapper logical, private :: is_inverse_required Should be create separate inverse FFT Plan or not Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure, public, pass(self) :: create_private => create ../../ Creates FFT plan via vkFFT Interface procedure, public, pass(self) :: execute_private => execute ../../ Executes vkFFT plan procedure, public, pass(self) :: destroy_private => destroy ../../ Destroys vkFFT plan procedure, public, nopass :: mem_alloc ../../ Dummy method. Raises error stop procedure, public, nopass :: mem_free ../../ Dummy method. Raises error stop Subroutines private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via vkFFT Interface Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform private  subroutine execute (self, a, b, sign) Executes vkFFT plan Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(in) :: self vkFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys vkFFT plan Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor private  subroutine mem_alloc (alloc_bytes, ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer private  subroutine mem_free (ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"module/dtfft_executor_vkfft_m.html"},{"title":"dtfft_transpose_plan_host – dtFFT","text":"This module describes transpose_plan_host class Uses dtfft_parameters iso_fortran_env dtfft_interface_nvtx dtfft_pencil dtfft_transpose_handle_host dtfft_utils dtfft_errors dtfft_abstract_transpose_plan mpi_f08 module~~dtfft_transpose_plan_host~~UsesGraph module~dtfft_transpose_plan_host dtfft_transpose_plan_host iso_fortran_env iso_fortran_env module~dtfft_transpose_plan_host->iso_fortran_env module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_errors dtfft_errors module~dtfft_transpose_plan_host->module~dtfft_errors module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_transpose_plan_host->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_transpose_plan_host->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_transpose_plan_host->module~dtfft_pencil module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft_utils dtfft_utils module~dtfft_transpose_plan_host->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_transpose_plan_host->mpi_f08 module~dtfft_abstract_transpose_plan->iso_fortran_env module~dtfft_abstract_transpose_plan->module~dtfft_errors module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan->module~dtfft_parameters module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_abstract_transpose_plan->module~dtfft_utils module~dtfft_abstract_transpose_plan->mpi_f08 iso_c_binding iso_c_binding module~dtfft_abstract_transpose_plan->iso_c_binding module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_config dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_errors->iso_fortran_env module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_transpose_handle_host->iso_fortran_env module~dtfft_transpose_handle_host->module~dtfft_interface_nvtx module~dtfft_transpose_handle_host->module~dtfft_parameters module~dtfft_transpose_handle_host->module~dtfft_pencil module~dtfft_transpose_handle_host->mpi_f08 module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_transpose_plan_host~~UsedByGraph module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int8), private, save :: FORWARD_PLAN_IDS (3) integer(kind=int8), private, save :: BACKWARD_PLAN_IDS (3) Derived Types type, public, extends( abstract_transpose_plan ) :: transpose_plan_host Host transpose plan Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend = DTFFT_BACKEND_MPI_DATATYPE GPU backend type( backend_helper ), public :: helper Backend helper logical, public :: is_z_slab Z-slab optimization flag (for 3D transforms) integer(kind=int64), public :: min_buffer_size Minimal buffer size for transposition type( transpose_handle_host ), private, allocatable :: fplans (:) Forward plans type( transpose_handle_host ), private, allocatable :: bplans (:) Backward plans Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Create transposition plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes transposition procedure, public, pass(self) :: get_aux_size ../../ Returns auxiliary buffer size procedure, public, non_overridable, pass(self) :: get_backend ../../ Returns backend id procedure, public, non_overridable, pass(self) :: mem_alloc ../../ Allocates memory based on selected backend procedure, public, non_overridable, pass(self) :: mem_free ../../ Frees memory allocated with mem_alloc procedure, public :: create_private procedure, public :: execute_private procedure, public :: destroy procedure, private, nopass :: get_plan_execution_time procedure, private, pass(self) :: autotune_transpose_id procedure, private, pass(self) :: autotune_mpi_datatypes procedure, private, pass(self) :: autotune_grid_decomposition procedure, private, pass(self) :: autotune_grid Functions private  function create_private (self, dims, transposed_dims, base_comm, comm_dims, effort, base_dtype, base_storage, is_custom_cart_comm, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plans Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator integer(kind=int32), intent(in) :: comm_dims (:) Number of MPI Processes in all directions type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_custom_cart_comm Is custom Cartesian communicator provided by user type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Pencils type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code private  function autotune_transpose_id (self, comm, cart_comm, from, to, base_dtype, base_storage, transpose_name_id, a, b, forward_id, backward_id) result(elapsed_time) Creates forward and backward transpose plans bases on source and target data distributing,\nexecutes them DTFFT_MEASURE_ITERS times ( 4 * DTFFT_MEASURE_ITERS iterations total ) Read more… Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Abstract plan type(MPI_Comm), intent(in) :: comm 1D comm in case of pencils, 3D comm in case of z_slabs type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer integer(kind=int8), intent(out) :: forward_id Best forward plan ID integer(kind=int8), intent(out) :: backward_id Best backward plan ID Return Value real(kind=real64) Elapsed time for best plans selected private  function get_plan_execution_time (comm, cart_comm, from, to, base_dtype, base_storage, datatype_id, transpose_name_id, a, b) result(elapsed_time) Creates transpose plan and executes it DTFFT_MEASURE_WARMUP_ITERS + DTFFT_MEASURE_ITERS times Read more… Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm 1D comm in case of pencils, 3D comm in case of z_slabs type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: datatype_id ID of transpose (1 or 2) integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer Return Value real(kind=real64) Execution time Subroutines private  subroutine execute_private (self, in, out, transpose_type) Executes single transposition Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(inout) :: self Transposition class real(kind=real32), intent(inout) :: in (:) Incoming buffer real(kind=real32), intent(inout) :: out (:) Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to execute private  subroutine destroy (self) Destroys transposition plans Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(inout) :: self Transposition class private  subroutine autotune_grid_decomposition (self, dims, transposed_dims, base_comm, effort, n_transpose_plans, base_dtype, base_storage, best_comm_dims, best_forward_ids, best_backward_ids) Runs through all possible grid decompositions and selects the best one based on the lowest average execution time Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dims (:) Global dims integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dims type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int8), intent(in) :: n_transpose_plans Number of transpose plans to test type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(out) :: best_comm_dims (:) Best communicator dimensions integer(kind=int8), intent(inout) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(inout) :: best_backward_ids (:) Best Datatype ids for backward plan private  subroutine autotune_grid (self, base_comm, comm_dims, dims, transposed_dims, effort, base_dtype, base_storage, latest_timer_id, timers, decomps, forw_ids, back_ids, ipencil) Creates cartesian communicator and executes various datatypes on it Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Abstract plan type(MPI_Comm), intent(in) :: base_comm Base communicator integer(kind=int32), intent(in) :: comm_dims (:) Number of MPI Processes in Y and Z directions integer(kind=int32), intent(in) :: dims (:) Global dims integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dims type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int32), intent(inout) :: latest_timer_id Current timer id real(kind=real64), intent(inout) :: timers (:) Time of current function execution is stored in timers(latest_timer_id) integer(kind=int32), intent(inout) :: decomps (:,:) Current decomposition is stored in decomps(:, latest_timer_id) integer(kind=int8), intent(inout) :: forw_ids (:,:) Best Forward ids are stored in forw_ids(:, latest_timer_id) integer(kind=int8), intent(inout) :: back_ids (:,:) Best Backward ids are stored in back_ids(:, latest_timer_id) type( pencil_init ), intent(in), optional :: ipencil private  subroutine autotune_mpi_datatypes (self, pencils, cart_comm, comms, base_dtype, base_storage, a, b, forward_ids, backward_ids, elapsed_time) Arguments Type Intent Optional Attributes Name class( transpose_plan_host ), intent(in) :: self Host plan type( pencil ), intent(in) :: pencils (:) Array of pencils type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type(MPI_Comm), intent(in) :: comms (:) Array of 1d communicators type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype real(kind=real32), intent(inout) :: a (:) Work buffer real(kind=real32), intent(inout) :: b (:) Work buffer integer(kind=int8), intent(inout) :: forward_ids (:) Forward plan IDs integer(kind=int8), intent(inout) :: backward_ids (:) Backward plan IDs real(kind=real64), intent(out) :: elapsed_time Elapsed time","tags":"","loc":"module/dtfft_transpose_plan_host.html"},{"title":"dtfft_interface_fftw_m – dtFFT","text":"This module creates interface with fftw3 library Uses iso_c_binding dtfft_interface_fftw_native_m module~~dtfft_interface_fftw_m~~UsesGraph module~dtfft_interface_fftw_m dtfft_interface_fftw_m dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m iso_c_binding iso_c_binding module~dtfft_interface_fftw_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_fftw_m~~UsedByGraph module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface public  function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Creates C2C plan, double precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Creates C2C plan, single precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates R2C plan, double precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates R2C plan, single precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates C2R plan, double precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates C2R plan, single precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C) Creates R2R plan, double precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kind (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C) Creates R2R plan, single precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kind (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  subroutine fftw_execute_dft(plan, in, out) bind(C) Executes C2C plan, double precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftwf_execute_dft(plan, in, out) bind(C) Executes C2C plan, single precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftw_execute_dft_r2c(plan, in, out) bind(C) Executes R2C plan, double precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftwf_execute_dft_r2c(plan, in, out) bind(C) Executes R2C plan, single precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftw_execute_dft_c2r(plan, in, out) bind(C) Executes C2R plan, double precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftwf_execute_dft_c2r(plan, in, out) bind(C) Executes C2R plan, single precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftw_execute_r2r(plan, in, out) bind(C) Executes R2R plan, double precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftwf_execute_r2r(plan, in, out) bind(C) Executes R2R plan, single precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out","tags":"","loc":"module/dtfft_interface_fftw_m.html"},{"title":"dtfft_executor_cufft_m – dtFFT","text":"This module describes cuFFT based FFT Executor: vkfft_executor https://docs.nvidia.com/cuda/cufft/index.html Uses dtfft_parameters dtfft_abstract_executor dtfft_interface_cuda_runtime iso_fortran_env iso_c_binding dtfft_utils dtfft_interface_cufft dtfft_config dtfft_errors mpi_f08 module~~dtfft_executor_cufft_m~~UsesGraph module~dtfft_executor_cufft_m dtfft_executor_cufft_m iso_c_binding iso_c_binding module~dtfft_executor_cufft_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_executor_cufft_m->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_config dtfft_config module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_parameters dtfft_parameters module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_executor_cufft_m->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_executor_cufft_m->mpi_f08 module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_pencil dtfft_pencil module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_executor_cufft_m~~UsedByGraph module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_executor ) :: cufft_executor cuFFT FFT Executor Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure, public :: create_private => create ../../ Creates FFT plan via cuFFT Interface procedure, public :: execute_private => execute ../../ Executes cuFFT plan procedure, public :: destroy_private => destroy ../../ Destroys cuFFT plan procedure, public, nopass :: mem_alloc ../../ Dummy method. Raises error stop procedure, public, nopass :: mem_free ../../ Dummy method. Raises error stop Subroutines private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via cuFFT Interface Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform private  subroutine execute (self, a, b, sign) Executes cuFFT plan Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(in) :: self cuFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys cuFFT plan Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor private  subroutine mem_alloc (alloc_bytes, ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer private  subroutine mem_free (ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"module/dtfft_executor_cufft_m.html"},{"title":"dtfft_backend_mpi – dtFFT","text":"MPI Based GPU Backends backend_mpi Uses dtfft_parameters dtfft_interface_cuda_runtime iso_c_binding iso_fortran_env dtfft_utils dtfft_abstract_backend mpi_f08 module~~dtfft_backend_mpi~~UsesGraph module~dtfft_backend_mpi dtfft_backend_mpi iso_c_binding iso_c_binding module~dtfft_backend_mpi->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_backend_mpi->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_parameters dtfft_parameters module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_backend_mpi->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_backend_mpi->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_pencil->module~dtfft_errors module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_backend_mpi~~UsedByGraph module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_backend ) :: backend_mpi MPI Backend Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer type( nvrtc_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), public, pointer :: unpack_kernel2 Kernel for unpacking data type( mpi_backend_helper ), private :: send MPI Helper for send data type( mpi_backend_helper ), private :: recv MPI Helper for recv data Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates Abstract GPU Backend procedure, public, non_overridable, pass(self) :: execute ../../ Executes GPU Backend procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys Abstract GPU Backend procedure, public, non_overridable, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, non_overridable, pass(self) :: set_unpack_kernel ../../ Sets unpack kernel for pipelined backend procedure, public :: create_private => create_mpi ../../ Creates MPI backend procedure, public :: execute_private => execute_mpi ../../ Executes MPI backend procedure, public :: destroy_private => destroy_mpi ../../ Destroys MPI backend type, private :: mpi_backend_helper MPI Helper Components Type Visibility Attributes Name Initial integer(kind=CNT_KIND), public, allocatable :: counts (:) Counts of data to send or recv integer(kind=ADDR_KIND), public, allocatable :: displs (:) Displacements of data to send or recv type(MPI_Request), public, allocatable :: requests (:) MPI Requests integer(kind=int32), public :: n_requests Number of requests logical, public :: is_request_created = .false. Request created flag. Used for persistent functions Type-Bound Procedures procedure, public, pass(self) :: create => create_helper ../../ Creates MPI helper procedure, public, pass(self) :: destroy => destoy_helper ../../ Destroys MPI helper Subroutines private  subroutine create_helper (self, counts, displs, max_requests) Creates MPI helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper integer(kind=int64), intent(in) :: counts (:) Counts of data to send or recv integer(kind=int64), intent(in) :: displs (:) Displacements of data to send or recv integer(kind=int32), intent(in) :: max_requests Maximum number of requests required private  subroutine destoy_helper (self) Destroys MPI helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper private  subroutine create_mpi (self, helper, tranpose_type, base_storage) Creates MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI GPU Backend type( backend_helper ), intent(in) :: helper Backend helper (unused) type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create (unused) integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) private  subroutine destroy_mpi (self) Destroys MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI GPU Backend private  subroutine execute_mpi (self, in, out, stream, aux) Executes MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer private  subroutine run_mpi_p2p (comm, send, recv, in, out) Executes MPI point-to-point communication Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI communicator type( mpi_backend_helper ), intent(inout) :: send MPI Helper for send data type( mpi_backend_helper ), intent(inout) :: recv MPI Helper for recv data real(kind=real32), intent(in) :: in (:) Data to be sent real(kind=real32), intent(inout) :: out (:) Data to be received private  subroutine run_mpi_a2a (comm, send, recv, in, out) Executes MPI all-to-all communication Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI communicator type( mpi_backend_helper ), intent(inout) :: send MPI Helper for send data type( mpi_backend_helper ), intent(inout) :: recv MPI Helper for recv data real(kind=real32), intent(in) :: in (:) Data to be sent real(kind=real32), intent(inout) :: out (:) Data to be received","tags":"","loc":"module/dtfft_backend_mpi.html"},{"title":"dtfft_interface_nvtx – dtFFT","text":"nvtx3 Interfaces Uses dtfft_utils iso_c_binding module~~dtfft_interface_nvtx~~UsesGraph module~dtfft_interface_nvtx dtfft_interface_nvtx iso_c_binding iso_c_binding module~dtfft_interface_nvtx->iso_c_binding module~dtfft_utils dtfft_utils module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_utils->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_utils->module~dtfft_parameters mpi_f08 mpi_f08 module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_nvtx~~UsedByGraph module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_handle_host->module~dtfft_interface_nvtx module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_host->module~dtfft_interface_nvtx module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( nvtxDomainHandle ), private, save :: domain_nvtx NVTX domain handle logical, private, save :: domain_created = .false. Has domain been created? Interfaces interface Creates an NVTX domain with the specified name. private  subroutine nvtxDomainCreate_c(name, domain) bind(C, name=\"nvtxDomainCreate_c\") Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: name (*) Name of the NVTX domain. type( nvtxDomainHandle ) :: domain Handle to the created NVTX domain. interface Pushes a range with a custom message and color onto the specified NVTX domain. private  subroutine nvtxDomainRangePushEx_c(domain, message, color) bind(C, name=\"nvtxDomainRangePushEx_c\") Arguments Type Intent Optional Attributes Name type( nvtxDomainHandle ), value :: domain NVTX domain handle. character(len=c_char), intent(in) :: message (*) Custom message for the range. integer(kind=c_int), intent(in), value :: color Color for the range. interface Pops a range from the specified NVTX domain. private  subroutine nvtxDomainRangePop_c(domain) bind(C, name=\"nvtxDomainRangePop_c\") Arguments Type Intent Optional Attributes Name type( nvtxDomainHandle ), value :: domain NVTX domain handle. Derived Types type, private, bind(C) :: nvtxDomainHandle Components Type Visibility Attributes Name Initial type(c_ptr), public :: handle Subroutines public  subroutine push_nvtx_domain_range (message, color) Pushes a range to the NVTX domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to push integer(kind=c_int), intent(in) :: color Color of the range public  subroutine pop_nvtx_domain_range () Pops a range from the NVTX domain Arguments None private  subroutine create_nvtx_domain () Creates a new NVTX domain Arguments None","tags":"","loc":"module/dtfft_interface_nvtx.html"},{"title":"dtfft_plan – dtFFT","text":"This module describes dtfft_plan_t , dtfft_plan_c2c_t , dtfft_plan_r2c_t and dtfft_plan_r2r_t types Uses dtfft_parameters dtfft_abstract_executor dtfft_interface_nvshmem iso_fortran_env dtfft_pencil dtfft_transpose_plan_cuda dtfft_executor_mkl_m dtfft_utils dtfft_transpose_plan_host dtfft_errors dtfft_interface_nvtx dtfft_executor_fftw_m mpi_f08 dtfft_executor_vkfft_m iso_c_binding dtfft_executor_cufft_m dtfft_config dtfft_nvrtc_kernel dtfft_interface_cuda_runtime dtfft_abstract_transpose_plan module~~dtfft_plan~~UsesGraph module~dtfft_plan dtfft_plan iso_c_binding iso_c_binding module~dtfft_plan->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_plan->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_config dtfft_config module~dtfft_plan->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_plan->module~dtfft_errors module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_parameters dtfft_parameters module~dtfft_plan->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_utils dtfft_utils module~dtfft_plan->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_plan->mpi_f08 module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_abstract_transpose_plan->iso_c_binding module~dtfft_abstract_transpose_plan->iso_fortran_env module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_errors module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_parameters module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_abstract_transpose_plan->module~dtfft_utils module~dtfft_abstract_transpose_plan->mpi_f08 module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_executor_cufft_m->iso_c_binding module~dtfft_executor_cufft_m->iso_fortran_env module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->mpi_f08 module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m->iso_c_binding module~dtfft_executor_fftw_m->iso_fortran_env module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_executor_mkl_m->iso_c_binding module~dtfft_executor_mkl_m->iso_fortran_env module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_executor_mkl_m->mpi_f08 module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_executor_vkfft_m->iso_c_binding module~dtfft_executor_vkfft_m->iso_fortran_env module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_transpose_plan_cuda->iso_c_binding module~dtfft_transpose_plan_cuda->iso_fortran_env module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_config module~dtfft_transpose_plan_cuda->module~dtfft_errors module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_parameters module~dtfft_transpose_plan_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_utils module~dtfft_transpose_plan_cuda->mpi_f08 module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvrtc module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_host->iso_fortran_env module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_errors module~dtfft_transpose_plan_host->module~dtfft_interface_nvtx module~dtfft_transpose_plan_host->module~dtfft_parameters module~dtfft_transpose_plan_host->module~dtfft_pencil module~dtfft_transpose_plan_host->module~dtfft_utils module~dtfft_transpose_plan_host->mpi_f08 module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_fftw_m->iso_c_binding dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_interface_mkl_m->module~dtfft_utils MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_vkfft_m->iso_c_binding module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_transpose_handle_cuda->iso_c_binding module~dtfft_transpose_handle_cuda->iso_fortran_env module~dtfft_transpose_handle_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_handle_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_parameters module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_transpose_handle_cuda->module~dtfft_utils module~dtfft_transpose_handle_cuda->mpi_f08 module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_host->iso_fortran_env module~dtfft_transpose_handle_host->module~dtfft_interface_nvtx module~dtfft_transpose_handle_host->module~dtfft_parameters module~dtfft_transpose_handle_host->module~dtfft_pencil module~dtfft_transpose_handle_host->mpi_f08 module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_nccl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_plan~~UsedByGraph module~dtfft_plan dtfft_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, abstract :: dtfft_plan_t Abstract class for all dtFFT plans Components Type Visibility Attributes Name Initial integer(kind=int8), private :: ndims Number of global dimensions integer(kind=int32), private, allocatable :: dims (:) Global dimensions type( dtfft_precision_t ), private :: precision Precision of transform logical, private :: is_created = .false. Plan creation flag logical, private :: is_transpose_plan = .false. Plan is transpose only logical, private :: is_aux_alloc = .false. Auxiliary buffer is allocated internally logical, private :: is_z_slab = .false. Using Z-slab optimization Read more… type( dtfft_effort_t ), private :: effort User defined type of effort integer(kind=int64), private :: storage_size Single element size in bytes type( dtfft_executor_t ), private :: executor FFT executor type type(MPI_Comm), private :: comm Grid communicator type(MPI_Comm), private, allocatable :: comms (:) Local 1d communicators class( abstract_transpose_plan ), private, allocatable :: plan Transpose plan handle type( pencil ), private, allocatable :: pencils (:) Information about data aligment and datatypes type( dtfft_platform_t ), private :: platform Execution platform type( dtfft_stream_t ), private :: stream CUDA Stream associated with current plan type(c_ptr), private :: aux_ptr Auxiliary pointer type( fft_executor ), private, allocatable :: fft (:) Internal fft runners integer(kind=int32), private, allocatable :: fft_mapping (:) Memory and plan creation optimization.\nIn case same FFTs needs to be run in different dimensions\nonly single FFT plan needs to be created Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected GPU backend during autotuning generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan procedure, private, pass(self), non_overridable :: get_stream_ptr ../../ Returns CUDA stream associated with plan procedure, private, pass(self), non_overridable :: get_stream_int64 ../../ Returns CUDA stream associated with plan procedure, private, pass(self), non_overridable :: execute_private ../../ Executes plan procedure, private, pass(self), non_overridable :: check_create_args ../../ Check arguments provided to create subroutines procedure, private, pass(self), non_overridable :: create_private ../../ Creates core procedure, private, pass(self), non_overridable :: alloc_fft_plans ../../ Allocates fft_executor classes procedure, private, pass(self), non_overridable :: check_aux ../../ Checks if aux buffer was passed\nand if not will allocate one internally procedure, private, pass(self), non_overridable :: mem_alloc_r32_1d ../../ Allocates memory for 1d real32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r64_1d ../../ Allocates memory for 1d real64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r32_2d ../../ Allocates memory for 2d real32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r64_2d ../../ Allocates memory for 2d real64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r32_3d ../../ Allocates memory for 2d real32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r64_3d ../../ Allocates memory for 2d real64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c32_1d ../../ Allocates memory for 1d complex32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c64_1d ../../ Allocates memory for 1d complex64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c32_2d ../../ Allocates memory for 2d complex32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c64_2d ../../ Allocates memory for 2d complex64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c32_3d ../../ Allocates memory for 3d complex32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c64_3d ../../ Allocates memory for 3d complex64 pointer procedure, private, pass(self), non_overridable :: mem_free_r32_1d ../../ Frees real32 1d pointer procedure, private, pass(self), non_overridable :: mem_free_r64_1d ../../ Frees real64 1d pointer procedure, private, pass(self), non_overridable :: mem_free_r32_2d ../../ Frees real32 2d pointer procedure, private, pass(self), non_overridable :: mem_free_r64_2d ../../ Frees real64 2d pointer procedure, private, pass(self), non_overridable :: mem_free_r32_3d ../../ Frees real32 3d pointer procedure, private, pass(self), non_overridable :: mem_free_r64_3d ../../ Frees real64 3d pointer procedure, private, pass(self), non_overridable :: mem_free_c32_1d ../../ Frees complex32 1d pointer procedure, private, pass(self), non_overridable :: mem_free_c64_1d ../../ Frees complex64 1d pointer procedure, private, pass(self), non_overridable :: mem_free_c32_2d ../../ Frees complex32 2d pointer procedure, private, pass(self), non_overridable :: mem_free_c64_2d ../../ Frees complex64 2d pointer procedure, private, pass(self), non_overridable :: mem_free_c32_3d ../../ Frees complex32 3d pointer procedure, private, pass(self), non_overridable :: mem_free_c64_3d ../../ Frees complex64 3d pointer type, public, extends( dtfft_core_c2c ) :: dtfft_plan_c2c_t C2C Plan Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected GPU backend during autotuning generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan generic, public :: create => create_c2c , create_c2c_pencil ../../ Creates C2C plan procedure, private, pass(self) :: create_c2c ../../ Creates C2C plan using global dimensions procedure, private, pass(self) :: create_c2c_pencil ../../ Creates C2C plan using Pencil of local data procedure, private, pass(self) :: create_c2c_internal ../../ Private method that combines common logic for C2C plan creation type, public, extends( dtfft_core_c2c ) :: dtfft_plan_r2c_t R2C Plan Components Type Visibility Attributes Name Initial type( pencil ), private :: real_pencil “Real” pencil decomposition info Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected GPU backend during autotuning generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan generic, public :: create => create_r2c , create_r2c_pencil ../../ Creates R2C plan procedure, private, pass(self) :: create_r2c ../../ Creates R2C plan using global dimensions procedure, private, pass(self) :: create_r2c_pencil ../../ Creates R2C plan using Pencil of local data procedure, private, pass(self) :: create_r2c_internal ../../ Private method that combines common logic for R2C plan creation type, public, extends( dtfft_plan_t ) :: dtfft_plan_r2r_t R2R Plan Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected GPU backend during autotuning generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan generic, public :: create => create_r2r , create_r2r_pencil ../../ Creates R2R plan procedure, private, pass(self) :: create_r2r ../../ Creates R2R plan using global dimensions procedure, private, pass(self) :: create_r2r_pencil ../../ Creates R2R plan using Pencil of local data procedure, private, pass(self) :: create_r2r_internal ../../ Private method that combines common logic for R2R plan creation type, private :: fft_executor FFT handle Components Type Visibility Attributes Name Initial class( abstract_executor ), public, allocatable :: fft Executor type, private, abstract, extends( dtfft_plan_t ) :: dtfft_core_c2c Abstract C2C Plan Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected GPU backend during autotuning generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan procedure, private, pass(self), non_overridable :: create_c2c_core ../../ Creates plan for both C2C and R2C Functions private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical private  function get_pencil (self, dim, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: dim Required dimension: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) private  function check_device_pointers (in, out, backend, aux) result(error_code) Checks if device pointers are provided by user Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: in First pointer type(c_ptr), intent(in) :: out Second pointer type( dtfft_backend_t ), intent(in) :: backend Backend. Required to check for nvshmem pointer type(c_ptr), intent(in) :: aux Optional auxiliary pointer. Return Value integer(kind=int32) private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan private  function create_private (self, sngl_type, sngl_storage_size, dbl_type, dbl_storage_size, dims, pencil, comm, precision, effort, executor, kinds) Creates core Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(MPI_Datatype), intent(in) :: sngl_type MPI_Datatype for single precision plan integer(kind=int64), intent(in) :: sngl_storage_size Number of bytes needed to store single element (single precision) type(MPI_Datatype), intent(in) :: dbl_type MPI_Datatype for double precision plan integer(kind=int64), intent(in) :: dbl_storage_size Number of bytes needed to store single element (double precision) integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm User-defined communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) private  function check_create_args (self, dims, pencil, comm, precision, effort, executor, kinds) Check arguments provided by user and sets private variables Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm Optional MPI Communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) private  function create_r2r_internal (self, dims, pencil, kinds, comm, precision, effort, executor) Creates plan for R2R plans Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) private  function create_c2c_internal (self, dims, pencil, comm, precision, effort, executor) Private method that combines common logic for C2C plan creation Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) private  function create_c2c_core (self, dims, pencil, comm, precision, effort, executor) Creates plan for both C2C and R2C Arguments Type Intent Optional Attributes Name class( dtfft_core_c2c ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) private  function create_r2c_internal (self, executor, dims, pencil, comm, precision, effort) Private method that combines common logic for R2C plan creation Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan Return Value integer(kind=int32) Subroutines private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine execute_private (self, in, out, execute_type, aux, inplace) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. logical, intent(in) :: inplace Inplace execution flag private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine alloc_fft_plans (self, kinds) Allocates abstract_executor with required FFT class\nand populates fft_mapping with similar FFT ids Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform private  subroutine check_aux (self, aux) Checks if aux buffer was passed by user and if not will allocate one internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: aux Optional auxiliary buffer. private  subroutine create_r2r (self, dims, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2r_pencil (self, pencil, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_c2c (self, dims, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_c2c_pencil (self, pencil, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2c (self, dims, executor, comm, precision, effort, error_code) R2C Generic Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2c_pencil (self, pencil, executor, comm, precision, effort, error_code) R2C Plan Constructor with pencil Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine mem_alloc_ptr (self, alloc_bytes, ptr, error_code) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) integer(kind=int32), intent(in), optional :: lbound integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) integer(kind=int32), intent(in) :: sizes (2) integer(kind=int32), intent(in), optional :: lbounds (2) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) integer(kind=int32), intent(in) :: sizes (3) integer(kind=int32), intent(in), optional :: lbounds (3) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user","tags":"","loc":"module/dtfft_plan.html"},{"title":"dtfft – dtFFT","text":"Main dtFFT module. Should be used in a Fortran program. Uses dtfft_parameters dtfft_plan dtfft_pencil dtfft_config dtfft_errors module~~dtfft~~UsesGraph module~dtfft dtfft module~dtfft_config dtfft_config module~dtfft->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters iso_c_binding iso_c_binding module~dtfft_config->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_config->iso_fortran_env module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_utils dtfft_utils module~dtfft_config->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_errors module~dtfft_plan->module~dtfft_parameters module~dtfft_plan->module~dtfft_pencil module~dtfft_plan->iso_c_binding module~dtfft_plan->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_utils module~dtfft_plan->mpi_f08 module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_errors module~dtfft_abstract_transpose_plan->module~dtfft_parameters module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_abstract_transpose_plan->iso_c_binding module~dtfft_abstract_transpose_plan->iso_fortran_env module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_utils module~dtfft_abstract_transpose_plan->mpi_f08 module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_executor_cufft_m->iso_c_binding module~dtfft_executor_cufft_m->iso_fortran_env module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->mpi_f08 module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->iso_c_binding module~dtfft_executor_fftw_m->iso_fortran_env module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_executor_mkl_m->iso_c_binding module~dtfft_executor_mkl_m->iso_fortran_env module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_executor_mkl_m->mpi_f08 module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_executor_vkfft_m->iso_c_binding module~dtfft_executor_vkfft_m->iso_fortran_env module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_transpose_plan_cuda->module~dtfft_config module~dtfft_transpose_plan_cuda->module~dtfft_errors module~dtfft_transpose_plan_cuda->module~dtfft_parameters module~dtfft_transpose_plan_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->iso_c_binding module~dtfft_transpose_plan_cuda->iso_fortran_env module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_utils module~dtfft_transpose_plan_cuda->mpi_f08 module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvrtc module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_host->module~dtfft_errors module~dtfft_transpose_plan_host->module~dtfft_parameters module~dtfft_transpose_plan_host->module~dtfft_pencil module~dtfft_transpose_plan_host->iso_fortran_env module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_interface_nvtx module~dtfft_transpose_plan_host->module~dtfft_utils module~dtfft_transpose_plan_host->mpi_f08 module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->mpi_f08 module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_fftw_m->iso_c_binding dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_interface_mkl_m->module~dtfft_utils MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->iso_c_binding module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_transpose_handle_cuda->module~dtfft_parameters module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_transpose_handle_cuda->iso_c_binding module~dtfft_transpose_handle_cuda->iso_fortran_env module~dtfft_transpose_handle_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_handle_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_utils module~dtfft_transpose_handle_cuda->mpi_f08 module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_host->module~dtfft_parameters module~dtfft_transpose_handle_host->module~dtfft_pencil module~dtfft_transpose_handle_host->iso_fortran_env module~dtfft_transpose_handle_host->module~dtfft_interface_nvtx module~dtfft_transpose_handle_host->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_nccl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/dtfft.html"},{"title":"dtfft_nvrtc_kernel – dtFFT","text":"This module describes NVRTC Kernel class nvrtc_kernel It uses caching of compiled kernels to avoid recompilation similar kernels: nvrtc_cache Uses dtfft_parameters dtfft_interface_cuda dtfft_interface_nvrtc dtfft_interface_cuda_runtime iso_fortran_env iso_c_binding dtfft_interface_nvtx dtfft_utils mpi_f08 module~~dtfft_nvrtc_kernel~~UsesGraph module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel iso_c_binding iso_c_binding module~dtfft_nvrtc_kernel->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_nvrtc_kernel->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_errors dtfft_errors module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_nvrtc_kernel~~UsedByGraph module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DEF_TILE_SIZE = 16 Default tile size integer(kind=int8), public, parameter :: KERNEL_DUMMY = -1 Dummy kernel, does nothing integer(kind=int8), public, parameter :: KERNEL_TRANSPOSE = 1 Basic transpose kernel type. integer(kind=int8), public, parameter :: KERNEL_TRANSPOSE_PACKED = 2 Transposes data and packs it into contiguous buffer.\nShould be used only in X-Y 3D plans. integer(kind=int8), public, parameter :: KERNEL_UNPACK = 3 Unpacks contiguous buffer. integer(kind=int8), public, parameter :: KERNEL_UNPACK_SIMPLE_COPY = 4 Doesn’t actually unpacks anything. Performs cudaMemcpyAsync call.\nShould be used only when backend is DTFFT_GPU_BACKEND_CUFFTMP . integer(kind=int8), public, parameter :: KERNEL_UNPACK_PIPELINED = 5 Unpacks pack of contiguous buffer recieved from rank. integer(kind=int8), public, parameter :: KERNEL_UNPACK_PARTIAL = 6 Unpacks contiguous buffer recieved from everyone except myself. integer(kind=int32), private, parameter :: MIN_TILE_SIZE = 8 Minimum tile size. Will launch 2 warps integer(kind=int32), private, parameter :: TARGET_THREADS_PER_BLOCK = DEF_TILE_SIZE*DEF_TILE_SIZE Maximum number of threads to run in a block (256) character(len=*), private, parameter :: DEFAULT_KERNEL_NAME = \"dtfft_kernel\" Basic kernel name integer(kind=int32), private, parameter :: CACHE_PREALLOC_SIZE = 10 Number of preallocated cache entries type( nvrtc_cache ), private, allocatable, save :: cache (:) Cache of compiled kernels integer(kind=int32), private, save :: cache_size = 0 Number of entries in cache Derived Types type, public :: nvrtc_kernel nvRTC Compiled kernel class Components Type Visibility Attributes Name Initial logical, private :: is_created = .false. Kernel is created flag. logical, private :: is_dummy = .false. If kernel should do anything or not. type( CUfunction ), private :: cuda_kernel Pointer to CUDA kernel. type( dim3 ), private :: num_blocks Grid of blocks. type( dim3 ), private :: block_size Thread block. integer(kind=int8), private :: kernel_type Type of kernel to execute. type( kernelArgs ), private :: args Kernel arguments. integer(kind=int32), private, allocatable :: pointers (:,:) Optional pointers that hold info about counts and displacements\nin KERNEL_UNPACK_PIPELINED kernel. Type-Bound Procedures procedure, public, pass(self) :: create ../../ Creates kernel procedure, public, pass(self) :: execute ../../ Executes kernel procedure, public, pass(self) :: destroy ../../ Destroys kernel type, private :: kernel_code Class to build CUDA kernel code Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: raw String that holds CUDA code Type-Bound Procedures procedure, public, pass(self) :: to_cstr ../../ Converts Fortran CUDA code to C pointer procedure, public, pass(self) :: add_line ../../ Adds new line to CUDA code procedure, public, pass(self) :: destroy => destroy_code ../../ Frees all memory type, private :: nvrtc_cache Class to cache compiled kernels Components Type Visibility Attributes Name Initial integer(kind=int32), private :: ref_count = 0 Number of references to this kernel type( CUmodule ), private :: cuda_module = CUmodule(c_null_ptr) Pointer to CUDA Module. type( CUfunction ), private :: cuda_kernel = CUfunction(c_null_ptr) Pointer to CUDA kernel. integer(kind=int8), private :: kernel_type Type of kernel to execute. type( dtfft_transpose_t ), private :: transpose_type Type of transpose integer(kind=int32), private :: tile_size Tile size of transpose kernel integer(kind=int64), private :: base_storage Number of bytes needed to store single element logical, private :: has_inner_loop If kernel has inner loop Functions private  function get_tile_size (x, y) Returns tile size to use in a tranpose kernel Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x Number of elements in x direction integer(kind=int32), intent(in) :: y Number of elements in y direction Return Value integer(kind=int32) private  function get_cached_kernel (transpose_type, kernel_type, base_storage, tile_size, has_inner_loop) result(kernel) Returns cached kernel if it exists.\nIf not returns null pointer. Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition to perform integer(kind=int8), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Tile size logical, intent(in) :: has_inner_loop If kernel has inner loop Return Value type( CUfunction ) Cached kernel private  function get_true_transpose_type (transpose_type) result(transpose_type_) Returns generic transpose id.\nSince X-Y and Y-Z transpositions are symmectric, it returns only one of them.\nX-Z and Z-X are not symmetric Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition to perform Return Value type( dtfft_transpose_t ) Fixed id of transposition private  function compile_and_cache (comm, dims, transpose_type, kernel_type, base_storage, tile_size, has_inner_loop) result(kernel) Compiles kernel and caches it. Returns compiled kernel. Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI Communicator integer(kind=int32), intent(in), target :: dims (:) Global dimensions to process type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition to perform integer(kind=int8), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Tile size logical, intent(in) :: has_inner_loop If kernel has inner loop Return Value type( CUfunction ) Compiled kernel to return private  function get_transpose_kernel_code (kernel_name, ndims, base_storage, transpose_type, enable_packing, enable_multiprocess) result(code) Generates code that will be used to locally tranpose data and prepares to send it to other processes\nndims == 2 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int8), intent(in) :: ndims Number of dimensions integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_transpose_t ), intent(in) :: transpose_type Transpose id logical, intent(in) :: enable_packing If data should be manually packed or not logical, intent(in) :: enable_multiprocess If thread should process more then one element Return Value type( kernel_code ) Resulting code private  function get_unpack_kernel_code (kernel_name, base_storage, is_partial) result(code) Generates code that will be used to unpack data when it is recieved Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_partial Return Value type( kernel_code ) Resulting code private  function get_unpack_pipelined_kernel_code (kernel_name, base_storage) result(code) Generates code that will be used to partially unpack data when it is recieved from other process Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value type( kernel_code ) Resulting code Subroutines public  subroutine clean_unused_cache () Removes unused modules from cuda context Arguments None private  subroutine to_cstr (self, c_code) Converts Fortran CUDA code to C pointer Arguments Type Intent Optional Attributes Name class( kernel_code ), intent(in) :: self Kernel code character(len=c_char), intent(out), allocatable :: c_code (:) C pointer to code private  subroutine add_line (self, line) Adds new line to CUDA code Arguments Type Intent Optional Attributes Name class( kernel_code ), intent(inout) :: self Kernel code character(len=*), intent(in) :: line Line to add private  subroutine destroy_code (self) Frees all memory Arguments Type Intent Optional Attributes Name class( kernel_code ), intent(inout) :: self Kernel code private  subroutine create_device_pointer (ptr, values) Allocates memory on a device and copies values to it. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(inout) :: ptr Device pointer integer(kind=c_int), intent(in), target :: values (:) Values to copy private  subroutine get_contiguous_execution_blocks (size, num_blocks, block_sizes) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: size Total amount of iterations required type( dim3 ), intent(out) :: num_blocks Grid of blocks. type( dim3 ), intent(out) :: block_sizes Thread block. private  subroutine create (self, comm, dims, base_storage, transpose_type, kernel_type, pointers) Creates kernel Arguments Type Intent Optional Attributes Name class( nvrtc_kernel ), intent(inout) :: self nvRTC Compiled kernel class type(MPI_Comm), intent(in) :: comm MPI Communicator integer(kind=int32), intent(in), target :: dims (0:) Global dimensions to process integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition to perform integer(kind=int8), intent(in) :: kernel_type Type of kernel to build integer(kind=int32), intent(in), optional :: pointers (:,:) Optional pointers to unpack kernels private  subroutine execute (self, in, out, stream, source) Executes kernel on stream Arguments Type Intent Optional Attributes Name class( nvrtc_kernel ), intent(inout) :: self nvRTC Compiled kernel class real(kind=real32), intent(in), target :: in (:) Source pointer real(kind=real32), intent(in), target :: out (:) Target pointer type( dtfft_stream_t ), intent(in) :: stream CUDA Stream integer(kind=int32), intent(in), optional :: source Source rank for pipelined unpacking private  subroutine destroy (self) Destroys kernel Arguments Type Intent Optional Attributes Name class( nvrtc_kernel ), intent(inout) :: self nvRTC Compiled kernel class private  subroutine mark_unused (kernel) Takes CUDA kernel as an argument and searches for it in cache\nIf kernel is found than reduces ref_count and return null pointer Arguments Type Intent Optional Attributes Name type( CUfunction ), intent(inout) :: kernel CUDA kernel to search for private  subroutine get_neighbor_function_code (code) Generated device function that is used to determite id of process that to which data is being sent or from which data has been recieved\nbased on local element coordinate Arguments Type Intent Optional Attributes Name type( kernel_code ), intent(inout) :: code Resulting code private  subroutine get_code_init (kernel_name, base_storage, code, buffer_type) Generates basic code that is used in all other kernels Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_code ), intent(inout) :: code Resulting code character(len=:), intent(out), optional, allocatable :: buffer_type Type of buffer that should be used","tags":"","loc":"module/dtfft_nvrtc_kernel.html"},{"title":"dtfft_utils – dtFFT","text":"All Utilities functions are located here Uses dtfft_parameters iso_fortran_env iso_c_binding dtfft_errors mpi_f08 module~~dtfft_utils~~UsesGraph module~dtfft_utils dtfft_utils iso_c_binding iso_c_binding module~dtfft_utils->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_utils->module~dtfft_parameters mpi_f08 mpi_f08 module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_utils~~UsedByGraph module~dtfft_utils dtfft_utils module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_utils module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_config dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_utils module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft_api->module~dtfft_plan module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_config->module~dtfft_utils module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_mkl_m->module~dtfft_utils module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_utils module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_utils module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_handle_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_utils module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_config module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvrtc module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_host->module~dtfft_utils module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_interface_nvtx module~dtfft_transpose_plan_host->module~dtfft_pencil module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft dtfft module~dtfft->module~dtfft_config module~dtfft->module~dtfft_pencil module~dtfft->module~dtfft_plan module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_transpose_handle_host->module~dtfft_interface_nvtx module~dtfft_transpose_handle_host->module~dtfft_pencil Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private, save :: is_init_called = .false. Has init_internal already been called or not logical, private, save :: is_log_enabled Should we log messages to stdout or not type( dtfft_platform_t ), private, save :: platform_from_env = PLATFORM_NOT_SET Platform obtained from environ integer(kind=int32), private, save :: z_slab_from_env Should Z-slab be used if possible type( dtfft_backend_t ), private, save :: backend_from_env Backend obtained from environ integer(kind=int32), private, save :: mpi_enabled_from_env Should we use MPI backends during autotune or not integer(kind=int32), private, save :: nccl_enabled_from_env Should we use NCCL backends during autotune or not integer(kind=int32), private, save :: nvshmem_enabled_from_env Should we use NVSHMEM backends during autotune or not integer(kind=int32), private, save :: pipe_enabled_from_env Should we use pipelined backends during autotune or not character(len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. integer(kind=c_int), private, parameter :: RTLD_LAZY = 1_c_int Each external function reference is bound the first time the function is called. integer(kind=c_int), private, parameter :: RTLD_NOW = 2_c_int All external function references are bound when the library is loaded. Interfaces public        interface int_to_str Converts integer to string private  function int_to_str_int8 (n) result(string) Convert 8-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int_to_str_int32 (n) result(string) Convert 32-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int_to_str_int64 (n) result(string) Convert 64-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string public        interface get_env Obtains environment variable private  function get_env_base (name) result(env) Base function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value character(len=:), allocatable Environment variable value private  function get_env_string (name, default, valid_values) result(env) Obtains string environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix character(len=*), intent(in) :: default Name of environment variable without prefix type( string ), intent(in) :: valid_values (:) List of valid variable values Return Value character(len=:), allocatable Environment variable value private  function get_env_int32 (name, default, valid_values, min_valid_value) result(env) Base Integer function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int32), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in), optional :: valid_values (:) List of valid values integer(kind=int32), intent(in), optional :: min_valid_value Mininum valid value. Usually 0 or 1 Return Value integer(kind=int32) private  function get_env_int8 (name, default, valid_values) result(env) Obtains int8 environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int8), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in) :: valid_values (:) List of valid values Return Value integer(kind=int8) private  function get_env_logical (name, default) result(env) Obtains logical environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix logical, intent(in) :: default Default value in case env is not set or it has wrong value Return Value logical public        interface string Creates string object private  function string_constructor (str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string ) interface Allocates memory using C11 Standard alloc_align with 16 bytes alignment public  subroutine mem_alloc_host(alloc_size, ptr) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: alloc_size Number of bytes to allocate type(c_ptr) :: ptr Pointer to allocate interface Frees memory allocated with mem_alloc_host public  subroutine mem_free_host(ptr) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to free interface Converts Fortran communicator to C public  function Comm_f2c(fcomm) bind(C, name=\"Comm_f2c\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: fcomm Fortran communicator Return Value type(c_ptr) interface Checks if pointer can be accessed from device public  function is_device_ptr(ptr) result(bool) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Device pointer Return Value logical(kind=c_bool) Result private        interface is_null_ptr Checks if pointer is NULL private  interface is_null_ptr () Checks if pointer is NULL Arguments None private elemental function is_null_funptr (ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_funptr), intent(in) :: ptr Pointer to check Return Value logical interface Load and link a dynamic library or bundle private  function dlopen(filename, mode) bind(C) Arguments Type Intent Optional Attributes Name character(len=c_char) :: filename (*) Name of the library integer(kind=c_int), value :: mode Options to dlopen Return Value type(c_ptr) Handle to the library interface Get address of a symbol private  function dlsym(handle, name) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Handle to the library character(len=c_char) :: name (*) Name of the symbol Return Value type(c_funptr) Address of the symbol interface Close a dynamic library or bundle private  function dlclose(handle) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Handle to the library Return Value integer(kind=c_int) Result of the operation interface Get diagnostic information private  function dlerror() bind(C) Arguments None Return Value type(c_ptr) Error message Derived Types type, public :: string Class used to create array of strings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: raw String Constructor Creates string object private\n\n                    \n                    function string_constructor (str) Creates string object Functions public  function init_internal () Checks if MPI is initialized and loads environment variables Arguments None Return Value integer(kind=int32) public pure function get_platform_from_env () Returns execution platform set by environment variable Arguments None Return Value type( dtfft_platform_t ) public pure function get_z_slab_from_env () Returns Z-slab to be used set by environment variable Arguments None Return Value integer(kind=int32) public pure function get_backend_from_env () Returns GPU backend to use set by environment variable Arguments None Return Value type( dtfft_backend_t ) public pure function get_mpi_enabled_from_env () Returns usage of MPI Backends during autotune set by environment variable Arguments None Return Value integer(kind=int32) public pure function get_nccl_enabled_from_env () Returns usage of NCCL Backends during autotune set by environment variable Arguments None Return Value integer(kind=int32) public pure function get_nvshmem_enabled_from_env () Returns usage of NVSHMEM Backends during autotune set by environment variable Arguments None Return Value integer(kind=int32) public pure function get_pipe_enabled_from_env () Returns usage of Pipelined Backends during autotune set by environment variable Arguments None Return Value integer(kind=int32) public  function get_iters_from_env (is_warmup) result(n_iters) Obtains number of iterations from environment variable Arguments Type Intent Optional Attributes Name logical, intent(in) :: is_warmup Warmup variable flag Return Value integer(kind=int32) public  function get_datatype_from_env (name) result(env) Obtains datatype id from environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value integer(kind=int8) public pure function get_log_enabled () result(log) Returns the value of the log_enabled variable Arguments None Return Value logical Value of the log_enabled variable public  function load_library (name) result(lib_handle) Dynamically loads library Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of library to load Return Value type(c_ptr) Loaded handle public  function load_symbol (handle, name) result(symbol_handle) Dynamically loads symbol from library Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: handle Loaded handle character(len=*), intent(in) :: name Name of function to load Return Value type(c_funptr) Function pointer public  function dynamic_load (name, symbol_names, handle, symbols) result(error_code) Dynamically loads library and its symbols Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of library to load type( string ), intent(in) :: symbol_names (:) Names of functions to load type(c_ptr), intent(out) :: handle Loaded handle type(c_funptr), intent(out) :: symbols (:) Function pointers Return Value integer(kind=int32) Error code public  function double_to_str (n) result(string) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string public elemental function get_inverse_kind (r2r_kind) result(result_kind) Get the inverse R2R kind of transform for the given R2R kind Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: r2r_kind R2R kind Return Value type( dtfft_r2r_kind_t ) public elemental function is_null_ptr (ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to check Return Value logical public elemental function is_same_ptr (ptr1, ptr2) Checks if two pointer are the same Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr1 First pointer type(c_ptr), intent(in) :: ptr2 Second pointer Return Value logical public  function count_unique (x) result(n) Count the number of unique elements in the array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) Array of integers Return Value integer(kind=int32) private  function string_constructor (str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string ) private  function get_env_base (name) result(env) Base function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value character(len=:), allocatable Environment variable value private  function get_env_string (name, default, valid_values) result(env) Obtains string environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix character(len=*), intent(in) :: default Name of environment variable without prefix type( string ), intent(in) :: valid_values (:) List of valid variable values Return Value character(len=:), allocatable Environment variable value private  function get_env_int32 (name, default, valid_values, min_valid_value) result(env) Base Integer function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int32), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in), optional :: valid_values (:) List of valid values integer(kind=int32), intent(in), optional :: min_valid_value Mininum valid value. Usually 0 or 1 Return Value integer(kind=int32) private  function get_env_int8 (name, default, valid_values) result(env) Obtains int8 environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int8), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in) :: valid_values (:) List of valid values Return Value integer(kind=int8) private  function get_env_logical (name, default) result(env) Obtains logical environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix logical, intent(in) :: default Default value in case env is not set or it has wrong value Return Value logical private  function int_to_str_int8 (n) result(string) Convert 8-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int_to_str_int32 (n) result(string) Convert 32-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int_to_str_int64 (n) result(string) Convert 64-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private elemental function is_null_funptr (ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_funptr), intent(in) :: ptr Pointer to check Return Value logical Subroutines public  subroutine destroy_strings (strings) Destroys array of string objects Arguments Type Intent Optional Attributes Name type( string ), intent(inout), allocatable :: strings (:) Array of strings public  subroutine string_f2c (fstring, cstring, string_size) Convert Fortran string to C string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstring Fortran string character(kind=c_char, len=1), intent(inout) :: cstring (*) C string integer(kind=int64), intent(out), optional :: string_size Size of the C string public  subroutine string_c2f (cstring, string) Convert C string to Fortran string Arguments Type Intent Optional Attributes Name type(c_ptr) :: cstring C string character(len=:), allocatable :: string Fortran string public  subroutine astring_f2c (fstring, cstring, string_size) Convert Fortran string to C allocatable string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstring Fortran string character(kind=c_char, len=1), intent(out), allocatable :: cstring (:) C string integer(kind=int64), intent(out), optional :: string_size Size of the C string public  subroutine unload_library (handle) Unloads library Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: handle Loaded handle public  subroutine write_message (unit, message, prefix) Write message to the specified unit Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: unit Unit number character(len=*), intent(in) :: message Message to write character(len=*), intent(in), optional :: prefix Prefix to the message private  subroutine dl_error (message) Writes error message to the error unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to write","tags":"","loc":"module/dtfft_utils.html"},{"title":"dtfft_interface_cuda – dtFFT","text":"CUDA Driver Interfaces CUDA Driver is loaded at runtime via dynamic loading. Uses dtfft_parameters dtfft_interface_cuda_runtime iso_fortran_env iso_c_binding dtfft_utils dtfft_errors module~~dtfft_interface_cuda~~UsesGraph module~dtfft_interface_cuda dtfft_interface_cuda iso_c_binding iso_c_binding module~dtfft_interface_cuda->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_cuda->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_parameters dtfft_parameters module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_cuda~~UsedByGraph module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial procedure( cuModuleLoadDataEx_interface ), public, pointer :: cuModuleLoadDataEx Fortran pointer to the cuModuleLoadDataEx function procedure( cuModuleUnload_interface ), public, pointer :: cuModuleUnload Fortran pointer to the cuModuleUnload function procedure( cuModuleGetFunction_interface ), public, pointer :: cuModuleGetFunction Fortran pointer to the cuModuleGetFunction function logical, private, save :: is_loaded = .false. Flag indicating whether the library is loaded type(c_ptr), private, save :: libcuda Handle to the loaded library type(c_funptr), private, save :: cuFunctions (4) Array of pointers to the CUDA functions Interfaces interface Launches a CUDA function CUfunction or a CUDA kernel CUkernel. private  function run_cuda_kernel(func, in, out, blocks, threads, stream, args, funptr) result(cuResult) bind(C, name=\"run_cuda_kernel\") Wrapper around cuLaunchKernel , since I have to idea how to pass array of pointers to cuLaunchKernel . Launches a CUDA function CUfunction or a CUDA kernel CUkernel. Arguments Type Intent Optional Attributes Name type( CUfunction ), value :: func Function CUfunction or Kernel CUkernel to launch type(c_ptr), value :: in Input pointer type(c_ptr), value :: out Output pointer type( dim3 ) :: blocks Grid in blocks type( dim3 ) :: threads Thread block type( dtfft_stream_t ), value :: stream Stream identifier type( kernelArgs ) :: args Kernel parameters type(c_funptr), value :: funptr Pointer to cuLaunchKernel Return Value integer(kind=c_int) Driver result code Abstract Interfaces abstract interface private  function cuModuleLoadDataEx_interface(mod, image, numOptions, options, optionValues) result(cuResult) Load a module’s data with options. Takes a pointer image and loads the corresponding module module into the current context. \nThe image may be a cubin or fatbin as output by nvcc, or a NULL-terminated PTX, either as output by nvcc or hand-written. Arguments Type Intent Optional Attributes Name type( CUmodule ) :: mod Returned module character(len=c_char) :: image (*) Module data to load integer(kind=c_int), value :: numOptions Number of options type(c_ptr), value :: options Options for JIT type(c_ptr) :: optionValues Option values for JIT Return Value integer(kind=c_int) Driver result code abstract interface private  function cuModuleUnload_interface(hmod) result(cuResult) Unloads a module. Unloads a module hmod from the current context. \nAttempting to unload a module which was obtained from the Library Management API \nsuch as cuLibraryGetModule will return CUDA_ERROR_NOT_PERMITTED . Arguments Type Intent Optional Attributes Name type( CUmodule ), value :: hmod Module to unload Return Value integer(kind=c_int) Driver result code abstract interface private  function cuModuleGetFunction_interface(hfunc, hmod, name) result(cuResult) Returns a function handle. Returns in hfunc the handle of the function of name name located in module hmod.\nIf no function of that name exists, cuModuleGetFunction returns CUDA_ERROR_NOT_FOUND . Arguments Type Intent Optional Attributes Name type( CUfunction ) :: hfunc Returns a function handle. type( CUmodule ), value :: hmod Module to retrieve function from character(len=c_char) :: name (*) Name of function to retrieve Return Value integer(kind=c_int) Driver result code Derived Types type, public, bind(C) :: kernelArgs Arguments passed to nvrtc-compiled kernels Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: n_ints = 0 Number of integers provided integer(kind=c_int), public :: ints (5) Integer array integer(kind=c_int), public :: n_ptrs = 0 Number of pointers provided type(c_ptr), public :: ptrs (3) Pointer array type, public, bind(C) :: CUmodule CUDA module Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr Actual pointer type, public, bind(C) :: CUfunction CUDA function Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr Actual pointer Functions public  function load_cuda () result(error_code) Loads the CUDA Driver library and needed symbols Arguments None Return Value integer(kind=int32) Error code public  function cuLaunchKernel (func, in, out, blocks, threads, stream, args) result(cuResult) Launches a CUDA function CUfunction or a CUDA kernel CUkernel. Arguments Type Intent Optional Attributes Name type( CUfunction ) :: func Function CUfunction or Kernel CUkernel to launch type(c_ptr) :: in Input pointer type(c_ptr) :: out Output pointer type( dim3 ) :: blocks Grid in blocks type( dim3 ) :: threads Thread block type( dtfft_stream_t ) :: stream Stream identifier type( kernelArgs ) :: args Kernel parameters Return Value integer(kind=c_int) Driver result code","tags":"","loc":"module/dtfft_interface_cuda.html"},{"title":"dtfft_interface_nccl – dtFFT","text":"NCCL Interfaces Uses dtfft_parameters dtfft_utils iso_c_binding module~~dtfft_interface_nccl~~UsesGraph module~dtfft_interface_nccl dtfft_interface_nccl iso_c_binding iso_c_binding module~dtfft_interface_nccl->iso_c_binding module~dtfft_parameters dtfft_parameters module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_parameters->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_nccl~~UsedByGraph module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( ncclDataType ), public, parameter :: ncclFloat = ncclDataType(7) Interfaces interface Generates an Id to be used in ncclCommInitRank. \nncclGetUniqueId should be called once when creating a communicator and the Id should be \ndistributed to all ranks in the communicator before calling ncclCommInitRank. \nuniqueId should point to a ncclUniqueId object allocated by the user. public  function ncclGetUniqueId(uniqueId) result(ncclResult_t) bind(C, name=\"ncclGetUniqueId\") Arguments Type Intent Optional Attributes Name type( ncclUniqueId ), intent(out) :: uniqueId Unique ID Return Value integer(kind=c_int32_t) Completion status interface Allocate a GPU buffer with size.\nAllocated buffer head address will be returned by ptr, and the actual allocated size can be larger \nthan requested because of the buffer granularity requirements from all types of NCCL optimizations. public  function ncclMemAlloc(ptr, alloc_bytes) result(ncclResult_t) bind(C, name=\"ncclMemAlloc\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: ptr Buffer address integer(kind=c_size_t), intent(in), value :: alloc_bytes Number of bytes to allocate Return Value integer(kind=c_int32_t) Completion status interface Free memory allocated by ncclMemAlloc(). public  function ncclMemFree(ptr) result(ncclResult_t) bind(C, name=\"ncclMemFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: ptr Buffer address Return Value integer(kind=c_int32_t) Completion status interface Creates a new communicator (multi thread/process version). rank must be between 0 and nranks-1 and unique within a communicator clique.\nEach rank is associated to a CUDA device, which has to be set before calling ncclCommInitRank. ncclCommInitRank implicitly synchronizes with other ranks, hence it must be called by different\nthreads/processes or used within ncclGroupStart/ncclGroupEnd. public  function ncclCommInitRank(comm, nranks, uniqueId, rank) result(ncclResult_t) bind(C, name=\"ncclCommInitRank\") Arguments Type Intent Optional Attributes Name type( ncclComm ) :: comm Communicator integer(kind=c_int), value :: nranks Number of ranks in communicator type( ncclUniqueId ), value :: uniqueId Unique ID integer(kind=c_int), value :: rank Calling rank Return Value integer(kind=c_int32_t) Completion status interface Send data from sendbuff to rank peer. Rank peer needs to call ncclRecv with the same datatype and the same count as this rank. This operation is blocking for the GPU.\nIf multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, \nthey must be fused within a ncclGroupStart()/ ncclGroupEnd() section. public  function ncclSend(sendbuff, count, datatype, peer, comm, stream) result(ncclResult_t) bind(c, name='ncclSend') Arguments Type Intent Optional Attributes Name real(kind=c_float) :: sendbuff Buffer to send data from integer(kind=c_size_t), value :: count Number of elements to send type( ncclDataType ), value :: datatype Datatype to send integer(kind=c_int), value :: peer Target GPU type( ncclComm ), value :: comm Communicator type( dtfft_stream_t ), value :: stream CUDA Stream Return Value integer(kind=c_int32_t) Completion status interface Receive data from rank peer into recvbuff. Rank peer needs to call ncclSend with the same datatype and the same count as this rank. This operation is blocking for the GPU.\nIf multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, \nthey must be fused within a ncclGroupStart()/ ncclGroupEnd() section. public  function ncclRecv(recvbuff, count, datatype, peer, comm, stream) result(ncclResult_t) bind(c, name='ncclRecv') Arguments Type Intent Optional Attributes Name real(kind=c_float) :: recvbuff Buffer to recv data into integer(kind=c_size_t), value :: count Number of elements to recv type( ncclDataType ), value :: datatype Datatype to recv integer(kind=c_int), value :: peer Source GPU type( ncclComm ), value :: comm Communicator type( dtfft_stream_t ), value :: stream CUDA Stream Return Value integer(kind=c_int32_t) Completion status interface Start a group call. All subsequent calls to NCCL until ncclGroupEnd will not block due to inter-CPU synchronization. public  function ncclGroupStart() result(ncclResult_t) bind(C, name=\"ncclGroupStart\") Arguments None Return Value integer(kind=c_int32_t) Completion status interface End a group call. Returns when all operations since ncclGroupStart have been processed.\nThis means the communication primitives have been enqueued to the provided streams, \nbut are not necessarily complete. public  function ncclGroupEnd() result(ncclResult_t) bind(C, name=\"ncclGroupEnd\") Arguments None Return Value integer(kind=c_int32_t) Completion status interface Destroy a communicator object comm. public  function ncclCommDestroy(comm) result(ncclResult_t) bind(C, name=\"ncclCommDestroy\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator Return Value integer(kind=c_int32_t) Completion status interface Register a buffer for collective communication. public  function ncclCommRegister(comm, buff, size, handle) result(ncclResult_t) bind(C, name=\"ncclCommRegister\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator type(c_ptr), value :: buff Buffer to register integer(kind=c_size_t), value :: size Size of the buffer in bytes type(c_ptr) :: handle Handle to the registered buffer Return Value integer(kind=c_int32_t) Completion status interface Deregister a buffer for collective communication. public  function ncclCommDeregister(comm, handle) result(ncclResult_t) bind(C, name=\"ncclCommDeregister\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator type(c_ptr), value :: handle Handle to the registered buffer Return Value integer(kind=c_int32_t) Completion status interface Returns a human-readable string corresponding to the passed error code. private  function ncclGetErrorString_c(ncclResult_t) result(message) bind(C, name=\"ncclGetErrorString\") Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in), value :: ncclResult_t Completion status of a NCCL function. Return Value type(c_ptr) Pointer to message Derived Types type, public, bind(c) :: ncclUniqueId Components Type Visibility Attributes Name Initial character(len=c_char), public :: internal (128) type, public, bind(c) :: ncclComm Components Type Visibility Attributes Name Initial type(c_ptr), public :: member type, public, bind(c) :: ncclDataType Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: member Functions public  function ncclGetErrorString (ncclResult_t) result(string) Generates an error message. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ncclResult_t Completion status of a function. Return Value character(len=:), allocatable Error message","tags":"","loc":"module/dtfft_interface_nccl.html"},{"title":"dtfft_backend_nccl_m – dtFFT","text":"NCCL Based GPU Backends backend_nccl Uses dtfft_parameters dtfft_interface_cuda_runtime iso_c_binding dtfft_interface_nccl iso_fortran_env dtfft_utils dtfft_abstract_backend mpi_f08 module~~dtfft_backend_nccl_m~~UsesGraph module~dtfft_backend_nccl_m dtfft_backend_nccl_m iso_c_binding iso_c_binding module~dtfft_backend_nccl_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_parameters dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_backend_nccl_m->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_pencil->module~dtfft_errors module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_backend_nccl_m~~UsedByGraph module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_backend ) :: backend_nccl NCCL backend Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer type( nvrtc_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( nvrtc_kernel ), public, pointer :: unpack_kernel2 Kernel for unpacking data type( ncclComm ), private :: nccl_comm NCCL Communicator Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates Abstract GPU Backend procedure, public, non_overridable, pass(self) :: execute ../../ Executes GPU Backend procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys Abstract GPU Backend procedure, public, non_overridable, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, non_overridable, pass(self) :: set_unpack_kernel ../../ Sets unpack kernel for pipelined backend procedure, public :: create_private => create_nccl ../../ Creates NCCL backend procedure, public :: execute_private => execute_nccl ../../ Executes NCCL backend procedure, public :: destroy_private => destroy_nccl ../../ Destroys NCCL backend Subroutines private  subroutine create_nccl (self, helper, tranpose_type, base_storage) Creates NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_transpose_t ), intent(in) :: tranpose_type Type of transpose to create (unused) integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) private  subroutine execute_nccl (self, in, out, stream, aux) Executes NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Auxiliary pointer private  subroutine destroy_nccl (self) Destroys NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend","tags":"","loc":"module/dtfft_backend_nccl_m.html"},{"title":"dtfft_transpose_handle_cuda – dtFFT","text":"This module describes transpose_handle_cuda class Uses dtfft_nvrtc_kernel dtfft_parameters dtfft_backend_nccl_m dtfft_backend_mpi dtfft_backend_cufftmp_m dtfft_interface_cuda_runtime iso_fortran_env iso_c_binding dtfft_interface_nvtx dtfft_pencil dtfft_utils dtfft_abstract_backend mpi_f08 module~~dtfft_transpose_handle_cuda~~UsesGraph module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda iso_c_binding iso_c_binding module~dtfft_transpose_handle_cuda->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_transpose_handle_cuda->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_transpose_handle_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_transpose_handle_cuda->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_parameters dtfft_parameters module~dtfft_transpose_handle_cuda->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_transpose_handle_cuda->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_transpose_handle_cuda->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_errors dtfft_errors module~dtfft_pencil->module~dtfft_errors module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_transpose_handle_cuda~~UsedByGraph module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: transpose_handle_cuda CUDA Transpose Handle Components Type Visibility Attributes Name Initial type( dtfft_transpose_t ), private :: transpose_type logical, private :: has_exchange = .false. If current handle has exchanges between GPUs logical, private :: is_pipelined = .false. If underlying exchanges are pipelined type( nvrtc_kernel ), private :: transpose_kernel Transposes data type( nvrtc_kernel ), private :: unpack_kernel Unpacks data type( nvrtc_kernel ), private :: unpack_kernel2 class( abstract_backend ), private, allocatable :: comm_handle Communication handle Type-Bound Procedures procedure, public, pass(self) :: create ../../ Creates CUDA Transpose Handle procedure, public, pass(self) :: execute ../../ Executes transpose - exchange - unpack procedure, public, pass(self) :: destroy ../../ Destroys CUDA Transpose Handle procedure, public, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, pass(self) :: get_tranpose_type ../../ Returns transpose_type, associated with handle type, private :: data_handle Helper class used to obtain displacements and \ncounts needed to send to other processes Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: ls (:,:) Starts of my data that I should send or recv\nwhile communicating with other processes integer(kind=int32), public, allocatable :: ln (:,:) Counts of my data that I should send or recv\nwhile communicating with other processes integer(kind=int32), public, allocatable :: sizes (:,:) Counts of every rank in a comm integer(kind=int32), public, allocatable :: starts (:,:) Starts of every rank in a comm integer(kind=int32), public, allocatable :: displs (:) Local buffer displacement integer(kind=int32), public, allocatable :: counts (:) Number of elements to send or recv Type-Bound Procedures procedure, public, pass(self) :: create => create_data_handle ../../ Creates handle procedure, public, pass(self) :: destroy => destroy_data_handle ../../ Destroys handle Functions private  function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(in) :: self CUDA Transpose Handle Return Value integer(kind=int64) private  function get_tranpose_type (self) result(tranpose_type) Returns transpose_type, associated with handle Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(in) :: self CUDA Transpose Handle Return Value type( dtfft_transpose_t ) Subroutines private  subroutine create_data_handle (self, info, comm, comm_size) Creates handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class type( pencil ), intent(in) :: info Pencil info type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int32), intent(in) :: comm_size Size of comm private  subroutine destroy_data_handle (self) Destroys handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class private  subroutine create (self, helper, send, recv, base_storage, backend) Creates CUDA Transpose Handle Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(inout) :: self CUDA Transpose Handle type( backend_helper ), intent(in) :: helper Backend helper type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_backend_t ), intent(in) :: backend Backend type private  subroutine execute (self, in, out, stream, aux) Executes transpose - exchange - unpack Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(inout) :: self CUDA Transpose Handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer private  subroutine destroy (self) Destroys CUDA Transpose Handle Arguments Type Intent Optional Attributes Name class( transpose_handle_cuda ), intent(inout) :: self CUDA Transpose Handle","tags":"","loc":"module/dtfft_transpose_handle_cuda.html"},{"title":"dtfft_interface_mkl_m – dtFFT","text":"This module creates C interface with MKL library Uses dtfft_utils iso_c_binding module~~dtfft_interface_mkl_m~~UsesGraph module~dtfft_interface_mkl_m dtfft_interface_mkl_m iso_c_binding iso_c_binding module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_utils dtfft_utils module~dtfft_interface_mkl_m->module~dtfft_utils module~dtfft_utils->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_utils->module~dtfft_parameters mpi_f08 mpi_f08 module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_mkl_m~~UsedByGraph module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface mkl_dfti_set_value Sets one particular configuration parameter with the specified configuration value. private  function mkl_dfti_set_integer(desc, param, value) result(status) bind(C) Sets one particular configuration parameter with integer value. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. integer(kind=c_int), intent(in), value :: param Configuration parameter. integer(kind=c_int), intent(in), value :: value Configuration value. Return Value integer(kind=c_long) Function completion status. private  function mkl_dfti_set_pointer(desc, param, value) result(status) bind(C) Sets one particular configuration parameter with pointer value. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. integer(kind=c_int), intent(in), value :: param Configuration parameter. integer(kind=c_long), intent(in) :: value (*) Configuration value. Return Value integer(kind=c_long) Function completion status. interface Allocates the descriptor data structure and initializes it with default configuration values. public  function mkl_dfti_create_desc(precision, domain, dim, length, desc) result(status) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: precision Precision of the transform: DFTI_SINGLE or DFTI_DOUBLE. integer(kind=c_int), intent(in), value :: domain Forward domain of the transform: DFTI_COMPLEX or DFTI_REAL. integer(kind=c_long), intent(in), value :: dim Dimension of the transform. integer(kind=c_long), intent(in) :: length (*) Length of the transform for a one-dimensional transform.\nLengths of each dimension for a multi-dimensional transform. type(c_ptr) :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status. interface Performs all initialization for the actual FFT computation. public  function mkl_dfti_commit_desc(desc) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status. interface Computes FFT. public  function mkl_dfti_execute(desc, in, out, sign) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. type(c_ptr), value :: in Data to be transformed type(c_ptr), value :: out The transformed data integer(kind=c_int), intent(in), value :: sign Sign of transform Return Value integer(kind=c_long) Function completion status. interface Frees the memory allocated for a descriptor. public  function mkl_dfti_free_desc(desc) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status. interface Allocates pointer via mkl_malloc public  function mkl_dfti_mem_alloc(alloc_bytes, ptr) result(status) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: alloc_bytes Number of bytes to allocate. type(c_ptr) :: ptr Pointer to allocated memory. Return Value integer(kind=c_long) Function completion status. interface Frees pointer via mkl_free public  function mkl_dfti_mem_free(ptr) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to allocated memory. Return Value integer(kind=c_long) Function completion status. interface Generates an error message. private  function DftiErrorMessage_c(error_code) result(message) bind(C, name=\"DftiErrorMessage\") Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in), value :: error_code Completion status of a function. Return Value type(c_ptr) Pointer to message Functions public  function DftiErrorMessage (error_code) result(string) Generates an error message. Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in) :: error_code Completion status of a function. Return Value character(len=:), allocatable Error message","tags":"","loc":"module/dtfft_interface_mkl_m.html"},{"title":"dtfft_pencil – dtFFT","text":"This module describes private pencil and public dtfft_pencil_t classes Uses dtfft_parameters dtfft_interface_cuda_runtime iso_c_binding iso_fortran_env dtfft_utils dtfft_errors mpi_f08 module~~dtfft_pencil~~UsesGraph module~dtfft_pencil dtfft_pencil iso_c_binding iso_c_binding module~dtfft_pencil->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_pencil->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_pencil->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_parameters dtfft_parameters module~dtfft_pencil->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_pencil->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_pencil->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_pencil~~UsedByGraph module~dtfft_pencil dtfft_pencil module~dtfft dtfft module~dtfft->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_pencil module~dtfft_api->module~dtfft_plan module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_pencil module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_handle_host->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_host->module~dtfft_pencil module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface dtfft_pencil_t Type bound constuctor for dtfft_pencil_t private  function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t ) Derived Types type, public :: dtfft_pencil_t Structure to hold pencil decomposition info Components Type Visibility Attributes Name Initial integer(kind=int8), public :: dim Aligned dimension id integer(kind=int8), public :: ndims = 0 Number of dimensions integer(kind=int32), public, allocatable :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), public, allocatable :: counts (:) Local counts of data, in elements integer(kind=int64), public :: size Total number of elements in a pencil logical, private :: is_created = .false. Is pencil created Constructor Type bound constuctor for dtfft_pencil_t private\n\n                    \n                    function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Finalizations Procedures final :: destroy_pencil_t Type-Bound Procedures procedure, private, pass(self) :: destroy => destroy_pencil_t_private type, public, bind(C) :: dtfft_pencil_c Structure to hold pencil decomposition info Components Type Visibility Attributes Name Initial integer(kind=c_int8_t), public :: dim Aligned dimension id integer(kind=c_int8_t), public :: ndims Number of dimensions integer(kind=c_int32_t), public :: starts (3) Local starts, starting from 0 for both C and Fortran integer(kind=c_int32_t), public :: counts (3) Local counts of data, in elements integer(kind=c_size_t), public :: size Total number of elements in a pencil type, public :: pencil Class that describes information about data layout Components Type Visibility Attributes Name Initial integer(kind=int8), public :: aligned_dim Position of aligned dimension. For example: X pencil aligned_dim = 1, Z pencil aligned_dim = 3 integer(kind=int8), public :: rank Rank of buffer: 2 or 3 integer(kind=int32), public, allocatable :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), public, allocatable :: counts (:) Local counts of data, in elements logical, public :: is_even Is data evenly distributed across processes Type-Bound Procedures procedure, public, pass(self) :: create ../../ Creates pencil procedure, public, pass(self) :: destroy ../../ Destroys pencil procedure, public, pass(self) :: make_public ../../ Creates public object that users can use to create own FFT backends type, public :: pencil_init Class that describes information about data layout Read more… Components Type Visibility Attributes Name Initial type(MPI_Comm), public, allocatable :: comms (:) 1D communicators for each dimension integer(kind=int32), public, allocatable :: starts (:) Local starts integer(kind=int32), public, allocatable :: counts (:) Local counts integer(kind=int32), public, allocatable :: dims (:) Global dimensions of entire region Type-Bound Procedures procedure, public, pass(self) :: create => create_pencil_init ../../ Creates and validates pencil passed by user to plan constructors procedure, public, pass(self) :: destroy => destroy_pencil_init ../../ Destroys pencil_init Functions public pure function get_transpose_type (send, recv) result(transpose_type) Determines transpose ID based on pencils Arguments Type Intent Optional Attributes Name type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Receive pencil Return Value type( dtfft_transpose_t ) Transpose ID private  function check_if_even (count, comm) Checks if data is evenly distributed across processes Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: count Local count type(MPI_Comm), intent(in) :: comm Grid communicator Return Value logical private  function make_public (self) Creates public object that users can use to create own FFT backends Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: self Pencil Return Value type( dtfft_pencil_t ) private  function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t ) private  function create_pencil_init (self, pencil, comm) result(error_code) Creates and validates pencil passed by user to plan constructors Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t type( dtfft_pencil_t ), intent(in) :: pencil Pencil passed by user to plan constructors type(MPI_Comm), intent(in) :: comm MPI Communicator passed to plan constructors Return Value integer(kind=int32) Error code private pure function check_overlap (lbounds1, sizes1, lbounds2, sizes2, ndims) Check if two pencols overlap in ndims-dimensional space Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lbounds1 (:) Lower bounds of first pencil integer(kind=int32), intent(in) :: sizes1 (:) Sizes of first pencil integer(kind=int32), intent(in) :: lbounds2 (:) Lower bounds of second pencil integer(kind=int32), intent(in) :: sizes2 (:) Sizes of second pencil integer(kind=int32), intent(in) :: ndims Number of dimensions Return Value logical private  function check_continuity (all_lbounds, all_sizes, global_dims, comm_size) Check if the local pencils cover the global space without gaps Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: all_lbounds (:,:) Lower bounds of local pencils for each process integer(kind=int32), intent(in) :: all_sizes (:,:) Sizes of local pencils for each process integer(kind=int32), intent(in) :: global_dims (:) Global dimensions of the problem integer(kind=int32), intent(in) :: comm_size Number of processes in the communicator Return Value logical private  function get_varying_dim (fixed_dims, total_dims) result(varying_dim) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: fixed_dims (:) integer(kind=int32), intent(in) :: total_dims Return Value integer(kind=int32) Subroutines public  subroutine pencil_f2c (pencil, c_pencil) Converts Fortran pencil to C pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_t ), intent(in) :: pencil Fortran pencil type( dtfft_pencil_c ), intent(out) :: c_pencil C pencil public  subroutine pencil_c2f (c_pencil, pencil) Converts C pencil to Fortran pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: c_pencil C pencil type( dtfft_pencil_t ), intent(out) :: pencil Fortran pencil public  subroutine get_local_sizes (pencils, in_starts, in_counts, out_starts, out_counts, alloc_size) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name type( pencil ), intent(in) :: pencils (:) Array of pencils integer(kind=int32), intent(out), optional :: in_starts (:) Start indexes in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements in real space integer(kind=int32), intent(out), optional :: out_starts (:) Start indexes in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan private  subroutine create (self, rank, aligned_dim, counts, comms, lstarts, lcounts) Creates pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil integer(kind=int8), intent(in) :: rank Rank of buffer integer(kind=int8), intent(in) :: aligned_dim Position of aligned dimension integer(kind=int32), intent(in) :: counts (:) Global counts type(MPI_Comm), intent(in) :: comms (:) Grid communicators integer(kind=int32), intent(in), optional :: lstarts (:) Local starts integer(kind=int32), intent(in), optional :: lcounts (:) Local counts private  subroutine destroy (self) Destroys pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil private  subroutine get_local_size (n_global, comm, start, count, start_to_keep, size_to_keep) Computes local portions of data based on global count and position inside grid communicator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_global Global number of points type(MPI_Comm), intent(in) :: comm Grid communicator integer(kind=int32), intent(out) :: start Local start integer(kind=int32), intent(out) :: count Local count integer(kind=int32), intent(in), optional :: start_to_keep Start to keep in case of user defined decomposition integer(kind=int32), intent(in), optional :: size_to_keep Size to keep in case of user defined decomposition private  subroutine destroy_pencil_t_private (self) Destroys pencil Arguments Type Intent Optional Attributes Name class( dtfft_pencil_t ), intent(inout) :: self Public pencil private  subroutine destroy_pencil_t (self) Destroys pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_t ), intent(inout) :: self Public pencil private  subroutine destroy_pencil_init (self) Destroys pencil_init Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t private  subroutine sort_by_varying_dim (ranks, coords) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: ranks (:) integer(kind=int32), intent(in) :: coords (:) private  subroutine create_1d_comm (lbounds, all_lbounds, fixed_dims, comm, new_comm) Creates a new 1D communicator based on the fixed dimensions of the current pencil Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lbounds (:) Local starts of the current pencil integer(kind=int32), intent(in) :: all_lbounds (:,:) Local starts of all processes integer(kind=int32), intent(in) :: fixed_dims (:) Indices of fixed coordinates type(MPI_Comm), intent(in) :: comm Original MPI communicator type(MPI_Comm), intent(out) :: new_comm New 1D MPI communicator","tags":"","loc":"module/dtfft_pencil.html"},{"title":"dtfft_transpose_handle_host – dtFFT","text":"This module describes transpose_handle_host class Uses dtfft_parameters dtfft_interface_nvtx iso_fortran_env dtfft_pencil mpi_f08 module~~dtfft_transpose_handle_host~~UsesGraph module~dtfft_transpose_handle_host dtfft_transpose_handle_host iso_fortran_env iso_fortran_env module~dtfft_transpose_handle_host->iso_fortran_env module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_transpose_handle_host->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_transpose_handle_host->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_transpose_handle_host->module~dtfft_pencil mpi_f08 mpi_f08 module~dtfft_transpose_handle_host->mpi_f08 iso_c_binding iso_c_binding module~dtfft_interface_nvtx->iso_c_binding module~dtfft_utils dtfft_utils module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_errors dtfft_errors module~dtfft_pencil->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->module~dtfft_errors Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_transpose_handle_host~~UsedByGraph module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=MPI_ADDRESS_KIND), private, parameter :: LB = 0 Lower bound for all derived datatypes Derived Types type, public :: transpose_handle_host Transposition class Components Type Visibility Attributes Name Initial type(MPI_Comm), private :: comm 1d communicator logical, private :: is_even Is decomposition even type( handle_t ), private :: send Handle to send data type( handle_t ), private :: recv Handle to recieve data type(MPI_Request), private :: request Request for persistent communication logical, private :: is_request_created Is request created Type-Bound Procedures procedure, public, pass(self) :: create ../../ Initializes class procedure, public, pass(self) :: execute ../../ Performs MPI_Alltoall(w) procedure, public, pass(self) :: destroy ../../ Destroys class procedure, private, pass(self) :: create_transpose_2d ../../ Creates two-dimensional transposition datatypes procedure, private, pass(self) :: create_transpose_XY ../../ Creates three-dimensional X –> Y, Y –> X transposition datatypes procedure, private, pass(self) :: create_transpose_YZ ../../ Creates three-dimensional Y –> Z, Z –> Y transposition datatypes procedure, private, pass(self) :: create_transpose_XZ ../../ Creates three-dimensional X –> Z datatype, only slab! procedure, private, pass(self) :: create_transpose_ZX ../../ Creates three-dimensional Z –> X datatype, only slab! type, private :: handle_t Transposition handle class Components Type Visibility Attributes Name Initial type(MPI_Datatype), public, allocatable :: dtypes (:) Datatypes buffer integer(kind=int32), public, allocatable :: counts (:) Number of datatypes (always equals 1) integer(kind=int32), public, allocatable :: displs (:) Displacements is bytes Type-Bound Procedures procedure, public, pass(self) :: create => create_handle ../../ Creates transposition handle procedure, public, pass(self) :: destroy => destroy_handle ../../ Destroys transposition handle Subroutines private  subroutine create_handle (self, n) Creates transposition handle Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle integer(kind=int32), intent(in) :: n Number of datatypes to be created private  subroutine destroy_handle (self) Destroys transposition handle Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle private  subroutine create (self, comm, send, recv, base_type, base_storage, datatype_id) Creates transpose_handle_host class Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm 1d communicator class( pencil ), intent(in) :: send Information about send buffer class( pencil ), intent(in) :: recv Information about recv buffer type(MPI_Datatype), intent(in) :: base_type Base MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int8), intent(in) :: datatype_id Type of datatype to use private  subroutine execute (self, send, recv) Executes transposition Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class real(kind=real32), intent(in) :: send (:) Incoming buffer real(kind=real32), intent(inout) :: recv (:) Resulting buffer private  subroutine destroy (self) Destroys transpose_handle_host class Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class private  subroutine create_transpose_2d (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates two-dimensional transposition datatypes Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element private  subroutine create_transpose_XY (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional X –> Y, Y –> X transposition datatypes Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element private  subroutine create_transpose_YZ (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional Y –> Z, Z –> Y transposition datatypes Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element private  subroutine create_transpose_XZ (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional X –> Z transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element private  subroutine create_transpose_ZX (self, n_neighbors, i, send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage) Creates three-dimensional Z –> X transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Arguments Type Intent Optional Attributes Name class( transpose_handle_host ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: n_neighbors Size of 1d comm integer(kind=int32), intent(in) :: i Counter class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element private  subroutine free_datatypes (t1, t2, t3, t4) Frees temporary datatypes Arguments Type Intent Optional Attributes Name type(MPI_Datatype), intent(inout), optional :: t1 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t2 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t3 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t4 Temporary datatype","tags":"","loc":"module/dtfft_transpose_handle_host.html"},{"title":"dtfft_abstract_transpose_plan – dtFFT","text":"This module describes Abstraction for all Tranpose plans: abstract_transpose_plan Uses dtfft_parameters dtfft_nvrtc_kernel dtfft_interface_cuda_runtime dtfft_interface_nvshmem iso_fortran_env iso_c_binding dtfft_abstract_backend dtfft_interface_nccl dtfft_pencil dtfft_utils dtfft_interface_nvtx dtfft_config dtfft_errors mpi_f08 module~~dtfft_abstract_transpose_plan~~UsesGraph module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan iso_c_binding iso_c_binding module~dtfft_abstract_transpose_plan->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_abstract_transpose_plan->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_config dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_abstract_transpose_plan->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_parameters dtfft_parameters module~dtfft_abstract_transpose_plan->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_transpose_plan->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_abstract_transpose_plan->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_abstract_transpose_plan~~UsedByGraph module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface private  function create_interface(self, dims, transposed_dims, base_comm, comm_dims, effort, base_dtype, base_storage, is_custom_cart_comm, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plans Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base MPI communicator integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_custom_cart_comm Custom cartesian communicator provided by user type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code abstract interface private  subroutine execute_interface(self, in, out, transpose_type) Executes single transposition Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class real(kind=real32), intent(inout) :: in (:) Incoming buffer real(kind=real32), intent(inout) :: out (:) Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose abstract interface private  subroutine destroy_interface(self) Destroys transposition plans Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class Derived Types type, public, abstract :: abstract_transpose_plan The most Abstract Transpose Plan Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend = DTFFT_BACKEND_MPI_DATATYPE GPU backend type( backend_helper ), public :: helper Backend helper logical, public :: is_z_slab Z-slab optimization flag (for 3D transforms) integer(kind=int64), public :: min_buffer_size Minimal buffer size for transposition Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Create transposition plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes transposition procedure, public, pass(self) :: get_aux_size ../../ Returns auxiliary buffer size procedure( create_interface ), public, deferred, pass(self) :: create_private ../../ Creates overriding class procedure( execute_interface ), public, deferred, pass(self) :: execute_private ../../ Executes overriding class procedure( destroy_interface ), public, deferred, pass(self) :: destroy ../../ Destroys overriding class procedure, public, non_overridable, pass(self) :: get_backend ../../ Returns backend id procedure, public, non_overridable, pass(self) :: mem_alloc ../../ Allocates memory based on selected backend procedure, public, non_overridable, pass(self) :: mem_free ../../ Frees memory allocated with mem_alloc Functions private  function create (self, dims, base_comm, effort, base_dtype, base_storage, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plans Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Return Value integer(kind=int32) Error code private  function get_aux_size (self) result(aux_size) Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(in) :: self Transposition class Return Value integer(kind=int64) private  function get_backend (self) Returns plan GPU backend Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(in) :: self Transposition class Return Value type( dtfft_backend_t ) Subroutines public  subroutine alloc_mem (helper, backend, comm, alloc_bytes, ptr, error_code) Allocates memory based on backend Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code public  subroutine free_mem (helper, backend, ptr, error_code) Frees memory based on backend Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code public  subroutine create_pencils_and_comm (transposed_dims, old_comm, comm_dims, comm, local_comms, pencils, ipencil) Creates cartesian communicator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: transposed_dims (:,:) Global counts in transposed coordinates type(MPI_Comm), intent(in) :: old_comm Communicator to create cartesian from integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type(MPI_Comm), intent(out) :: comm Cartesian communicator type(MPI_Comm), intent(out) :: local_comms (:) 1d communicators in cartesian communicator type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil private  subroutine execute (self, in, out, transpose_type) Executes single transposition Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming pointer type(c_ptr), intent(in) :: out Result pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose private  subroutine mem_alloc (self, comm, alloc_bytes, ptr, error_code) Allocates memory based on selected backend Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code private  subroutine mem_free (self, ptr, error_code) Frees memory allocated with mem_alloc Arguments Type Intent Optional Attributes Name class( abstract_transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code private  subroutine create_cart_comm (old_comm, comm_dims, comm, local_comms, ipencil) Creates cartesian communicator Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: old_comm Communicator to create cartesian from integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type(MPI_Comm), intent(out) :: comm Cartesian communicator type(MPI_Comm), intent(out) :: local_comms (:) 1d communicators in cartesian communicator type( pencil_init ), intent(in), optional :: ipencil","tags":"","loc":"module/dtfft_abstract_transpose_plan.html"},{"title":"dtfft_config – dtFFT","text":"This module handles additional configuration dtFFT , provided by dtfft_config_t or environment variables Uses dtfft_parameters dtfft_interface_cuda_runtime iso_fortran_env iso_c_binding dtfft_utils dtfft_errors mpi_f08 module~~dtfft_config~~UsesGraph module~dtfft_config dtfft_config iso_c_binding iso_c_binding module~dtfft_config->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_config->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_config->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_parameters dtfft_parameters module~dtfft_config->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_config->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_config~~UsedByGraph module~dtfft_config dtfft_config module~dtfft dtfft module~dtfft->module~dtfft_config module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_plan module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_transpose_plan_cuda->module~dtfft_config module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private, save :: is_z_slab_enabled = .true. Should we use z-slab decomposition or not type( dtfft_platform_t ), private, save :: platform = DTFFT_PLATFORM_HOST Default platform type( dtfft_backend_t ), private, parameter :: DEFAULT_GPU_BACKEND = DTFFT_BACKEND_NCCL Default GPU backend type( dtfft_stream_t ), private, save :: main_stream Default dtFFT CUDA stream type( dtfft_stream_t ), private, save :: custom_stream CUDA stream set by the user logical, private, save :: is_stream_created = .false. Is the default stream created? logical, private, save :: is_custom_stream = .false. Is the custom stream provided by the user? logical, private, save :: is_pipelined_enabled = .true. Should we use pipelined backends or not logical, private, save :: is_mpi_enabled = .false. Should we use MPI backends or not logical, private, save :: is_nccl_enabled = .true. Should we use NCCL backends or not logical, private, save :: is_nvshmem_enabled = .true. Should we use NCCL backends or not type( dtfft_backend_t ), private, save :: backend = DEFAULT_GPU_BACKEND Default GPU backend Interfaces public        interface dtfft_config_t Interface to create a new configuration private pure function config_constructor (enable_z_slab, platform, stream, backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config Derived Types type, public, bind(C) :: dtfft_config_t Type that can be used to set additional configuration parameters to dtFFT Components Type Visibility Attributes Name Initial logical(kind=c_bool), public :: enable_z_slab Should dtFFT use Z-slab optimization or not. Read more… type( dtfft_platform_t ), public :: platform Selects platform to execute plan. Read more… type( dtfft_stream_t ), public :: stream Main CUDA stream that will be used in dtFFT. Read more… type( dtfft_backend_t ), public :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . Read more… logical(kind=c_bool), public :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. Read more… logical(kind=c_bool), public :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. Read more… logical(kind=c_bool), public :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. Read more… logical(kind=c_bool), public :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. Read more… Constructor Interface to create a new configuration private\n\n                    pure\n                    function config_constructor (enable_z_slab, platform, stream, backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends) Creates a new configuration Functions public pure function get_z_slab () Whether Z-slab optimization is enabled or not Arguments None Return Value logical public pure function get_user_platform () Returns platform set by the user or default one Arguments None Return Value type( dtfft_platform_t ) public  function get_user_stream () result(stream) Returns either the custom provided by user or creates a new one Arguments None Return Value type( dtfft_stream_t ) public pure function get_user_gpu_backend () Returns GPU backend set by the user or default one Arguments None Return Value type( dtfft_backend_t ) public pure function get_pipelined_enabled () Whether pipelined backends are enabled or not Arguments None Return Value logical public pure function get_mpi_enabled () Whether MPI backends are enabled or not Arguments None Return Value logical public pure function get_nccl_enabled () Whether NCCL backends are enabled or not Arguments None Return Value logical public pure function get_nvshmem_enabled () Whether nvshmem backends are enabled or not Arguments None Return Value logical private pure function config_constructor (enable_z_slab, platform, stream, backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config Subroutines public pure subroutine dtfft_create_config (config) bind(C, name=\"dtfft_create_config_c\") Creates a new configuration with default values. Read more… Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(out) :: config Configuration to create public  subroutine dtfft_set_config (config, error_code) Sets configuration parameters Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(in) :: config Configuration to set integer(kind=int32), intent(out), optional :: error_code Error code public  subroutine destroy_stream () Destroy the default stream if it was created Arguments None","tags":"","loc":"module/dtfft_config.html"},{"title":"dtfft_api – dtFFT","text":"This module is a Fortran part of C/C++ interface Uses dtfft_parameters iso_fortran_env iso_c_binding dtfft_plan dtfft_pencil dtfft_utils dtfft_config dtfft_errors mpi_f08 module~~dtfft_api~~UsesGraph module~dtfft_api dtfft_api iso_c_binding iso_c_binding module~dtfft_api->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_api->iso_fortran_env module~dtfft_config dtfft_config module~dtfft_api->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_api->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_api->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_api->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft_api->module~dtfft_plan module~dtfft_utils dtfft_utils module~dtfft_api->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_api->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_plan->iso_c_binding module~dtfft_plan->iso_fortran_env module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_errors module~dtfft_plan->module~dtfft_parameters module~dtfft_plan->module~dtfft_pencil module~dtfft_plan->module~dtfft_utils module~dtfft_plan->mpi_f08 module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_abstract_transpose_plan dtfft_abstract_transpose_plan module~dtfft_plan->module~dtfft_abstract_transpose_plan module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_nvrtc_kernel dtfft_nvrtc_kernel module~dtfft_plan->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda dtfft_transpose_plan_cuda module~dtfft_plan->module~dtfft_transpose_plan_cuda module~dtfft_transpose_plan_host dtfft_transpose_plan_host module~dtfft_plan->module~dtfft_transpose_plan_host module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan->iso_c_binding module~dtfft_abstract_transpose_plan->iso_fortran_env module~dtfft_abstract_transpose_plan->module~dtfft_config module~dtfft_abstract_transpose_plan->module~dtfft_errors module~dtfft_abstract_transpose_plan->module~dtfft_parameters module~dtfft_abstract_transpose_plan->module~dtfft_pencil module~dtfft_abstract_transpose_plan->module~dtfft_utils module~dtfft_abstract_transpose_plan->mpi_f08 module~dtfft_abstract_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_abstract_transpose_plan->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_plan->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_plan->module~dtfft_abstract_backend module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_transpose_plan->module~dtfft_interface_nccl module~dtfft_executor_cufft_m->iso_c_binding module~dtfft_executor_cufft_m->iso_fortran_env module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->mpi_f08 module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m->iso_c_binding module~dtfft_executor_fftw_m->iso_fortran_env module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_executor_mkl_m->iso_c_binding module~dtfft_executor_mkl_m->iso_fortran_env module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_executor_mkl_m->mpi_f08 module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_executor_vkfft_m->iso_c_binding module~dtfft_executor_vkfft_m->iso_fortran_env module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_kernel->iso_c_binding module~dtfft_nvrtc_kernel->iso_fortran_env module~dtfft_nvrtc_kernel->module~dtfft_parameters module~dtfft_nvrtc_kernel->module~dtfft_utils module~dtfft_nvrtc_kernel->mpi_f08 module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_kernel->module~dtfft_interface_nvtx module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_kernel->module~dtfft_interface_cuda module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_kernel->module~dtfft_interface_nvrtc module~dtfft_transpose_plan_cuda->iso_c_binding module~dtfft_transpose_plan_cuda->iso_fortran_env module~dtfft_transpose_plan_cuda->module~dtfft_config module~dtfft_transpose_plan_cuda->module~dtfft_errors module~dtfft_transpose_plan_cuda->module~dtfft_parameters module~dtfft_transpose_plan_cuda->module~dtfft_pencil module~dtfft_transpose_plan_cuda->module~dtfft_utils module~dtfft_transpose_plan_cuda->mpi_f08 module~dtfft_transpose_plan_cuda->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_plan_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_plan_cuda->module~dtfft_abstract_backend module~dtfft_transpose_plan_cuda->module~dtfft_interface_cuda module~dtfft_transpose_plan_cuda->module~dtfft_interface_nvrtc module~dtfft_transpose_handle_cuda dtfft_transpose_handle_cuda module~dtfft_transpose_plan_cuda->module~dtfft_transpose_handle_cuda module~dtfft_transpose_plan_host->iso_fortran_env module~dtfft_transpose_plan_host->module~dtfft_errors module~dtfft_transpose_plan_host->module~dtfft_parameters module~dtfft_transpose_plan_host->module~dtfft_pencil module~dtfft_transpose_plan_host->module~dtfft_utils module~dtfft_transpose_plan_host->mpi_f08 module~dtfft_transpose_plan_host->module~dtfft_abstract_transpose_plan module~dtfft_transpose_plan_host->module~dtfft_interface_nvtx module~dtfft_transpose_handle_host dtfft_transpose_handle_host module~dtfft_transpose_plan_host->module~dtfft_transpose_handle_host module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_nvrtc_kernel module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_fftw_m->iso_c_binding dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_interface_mkl_m->module~dtfft_utils MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_parameters module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_interface_cuda_runtime module~dtfft_interface_vkfft_m->iso_c_binding module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_transpose_handle_cuda->iso_c_binding module~dtfft_transpose_handle_cuda->iso_fortran_env module~dtfft_transpose_handle_cuda->module~dtfft_parameters module~dtfft_transpose_handle_cuda->module~dtfft_pencil module~dtfft_transpose_handle_cuda->module~dtfft_utils module~dtfft_transpose_handle_cuda->mpi_f08 module~dtfft_transpose_handle_cuda->module~dtfft_interface_cuda_runtime module~dtfft_transpose_handle_cuda->module~dtfft_interface_nvtx module~dtfft_transpose_handle_cuda->module~dtfft_nvrtc_kernel module~dtfft_transpose_handle_cuda->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_cuda->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_cuda->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_host->iso_fortran_env module~dtfft_transpose_handle_host->module~dtfft_parameters module~dtfft_transpose_handle_host->module~dtfft_pencil module~dtfft_transpose_handle_host->mpi_f08 module~dtfft_transpose_handle_host->module~dtfft_interface_nvtx module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_nccl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, private :: plan_c C pointer to Fortran plan Components Type Visibility Attributes Name Initial class( dtfft_plan_t ), public, allocatable :: p Actual Fortran plan Functions private pure function get_comm (c_comm) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: c_comm Return Value type(mpi_comm) private  function dtfft_create_plan_r2r_c (ndims, dims, kinds, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates R2R dtFFT Plan, allocates all structures and prepares FFT, C/C++/Python interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: ndims Rank of transform. Can be 2 or 3. type(c_ptr), intent(in), value :: dims Global sizes of transform type(c_ptr), intent(in), value :: kinds FFT R2R kinds integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_create_plan_r2r_pencil_c (pencil, kinds, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates R2R dtFFT Plan from Pencil, allocates all structures and prepares FFT, C/C++/Python interface Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: pencil C pointer to Fortran pencil type(c_ptr), intent(in), value :: kinds FFT R2R kinds integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_create_plan_c2c_c (ndims, dims, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates C2C dtFFT Plan, allocates all structures and prepares FFT, C/C++ interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: ndims Rank of transform. Can be 2 or 3. type(c_ptr), intent(in), value :: dims Global sizes of transform integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_create_plan_c2c_pencil_c (pencil, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates C2C dtFFT plan from Pencil, allocates all structures and prepares FFT, C/C++/Python interface Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: pencil C pointer to Fortran pencil integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_z_slab_enabled_c (plan_ptr, is_z_slab_enabled) result(error_code) bind(C) Checks if dtFFT Plan is using Z-slab optimization Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan logical(kind=c_bool), intent(out) :: is_z_slab_enabled Is plan internally using Z-slab optimization Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_execute_c (plan_ptr, in, out, execute_type, aux) result(error_code) bind(C) Executes dtFFT Plan, C/C++ interface. aux can be NULL. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_execute_t ), intent(in) :: execute_type Type of execution type(c_ptr), intent(in), value :: aux Aux buffer, can be NULL Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_transpose_c (plan_ptr, in, out, transpose_type) result(error_code) bind(C) Executes single transposition, C/C++ interface. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_destroy_c (plan_ptr) result(error_code) bind(C) Destroys dtFFT Plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_local_sizes_c (plan_ptr, in_starts, in_counts, out_starts, out_counts, alloc_size) result(error_code) bind(C) Returns local sizes, counts in real and Fourier spaces and number of elements to be allocated for in and out buffers,\nC/C++ interface. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int32_t), intent(out), optional :: in_starts (3) Starts of local portion of data in ‘real’ space integer(kind=c_int32_t), intent(out), optional :: in_counts (3) Counts of local portion of data in ‘real’ space integer(kind=c_int32_t), intent(out), optional :: out_starts (3) Starts of local portion of data in ‘fourier’ space integer(kind=c_int32_t), intent(out), optional :: out_counts (3) Counts of local portion of data in ‘fourier’ space integer(kind=c_size_t), intent(out), optional :: alloc_size Minimum data needs to be allocated Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_alloc_size_c (plan_ptr, alloc_size) result(error_code) bind(C) Returns minimum number of bytes to be allocated for in and out buffers, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: alloc_size Minimum data needs to be allocated Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_pencil_c (plan_ptr, dim, pencil) result(error_code) bind(C) Returns pencil decomposition info, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int32_t), intent(in) :: dim Dimension requested type( dtfft_pencil_c ) :: pencil Pencil pointer Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_element_size_c (plan_ptr, element_size) result(error_code) bind(C) Returns size of element in bytes, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: element_size Size of element in bytes Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_alloc_bytes_c (plan_ptr, alloc_bytes) result(error_code) bind(C) Returns minimum number of bytes required to execute plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: alloc_bytes Number of bytes required Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_executor_c (plan_ptr, executor) result(error_code) bind(C) Returns executor type used in plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_executor_t ), intent(out) :: executor The enumerated type dtfft_executor_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_precision_c (plan_ptr, precision) result(error_code) bind(C) Returns precision used in plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_precision_t ), intent(out) :: precision The enumerated type dtfft_precision_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_dims_c (plan_ptr, ndims, dims) result(error_code) bind(C) Returns dimensions of plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int8_t), intent(out) :: ndims Number of dimensions type(c_ptr), intent(out) :: dims Array of dimensions Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_set_config_c (config) result(error_code) bind(C) Sets dtFFT configuration, C/C++ interface Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(in) :: config Configuration to set Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_report_c (plan_ptr) result(error_code) bind(C) Reports dtFFT Plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_mem_alloc_c (plan_ptr, alloc_bytes, ptr) result(error_code) bind(C) Allocates memory for dtFFT Plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), value :: alloc_bytes Number of bytes to allocate type(c_ptr) :: ptr Allocated pointer Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_mem_free_c (plan_ptr, ptr) result(error_code) bind(C) Frees memory for dtFFT Plan, C/C++ interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type(c_ptr), value :: ptr Pointer to deallocate Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_stream_c (plan_ptr, stream) result(error_code) bind(C) Returns Stream associated with plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_stream_t ), intent(out) :: stream CUDA stream Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_backend_c (plan_ptr, backend) result(error_code) bind(C) Returns selected dtfft_backend_t during autotuning Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_backend_t ), intent(out) :: backend The enumerated type dtfft_backend_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_platform_c (plan_ptr, platform) result(error_code) bind(C) Returns selected dtfft_platform_t during autotuning Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_platform_t ), intent(out) :: platform The enumerated type dtfft_platform_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Subroutines private  subroutine dtfft_get_error_string_c (error_code, error_string, error_string_size) bind(C) Returns an explaination of error_code that could have been previously returned by one of dtFFT API calls,\nC/C++ interface Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: error_code The enumerated type dtfft_error_t\ndefines API call result codes. character(len=c_char), intent(out) :: error_string (*) Explanation of error integer(kind=c_size_t), intent(out) :: error_string_size Size of error_string private  subroutine dtfft_get_precision_string_c (precision, precision_string, precision_string_size) bind(C) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: precision The enumerated type dtfft_precision_t character(len=c_char), intent(out) :: precision_string (*) Resulting string integer(kind=c_size_t), intent(out) :: precision_string_size Size of string private  subroutine dtfft_get_executor_string_c (executor, executor_string, executor_string_size) bind(C) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: executor The enumerated type dtfft_executor_t character(len=c_char), intent(out) :: executor_string (*) Resulting string integer(kind=c_size_t), intent(out) :: executor_string_size Size of string private  subroutine dtfft_get_backend_string_c (backend, backend_string, backend_string_size) bind(C) Returns string representation of dtfft_backend_t Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: backend The enumerated type dtfft_backend_t character(len=c_char), intent(out) :: backend_string (*) Resulting string integer(kind=c_size_t), intent(out) :: backend_string_size Size of string","tags":"","loc":"module/dtfft_api.html"},{"title":"dtfft_abstract_executor.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_abstract_executor.f90~~EfferentGraph sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_abstract_executor.f90~~AfferentGraph sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_abstract_executor !! This module describes Abstraction for all FFT Executors: [[abstract_executor]] use iso_c_binding , only : c_loc , c_ptr , c_null_ptr use iso_fortran_env , only : int8 , int32 , int64 use dtfft_errors use dtfft_pencil , only : pencil use dtfft_parameters use dtfft_utils #include \"dtfft_profile.h\" #include \"dtfft_private.h\" implicit none private public :: abstract_executor integer ( int8 ), public , parameter :: FFT_C2C = 0 !! Complex to complex FFT integer ( int8 ), public , parameter :: FFT_R2C = 1 !! Real to complex FFT integer ( int8 ), public , parameter :: FFT_R2R = 2 !! Real to real FFT integer ( int8 ), public , parameter :: FFT_1D = 1 !! 1D FFT integer ( int8 ), public , parameter :: FFT_2D = 2 !! 2D FFT type , abstract :: abstract_executor !! The \"most\" abstract executor. !! All FFT executors are extending this class. type ( c_ptr ) :: plan_forward !! Pointer to forward plan type ( c_ptr ) :: plan_backward !! Pointer to backward plan logical , private :: is_created = . false . !! Is plan created? logical :: is_inverse_copied = . false . !! Is inverse plan copied? contains procedure , non_overridable , pass ( self ), public :: create !! Creates FFT plan procedure , non_overridable , pass ( self ), public :: execute !! Executes plan procedure , non_overridable , pass ( self ), public :: destroy !! Destroys plan procedure ( mem_alloc_interface ), deferred , nopass , public :: mem_alloc !! Allocates aligned memory procedure ( mem_free_interface ), deferred , nopass , public :: mem_free !! Frees aligned memory procedure ( create_interface ), deferred , pass ( self ) :: create_private !! Creates FFT plan procedure ( execute_interface ), deferred , pass ( self ) :: execute_private !! Executes plan procedure ( destroy_interface ), deferred , pass ( self ) :: destroy_private !! Destroys plan end type abstract_executor abstract interface subroutine create_interface ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan import class ( abstract_executor ), intent ( inout ) :: self !! FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform end subroutine create_interface subroutine execute_interface ( self , a , b , sign ) !! Executes plan import class ( abstract_executor ), intent ( in ) :: self !! FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform end subroutine execute_interface subroutine destroy_interface ( self ) !! Destroys plan import class ( abstract_executor ), intent ( inout ) :: self !! FFT Executor end subroutine destroy_interface subroutine mem_alloc_interface ( alloc_bytes , ptr ) !! Allocates aligned memory import integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer end subroutine mem_alloc_interface subroutine mem_free_interface ( ptr ) !! Frees aligned memory import type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free end subroutine mem_free_interface end interface contains integer ( int32 ) function create ( self , fft_rank , fft_type , precision , real_pencil , complex_pencil , r2r_kinds ) !! Creates FFT plan class ( abstract_executor ), intent ( inout ) :: self !! FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type ( pencil ), optional , intent ( in ) :: real_pencil !! Real data layout type ( pencil ), optional , intent ( in ) :: complex_pencil !! Complex data layout type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform integer ( int32 ), allocatable :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), allocatable :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), allocatable :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ) :: how_many !! Number of transforms to create create = DTFFT_SUCCESS if ( self % is_created . and . . not . is_null_ptr ( self % plan_forward ) . and . . not . is_null_ptr ( self % plan_backward ) ) return PHASE_BEGIN ( \"Creating FFT\" , COLOR_FFT ) self % plan_forward = c_null_ptr self % plan_backward = c_null_ptr self % is_created = . false . self % is_inverse_copied = . false . if ( fft_rank /= FFT_1D . and . fft_rank /= FFT_2D ) INTERNAL_ERROR ( \"fft_rank /= FFT_1D .and. fft_rank /= FFT_2D\" ) if ( ( fft_type == FFT_R2C ). and .(. not . present ( complex_pencil ) . or . . not . present ( real_pencil )) ) INTERNAL_ERROR ( \"(fft_type == FFT_R2C).and.(.not.present(complex_pencil) .or. .not.present(real_pencil))\" ) if ( ( fft_type == FFT_R2R ). and .(. not . present ( real_pencil ) . or .. not . present ( r2r_kinds )) ) INTERNAL_ERROR ( \"(fft_type == FFT_R2R).and.(.not.present(real_pencil) .or..not.present(r2r_kinds))\" ) allocate ( fft_sizes ( fft_rank ), inembed ( fft_rank ), onembed ( fft_rank ) ) how_many = 0 select case ( fft_type ) case ( FFT_C2C ) select case ( fft_rank ) case ( FFT_1D ) fft_sizes ( 1 ) = complex_pencil % counts ( 1 ) case ( FFT_2D ) fft_sizes ( 1 ) = complex_pencil % counts ( 2 ) fft_sizes ( 2 ) = complex_pencil % counts ( 1 ) endselect inembed (:) = fft_sizes (:) onembed (:) = fft_sizes (:) idist = product ( fft_sizes ) odist = idist how_many = product ( complex_pencil % counts ) / idist case ( FFT_R2C ) select case ( fft_rank ) case ( FFT_1D ) fft_sizes ( 1 ) = real_pencil % counts ( 1 ) onembed ( 1 ) = complex_pencil % counts ( 1 ) case ( FFT_2D ) fft_sizes ( 1 ) = real_pencil % counts ( 2 ) fft_sizes ( 2 ) = real_pencil % counts ( 1 ) onembed ( 1 ) = complex_pencil % counts ( 2 ) onembed ( 2 ) = complex_pencil % counts ( 1 ) endselect inembed (:) = fft_sizes (:) idist = product ( inembed ) odist = product ( onembed ) how_many = product ( real_pencil % counts ) / idist case ( FFT_R2R ) select case ( fft_rank ) case ( FFT_1D ) fft_sizes ( 1 ) = real_pencil % counts ( 1 ) case ( FFT_2D ) fft_sizes ( 1 ) = real_pencil % counts ( 2 ) fft_sizes ( 2 ) = real_pencil % counts ( 1 ) endselect inembed (:) = fft_sizes (:) onembed (:) = fft_sizes (:) idist = product ( fft_sizes ) odist = idist how_many = product ( real_pencil % counts ) / idist endselect if ( how_many == 0 ) then PHASE_END ( \"Creating FFT\" ) return endif call self % create_private ( fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , create , r2r_kinds ) ! This should only happen when current process do not have any data, so FFT plan is not required here if ( is_null_ptr ( self % plan_forward ) . or . is_null_ptr ( self % plan_backward ) ) return if ( create == DTFFT_SUCCESS ) self % is_created = . true . deallocate ( fft_sizes , inembed , onembed ) PHASE_END ( \"Creating FFT\" ) end function create subroutine execute ( self , in , out , sign ) !! Executes plan class ( abstract_executor ), intent ( in ) :: self !! FFT Executor type ( c_ptr ), intent ( in ) :: in !! Source buffer type ( c_ptr ), intent ( in ) :: out !! Target buffer integer ( int8 ), intent ( in ) :: sign !! Sign of transform if ( . not . self % is_created ) return PHASE_BEGIN ( \"Executing FFT\" , COLOR_FFT ) call self % execute_private ( in , out , sign ) PHASE_END ( \"Executing FFT\" ) end subroutine execute subroutine destroy ( self ) !! Destroys plan class ( abstract_executor ), intent ( inout ) :: self !! FFT Executor if ( self % is_created ) call self % destroy_private () self % plan_forward = c_null_ptr self % plan_backward = c_null_ptr self % is_created = . false . self % is_inverse_copied = . false . end subroutine destroy end module dtfft_abstract_executor","tags":"","loc":"sourcefile/dtfft_abstract_executor.f90.html"},{"title":"dtfft_interface_mkl_native_m.F90 – dtFFT","text":"Files dependent on this one sourcefile~~dtfft_interface_mkl_native_m.f90~~AfferentGraph sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"mkl_dfti.f90\" module dtfft_interface_mkl_native_m !! This module creates native interface with MKL library use MKL_DFTI implicit none private public :: DFTI_NO_ERROR , & DFTI_DOUBLE , DFTI_SINGLE , & DFTI_NUMBER_OF_TRANSFORMS , & DFTI_PLACEMENT , & DFTI_INPUT_DISTANCE , & DFTI_OUTPUT_DISTANCE , & DFTI_CONJUGATE_EVEN_STORAGE , & DFTI_COMPLEX_COMPLEX , & DFTI_COMPLEX , & DFTI_REAL , & DFTI_INPLACE , & DFTI_NOT_INPLACE , & DFTI_INPUT_STRIDES , & DFTI_OUTPUT_STRIDES end module dtfft_interface_mkl_native_m","tags":"","loc":"sourcefile/dtfft_interface_mkl_native_m.f90.html"},{"title":"dtfft_backend_cufftmp.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_backend_cufftmp.f90~~EfferentGraph sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_backend_cufftmp.f90~~AfferentGraph sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_backend_cufftmp_m !! cuFFTMp GPU Backend [[backend_cufftmp]] use iso_fortran_env use iso_c_binding use dtfft_interface_nvshmem use dtfft_abstract_backend , only : abstract_backend , backend_helper use dtfft_interface_cuda_runtime use dtfft_interface_cufft use dtfft_parameters use dtfft_pencil , only : pencil use dtfft_utils #include \"dtfft_mpi.h\" #include \"dtfft_cuda.h\" #include \"dtfft_private.h\" implicit none private public :: backend_cufftmp type :: Box3D integer ( c_long_long ) :: lower ( 3 ) integer ( c_long_long ) :: upper ( 3 ) integer ( c_long_long ) :: strides ( 3 ) end type Box3D type , extends ( abstract_backend ) :: backend_cufftmp !! cuFFTMp GPU Backend private type ( cufftReshapeHandle ) :: plan contains procedure :: create_private => create procedure :: execute_private => execute procedure :: destroy_private => destroy endtype backend_cufftmp contains subroutine create ( self , helper , tranpose_type , base_storage ) !! Creates cuFFTMp GPU Backend class ( backend_cufftmp ), intent ( inout ) :: self !! cuFFTMp GPU Backend type ( backend_helper ), intent ( in ) :: helper !! Backend helper type ( dtfft_transpose_t ), intent ( in ) :: tranpose_type !! Type of transpose to create integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element type ( Box3D ) :: inbox , outbox !! Reshape boxes type ( pencil ), pointer :: in , out type ( c_ptr ) :: c_comm integer ( int64 ) :: aux_size select case ( tranpose_type % val ) case ( DTFFT_TRANSPOSE_X_TO_Y % val ) in => helper % pencils ( 1 ) out => helper % pencils ( 2 ) case ( DTFFT_TRANSPOSE_Y_TO_X % val ) in => helper % pencils ( 2 ) out => helper % pencils ( 1 ) case ( DTFFT_TRANSPOSE_Y_TO_Z % val ) in => helper % pencils ( 2 ) out => helper % pencils ( 3 ) case ( DTFFT_TRANSPOSE_Z_TO_Y % val ) in => helper % pencils ( 3 ) out => helper % pencils ( 2 ) case ( DTFFT_TRANSPOSE_X_TO_Z % val ) in => helper % pencils ( 1 ) out => helper % pencils ( 3 ) case ( DTFFT_TRANSPOSE_Z_TO_X % val ) in => helper % pencils ( 3 ) out => helper % pencils ( 1 ) case default INTERNAL_ERROR ( \"unknown `tranpose_type`\" ) endselect if ( in % rank == 3 ) then if ( tranpose_type == DTFFT_TRANSPOSE_X_TO_Y . or . tranpose_type == DTFFT_TRANSPOSE_Y_TO_X ) then inbox % lower = [ in % starts ( 3 ), in % starts ( 1 ), in % starts ( 2 )] inbox % upper = [ in % starts ( 3 ) + in % counts ( 3 ), in % starts ( 1 ) + in % counts ( 1 ), in % starts ( 2 ) + in % counts ( 2 )] inbox % strides = [ in % counts ( 1 ) * in % counts ( 2 ), in % counts ( 2 ), 1 ] elseif ( tranpose_type == DTFFT_TRANSPOSE_Y_TO_Z . or . tranpose_type == DTFFT_TRANSPOSE_Z_TO_Y ) then inbox % lower = [ in % starts ( 1 ), in % starts ( 2 ), in % starts ( 3 )] inbox % upper = [ in % starts ( 1 ) + in % counts ( 1 ), in % starts ( 2 ) + in % counts ( 2 ), in % starts ( 3 ) + in % counts ( 3 )] inbox % strides = [ in % counts ( 2 ) * in % counts ( 3 ), in % counts ( 3 ), 1 ] else if ( tranpose_type == DTFFT_TRANSPOSE_X_TO_Z ) then inbox % lower = [ in % starts ( 2 ), in % starts ( 1 ), in % starts ( 3 )] inbox % upper = [ in % starts ( 2 ) + in % counts ( 2 ), in % starts ( 1 ) + in % counts ( 1 ), in % starts ( 3 ) + in % counts ( 3 )] inbox % strides = [ in % counts ( 1 ) * in % counts ( 3 ), in % counts ( 3 ), 1 ] else if ( tranpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then inbox % lower = [ in % starts ( 1 ), in % starts ( 3 ), in % starts ( 2 )] inbox % upper = [ in % starts ( 1 ) + in % counts ( 1 ), in % starts ( 3 ) + in % counts ( 3 ), in % starts ( 2 ) + in % counts ( 2 )] inbox % strides = [ in % counts ( 2 ) * in % counts ( 3 ), in % counts ( 2 ), 1 ] else INTERNAL_ERROR ( \"unknown transposition using cufftMp backend\" ) endif outbox % lower = [ out % starts ( 3 ), out % starts ( 2 ), out % starts ( 1 )] outbox % upper = [ out % starts ( 3 ) + out % counts ( 3 ), out % starts ( 2 ) + out % counts ( 2 ), out % starts ( 1 ) + out % counts ( 1 )] outbox % strides = [ out % counts ( 1 ) * out % counts ( 2 ), out % counts ( 1 ), 1 ] else inbox % lower = [ 0 , in % starts ( 1 ), in % starts ( 2 )] inbox % upper = [ 1 , in % starts ( 1 ) + in % counts ( 1 ), in % starts ( 2 ) + in % counts ( 2 )] inbox % strides = [ in % counts ( 1 ) * in % counts ( 2 ), in % counts ( 2 ), 1 ] outbox % lower = [ 0 , out % starts ( 2 ), out % starts ( 1 )] outbox % upper = [ 1 , out % starts ( 2 ) + out % counts ( 2 ), out % starts ( 1 ) + out % counts ( 1 )] outbox % strides = [ out % counts ( 1 ) * out % counts ( 2 ), out % counts ( 1 ), 1 ] endif CUFFT_CALL ( \"cufftMpCreateReshape\" , cufftMpCreateReshape ( self % plan ) ) c_comm = Comm_f2c ( GET_MPI_VALUE ( helper % comms ( 1 ))) CUFFT_CALL ( \"cufftMpAttachReshapeComm\" , cufftMpAttachReshapeComm ( self % plan , CUFFT_COMM_MPI , c_comm ) ) CUFFT_CALL ( \"cufftMpMakeReshape\" , cufftMpMakeReshape ( self % plan , base_storage , 3 , inbox % lower , inbox % upper , outbox % lower , outbox % upper , inbox % strides , outbox % strides ) ) CUFFT_CALL ( \"cufftMpGetReshapeSize\" , cufftMpGetReshapeSize ( self % plan , aux_size ) ) self % aux_size = max ( aux_size , self % aux_size ) end subroutine create subroutine execute ( self , in , out , stream , aux ) !! Executes cuFFTMp GPU Backend class ( backend_cufftmp ), intent ( inout ) :: self !! cuFFTMp GPU Backend real ( real32 ), target , intent ( inout ) :: in (:) !! Send pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Main execution CUDA stream real ( real32 ), target , intent ( inout ) :: aux (:) !! Aux pointer integer ( int32 ) :: ierr ! call nvshmemx_sync_all_on_stream(stream) CUDA_CALL ( \"cudaStreamSynchronize\" , cudaStreamSynchronize ( stream ) ) call MPI_Barrier ( self % comm , ierr ) CUFFT_CALL ( \"cufftMpExecReshapeAsync\" , cufftMpExecReshapeAsync ( self % plan , c_loc ( out ), c_loc ( in ), c_loc ( aux ), stream ) ) end subroutine execute subroutine destroy ( self ) !! Destroys cuFFTMp GPU Backend class ( backend_cufftmp ), intent ( inout ) :: self !! cuFFTMp GPU Backend CUFFT_CALL ( \"cufftMpDestroyReshape\" , cufftMpDestroyReshape ( self % plan ) ) end subroutine destroy end module dtfft_backend_cufftmp_m","tags":"","loc":"sourcefile/dtfft_backend_cufftmp.f90.html"},{"title":"dtfft_parameters.F90 – dtFFT","text":"Files dependent on this one sourcefile~~dtfft_parameters.f90~~AfferentGraph sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_parameters !! This module defines common ``dtFFT`` parameters use iso_c_binding , only : c_int32_t , c_null_ptr , c_ptr use iso_fortran_env , only : int8 , int32 , int64 , real32 , real64 #include \"dtfft_mpi.h\" #include \"dtfft_private.h\" implicit none private public :: dtfft_execute_t , dtfft_transpose_t public :: dtfft_executor_t , dtfft_effort_t public :: dtfft_precision_t , dtfft_r2r_kind_t public :: is_valid_execute_type , is_valid_transpose_type public :: is_valid_executor , is_valid_effort public :: is_valid_precision , is_valid_r2r_kind public :: is_valid_dimension , is_valid_comm_type public :: dtfft_get_version public :: dtfft_get_precision_string , dtfft_get_executor_string #ifdef DTFFT_WITH_CUDA public :: is_valid_platform public :: is_host_executor , is_cuda_executor public :: dtfft_backend_t public :: dtfft_get_backend_string public :: is_valid_gpu_backend , is_backend_pipelined , is_backend_mpi , is_backend_nccl , is_backend_cufftmp , is_backend_nvshmem public :: dtfft_stream_t , dtfft_get_cuda_stream #endif integer ( int32 ), parameter , public :: DTFFT_VERSION_MAJOR = CONF_DTFFT_VERSION_MAJOR !! dtFFT Major Version integer ( int32 ), parameter , public :: DTFFT_VERSION_MINOR = CONF_DTFFT_VERSION_MINOR !! dtFFT Minor Version integer ( int32 ), parameter , public :: DTFFT_VERSION_PATCH = CONF_DTFFT_VERSION_PATCH !! dtFFT Patch Version integer ( int32 ), parameter , public :: DTFFT_VERSION_CODE = CONF_DTFFT_VERSION_CODE !! dtFFT Version Code. Can be used in Version comparison interface dtfft_get_version !! Get dtFFT version module procedure :: dtfft_get_version_current !! Get current version module procedure :: dtfft_get_version_required !! Get required version end interface dtfft_get_version !------------------------------------------------------------------------------------------------ ! Execute types !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_execute_t !! Type that is used during call to `execute` method integer ( c_int32_t ) :: val !! Internal value end type dtfft_execute_t type ( dtfft_execute_t ), parameter , public :: DTFFT_EXECUTE_FORWARD = dtfft_execute_t ( CONF_DTFFT_EXECUTE_FORWARD ) !! Perform XYZ --> YXZ --> ZXY plan execution (Forward) type ( dtfft_execute_t ), parameter , public :: DTFFT_EXECUTE_BACKWARD = dtfft_execute_t ( CONF_DTFFT_EXECUTE_BACKWARD ) !! Perform ZXY --> YXZ --> XYZ plan execution (Backward) type ( dtfft_execute_t ), parameter :: VALID_EXECUTE_TYPES ( * ) = [ DTFFT_EXECUTE_FORWARD , DTFFT_EXECUTE_BACKWARD ] !! Valid execute types !------------------------------------------------------------------------------------------------ ! Transpose types !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_transpose_t !! Type that is used during call to [[dtfft_plan_t(type):transpose]] method integer ( c_int32_t ) :: val !! Internal value end type dtfft_transpose_t type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_X_TO_Y = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_X_TO_Y ) !! Perform single transposition, from X aligned to Y aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_Y_TO_X = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_Y_TO_X ) !! Perform single transposition, from Y aligned to X aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_X_TO_Z = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_X_TO_Z ) !! Perform single transposition, from X aligned to Z aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_Y_TO_Z = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_Y_TO_Z ) !! Perform single transposition, from Y aligned to Z aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_Z_TO_Y = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_Z_TO_Y ) !! Perform single transposition, from Z aligned to Y aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_Z_TO_X = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_Z_TO_X ) !! Perform single transposition, from Z aligned to X aligned type ( dtfft_transpose_t ), parameter :: VALID_TRANSPOSE_TYPES ( * ) = [ DTFFT_TRANSPOSE_X_TO_Y , DTFFT_TRANSPOSE_Y_TO_X , DTFFT_TRANSPOSE_Y_TO_Z , DTFFT_TRANSPOSE_Z_TO_Y , DTFFT_TRANSPOSE_X_TO_Z , DTFFT_TRANSPOSE_Z_TO_X ] !! Types of transpose that are valid to pass to `transpose` method character ( len =* ), parameter , public :: TRANSPOSE_NAMES ( - 3 : 3 ) = [ \"Z2X\" , \"Z2Y\" , \"Y2X\" , \"NUL\" , \"X2Y\" , \"Y2Z\" , \"X2Z\" ] !! String representation of `dtfft_transpose_t` !------------------------------------------------------------------------------------------------ ! External FFT executor types !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_executor_t !! Type that specifies external FFT executor integer ( c_int32_t ) :: val !! Internal value end type dtfft_executor_t type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_NONE = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_NONE ) !! Do not setup any executor. If this type is provided, then `execute` method should not be called. !! Use `transpose` method instead type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_FFTW3 = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_FFTW3 ) !! FFTW3 executor type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_MKL = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_MKL ) !! MKL executor type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_CUFFT = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_CUFFT ) !! cuFFT GPU executor type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_VKFFT = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_VKFFT ) !! VkFFT GPU executor type ( dtfft_executor_t ), parameter :: VALID_EXECUTORS ( * ) = [ DTFFT_EXECUTOR_NONE & #ifdef DTFFT_WITH_FFTW , DTFFT_EXECUTOR_FFTW3 & #endif #ifdef DTFFT_WITH_MKL , DTFFT_EXECUTOR_MKL & #endif #ifdef DTFFT_WITH_CUFFT , DTFFT_EXECUTOR_CUFFT & #endif #ifdef DTFFT_WITH_VKFFT , DTFFT_EXECUTOR_VKFFT & #endif ] !! List of valid executors #ifdef DTFFT_WITH_CUDA type ( dtfft_executor_t ), parameter :: HOST_EXECUTORS ( * ) = [ DTFFT_EXECUTOR_NONE , DTFFT_EXECUTOR_FFTW3 , DTFFT_EXECUTOR_MKL ] !! List of host executors type ( dtfft_executor_t ), parameter :: CUDA_EXECUTORS ( * ) = [ DTFFT_EXECUTOR_NONE , DTFFT_EXECUTOR_CUFFT , DTFFT_EXECUTOR_VKFFT ] !! List of CUDA executors #endif !------------------------------------------------------------------------------------------------ ! FFT Execution directions !------------------------------------------------------------------------------------------------ integer ( int8 ), parameter , public :: FFT_FORWARD = CONF_FFT_FORWARD !! Forward c2c transform integer ( int8 ), parameter , public :: FFT_BACKWARD = CONF_FFT_BACKWARD !! Backward c2c transform !------------------------------------------------------------------------------------------------ ! Effort flags. !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_effort_t !! Type that specifies effort that dtFFT should use when creating plan integer ( c_int32_t ) :: val !! Internal value end type dtfft_effort_t type ( dtfft_effort_t ), parameter , public :: DTFFT_ESTIMATE = dtfft_effort_t ( CONF_DTFFT_ESTIMATE ) !! Estimate flag. ``dtFFT`` will use default decomposition provided by MPI_Dims_create type ( dtfft_effort_t ), parameter , public :: DTFFT_MEASURE = dtfft_effort_t ( CONF_DTFFT_MEASURE ) !! Measure flag. ``dtFFT`` will run transpose routines to find the best grid decomposition. !! Passing this flag and MPI Communicator with Cartesian topology to `plan%create` makes dtFFT do nothing. type ( dtfft_effort_t ), parameter , public :: DTFFT_PATIENT = dtfft_effort_t ( CONF_DTFFT_PATIENT ) !! Patient flag. Same as `DTFFT_MEASURE`, but different MPI datatypes will also be tested type ( dtfft_effort_t ), parameter :: VALID_EFFORTS ( * ) = [ DTFFT_ESTIMATE , DTFFT_MEASURE , DTFFT_PATIENT ] !! Valid effort flags !------------------------------------------------------------------------------------------------ ! Precision flags !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_precision_t !! Type that specifies precision of dtFFT plan integer ( c_int32_t ) :: val !! Internal value end type dtfft_precision_t type ( dtfft_precision_t ), parameter , public :: DTFFT_SINGLE = dtfft_precision_t ( CONF_DTFFT_SINGLE ) !! Use single precision type ( dtfft_precision_t ), parameter , public :: DTFFT_DOUBLE = dtfft_precision_t ( CONF_DTFFT_DOUBLE ) !! Use double precision type ( dtfft_precision_t ), parameter :: VALID_PRECISIONS ( * ) = [ DTFFT_SINGLE , DTFFT_DOUBLE ] !! Valid precision flags !------------------------------------------------------------------------------------------------ ! R2R Transform kinds ! This parameters matches FFTW definitions. Hope they will never change there. !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_r2r_kind_t !! Type that specifies various kinds of R2R FFTs integer ( c_int32_t ) :: val !! Internal value end type dtfft_r2r_kind_t type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DCT_1 = dtfft_r2r_kind_t ( CONF_DTFFT_DCT_1 ) !! DCT-I (Logical N=2*(n-1), inverse is `DTFFT_DCT_1`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DCT_2 = dtfft_r2r_kind_t ( CONF_DTFFT_DCT_2 ) !! DCT-II (Logical N=2*n, inverse is `DTFFT_DCT_3`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DCT_3 = dtfft_r2r_kind_t ( CONF_DTFFT_DCT_3 ) !! DCT-III (Logical N=2*n, inverse is `DTFFT_DCT_2`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DCT_4 = dtfft_r2r_kind_t ( CONF_DTFFT_DCT_4 ) !! DCT-IV (Logical N=2*n, inverse is `DTFFT_DCT_4`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DST_1 = dtfft_r2r_kind_t ( CONF_DTFFT_DST_1 ) !! DST-I (Logical N=2*(n+1), inverse is `DTFFT_DST_1`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DST_2 = dtfft_r2r_kind_t ( CONF_DTFFT_DST_2 ) !! DST-II (Logical N=2*n, inverse is `DTFFT_DST_3`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DST_3 = dtfft_r2r_kind_t ( CONF_DTFFT_DST_3 ) !! DST-III (Logical N=2*n, inverse is `DTFFT_DST_2`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DST_4 = dtfft_r2r_kind_t ( CONF_DTFFT_DST_4 ) !! DST-IV (Logical N=2*n, inverse is `DTFFT_DST_4`) type ( dtfft_r2r_kind_t ), parameter :: VALID_R2R_KINDS ( * ) = [ DTFFT_DCT_1 , DTFFT_DCT_2 , DTFFT_DCT_3 , DTFFT_DCT_4 , DTFFT_DST_1 , DTFFT_DST_2 , DTFFT_DST_3 , DTFFT_DST_4 ] !! Array of valid R2R kinds public :: operator ( == ) interface operator ( == ) module procedure execute_type_eq !! Check if two `dtfft_execute_t` are equal module procedure transpose_type_eq !! Check if two `dtfft_transpose_t` are equal module procedure executor_eq !! Check if two `dtfft_executor_t` are equal module procedure effort_eq !! Check if two `dtfft_effort_t` are equal module procedure precision_eq !! Check if two `dtfft_precision_t` are equal module procedure r2r_kind_eq !! Check if two `dtfft_r2r_kind_t` are equal module procedure platform_eq !! Check if two `dtfft_platform_t` are equal #ifdef DTFFT_WITH_CUDA module procedure gpu_backend_eq !! Check if two `dtfft_backend_t` are equal #endif end interface public :: operator ( /= ) interface operator ( /= ) module procedure execute_type_ne !! Check if two `dtfft_execute_t` are not equal module procedure transpose_type_ne !! Check if two `dtfft_transpose_t` are not equal module procedure executor_ne !! Check if two `dtfft_executor_t` are not equal module procedure effort_ne !! Check if two `dtfft_effort_t` are not equal module procedure precision_ne !! Check if two `dtfft_precision_t` are not equal module procedure r2r_kind_ne !! Check if two `dtfft_r2r_kind_t` are not equal module procedure platform_ne !! Check if two `dtfft_platform_t` are not equal #ifdef DTFFT_WITH_CUDA module procedure gpu_backend_ne !! Check if two `dtfft_backend_t` are not equal #endif end interface !------------------------------------------------------------------------------------------------ ! Storage sizes !------------------------------------------------------------------------------------------------ integer ( int64 ), parameter , public :: DOUBLE_COMPLEX_STORAGE_SIZE = storage_size (( 1._real64 , 1._real64 )) / 8_int64 !! Number of bytes to store single double precision complex element integer ( int64 ), parameter , public :: COMPLEX_STORAGE_SIZE = storage_size (( 1._real32 , 1._real32 )) / 8_int64 !! Number of bytes to store single float precision complex element integer ( int64 ), parameter , public :: DOUBLE_STORAGE_SIZE = storage_size ( 1._real64 ) / 8_int64 !! Number of bytes to store single double precision real element integer ( int64 ), parameter , public :: FLOAT_STORAGE_SIZE = storage_size ( 1._real32 ) / 8_int64 !! Number of bytes to store single single precision real element integer ( int8 ), parameter :: VALID_DIMENSIONS ( * ) = [ 2_int8 , 3_int8 ] !! Valid dimensions for `plan.create` integer ( int32 ), parameter :: VALID_COMM_TYPES ( * ) = [ MPI_UNDEFINED , MPI_CART ] !! Valid communicator types for `plan.create` integer ( int32 ), parameter , public :: COLOR_CREATE = int ( Z '00FAB53C' ) !! Color for `plan.create` integer ( int32 ), parameter , public :: COLOR_EXECUTE = int ( Z '00E25DFC' ) !! Color for `plan.execute` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE = int ( Z '00B175BD' ) !! Color for `plan.transpose` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_XY = int ( Z '005DFCCA' ) !! Color for `DTFFT_TRANSPOSE_X_TO_Y` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_YX = int ( Z '0076A797' ) !! Color for `DTFFT_TRANSPOSE_Y_TO_X` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_YZ = int ( Z '00E3CF9F' ) !! Color for `DTFFT_TRANSPOSE_Y_TO_Z` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_ZY = int ( Z '008C826A' ) !! Color for `DTFFT_TRANSPOSE_Z_TO_Y` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_XZ = int ( Z '00546F66' ) !! Color for `DTFFT_TRANSPOSE_X_TO_Z` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_ZX = int ( Z '007A6D7D' ) !! Color for `DTFFT_TRANSPOSE_Z_TO_X` integer ( int32 ), parameter , public :: COLOR_FFT = int ( Z '00FCD05D' ) !! Color for FFT integer ( int32 ), parameter , public :: COLOR_AUTOTUNE = int ( Z '006075FF' ) !! Color for Autotune integer ( int32 ), parameter , public :: COLOR_AUTOTUNE2 = int ( Z '0056E874' ) !! Color for Autotune2 integer ( int32 ), parameter , public :: COLOR_DESTROY = int ( Z '00000000' ) !! Color for `plan.destroy` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_PALLETTE ( - 3 : 3 ) = [ COLOR_TRANSPOSE_ZX , COLOR_TRANSPOSE_ZY , COLOR_TRANSPOSE_YX , 0 , COLOR_TRANSPOSE_XY , COLOR_TRANSPOSE_YZ , COLOR_TRANSPOSE_XZ ] !! Color pallete for `plan.transpose` integer ( int32 ), parameter , public :: VARIABLE_NOT_SET = - 111 !! Default value when environ is not set #ifdef DTFFT_WITH_CUDA !------------------------------------------------------------------------------------------------ ! GPU Backends that are responsible for transfering data across GPUs !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_backend_t !! Type that specifies various GPU Backend present in dtFFT integer ( c_int32_t ) :: val !! Internal value end type dtfft_backend_t type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_DATATYPE = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_DATATYPE ) !! Backend that uses MPI datatypes !! Not really recommended to use, since it is a million times slower than other backends !! Left here just to show how slow MPI Datatypes are for GPU usage type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_P2P = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_P2P ) !! MPI peer-to-peer algorithm type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_A2A = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_A2A ) !! MPI backend using MPI_Alltoallv type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_NCCL = dtfft_backend_t ( CONF_DTFFT_BACKEND_NCCL ) !! NCCL backend type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_P2P_PIPELINED = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_P2P_PIPELINED ) !! MPI peer-to-peer algorithm with overlapping data copying and unpacking type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_NCCL_PIPELINED = dtfft_backend_t ( CONF_DTFFT_BACKEND_NCCL_PIPELINED ) !! NCCL backend with overlapping data copying and unpacking type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_CUFFTMP = dtfft_backend_t ( CONF_DTFFT_BACKEND_CUFFTMP ) !! cuFFTMp backend type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_CUFFTMP_PIPELINED = dtfft_backend_t ( CONF_DTFFT_BACKEND_CUFFTMP_PIPELINED ) !! cuFFTMp backend that uses extra buffer to gain performance type ( dtfft_backend_t ), parameter , public :: BACKEND_NOT_SET = dtfft_backend_t ( VARIABLE_NOT_SET ) !! Backend is not used type ( dtfft_backend_t ), parameter :: PIPELINED_BACKENDS ( * ) = [ DTFFT_BACKEND_MPI_P2P_PIPELINED , DTFFT_BACKEND_NCCL_PIPELINED , DTFFT_BACKEND_CUFFTMP_PIPELINED ] !! List of pipelined backends type ( dtfft_backend_t ), parameter :: MPI_BACKENDS ( * ) = [ DTFFT_BACKEND_MPI_P2P , DTFFT_BACKEND_MPI_A2A , DTFFT_BACKEND_MPI_P2P_PIPELINED ] !! List of MPI backends type ( dtfft_backend_t ), parameter :: NCCL_BACKENDS ( * ) = [ DTFFT_BACKEND_NCCL , DTFFT_BACKEND_NCCL_PIPELINED ] !! List of NCCL backends type ( dtfft_backend_t ), parameter :: CUFFTMP_BACKENDS ( * ) = [ DTFFT_BACKEND_CUFFTMP , DTFFT_BACKEND_CUFFTMP_PIPELINED ] !! List of cuFFTMp backends type ( dtfft_backend_t ), parameter :: NVSHMEM_BACKENDS ( * ) = [ DTFFT_BACKEND_CUFFTMP , DTFFT_BACKEND_CUFFTMP_PIPELINED ] !! List of NVSHMEM-based backends type ( dtfft_backend_t ), parameter , public :: VALID_GPU_BACKENDS ( * ) = [ DTFFT_BACKEND_MPI_DATATYPE & , DTFFT_BACKEND_MPI_P2P & , DTFFT_BACKEND_MPI_A2A & , DTFFT_BACKEND_MPI_P2P_PIPELINED & #ifdef DTFFT_WITH_NCCL , DTFFT_BACKEND_NCCL_PIPELINED & , DTFFT_BACKEND_NCCL & #endif #ifdef DTFFT_WITH_NVSHMEM , DTFFT_BACKEND_CUFFTMP & , DTFFT_BACKEND_CUFFTMP_PIPELINED & #endif ] !! List of valid GPU backends type , bind ( C ) :: dtfft_stream_t !! `dtFFT` stream representation. type ( c_ptr ) :: stream !! Actual stream end type dtfft_stream_t type ( dtfft_stream_t ), parameter , public :: NULL_STREAM = dtfft_stream_t ( c_null_ptr ) interface dtfft_stream_t !! Creates [[dtfft_stream_t]] from integer(cuda_stream_kind) module procedure stream_from_int64 end interface dtfft_stream_t #endif public :: dtfft_platform_t type , bind ( C ) :: dtfft_platform_t !! Type that specifies runtime platform, e.g. Host, CUDA, HIP integer ( c_int32_t ) :: val !! Internal value end type dtfft_platform_t type ( dtfft_platform_t ), public , parameter :: DTFFT_PLATFORM_HOST = dtfft_platform_t ( CONF_DTFFT_PLATFORM_HOST ) !! Host platform type ( dtfft_platform_t ), public , parameter :: DTFFT_PLATFORM_CUDA = dtfft_platform_t ( CONF_DTFFT_PLATFORM_CUDA ) !! CUDA platform #ifdef DTFFT_WITH_CUDA type ( dtfft_platform_t ), parameter :: VALID_PLATFORMS ( * ) = [ DTFFT_PLATFORM_HOST , DTFFT_PLATFORM_CUDA ] !! Valid platforms #endif ! type(dtfft_platform_t), public, parameter :: DTFFT_PLATFORM_HIP = dtfft_platform_t(3) type ( dtfft_platform_t ), public , parameter :: PLATFORM_NOT_SET = dtfft_platform_t ( VARIABLE_NOT_SET ) #define MAKE_EQ_FUN(datatype, name)                         \\ pure elemental function name ( left , right ) result ( res ); \\ type ( datatype ), intent ( in ) :: left ; \\ type ( datatype ), intent ( in ) :: right ; \\ logical :: res ; \\ res = left % val == right % val ; \\ end function name #define MAKE_NE_FUN(datatype, name)                         \\ pure elemental function name ( left , right ) result ( res ); \\ type ( datatype ), intent ( in ) :: left ; \\ type ( datatype ), intent ( in ) :: right ; \\ logical :: res ; \\ res = left % val /= right % val ; \\ end function name #define MAKE_VALID_FUN(type, name, valid_values)            \\ pure elemental function name ( param ) result ( res ); \\ type , intent ( in ) :: param ; \\ logical :: res ; \\ res = any ( param == valid_values ); \\ end function name #define MAKE_VALID_FUN_DTYPE(datatype, name, valid_values)  \\ MAKE_VALID_FUN ( type ( datatype ), name , valid_values ) contains MAKE_EQ_FUN ( dtfft_execute_t , execute_type_eq ) MAKE_EQ_FUN ( dtfft_transpose_t , transpose_type_eq ) MAKE_EQ_FUN ( dtfft_executor_t , executor_eq ) MAKE_EQ_FUN ( dtfft_effort_t , effort_eq ) MAKE_EQ_FUN ( dtfft_precision_t , precision_eq ) MAKE_EQ_FUN ( dtfft_r2r_kind_t , r2r_kind_eq ) MAKE_EQ_FUN ( dtfft_platform_t , platform_eq ) MAKE_NE_FUN ( dtfft_execute_t , execute_type_ne ) MAKE_NE_FUN ( dtfft_transpose_t , transpose_type_ne ) MAKE_NE_FUN ( dtfft_executor_t , executor_ne ) MAKE_NE_FUN ( dtfft_effort_t , effort_ne ) MAKE_NE_FUN ( dtfft_precision_t , precision_ne ) MAKE_NE_FUN ( dtfft_r2r_kind_t , r2r_kind_ne ) MAKE_NE_FUN ( dtfft_platform_t , platform_ne ) MAKE_VALID_FUN_DTYPE ( dtfft_execute_t , is_valid_execute_type , VALID_EXECUTE_TYPES ) MAKE_VALID_FUN_DTYPE ( dtfft_transpose_t , is_valid_transpose_type , VALID_TRANSPOSE_TYPES ) MAKE_VALID_FUN_DTYPE ( dtfft_executor_t , is_valid_executor , VALID_EXECUTORS ) MAKE_VALID_FUN_DTYPE ( dtfft_effort_t , is_valid_effort , VALID_EFFORTS ) MAKE_VALID_FUN_DTYPE ( dtfft_precision_t , is_valid_precision , VALID_PRECISIONS ) MAKE_VALID_FUN_DTYPE ( dtfft_r2r_kind_t , is_valid_r2r_kind , VALID_R2R_KINDS ) MAKE_VALID_FUN ( integer ( int8 ), is_valid_dimension , VALID_DIMENSIONS ) MAKE_VALID_FUN ( integer ( int32 ), is_valid_comm_type , VALID_COMM_TYPES ) integer ( c_int32_t ) function dtfft_get_version_current () bind ( C ) !! Returns the current version code dtfft_get_version_current = DTFFT_VERSION_CODE end function dtfft_get_version_current integer ( int32 ) function dtfft_get_version_required ( major , minor , patch ) !! Returns the version code required by the user integer ( int32 ), intent ( in ) :: major !! Major version integer ( int32 ), intent ( in ) :: minor !! Minor version integer ( int32 ), intent ( in ) :: patch !! Patch version dtfft_get_version_required = CONF_DTFFT_VERSION ( major , minor , patch ) end function dtfft_get_version_required function dtfft_get_precision_string ( precision ) result ( string ) !! Gets the string description of a precision type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision type character ( len = :), allocatable :: string !! Precision string select case ( precision % val ) case ( DTFFT_SINGLE % val ) allocate ( string , source = \"Single\" ) case ( DTFFT_DOUBLE % val ) allocate ( string , source = \"Double\" ) case default allocate ( string , source = \"Unknown precision\" ) endselect end function dtfft_get_precision_string function dtfft_get_executor_string ( executor ) result ( string ) !! Gets the string description of an executor type ( dtfft_executor_t ), intent ( in ) :: executor !! Executor type character ( len = :), allocatable :: string !! Executor string select case ( executor % val ) case ( DTFFT_EXECUTOR_NONE % val ) allocate ( string , source = \"None\" ) case ( DTFFT_EXECUTOR_FFTW3 % val ) allocate ( string , source = \"FFTW3\" ) case ( DTFFT_EXECUTOR_MKL % val ) allocate ( string , source = \"MKL\" ) case ( DTFFT_EXECUTOR_CUFFT % val ) allocate ( string , source = \"CUFFT\" ) case ( DTFFT_EXECUTOR_VKFFT % val ) allocate ( string , source = \"VKFFT\" ) case default allocate ( string , source = \"Unknown executor\" ) endselect end function dtfft_get_executor_string #ifdef DTFFT_WITH_CUDA MAKE_EQ_FUN ( dtfft_backend_t , gpu_backend_eq ) MAKE_NE_FUN ( dtfft_backend_t , gpu_backend_ne ) MAKE_VALID_FUN_DTYPE ( dtfft_executor_t , is_host_executor , HOST_EXECUTORS ) MAKE_VALID_FUN_DTYPE ( dtfft_executor_t , is_cuda_executor , CUDA_EXECUTORS ) MAKE_VALID_FUN_DTYPE ( dtfft_platform_t , is_valid_platform , VALID_PLATFORMS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_valid_gpu_backend , VALID_GPU_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_pipelined , PIPELINED_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_mpi , MPI_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_nccl , NCCL_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_cufftmp , CUFFTMP_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_nvshmem , NVSHMEM_BACKENDS ) function dtfft_get_backend_string ( backend ) result ( string ) !! Gets the string description of a GPU backend type ( dtfft_backend_t ), intent ( in ) :: backend !! GPU backend character ( len = :), allocatable :: string !! Backend string select case ( backend % val ) case ( DTFFT_BACKEND_MPI_DATATYPE % val ) allocate ( string , source = \"MPI_DATATYPE\" ) case ( DTFFT_BACKEND_MPI_P2P % val ) allocate ( string , source = \"MPI_P2P\" ) case ( DTFFT_BACKEND_MPI_A2A % val ) allocate ( string , source = \"MPI_A2A\" ) case ( DTFFT_BACKEND_NCCL % val ) allocate ( string , source = \"NCCL\" ) case ( DTFFT_BACKEND_CUFFTMP % val ) allocate ( string , source = \"CUFFTMP\" ) case ( DTFFT_BACKEND_MPI_P2P_PIPELINED % val ) allocate ( string , source = \"MPI_P2P_PIPELINED\" ) case ( DTFFT_BACKEND_NCCL_PIPELINED % val ) allocate ( string , source = \"NCCL_PIPELINED\" ) case ( DTFFT_BACKEND_CUFFTMP_PIPELINED % val ) allocate ( string , source = \"CUFFTMP_PIPELINED\" ) case ( BACKEND_NOT_SET % val ) allocate ( string , source = \"None\" ) case default allocate ( string , source = \"Unknown backend\" ) endselect end function dtfft_get_backend_string function stream_from_int64 ( cuda_stream ) result ( stream ) !! Creates [[dtfft_stream_t]] from integer(cuda_stream_kind) integer ( int64 ), intent ( in ) :: cuda_stream !! CUDA stream type ( dtfft_stream_t ) :: stream !! dtfft Stream stream = transfer ( cuda_stream , stream ) end function stream_from_int64 function dtfft_get_cuda_stream ( stream ) result ( cuda_stream ) !! Returns the CUDA stream from [[dtfft_stream_t]] type ( dtfft_stream_t ), intent ( in ) :: stream !! dtfft stream integer ( int64 ) :: cuda_stream !! CUDA stream cuda_stream = transfer ( stream , int64 ) end function dtfft_get_cuda_stream #endif end module dtfft_parameters","tags":"","loc":"sourcefile/dtfft_parameters.f90.html"},{"title":"dtfft_interface_vkfft_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_vkfft_m.f90~~EfferentGraph sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_vkfft_m.f90~~AfferentGraph sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_vkfft_m !! This module creates interface with VkFFT library !! !! VkFFT is loaded at runtime via dynamic loading. use iso_c_binding use iso_fortran_env use dtfft_errors use dtfft_parameters use dtfft_utils implicit none private #include \"dtfft_private.h\" public :: load_vkfft abstract interface subroutine vkfft_create_interface ( rank , dims , double_precision , how_many , r2c , c2r , dct , dst , stream , app_handle ) bind ( C ) !! Creates FFT plan via vkFFT Interface import integer ( c_int8_t ), value :: rank !! Rank of fft: 1 or 2 integer ( c_int ) :: dims ( * ) !! Dimensions of transform integer ( c_int ), value :: double_precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( c_int ), value :: how_many !! Number of transforms to create integer ( c_int8_t ), value :: r2c !! Is R2C transform required integer ( c_int8_t ), value :: c2r !! Is C2R transform required integer ( c_int8_t ), value :: dct !! Is DCT transform required integer ( c_int8_t ), value :: dst !! Is DST transform required type ( dtfft_stream_t ), value :: stream !! CUDA stream type ( c_ptr ) :: app_handle !! vkFFT application handle end subroutine vkfft_create_interface subroutine vkfft_execute_interface ( app_handle , in , out , sign ) bind ( C ) !! Executes vkFFT plan import type ( c_ptr ), value :: app_handle !! vkFFT application handle type ( c_ptr ), value :: in !! Input data type ( c_ptr ), value :: out !! Output data integer ( c_int8_t ), value :: sign !! Sign of FFT end subroutine vkfft_execute_interface subroutine vkfft_destroy_interface ( app_handle ) bind ( C ) !! Destroys vkFFT plan import type ( c_ptr ), value :: app_handle !! vkFFT application handle end subroutine vkfft_destroy_interface end interface public :: vkfft_wrapper type :: vkfft_wrapper !! VkFFT Wrapper private logical :: is_loaded = . false . !! Is VkFFT library loaded type ( c_ptr ) :: lib_handle !! Handle to the loaded library type ( c_funptr ) :: vkfft_functions ( 3 ) !! Array of VkFFT functions procedure ( vkfft_create_interface ), pointer , public , nopass :: create !! Fortran Pointer to vkFFT create function procedure ( vkfft_execute_interface ), pointer , public , nopass :: execute !! Fortran Pointer to vkFFT execute function procedure ( vkfft_destroy_interface ), pointer , public , nopass :: destroy !! Fortran Pointer to vkFFT destroy function end type vkfft_wrapper type ( vkfft_wrapper ), public , save , target :: cuda_wrapper !! VkFFT Wrapper for CUDA platform contains integer ( int32 ) function load_vkfft ( platform ) !! Loads VkFFT library based on the platform type ( dtfft_platform_t ), intent ( in ) :: platform !! Platform to load VkFFT library for if ( platform == DTFFT_PLATFORM_CUDA ) then load_vkfft = load ( cuda_wrapper , \"cuda\" ) endif end function load_vkfft function load ( wrapper , suffix ) result ( error_code ) !! Loads VkFFT library class ( vkfft_wrapper ), intent ( inout ) :: wrapper !! VkFFT Wrapper character ( len =* ), intent ( in ) :: suffix !! Suffix for the library name type ( string ), allocatable :: func_names (:) integer ( int32 ) :: error_code error_code = DTFFT_SUCCESS if ( wrapper % is_loaded ) return allocate ( func_names ( 3 )) func_names ( 1 ) = string ( \"vkfft_create\" ) func_names ( 2 ) = string ( \"vkfft_execute\" ) func_names ( 3 ) = string ( \"vkfft_destroy\" ) error_code = dynamic_load ( \"libdtfft_vkfft_\" // suffix // \".so\" , func_names , wrapper % lib_handle , wrapper % vkfft_functions ) call destroy_strings ( func_names ) if ( error_code /= DTFFT_SUCCESS ) return call c_f_procpointer ( wrapper % vkfft_functions ( 1 ), wrapper % create ) call c_f_procpointer ( wrapper % vkfft_functions ( 2 ), wrapper % execute ) call c_f_procpointer ( wrapper % vkfft_functions ( 3 ), wrapper % destroy ) wrapper % is_loaded = . true . end function load end module dtfft_interface_vkfft_m","tags":"","loc":"sourcefile/dtfft_interface_vkfft_m.f90.html"},{"title":"dtfft_interface_nvrtc.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_nvrtc.f90~~EfferentGraph sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_nvrtc.f90~~AfferentGraph sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_nvrtc !! nvRTC Interfaces. !! !! nvRTC is loaded at runtime via dynamic loading due to explicit cuda_driver linking by cmake. use iso_c_binding use iso_fortran_env , only : int32 use dtfft_errors use dtfft_interface_cuda_runtime , only : dim3 use dtfft_parameters use dtfft_utils implicit none private #include \"dtfft_private.h\" public :: nvrtcGetErrorString public :: load_nvrtc public :: nvrtcProgram type , bind ( C ) :: nvrtcProgram !! nvrtcProgram is the unit of compilation, and an opaque handle for a program. type ( c_ptr ) :: cptr !! Actual pointer end type nvrtcProgram abstract interface function nvrtcGetErrorString_interface ( error_code ) & result ( string ) !! Helper function that returns a string describing the given nvrtcResult code !! For unrecognized enumeration values, it returns \"NVRTC_ERROR unknown\" import integer ( c_int ), value :: error_code !! CUDA Runtime Compilation API result code. type ( c_ptr ) :: string !! Pointer to C string end function nvrtcGetErrorString_interface function nvrtcCreateProgram_interface ( prog , src , name , numHeaders , headers , includeNames ) & result ( nvrtcResult ) !! Creates an instance of nvrtcProgram with the given input parameters, !! and sets the output parameter prog with it. import type ( nvrtcProgram ) :: prog !! CUDA Runtime Compilation program. character ( c_char ) :: src ( * ) !! CUDA program source. character ( c_char ) :: name ( * ) !! CUDA program name. integer ( c_int ), value :: numHeaders !! Number of headers used. Must be greater than or equal to 0. type ( c_ptr ), value :: headers !! Sources of the headers type ( c_ptr ), value :: includeNames !! Name of each header by which they can be included in the CUDA program source integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcCreateProgram_interface function nvrtcDestroyProgram_interface ( prog ) & result ( nvrtcResult ) !! Destroys the given program. import type ( nvrtcProgram ) :: prog !! CUDA Runtime Compilation program. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcDestroyProgram_interface function nvrtcCompileProgram_interface ( prog , numOptions , options ) & result ( nvrtcResult ) !! Compiles the given program. import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. integer ( c_int ), value :: numOptions !! Number of compiler options passed. type ( c_ptr ) :: options ( * ) !! Compiler options in the form of C string array integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcCompileProgram_interface function nvrtcGetProgramLog_interface ( prog , log ) & result ( nvrtcResult ) !! Stores the log generated by the previous compilation of prog in the memory pointed by log import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. type ( c_ptr ), value :: log !! Compilation log. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcGetProgramLog_interface function nvrtcGetCUBINSize_interface ( prog , cubinSizeRet ) & result ( nvrtcResult ) !! Sets the value of ``cubinSizeRet`` with the size of the cubin generated by the previous compilation of ``prog``. import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. integer ( c_size_t ) :: cubinSizeRet !! Size of the generated cubin. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcGetCUBINSize_interface function nvrtcGetCUBIN_interface ( prog , cubin ) & result ( nvrtcResult ) !! Stores the cubin generated by the previous compilation of ``prog`` in the memory pointed by ``cubin``. import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. character ( c_char ) :: cubin ( * ) !! Compiled and assembled result. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcGetCUBIN_interface end interface logical , save :: is_loaded = . false . !! Flag indicating whether the library is loaded type ( c_ptr ), save :: libnvrtc !! Handle to the loaded library type ( c_funptr ), save :: nvrtcFunctions ( 7 ) !! Array of pointers to the nvRTC functions procedure ( nvrtcGetErrorString_interface ), pointer , public :: nvrtcGetErrorString_c !! Fortran pointer to the nvrtcGetErrorString function procedure ( nvrtcCreateProgram_interface ), pointer , public :: nvrtcCreateProgram !! Fortran pointer to the nvrtcCreateProgram function procedure ( nvrtcDestroyProgram_interface ), pointer , public :: nvrtcDestroyProgram !! Fortran pointer to the nvrtcDestroyProgram function procedure ( nvrtcCompileProgram_interface ), pointer , public :: nvrtcCompileProgram !! Fortran pointer to the nvrtcCompileProgram function procedure ( nvrtcGetProgramLog_interface ), pointer , public :: nvrtcGetProgramLog !! Fortran pointer to the nvrtcGetProgramLog function procedure ( nvrtcGetCUBINSize_interface ), pointer , public :: nvrtcGetCUBINSize !! Fortran pointer to the nvrtcGetCUBINSize function procedure ( nvrtcGetCUBIN_interface ), pointer , public :: nvrtcGetCUBIN !! Fortran pointer to the nvrtcGetCUBIN function contains function nvrtcGetErrorString ( error_code ) result ( string ) !! Helper function that returns a string describing the given nvrtcResult code !! For unrecognized enumeration values, it returns \"NVRTC_ERROR unknown\" integer ( c_int ), intent ( in ) :: error_code !! CUDA Runtime Compilation API result code. character ( len = :), allocatable :: string !! Result string type ( c_ptr ) :: c_string !! Pointer to C string c_string = nvrtcGetErrorString_c ( error_code ) call string_c2f ( c_string , string ) end function nvrtcGetErrorString function load_nvrtc () result ( error_code ) !! Dynamically loads nvRTC library and its functions integer ( int32 ) :: error_code !! Error code type ( string ), allocatable :: func_names (:) error_code = DTFFT_SUCCESS if ( is_loaded ) return allocate ( func_names ( 7 )) func_names ( 1 ) = string ( \"nvrtcGetErrorString\" ) func_names ( 2 ) = string ( \"nvrtcCreateProgram\" ) func_names ( 3 ) = string ( \"nvrtcDestroyProgram\" ) func_names ( 4 ) = string ( \"nvrtcCompileProgram\" ) func_names ( 5 ) = string ( \"nvrtcGetProgramLog\" ) func_names ( 6 ) = string ( \"nvrtcGetCUBINSize\" ) func_names ( 7 ) = string ( \"nvrtcGetCUBIN\" ) error_code = dynamic_load ( \"libnvrtc.so\" , func_names , libnvrtc , nvrtcFunctions ) call destroy_strings ( func_names ) if ( error_code /= DTFFT_SUCCESS ) return call c_f_procpointer ( nvrtcFunctions ( 1 ), nvrtcGetErrorString_c ) call c_f_procpointer ( nvrtcFunctions ( 2 ), nvrtcCreateProgram ) call c_f_procpointer ( nvrtcFunctions ( 3 ), nvrtcDestroyProgram ) call c_f_procpointer ( nvrtcFunctions ( 4 ), nvrtcCompileProgram ) call c_f_procpointer ( nvrtcFunctions ( 5 ), nvrtcGetProgramLog ) call c_f_procpointer ( nvrtcFunctions ( 6 ), nvrtcGetCUBINSize ) call c_f_procpointer ( nvrtcFunctions ( 7 ), nvrtcGetCUBIN ) is_loaded = . true . end function load_nvrtc end module dtfft_interface_nvrtc","tags":"","loc":"sourcefile/dtfft_interface_nvrtc.f90.html"},{"title":"dtfft_errors.F90 – dtFFT","text":"Files dependent on this one sourcefile~~dtfft_errors.f90~~AfferentGraph sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_interface_nvtx.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module dtfft_errors use iso_fortran_env , only : int32 #include \"dtfft_config.h\" implicit none private public :: dtfft_get_error_string integer ( int32 ), parameter , public :: DTFFT_SUCCESS = CONF_DTFFT_SUCCESS !! Successful execution integer ( int32 ), parameter , public :: DTFFT_ERROR_MPI_FINALIZED = CONF_DTFFT_ERROR_MPI_FINALIZED !! MPI_Init is not called or MPI_Finalize has already been called integer ( int32 ), parameter , public :: DTFFT_ERROR_PLAN_NOT_CREATED = CONF_DTFFT_ERROR_PLAN_NOT_CREATED !! Plan not created integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_TRANSPOSE_TYPE = CONF_DTFFT_ERROR_INVALID_TRANSPOSE_TYPE !! Invalid `transpose_type` provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_N_DIMENSIONS = CONF_DTFFT_ERROR_INVALID_N_DIMENSIONS !! Invalid Number of dimensions provided. Valid options are 2 and 3 integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_DIMENSION_SIZE = CONF_DTFFT_ERROR_INVALID_DIMENSION_SIZE !! One or more provided dimension sizes <= 0 integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_COMM_TYPE = CONF_DTFFT_ERROR_INVALID_COMM_TYPE !! Invalid communicator type provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_PRECISION = CONF_DTFFT_ERROR_INVALID_PRECISION !! Invalid `precision` parameter provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_EFFORT = CONF_DTFFT_ERROR_INVALID_EFFORT_FLAG !! Invalid `effort` parameter provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_EXECUTOR = CONF_DTFFT_ERROR_INVALID_EXECUTOR_TYPE !! Invalid `executor` parameter provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_COMM_DIMS = CONF_DTFFT_ERROR_INVALID_COMM_DIMS !! Number of dimensions in provided Cartesian communicator > Number of dimension passed to `create` subroutine integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_COMM_FAST_DIM = CONF_DTFFT_ERROR_INVALID_COMM_FAST_DIM !! Passed Cartesian communicator with number of processes in 1st (fastest varying) dimension > 1 integer ( int32 ), parameter , public :: DTFFT_ERROR_MISSING_R2R_KINDS = CONF_DTFFT_ERROR_MISSING_R2R_KINDS !! For R2R plan, `kinds` parameter must be passed if `executor` != `DTFFT_EXECUTOR_NONE` integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_R2R_KINDS = CONF_DTFFT_ERROR_INVALID_R2R_KINDS !! Invalid values detected in `kinds` parameter integer ( int32 ), parameter , public :: DTFFT_ERROR_R2C_TRANSPOSE_PLAN = CONF_DTFFT_ERROR_R2C_TRANSPOSE_PLAN !! Transpose plan is not supported in R2C, use R2R or C2C plan instead integer ( int32 ), parameter , public :: DTFFT_ERROR_INPLACE_TRANSPOSE = CONF_DTFFT_ERROR_INPLACE_TRANSPOSE !! Inplace transpose is not supported integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_AUX = CONF_DTFFT_ERROR_INVALID_AUX !! Invalid `aux` buffer provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_DIM = CONF_DTFFT_ERROR_INVALID_DIM !! Invalid `dim` passed to `plan.get_pencil` integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_USAGE = CONF_DTFFT_ERROR_INVALID_USAGE !! Invalid API Usage. integer ( int32 ), parameter , public :: DTFFT_ERROR_PLAN_IS_CREATED = CONF_DTFFT_ERROR_PLAN_IS_CREATED !! Trying to create already created plan integer ( int32 ), parameter , public :: DTFFT_ERROR_ALLOC_FAILED = CONF_DTFFT_ERROR_ALLOC_FAILED !! Internal allocation failed integer ( int32 ), parameter , public :: DTFFT_ERROR_FREE_FAILED = CONF_DTFFT_ERROR_FREE_FAILED !! Internal memory free failed integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_ALLOC_BYTES = CONF_DTFFT_ERROR_INVALID_ALLOC_BYTES !! Invalid `alloc_bytes` provided integer ( int32 ), parameter , public :: DTFFT_ERROR_DLOPEN_FAILED = CONF_DTFFT_ERROR_DLOPEN_FAILED !! dlopen failed integer ( int32 ), parameter , public :: DTFFT_ERROR_DLSYM_FAILED = CONF_DTFFT_ERROR_DLSYM_FAILED !! dlsym failed integer ( int32 ), parameter , public :: DTFFT_ERROR_R2C_TRANSPOSE_CALLED = CONF_DTFFT_ERROR_R2C_TRANSPOSE_CALLED !! Calling to `transpose` method for R2C plan is not allowed integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH = CONF_DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH !! Sizes of `starts` and `counts` arrays passed to `dtfft_pencil_t` constructor do not match integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES = CONF_DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES !! Sizes of `starts` and `counts` < 2 or > 3 provided to `dtfft_pencil_t` constructor integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_INVALID_COUNTS = CONF_DTFFT_ERROR_PENCIL_INVALID_COUNTS !! Invalid `counts` provided to `dtfft_pencil_t` constructor integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_INVALID_STARTS = CONF_DTFFT_ERROR_PENCIL_INVALID_STARTS !! Invalid `starts` provided to `dtfft_pencil_t` constructor integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_SHAPE_MISMATCH = CONF_DTFFT_ERROR_PENCIL_SHAPE_MISMATCH !! Processes have same lower bounds but different sizes in some dimensions integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_OVERLAP = CONF_DTFFT_ERROR_PENCIL_OVERLAP !! Pencil overlap detected, i.e. two processes share same part of global space integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_NOT_CONTINUOUS = CONF_DTFFT_ERROR_PENCIL_NOT_CONTINUOUS !! Local pencils do not cover the global space without gaps integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_NOT_INITIALIZED = CONF_DTFFT_ERROR_PENCIL_NOT_INITIALIZED !! Pencil is not initialized, i.e. `constructor` subroutine was not called integer ( int32 ), parameter , public :: DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED = CONF_DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED !! Selected `executor` do not support R2R FFTs integer ( int32 ), parameter , public :: DTFFT_ERROR_GPU_INVALID_STREAM = CONF_DTFFT_ERROR_GPU_INVALID_STREAM !! Invalid stream provided integer ( int32 ), parameter , public :: DTFFT_ERROR_GPU_INVALID_BACKEND = CONF_DTFFT_ERROR_GPU_INVALID_BACKEND !! Invalid GPU backend provided integer ( int32 ), parameter , public :: DTFFT_ERROR_GPU_NOT_SET = CONF_DTFFT_ERROR_GPU_NOT_SET !! Multiple MPI Processes located on same host share same GPU which is not supported integer ( int32 ), parameter , public :: DTFFT_ERROR_VKFFT_R2R_2D_PLAN = CONF_DTFFT_ERROR_VKFFT_R2R_2D_PLAN !! When using R2R FFT and executor type is vkFFT and plan uses Z-slab optimization, it is required that types of R2R transform are same in X and Y directions integer ( int32 ), parameter , public :: DTFFT_ERROR_GPU_BACKENDS_DISABLED = CONF_DTFFT_ERROR_GPU_BACKENDS_DISABLED !! Passed `effort` ==  `DTFFT_PATIENT` but all GPU Backends has been disabled by `dtfft_config_t` */ integer ( int32 ), parameter , public :: DTFFT_ERROR_NOT_DEVICE_PTR = CONF_DTFFT_ERROR_NOT_DEVICE_PTR !! One of pointers passed to `plan.execute` or `plan.transpose` cannot be accessed from device integer ( int32 ), parameter , public :: DTFFT_ERROR_NOT_NVSHMEM_PTR = CONF_DTFFT_ERROR_NOT_NVSHMEM_PTR !! One of pointers passed to `plan.execute` or `plan.transpose` is not an `NVSHMEM` pointer integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_PLATFORM = CONF_DTFFT_ERROR_INVALID_PLATFORM !! Invalid platform provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR_TYPE = CONF_DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR_TYPE !! Invalid executor provided for selected platform contains pure function dtfft_get_error_string ( error_code ) result ( error_string ) !! Gets the string description of an error code integer ( int32 ), intent ( in ) :: error_code !! Error code character ( len = :), allocatable :: error_string !! Error string select case ( error_code ) case ( DTFFT_SUCCESS ) allocate ( error_string , source = \"DTFFT_SUCCESS\" ) case ( DTFFT_ERROR_MPI_FINALIZED ) allocate ( error_string , source = \"MPI_Init is not called or MPI_Finalize has already been called\" ) case ( DTFFT_ERROR_PLAN_NOT_CREATED ) allocate ( error_string , source = \"Plan not created\" ) case ( DTFFT_ERROR_INVALID_TRANSPOSE_TYPE ) allocate ( error_string , source = \"Invalid `transpose_type` provided\" ) case ( DTFFT_ERROR_INVALID_N_DIMENSIONS ) allocate ( error_string , source = \"Invalid Number of dimensions provided. Valid options are 2 and 3\" ) case ( DTFFT_ERROR_INVALID_DIMENSION_SIZE ) allocate ( error_string , source = \"One or more provided dimension sizes <= 0\" ) case ( DTFFT_ERROR_INVALID_COMM_TYPE ) allocate ( error_string , source = \"Invalid communicator type provided\" ) case ( DTFFT_ERROR_INVALID_PRECISION ) allocate ( error_string , source = \"Invalid `precision` parameter provided\" ) case ( DTFFT_ERROR_INVALID_EFFORT ) allocate ( error_string , source = \"Invalid `effort` parameter provided\" ) case ( DTFFT_ERROR_INVALID_EXECUTOR ) allocate ( error_string , source = \"Invalid `executor` parameter provided\" ) case ( DTFFT_ERROR_INVALID_COMM_DIMS ) allocate ( error_string , source = \"Number of dimensions in provided Cartesian communicator > Number of dimension passed to `create` subroutine\" ) case ( DTFFT_ERROR_INVALID_COMM_FAST_DIM ) allocate ( error_string , source = \"Passed Cartesian communicator with number of processes in 1st (fastest varying) dimension > 1 OR provided dtfft_pencil_t with distribution over 1st dimension\" ) case ( DTFFT_ERROR_MISSING_R2R_KINDS ) allocate ( error_string , source = \"For R2R plan, `kinds` parameter must be passed if `executor` != `DTFFT_EXECUTOR_NONE`\" ) case ( DTFFT_ERROR_INVALID_R2R_KINDS ) allocate ( error_string , source = \"Invalid values detected in `kinds` parameter\" ) case ( DTFFT_ERROR_R2C_TRANSPOSE_PLAN ) allocate ( error_string , source = \"Transpose plan is not supported in R2C, use R2R or C2C plan instead\" ) case ( DTFFT_ERROR_INVALID_AUX ) allocate ( error_string , source = \"Invalid `aux` buffer provided\" ) case ( DTFFT_ERROR_INPLACE_TRANSPOSE ) allocate ( error_string , source = \"Inplace transpose is not supported\" ) case ( DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED ) allocate ( error_string , source = \"Selected `executor` do not support R2R FFTs\" ) case ( DTFFT_ERROR_INVALID_DIM ) allocate ( error_string , source = \"Invalid `dim` passed to `dtfft_get_pencil`\" ) case ( DTFFT_ERROR_INVALID_USAGE ) allocate ( error_string , source = \"Invalid API Usage.\" ) case ( DTFFT_ERROR_PLAN_IS_CREATED ) allocate ( error_string , source = \"Trying to create already created plan\" ) case ( DTFFT_ERROR_ALLOC_FAILED ) allocate ( error_string , source = \"Allocation failed\" ) case ( DTFFT_ERROR_FREE_FAILED ) allocate ( error_string , source = \"Memory free failed\" ) case ( DTFFT_ERROR_INVALID_ALLOC_BYTES ) allocate ( error_string , source = \"Invalid `alloc_bytes` provided\" ) case ( DTFFT_ERROR_DLOPEN_FAILED ) allocate ( error_string , source = \"Failed to open shared library. Set DTFFT_ENABLE_LOG=1 to see the error\" ) case ( DTFFT_ERROR_DLSYM_FAILED ) allocate ( error_string , source = \"Failed to find symbol in shared library. Set DTFFT_ENABLE_LOG=1 to see the error\" ) case ( DTFFT_ERROR_R2C_TRANSPOSE_CALLED ) allocate ( error_string , source = \"Calling to `transpose` method for R2C plan is not allowed\" ) case ( DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH ) allocate ( error_string , source = \"Sizes of `lbound` and `sizes` arrays passed to `dtfft_pencil_t` constructor do not match\" ) case ( DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES ) allocate ( error_string , source = \"Sizes of `lbound` and `sizes` < 2 or > 3 provided to `dtfft_pencil_t` constructor\" ) case ( DTFFT_ERROR_PENCIL_INVALID_COUNTS ) allocate ( error_string , source = \"Invalid `counts` provided to `dtfft_pencil_t` constructor\" ) case ( DTFFT_ERROR_PENCIL_INVALID_STARTS ) allocate ( error_string , source = \"Invalid `starts` provided to `dtfft_pencil_t` constructor\" ) case ( DTFFT_ERROR_PENCIL_SHAPE_MISMATCH ) allocate ( error_string , source = \"Processes have same `starts` but different `counts` in some dimensions\" ) case ( DTFFT_ERROR_PENCIL_OVERLAP ) allocate ( error_string , source = \"Pencil overlap detected, i.e. two processes share same part of global space\" ) case ( DTFFT_ERROR_PENCIL_NOT_CONTINUOUS ) allocate ( error_string , source = \"Local pencils do not cover the global space without gaps\" ) case ( DTFFT_ERROR_PENCIL_NOT_INITIALIZED ) allocate ( error_string , source = \"Pencil is not initialized, i.e. `constructor` subroutine was not called\" ) case ( DTFFT_ERROR_GPU_INVALID_STREAM ) allocate ( error_string , source = \"Invalid stream provided\" ) case ( DTFFT_ERROR_GPU_INVALID_BACKEND ) allocate ( error_string , source = \"Invalid GPU backend provided\" ) case ( DTFFT_ERROR_GPU_NOT_SET ) allocate ( error_string , source = \"Multiple MPI Processes located on same host share same GPU which is not supported\" ) case ( DTFFT_ERROR_VKFFT_R2R_2D_PLAN ) allocate ( error_string , source = \"When using R2R FFT and executor type is vkFFT and plan uses Z-slab optimization, it is required that types of R2R transform are same in X and Y directions\" ) case ( DTFFT_ERROR_GPU_BACKENDS_DISABLED ) allocate ( error_string , source = \"Passed `effort` ==  `::DTFFT_PATIENT` but all GPU Backends has been disabled by `dtfft_config_t`\" ) case ( DTFFT_ERROR_NOT_DEVICE_PTR ) allocate ( error_string , source = \"One of pointers passed to `dtfft_execute` or `dtfft_transpose` cannot be accessed from device\" ) case ( DTFFT_ERROR_NOT_NVSHMEM_PTR ) allocate ( error_string , source = \"One of pointers passed to `dtfft_execute` or `dtfft_transpose` is not an `NVSHMEM` pointer\" ) case ( DTFFT_ERROR_INVALID_PLATFORM ) allocate ( error_string , source = \"Invalid platform provided\" ) case ( DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR_TYPE ) allocate ( error_string , source = \"Invalid executor provided for selected platform\" ) case default allocate ( error_string , source = \"Unknown error\" ) endselect end function dtfft_get_error_string end module dtfft_errors","tags":"","loc":"sourcefile/dtfft_errors.f90.html"},{"title":"dtfft_executor_fftw_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_executor_fftw_m.f90~~EfferentGraph sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_executor_fftw_m.f90~~AfferentGraph sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_executor_fftw_m !! This module describes FFTW3 based FFT Executor: [[fftw_executor]] !! !! http://www.fftw.org use iso_c_binding , only : c_ptr , c_loc , c_null_ptr , c_int use iso_fortran_env , only : int8 , int32 , int64 , real32 use dtfft_abstract_executor , only : abstract_executor , FFT_C2C , FFT_R2C , FFT_R2R use dtfft_errors use dtfft_pencil , only : pencil use dtfft_interface_fftw_m use dtfft_parameters use dtfft_utils , only : get_inverse_kind implicit none private public :: fftw_executor integer ( int32 ), parameter :: FFTW3_FLAGS = FFTW_MEASURE + FFTW_DESTROY_INPUT !! FFTW3 planner flags type , extends ( abstract_executor ) :: fftw_executor !! FFTW3 FFT Executor private procedure ( apply_interface ), nopass , pointer :: apply => NULL () !! Pointer to FFTW3 function that executes FFT plan procedure ( free_interface ), nopass , pointer :: free => NULL () !! Pointer to FFTW3 function that destroys FFT plan procedure ( apply_interface ), nopass , pointer :: apply_inverse => NULL () !! Pointer to FFTW3 function that executes inverse FFT plan !! Used in R2C only contains procedure :: create_private => create !! Creates FFT plan via FFTW3 Interface procedure :: execute_private => execute !! Executes FFTW3 plan procedure :: destroy_private => destroy !! Destroys FFTW3 plan procedure , nopass :: mem_alloc !! Allocates FFTW3 memory procedure , nopass :: mem_free !! Frees FFTW3 aligned memory end type fftw_executor abstract interface subroutine apply_interface ( plan , in , out ) bind ( C ) !! Executes FFTW3 Plan #include \"args_execute.i90\" end subroutine apply_interface subroutine free_interface ( plan ) bind ( C ) !! Destroys FFTW3 Plan import type ( c_ptr ), value :: plan end subroutine free_interface type ( c_ptr ) function create_c2c_plan ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , sign , flags ) bind ( C ) !! Creates C2C FFTW3 Plan #include \"args_create.i90\" integer ( C_INT ), value :: sign end function create_c2c_plan type ( c_ptr ) function create_r2c_plan ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates R2C FFTW3 Plan #include \"args_create.i90\" end function create_r2c_plan type ( c_ptr ) function create_r2r_plan ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , kinds , flags ) bind ( C ) !! Creates R2R FFTW3 Plan #include \"args_create.i90\" integer ( C_FFTW_R2R_KIND ), intent ( in ) :: kinds ( * ) end function create_r2r_plan end interface contains subroutine create ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan via FFTW3 Interface class ( fftw_executor ), intent ( inout ) :: self !! FFTW FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform real ( real32 ), target , allocatable :: buf (:) !! Buffer needed to create plan integer ( int32 ) :: n_elements !! Number of elements in `buf` type ( c_ptr ) :: ptr !! C pointer to `buf` error_code = DTFFT_SUCCESS n_elements = product ( fft_sizes ) * how_many if ( fft_type == FFT_C2C . or . fft_type == FFT_R2C ) then n_elements = n_elements * 2 endif if ( precision == DTFFT_DOUBLE ) then n_elements = n_elements * 2 endif allocate ( buf ( n_elements ) ) ptr = c_loc ( buf ) if ( precision == DTFFT_SINGLE ) then self % free => fftwf_destroy_plan else self % free => fftw_destroy_plan endif select case ( fft_type ) case ( FFT_C2C ) block procedure ( create_c2c_plan ), pointer :: constructor if ( precision == DTFFT_SINGLE ) then constructor => fftwf_plan_many_dft self % apply => fftwf_execute_dft else constructor => fftw_plan_many_dft self % apply => fftw_execute_dft endif self % apply_inverse => NULL () self % plan_forward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , int ( FFT_FORWARD , int32 ), FFTW3_FLAGS ) self % plan_backward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , int ( FFT_BACKWARD , int32 ), FFTW3_FLAGS ) nullify ( constructor ) endblock case ( FFT_R2C ) block procedure ( create_r2c_plan ), pointer :: constructor , constructor_inverse if ( precision == DTFFT_SINGLE ) then constructor => fftwf_plan_many_dft_r2c self % apply => fftwf_execute_dft_r2c constructor_inverse => fftwf_plan_many_dft_c2r self % apply_inverse => fftwf_execute_dft_c2r else constructor => fftw_plan_many_dft_r2c self % apply => fftw_execute_dft_r2c constructor_inverse => fftw_plan_many_dft_c2r self % apply_inverse => fftw_execute_dft_c2r endif self % plan_forward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , FFTW3_FLAGS ) self % plan_backward = constructor_inverse ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , onembed , 1 , odist , ptr , inembed , 1 , idist , FFTW3_FLAGS ) nullify ( constructor , constructor_inverse ) endblock case ( FFT_R2R ) block procedure ( create_r2r_plan ), pointer :: constructor type ( dtfft_r2r_kind_t ), allocatable :: inverse_kinds (:) integer ( C_FFTW_R2R_KIND ), allocatable :: knds (:) if ( precision == DTFFT_SINGLE ) then constructor => fftwf_plan_many_r2r self % apply => fftwf_execute_r2r else constructor => fftw_plan_many_r2r self % apply => fftw_execute_r2r endif self % apply_inverse => NULL () allocate ( knds ( size ( r2r_kinds )) ) knds (:) = int ( r2r_kinds (:)% val , C_FFTW_R2R_KIND ) self % plan_forward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , knds , FFTW3_FLAGS ) allocate ( inverse_kinds ( size ( r2r_kinds ) ) ) inverse_kinds (:) = get_inverse_kind ( r2r_kinds ) if ( all ( inverse_kinds == r2r_kinds ) ) then self % plan_backward = self % plan_forward self % is_inverse_copied = . true . else knds (:) = int ( inverse_kinds (:)% val , C_FFTW_R2R_KIND ) self % plan_backward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , knds , FFTW3_FLAGS ) endif deallocate ( inverse_kinds , knds ) nullify ( constructor ) endblock endselect deallocate ( buf ) ptr = c_null_ptr end subroutine create subroutine execute ( self , a , b , sign ) !! Executes FFTW3 plan class ( fftw_executor ), intent ( in ) :: self !! FFTW FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform if ( sign == FFT_FORWARD ) then call self % apply ( self % plan_forward , a , b ) else if ( associated ( self % apply_inverse ) ) then call self % apply_inverse ( self % plan_backward , a , b ) else call self % apply ( self % plan_backward , a , b ) endif endif end subroutine execute subroutine destroy ( self ) !! Destroys FFTW3 plan class ( fftw_executor ), intent ( inout ) :: self !! FFTW FFT Executor call self % free ( self % plan_forward ) if ( . not . self % is_inverse_copied ) call self % free ( self % plan_backward ) self % apply => NULL () self % apply_inverse => NULL () self % free => NULL () end subroutine destroy subroutine mem_alloc ( alloc_bytes , ptr ) !! Allocates FFTW3 memory integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer ptr = fftw_malloc ( alloc_bytes ) end subroutine mem_alloc subroutine mem_free ( ptr ) !! Frees FFTW3 aligned memory type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free call fftw_free ( ptr ) end subroutine mem_free end module dtfft_executor_fftw_m","tags":"","loc":"sourcefile/dtfft_executor_fftw_m.f90.html"},{"title":"dtfft_executor_mkl_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_executor_mkl_m.f90~~EfferentGraph sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_executor_mkl_m.f90~~AfferentGraph sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_executor_mkl_m !! This module describes MKL based FFT Executor: [[mkl_executor]] !! !! https://software.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/fourier-transform-functions/fft-functions.html use iso_fortran_env , only : int8 , int32 , int64 , error_unit use iso_c_binding , only : c_int , c_long , c_ptr use dtfft_abstract_executor , only : abstract_executor , FFT_C2C , FFT_R2C , FFT_R2R use dtfft_errors use dtfft_interface_mkl_m use dtfft_interface_mkl_native_m use dtfft_parameters use dtfft_utils , only : int_to_str #include \"dtfft_mpi.h\" implicit none private public :: mkl_executor #define MKL_DFTI_CALL(name, func)                                                                                                                                     \\ block ; \\ integer ( c_long ) :: ierr ; \\ integer ( int32 ) :: mpi_err ; \\ ierr = func ; \\ if ( ierr /= DFTI_NO_ERROR ) then ; \\ write ( error_unit , '(a)' ) \"Error occured during call to MKL DFTI function '\" // name // \"': \" // DftiErrorMessage ( ierr ) // \" at \" // __ FILE__ // \":\" // int_to_str ( __ LINE__ ); \\ call MPI_Abort ( MPI_COMM_WORLD , int ( ierr , c_int ), mpi_err ); \\ endif ; \\ endblock type , extends ( abstract_executor ) :: mkl_executor !! MKL FFT Executor private logical :: need_reconfigure !! Needed for R2C plans integer ( c_long ), allocatable :: istrides (:) !! Input strides. Needed for R2C plans to reconfigure plan integer ( c_long ), allocatable :: ostrides (:) !! Output strides. Needed for R2C plans to reconfigure plan integer ( int32 ) :: idist !! Input distance between the first data elements of consecutive data sets integer ( int32 ) :: odist !! Output distance between the first data elements of consecutive data sets contains procedure :: create_private => create !! Creates FFT plan via MKL DFTI Interface procedure :: execute_private => execute !! Executes MKL plan procedure :: destroy_private => destroy !! Destroys MKL plan procedure , nopass :: mem_alloc !! Allocates MKL memory procedure , nopass :: mem_free !! Frees MKL aligned memory endtype mkl_executor contains subroutine make_plan ( fft_rank , fft_sizes , mkl_precision , forward_domain , how_many , idist , odist , plan ) !! Creates general MKL plan integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( c_long ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: mkl_precision !! MKL Precision integer ( int32 ), intent ( in ) :: forward_domain !! C2C or R2C flag integer ( int32 ), intent ( in ) :: how_many !! Sets DFTI_NUMBER_OF_TRANSFORMS integer ( int32 ), intent ( in ) :: idist !! Sets DFTI_INPUT_DISTANCE integer ( int32 ), intent ( in ) :: odist !! Sets DFTI_OUTPUT_DISTANCE type ( c_ptr ), intent ( inout ) :: plan !! Resulting plan MKL_DFTI_CALL ( \"DftiCreateDescriptor\" , mkl_dfti_create_desc ( mkl_precision , forward_domain , int ( fft_rank , c_long ), fft_sizes , plan ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_NUMBER_OF_TRANSFORMS , how_many ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_PLACEMENT , DFTI_NOT_INPLACE ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_INPUT_DISTANCE , idist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_OUTPUT_DISTANCE , odist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_CONJUGATE_EVEN_STORAGE , DFTI_COMPLEX_COMPLEX ) ) MKL_DFTI_CALL ( \"DftiCommitDescriptor\" , mkl_dfti_commit_desc ( plan ) ) end subroutine make_plan subroutine create ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan via MKL DFTI Interface class ( mkl_executor ), intent ( inout ) :: self !! MKL FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform integer ( int32 ) :: forward_domain , mkl_precision , i , idx integer ( c_long ) :: iprod , oprod , sizes ( fft_rank ) if ( present ( r2r_kinds ) ) then endif error_code = DTFFT_SUCCESS self % is_inverse_copied = . true . self % need_reconfigure = . false . select case ( fft_type ) case ( FFT_C2C ) forward_domain = DFTI_COMPLEX case ( FFT_R2C ) forward_domain = DFTI_REAL self % need_reconfigure = . true . self % idist = idist self % odist = odist allocate ( self % istrides ( size ( inembed ) + 1 ), source = 0_c_long ) allocate ( self % ostrides ( size ( onembed ) + 1 ), source = 0_c_long ) iprod = 1 ; oprod = 1 self % istrides ( size ( inembed ) + 1 ) = iprod self % ostrides ( size ( onembed ) + 1 ) = oprod do i = 1 , size ( inembed ) - 1 idx = size ( inembed ) + 1 - i iprod = iprod * inembed ( idx ) oprod = oprod * onembed ( idx ) self % istrides ( idx ) = iprod self % ostrides ( idx ) = oprod enddo case ( FFT_R2R ) error_code = DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED return endselect if ( precision == DTFFT_DOUBLE ) then mkl_precision = DFTI_DOUBLE else mkl_precision = DFTI_SINGLE endif sizes (:) = fft_sizes (:) call make_plan ( fft_rank , sizes , mkl_precision , forward_domain , how_many , idist , odist , self % plan_forward ) self % plan_backward = self % plan_forward end subroutine create subroutine execute ( self , a , b , sign ) !! Executes MKL plan class ( mkl_executor ), intent ( in ) :: self !! MKL FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform if ( self % need_reconfigure ) then if ( sign == FFT_FORWARD ) then MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_INPUT_DISTANCE , self % idist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_OUTPUT_DISTANCE , self % odist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_INPUT_STRIDES , self % istrides ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_OUTPUT_STRIDES , self % ostrides ) ) else MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_INPUT_DISTANCE , self % odist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_OUTPUT_DISTANCE , self % idist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_INPUT_STRIDES , self % ostrides ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_OUTPUT_STRIDES , self % istrides ) ) endif MKL_DFTI_CALL ( \"DftiCommitDescriptor\" , mkl_dfti_commit_desc ( self % plan_forward ) ) endif MKL_DFTI_CALL ( \"DftiCompute\" , mkl_dfti_execute ( self % plan_forward , a , b , int ( sign , c_int )) ) end subroutine execute subroutine destroy ( self ) !! Destroys MKL plan class ( mkl_executor ), intent ( inout ) :: self !! MKL FFT Executor MKL_DFTI_CALL ( \"DftiFreeDescriptor\" , mkl_dfti_free_desc ( self % plan_forward ) ) end subroutine destroy subroutine mem_alloc ( alloc_bytes , ptr ) !! Allocates MKL memory integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer MKL_DFTI_CALL ( \"mkl_malloc\" , mkl_dfti_mem_alloc ( alloc_bytes , ptr ) ) end subroutine mem_alloc subroutine mem_free ( ptr ) !! Frees MKL aligned memory type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free MKL_DFTI_CALL ( \"mkl_free\" , mkl_dfti_mem_free ( ptr ) ) end subroutine mem_free end module dtfft_executor_mkl_m","tags":"","loc":"sourcefile/dtfft_executor_mkl_m.f90.html"},{"title":"dtfft_interface_cufft.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_cufft.f90~~EfferentGraph sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_cufft.f90~~AfferentGraph sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_cufft !! cuFFT Interfaces use iso_c_binding use iso_fortran_env use dtfft_parameters ! #ifdef DTFFT_WITH_NVSHMEM ! use dtfft_interface_nvshmem,              only: load_nvshmem ! #endif use dtfft_utils implicit none private public :: CUFFT_R2C , CUFFT_C2R , CUFFT_C2C public :: CUFFT_D2Z , CUFFT_Z2D , CUFFT_Z2Z public :: cufftGetErrorString ! public :: load_cufft integer ( c_int ), parameter , public :: CUFFT_COMM_MPI = 0 enum , bind ( C ) enumerator :: CUFFT_R2C = 42 enumerator :: CUFFT_C2R = 44 enumerator :: CUFFT_C2C = 41 enumerator :: CUFFT_D2Z = 106 enumerator :: CUFFT_Z2D = 108 enumerator :: CUFFT_Z2Z = 105 end enum enum , bind ( C ) enumerator :: CUFFT_SUCCESS = 0 enumerator :: CUFFT_INVALID_PLAN = 1 enumerator :: CUFFT_ALLOC_FAILED = 2 enumerator :: CUFFT_INVALID_TYPE = 3 enumerator :: CUFFT_INVALID_VALUE = 4 enumerator :: CUFFT_INTERNAL_ERROR = 5 enumerator :: CUFFT_EXEC_FAILED = 6 enumerator :: CUFFT_SETUP_FAILED = 7 enumerator :: CUFFT_INVALID_SIZE = 8 enumerator :: CUFFT_UNALIGNED_DATA = 9 enumerator :: CUFFT_INCOMPLETE_PARAMETER_LIST = 10 enumerator :: CUFFT_INVALID_DEVICE = 11 enumerator :: CUFFT_PARSE_ERROR = 12 enumerator :: CUFFT_NO_WORKSPACE = 13 enumerator :: CUFFT_NOT_IMPLEMENTED = 14 enumerator :: CUFFT_LICENSE_ERROR = 15 enumerator :: CUFFT_NOT_SUPPORTED = 16 end enum public :: cufftReshapeHandle type , bind ( C ) :: cufftReshapeHandle !! An opaque handle to a reshape operation. type ( c_ptr ) :: cptr end type cufftReshapeHandle public :: cufftPlanMany interface !! Creates a FFT plan configuration of dimension rank, with sizes specified in the array n. function cufftPlanMany ( plan , rank , n , inembed , istride , idist , onembed , ostride , odist , ffttype , batch ) & result ( cufftResult ) & bind ( C , name = \"cufftPlanMany\" ) import type ( c_ptr ) :: plan !! Pointer to an uninitialized cufftHandle object. integer ( c_int ), value :: rank !! Dimensionality of the transform (1, 2, or 3). integer ( c_int ) :: n ( * ) !! Array of size rank, describing the size of each dimension, !! n[0] being the size of the outermost !! and n[rank-1] innermost (contiguous) dimension of a transform. integer ( c_int ) :: inembed ( * ) !! Pointer of size rank that indicates the storage dimensions of the input data in memory. !! If set to NULL, all other advanced data layout parameters are ignored. integer ( c_int ), value :: istride !! Indicates the distance between two successive input elements in the least !! significant (i.e., innermost) dimension. integer ( c_int ), value :: idist !! Indicates the distance between the first element of two consecutive signals !! in a batch of the input data. integer ( c_int ) :: onembed ( * ) !! Pointer of size rank that indicates the storage dimensions of the output data in memory. !! If set to NULL, all other advanced data layout parameters are ignored. integer ( c_int ), value :: ostride !! Indicates the distance between two successive output elements in the output array !! in the least significant (i.e., innermost) dimension. integer ( c_int ), value :: odist !! Indicates the distance between the first element of two consecutive signals !! in a batch of the output data. integer ( c_int ), value :: ffttype !! The transform data type (e.g., CUFFT_R2C for single precision real to complex). integer ( c_int ), value :: batch !! Batch size for this transform. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftPlanMany end interface public :: cufftXtExec interface !! Executes any cuFFT transform regardless of precision and type. !! In case of complex-to-real and real-to-complex transforms, the direction parameter is ignored. function cufftXtExec ( plan , input , output , direction ) & result ( cufftResult ) & bind ( C , name = \"cufftXtExec\" ) import type ( c_ptr ), value :: plan !! cufftHandle returned by cufftCreate. type ( c_ptr ), value :: input !! Pointer to the input data (in GPU memory) to transform. type ( c_ptr ), value :: output !! Pointer to the output data (in GPU memory). integer ( c_int ), value :: direction !! The transform direction: CUFFT_FORWARD or CUFFT_INVERSE. !! Ignored for complex-to-real and real-to-complex transforms. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftXtExec end interface public :: cufftDestroy interface !! Frees all GPU resources associated with a cuFFT plan and destroys the internal plan data structure. function cufftDestroy ( plan ) & result ( cufftResult ) & bind ( C , name = \"cufftDestroy\" ) import type ( c_ptr ), value :: plan !! Object of the plan to be destroyed. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftDestroy end interface public :: cufftSetStream interface !! Associates a CUDA stream with a cuFFT plan. function cufftSetStream ( plan , stream ) & result ( cufftResult ) & bind ( C , name = \"cufftSetStream\" ) import type ( c_ptr ), value :: plan !! Object to associate with the stream. type ( dtfft_stream_t ), value :: stream !! A valid CUDA stream. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftSetStream end interface public :: cufftMpCreateReshape interface !! Initializes a reshape handle for future use. This function is not collective. function cufftMpCreateReshape ( reshapeHandle ) & result ( cufftResult ) & bind ( C , name = \"cufftMpCreateReshape\" ) import type ( cufftReshapeHandle ) :: reshapeHandle !! The reshape handle. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpCreateReshape end interface public :: cufftMpAttachReshapeComm interface !! Attaches a communication handle to a reshape. This function is not collective. function cufftMpAttachReshapeComm ( reshapeHandle , commType , comm ) & result ( cufftResult ) & bind ( C , name = \"cufftMpAttachReshapeComm\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. integer ( c_int ), value :: commType !! An enum describing the communication type of the handle. type ( c_ptr ) :: comm !! If commType is CUFFT_COMM_MPI, this should be a pointer to an MPI communicator. !! The pointer should remain valid until destruction of the handle. !! Otherwise, this should be NULL. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpAttachReshapeComm end interface public :: cufftMpGetReshapeSize interface !! Returns the amount (in bytes) of workspace required to execute the handle. function cufftMpGetReshapeSize ( reshapeHandle , workSize ) & result ( cufftResult ) & bind ( C , name = \"cufftMpGetReshapeSize\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. integer ( c_size_t ) :: workSize !! The size, in bytes, of the workspace required during reshape execution. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpGetReshapeSize end interface public :: cufftMpMakeReshape interface !! Creates a reshape intended to re-distribute a global array of 3D data. function cufftMpMakeReshape ( reshapeHandle , elementSize , rank , lower_input , upper_input , & lower_output , upper_output , & strides_input , strides_output ) & result ( cufftResult ) & bind ( C , name = \"cufftMpMakeReshape\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. integer ( c_long_long ), value :: elementSize !! The size of the individual elements, in bytes. Allowed values are 4, 8, and 16. integer ( c_int ), value :: rank !! The length of the lower_input, upper_input, lower_output, upper_output, strides_input, and strides_output arrays. rank should be 3. integer ( c_long_long ) :: lower_input ( * ) !! An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer ( c_long_long ) :: upper_input ( * ) !! An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer ( c_long_long ) :: lower_output ( * ) !! An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer ( c_long_long ) :: upper_output ( * ) !! An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer ( c_long_long ) :: strides_input ( * ) !! An array of length rank, representing the local data layout of the input descriptor in memory. All entries must be decreasing and positive. integer ( c_long_long ) :: strides_output ( * ) !! An array of length rank, representing the local data layout of the output descriptor in memory. All entries must be decreasing and positive. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpMakeReshape end interface public :: cufftMpExecReshapeAsync interface !! Executes the reshape, redistributing data_in into data_out using the workspace in workspace. function cufftMpExecReshapeAsync ( reshapeHandle , dataOut , dataIn , workSpace , stream ) & result ( cufftResult ) & bind ( C , name = \"cufftMpExecReshapeAsync\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. type ( c_ptr ), value :: dataOut !! A symmetric-heap pointer to the output data. This memory should be NVSHMEM allocated and identical on all processes. type ( c_ptr ), value :: dataIn !! A symmetric-heap pointer to the input data. This memory should be NVSHMEM allocated and identical on all processes. type ( c_ptr ), value :: workSpace !! A symmetric-heap pointer to the workspace data. This memory should be NVSHMEM allocated and identical on all processes. type ( dtfft_stream_t ), value :: stream !! The CUDA stream in which to run the reshape operation. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpExecReshapeAsync end interface public :: cufftMpDestroyReshape interface !! Destroys a reshape and all its associated data. function cufftMpDestroyReshape ( reshapeHandle ) & result ( cufftResult ) & bind ( C , name = \"cufftMpDestroyReshape\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpDestroyReshape end interface !   logical, save :: is_loaded = .false. !     !! Flag indicating whether the library is loaded !   type(c_ptr), save :: libcufft !     !! Handle to the loaded library ! #ifdef DTFFT_WITH_NVSHMEM !   character(len=*), parameter :: LIB_NAME = \"libcufftMp.so\" !   integer(c_int),   parameter :: CUFFT_MAX_FUNCTIONS = 10 ! #else !   character(len=*), parameter :: LIB_NAME = \"libcufft.so\" !   integer(c_int),   parameter :: CUFFT_MAX_FUNCTIONS = 4 ! #endif !   type(c_funptr), save :: cufftFunctions(CUFFT_MAX_FUNCTIONS) !     !! Array of pointers to the cuFFT functions !   procedure(cufftPlanMany_interface),             pointer, public :: cufftPlanMany !     !! Fortran pointer to the cufftPlanMany function !   procedure(cufftXtExec_interface),               pointer, public :: cufftXtExec !     !! Fortran pointer to the cufftXtExec function !   procedure(cufftDestroy_interface),              pointer, public :: cufftDestroy !     !! Fortran pointer to the cufftDestroy function !   procedure(cufftSetStream_interface),            pointer, public :: cufftSetStream !     !! Fortran pointer to the cufftSetStream function !   procedure(cufftMpCreateReshape_interface),      pointer, public :: cufftMpCreateReshape !     !! Fortran pointer to the cufftMpCreateReshape function !   procedure(cufftMpAttachReshapeComm_interface),  pointer, public :: cufftMpAttachReshapeComm !     !! Fortran pointer to the cufftMpAttachReshapeComm function !   procedure(cufftMpGetReshapeSize_interface),     pointer, public :: cufftMpGetReshapeSize !     !! Fortran pointer to the cufftMpGetReshapeSize function !   procedure(cufftMpMakeReshape_interface),        pointer, public :: cufftMpMakeReshape !     !! Fortran pointer to the cufftMpMakeReshape function !   procedure(cufftMpExecReshapeAsync_interface),   pointer, public :: cufftMpExecReshapeAsync !     !! Fortran pointer to the cufftMpExecReshapeAsync function !   procedure(cufftMpDestroyReshape_interface),     pointer, public :: cufftMpDestroyReshape !     !! Fortran pointer to the cufftMpDestroyReshape function contains !   function load_cufft() result(error_code) !   !! Loads the cuFFT library and needed symbols !     integer(int32)  :: error_code !! Error code !     type(string), allocatable :: func_names(:) !     error_code = DTFFT_SUCCESS ! !     if ( is_loaded ) return ! !     allocate(func_names(CUFFT_MAX_FUNCTIONS)) ! !     func_names(1) = string(\"cufftPlanMany\") ! !     func_names(2) = string(\"cufftXtExec\") ! !     func_names(3) = string(\"cufftDestroy\") ! !     func_names(4) = string(\"cufftSetStream\") ! ! #ifdef DTFFT_WITH_NVSHMEM ! !     func_names(5) = string(\"cufftMpCreateReshape\") ! !     func_names(6) = string(\"cufftMpAttachReshapeComm\") ! !     func_names(7) = string(\"cufftMpGetReshapeSize\") ! !     func_names(8) = string(\"cufftMpMakeReshape\") ! !     func_names(9) = string(\"cufftMpExecReshapeAsync\") ! !     func_names(10) = string(\"cufftMpDestroyReshape\") ! ! #endif ! !     error_code = dynamic_load(LIB_NAME, func_names, libcufft, cufftFunctions) ! !     call destroy_strings(func_names) ! !     if ( error_code /= DTFFT_SUCCESS ) return ! !     call c_f_procpointer(cufftFunctions(1), cufftPlanMany) ! !     call c_f_procpointer(cufftFunctions(2), cufftXtExec) ! !     call c_f_procpointer(cufftFunctions(3), cufftDestroy) ! !     call c_f_procpointer(cufftFunctions(4), cufftSetStream) ! ! #ifdef DTFFT_WITH_NVSHMEM ! !     call c_f_procpointer(cufftFunctions(5), cufftMpCreateReshape) ! !     call c_f_procpointer(cufftFunctions(6), cufftMpAttachReshapeComm) ! !     call c_f_procpointer(cufftFunctions(7), cufftMpGetReshapeSize) ! !     call c_f_procpointer(cufftFunctions(8), cufftMpMakeReshape) ! !     call c_f_procpointer(cufftFunctions(9), cufftMpExecReshapeAsync) ! !     call c_f_procpointer(cufftFunctions(10), cufftMpDestroyReshape) ! !     error_code = load_nvshmem(libcufft) ! ! #endif ! !     is_loaded = .true. !   end function load_cufft function cufftGetErrorString ( error_code ) result ( string ) !! Returns a string representation of the cuFFT error code. integer ( c_int32_t ), intent ( in ) :: error_code !! cuFFT error code character ( len = :), allocatable :: string !! String representation of the cuFFT error code select case ( error_code ) case ( CUFFT_SUCCESS ) allocate ( string , source = \"CUFFT_SUCCESS\" ) case ( CUFFT_INVALID_PLAN ) allocate ( string , source = \"CUFFT_INVALID_PLAN\" ) case ( CUFFT_ALLOC_FAILED ) allocate ( string , source = \"CUFFT_ALLOC_FAILED\" ) case ( CUFFT_INVALID_TYPE ) allocate ( string , source = \"CUFFT_INVALID_TYPE\" ) case ( CUFFT_INVALID_VALUE ) allocate ( string , source = \"CUFFT_INVALID_VALUE\" ) case ( CUFFT_INTERNAL_ERROR ) allocate ( string , source = \"CUFFT_INTERNAL_ERROR\" ) case ( CUFFT_EXEC_FAILED ) allocate ( string , source = \"CUFFT_EXEC_FAILED\" ) case ( CUFFT_SETUP_FAILED ) allocate ( string , source = \"CUFFT_SETUP_FAILED\" ) case ( CUFFT_INVALID_SIZE ) allocate ( string , source = \"CUFFT_INVALID_SIZE\" ) case ( CUFFT_UNALIGNED_DATA ) allocate ( string , source = \"CUFFT_UNALIGNED_DATA\" ) case ( CUFFT_INCOMPLETE_PARAMETER_LIST ) allocate ( string , source = \"CUFFT_INCOMPLETE_PARAMETER_LIST\" ) case ( CUFFT_INVALID_DEVICE ) allocate ( string , source = \"CUFFT_INVALID_DEVICE\" ) case ( CUFFT_PARSE_ERROR ) allocate ( string , source = \"CUFFT_PARSE_ERROR\" ) case ( CUFFT_NO_WORKSPACE ) allocate ( string , source = \"CUFFT_NO_WORKSPACE\" ) case ( CUFFT_NOT_IMPLEMENTED ) allocate ( string , source = \"CUFFT_NOT_IMPLEMENTED\" ) case ( CUFFT_LICENSE_ERROR ) allocate ( string , source = \"CUFFT_LICENSE_ERROR\" ) case ( CUFFT_NOT_SUPPORTED ) allocate ( string , source = \"CUFFT_NOT_SUPPORTED\" ) case default allocate ( string , source = \"Unknown CUFFT error code\" ) end select end function cufftGetErrorString end module dtfft_interface_cufft","tags":"","loc":"sourcefile/dtfft_interface_cufft.f90.html"},{"title":"dtfft_transpose_plan_cuda.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_transpose_plan_cuda.f90~~EfferentGraph sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_transpose_plan_cuda.f90~~AfferentGraph sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" #include \"dtfft.f03\" module dtfft_transpose_plan_cuda !! This module describes [[transpose_plan_cuda]] class use iso_fortran_env use iso_c_binding use dtfft_abstract_backend , only : backend_helper use dtfft_abstract_transpose_plan , only : abstract_transpose_plan , create_pencils_and_comm , alloc_mem , free_mem use dtfft_config use dtfft_errors use dtfft_interface_cuda_runtime use dtfft_interface_cuda , only : load_cuda use dtfft_interface_nvrtc , only : load_nvrtc use dtfft_nvrtc_kernel , only : clean_unused_cache use dtfft_parameters use dtfft_pencil , only : pencil , pencil_init , get_local_sizes use dtfft_transpose_handle_cuda , only : transpose_handle_cuda use dtfft_utils #include \"dtfft_mpi.h\" #include \"dtfft_profile.h\" #include \"dtfft_cuda.h\" #include \"dtfft_private.h\" implicit none private public :: transpose_plan_cuda real ( real32 ), parameter :: MaxR4P = huge ( 1._real32 ) !! Maximum value of real32 type , extends ( abstract_transpose_plan ) :: transpose_plan_cuda !! CUDA Transpose Plan private type ( dtfft_stream_t ) :: stream !! CUDA stream type ( c_ptr ) :: aux !! Auxiliary memory real ( real32 ), pointer :: paux (:) !! Pointer to auxiliary memory logical :: is_aux_alloc !! Is auxiliary memory allocated type ( transpose_handle_cuda ), allocatable :: fplans (:) !! Forward transposition plans type ( transpose_handle_cuda ), allocatable :: bplans (:) !! Backward transposition plans contains procedure :: create_private => create_cuda !! Creates CUDA transpose plan procedure :: execute_private => execute_cuda !! Executes single transposition procedure :: destroy => destroy_cuda !! Destroys CUDA transpose plan procedure :: get_aux_size !! Returns auxiliary buffer size end type transpose_plan_cuda contains integer ( int32 ) function create_cuda ( self , dims , transposed_dims , base_comm , comm_dims , effort , base_dtype , base_storage , is_custom_cart_comm , cart_comm , comms , pencils , ipencil ) !! Creates CUDA transpose plan class ( transpose_plan_cuda ), intent ( inout ) :: self !! GPU transpose plan integer ( int32 ), intent ( in ) :: dims (:) !! Global sizes of the transform requested integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Transposed dimensions TYPE_MPI_COMM , intent ( in ) :: base_comm !! Base communicator integer ( int32 ), intent ( in ) :: comm_dims (:) !! Number of processors in each dimension type ( dtfft_effort_t ), intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element logical , intent ( in ) :: is_custom_cart_comm !! is custom Cartesian communicator provided by user TYPE_MPI_COMM , intent ( out ) :: cart_comm !! Cartesian communicator TYPE_MPI_COMM , intent ( out ) :: comms (:) !! Array of 1d communicators type ( pencil ), intent ( out ) :: pencils (:) !! Data distributing meta type ( pencil_init ), optional , intent ( in ) :: ipencil integer ( int8 ) :: n_transpose_plans integer ( int8 ) :: d , ndims !, b integer ( int32 ) :: comm_size , ierr ! integer(cuda_count_kind) :: free, total integer ( int32 ), allocatable :: best_decomposition (:) ! real(real32) :: execution_time logical :: pencils_created real ( real64 ) :: ts , te create_cuda = DTFFT_SUCCESS if ( . not . get_mpi_enabled () . and . . not . get_nccl_enabled () . and . . not . get_nvshmem_enabled () . and . effort == DTFFT_PATIENT ) then create_cuda = DTFFT_ERROR_GPU_BACKENDS_DISABLED return endif CHECK_CALL ( load_cuda (), create_cuda ) CHECK_CALL ( load_nvrtc (), create_cuda ) ndims = size ( dims , kind = int8 ) allocate ( best_decomposition ( ndims ) ) self % stream = get_user_stream () self % backend = get_user_gpu_backend () best_decomposition (:) = comm_dims (:) call MPI_Comm_size ( base_comm , comm_size , ierr ) if ( comm_size == 1 ) self % backend = BACKEND_NOT_SET pencils_created = . false . if ( ndims == 2 . or . is_custom_cart_comm . or . self % is_z_slab ) then pencils_created = . true . call create_pencils_and_comm ( transposed_dims , base_comm , comm_dims , cart_comm , comms , pencils , ipencil = ipencil ) endif ts = MPI_Wtime () if ( effort == DTFFT_PATIENT . and . comm_size > 1 ) then if ( pencils_created ) then call run_autotune_backend ( comms , cart_comm , pencils , base_storage , self % stream , self % is_z_slab , best_backend = self % backend ) else call autotune_grid_decomposition ( dims , transposed_dims , base_comm , base_storage , self % stream , best_decomposition , best_backend = self % backend ) endif else if ( ndims == 3 & . and . . not . is_custom_cart_comm & . and . . not . self % is_z_slab & . and . effort == DTFFT_MEASURE & . and . comm_size > 1 ) then call autotune_grid_decomposition ( dims , transposed_dims , base_comm , base_storage , self % stream , best_decomposition , backend = self % backend ) endif te = MPI_Wtime () if ( effort % val >= DTFFT_MEASURE % val . and . ndims > 2 . and . comm_size > 1 ) then WRITE_INFO ( repeat ( \"*\" , 50 )) if ( self % is_z_slab ) then WRITE_INFO ( \"Skipped search of MPI processor grid due to Z-slab optimization enabled\" ) else if ( is_custom_cart_comm ) then WRITE_INFO ( \"Skipped search of MPI processor grid due to custom grid provided\" ) else WRITE_INFO ( \"DTFFT_MEASURE: Selected MPI processor grid 1x\" // int_to_str ( best_decomposition ( 2 )) // \"x\" // int_to_str ( best_decomposition ( 3 ))) endif endif if ( effort == DTFFT_PATIENT . and . comm_size > 1 ) then WRITE_INFO ( \"DTFFT_PATIENT: Selected backend is \" // dtfft_get_backend_string ( self % backend )) endif if ( effort % val >= DTFFT_MEASURE % val . and . comm_size > 1 ) then WRITE_INFO ( \"Time spent on autotune: \" // double_to_str ( te - ts ) // \" [s]\" ) endif if ( . not . pencils_created ) then call create_pencils_and_comm ( transposed_dims , base_comm , best_decomposition , cart_comm , comms , pencils ) endif n_transpose_plans = ndims - 1_int8 ; if ( self % is_z_slab ) n_transpose_plans = n_transpose_plans + 1_int8 allocate ( self % fplans ( n_transpose_plans ), self % bplans ( n_transpose_plans ) ) call self % helper % create ( cart_comm , comms , is_backend_nccl ( self % backend ), pencils ) do d = 1_int8 , ndims - 1_int8 call self % fplans ( d )% create ( self % helper , pencils ( d ), pencils ( d + 1 ), base_storage , self % backend ) call self % bplans ( d )% create ( self % helper , pencils ( d + 1 ), pencils ( d ), base_storage , self % backend ) enddo if ( self % is_z_slab ) then call self % fplans ( 3 )% create ( self % helper , pencils ( 1 ), pencils ( 3 ), base_storage , self % backend ) call self % bplans ( 3 )% create ( self % helper , pencils ( 3 ), pencils ( 1 ), base_storage , self % backend ) endif self % is_aux_alloc = alloc_and_set_aux ( self % helper , self % backend , cart_comm , self % aux , self % paux , self % fplans , self % bplans ) call clean_unused_cache () deallocate ( best_decomposition ) create_cuda = DTFFT_SUCCESS end function create_cuda subroutine execute_cuda ( self , in , out , transpose_type ) !! Executes single transposition class ( transpose_plan_cuda ), intent ( inout ) :: self !! Transposition class real ( real32 ), intent ( inout ) :: in (:) !! Incoming buffer real ( real32 ), intent ( inout ) :: out (:) !! Resulting buffer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transpose to execute if ( transpose_type % val > 0 ) then call self % fplans ( transpose_type % val )% execute ( in , out , self % stream , self % paux ) else call self % bplans ( abs ( transpose_type % val ))% execute ( in , out , self % stream , self % paux ) endif end subroutine execute_cuda subroutine destroy_cuda ( self ) !! Destroys transposition plans class ( transpose_plan_cuda ), intent ( inout ) :: self !! Transposition class integer ( int8 ) :: i integer ( int32 ) :: ierr if ( self % is_aux_alloc ) then call self % mem_free ( self % aux , ierr ) self % paux => null () self % is_aux_alloc = . false . endif if ( allocated ( self % bplans ) ) then do i = 1 , size ( self % bplans , kind = int8 ) call self % fplans ( i )% destroy () call self % bplans ( i )% destroy () enddo deallocate ( self % fplans ) deallocate ( self % bplans ) endif call self % helper % destroy () end subroutine destroy_cuda subroutine autotune_grid_decomposition ( dims , transposed_dims , base_comm , base_storage , stream , best_decomposition , backend , min_execution_time , best_backend ) !! Runs through all possible grid decompositions and selects the best one based on the lowest average execution time integer ( int32 ), intent ( in ) :: dims (:) !! Global sizes of the transform requested integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Transposed dimensions TYPE_MPI_COMM , intent ( in ) :: base_comm !! 3D comm integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to use integer ( int32 ), intent ( out ) :: best_decomposition (:) !! Best decomposition found type ( dtfft_backend_t ), optional , intent ( in ) :: backend !! GPU Backend to test. Should be passed only when effort is `DTFFT_ESTIMATE` or `DTFFT_MEASURE` real ( real32 ), optional , intent ( out ) :: min_execution_time !! Elapsed time for best plan selected type ( dtfft_backend_t ), optional , intent ( out ) :: best_backend !! Best backend selected integer ( int8 ) :: ndims type ( dtfft_backend_t ) :: best_backend_ integer ( int32 ) :: comm_size , square_root , i , current_timer , k , ierr real ( real32 ) :: current_time , elapsed_time real ( real32 ), allocatable :: timers (:) integer ( int32 ), allocatable :: decomps (:,:) type ( dtfft_backend_t ), allocatable :: backends (:) call MPI_Comm_size ( base_comm , comm_size , ierr ) ndims = size ( dims , kind = int8 ) square_root = int ( sqrt ( real ( comm_size , real64 ))) + 1 allocate ( timers ( 2 * square_root )) allocate ( decomps ( 2 , 2 * square_root )) allocate ( backends ( 2 * square_root )) current_timer = 0 do i = 1 , square_root - 1 if ( mod ( comm_size , i ) /= 0 ) cycle call autotune_grid ( dims , transposed_dims , base_comm , [ 1 , i , comm_size / i ], base_storage , . false ., stream , backend = backend , best_time = current_time , best_backend = best_backend_ ) if ( current_time > 0.0 ) then current_timer = current_timer + 1 timers ( current_timer ) = current_time decomps ( 1 , current_timer ) = i decomps ( 2 , current_timer ) = comm_size / i backends ( current_timer ) = best_backend_ endif if ( i /= comm_size / i ) then call autotune_grid ( dims , transposed_dims , base_comm , [ 1 , comm_size / i , i ], base_storage , . false ., stream , backend = backend , best_time = current_time , best_backend = best_backend_ ) if ( current_time > 0.0 ) then current_timer = current_timer + 1 timers ( current_timer ) = current_time decomps ( 1 , current_timer ) = comm_size / i decomps ( 2 , current_timer ) = i backends ( current_timer ) = best_backend_ endif endif enddo elapsed_time = MaxR4P k = 1 do i = 1 , current_timer if ( timers ( i ) < elapsed_time ) then elapsed_time = timers ( i ) k = i endif enddo best_decomposition ( 1 ) = 1 best_decomposition ( 2 ) = decomps ( 1 , k ) best_decomposition ( 3 ) = decomps ( 2 , k ) if ( present ( best_backend ) ) best_backend = backends ( k ) if ( present ( min_execution_time ) ) min_execution_time = elapsed_time deallocate ( timers , decomps , backends ) end subroutine autotune_grid_decomposition subroutine autotune_grid ( dims , transposed_dims , base_comm , comm_dims , base_storage , is_z_slab , stream , backend , best_time , best_backend ) !! Creates cartesian grid and runs various backends on it. Can return best backend and execution time integer ( int32 ), intent ( in ) :: dims (:) !! Global sizes of the transform requested integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Transposed dimensions TYPE_MPI_COMM , intent ( in ) :: base_comm !! Basic communicator to create 3d grid from integer ( int32 ), intent ( in ) :: comm_dims (:) !! Number of processors in each dimension integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element logical , intent ( in ) :: is_z_slab !! Is Z-slab optimization enabled type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to use type ( dtfft_backend_t ), optional , intent ( in ) :: backend !! GPU Backend to test. Should be passed only when effort is `DTFFT_ESTIMATE` or `DTFFT_MEASURE` type ( dtfft_backend_t ), optional , intent ( out ) :: best_backend !! Best backend selected for the grid real ( real32 ), optional , intent ( out ) :: best_time !! Elapsed time for best plan selected type ( pencil ), allocatable :: pencils (:) character ( len = :), allocatable :: phase_name !! Caliper phase name integer ( int8 ) :: d , ndims TYPE_MPI_COMM , allocatable :: comms (:) TYPE_MPI_COMM :: cart_comm integer ( int32 ) :: mpi_ierr best_time = - 1.0 ndims = size ( dims , kind = int8 ) if ( ndims == 3 ) then if ( comm_dims ( 2 ) > dims ( 2 ) . or . comm_dims ( 3 ) > dims ( 3 ) ) return allocate ( phase_name , source = \"Testing grid 1x\" // int_to_str ( comm_dims ( 2 )) // \"x\" // int_to_str ( comm_dims ( 3 )) ) else allocate ( phase_name , source = \"Testing grid 1x\" // int_to_str ( comm_dims ( 2 )) ) endif WRITE_INFO ( \"\" ) WRITE_INFO ( phase_name ) PHASE_BEGIN ( phase_name , COLOR_AUTOTUNE ) allocate ( comms ( ndims ), pencils ( ndims ) ) call create_pencils_and_comm ( transposed_dims , base_comm , comm_dims , cart_comm , comms , pencils ) ! elapsed_time = autotune_backend_id(comms, cart_comm, pencils, base_storage, backend, stream) call run_autotune_backend ( comms , cart_comm , pencils , base_storage , stream , is_z_slab , backend = backend , best_time = best_time , best_backend = best_backend ) do d = 1 , ndims call pencils ( d )% destroy () call MPI_Comm_free ( comms ( d ), mpi_ierr ) enddo call MPI_Comm_free ( cart_comm , mpi_ierr ) deallocate ( comms , pencils ) PHASE_END ( phase_name ) end subroutine autotune_grid subroutine run_autotune_backend ( comms , cart_comm , pencils , base_storage , stream , is_z_slab , backend , best_time , best_backend ) !! Runs autotune for all backends TYPE_MPI_COMM , intent ( in ) :: comms (:) !! 1D comms TYPE_MPI_COMM , intent ( in ) :: cart_comm !! 3D Cartesian comm type ( pencil ), intent ( in ) :: pencils (:) !! Source meta integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to use logical , intent ( in ) :: is_z_slab !! Is Z-slab optimization enabled type ( dtfft_backend_t ), optional , intent ( in ) :: backend !! GPU Backend to test. Should be passed only when effort is `DTFFT_ESTIMATE` or `DTFFT_MEASURE` real ( real32 ), optional , intent ( out ) :: best_time !! Elapsed time for best backend type ( dtfft_backend_t ), optional , intent ( out ) :: best_backend !! Best backend selected type ( dtfft_backend_t ), allocatable :: backends_to_run (:) type ( dtfft_backend_t ) :: current_backend_id , best_backend_ logical :: is_udb !! Used defined backend real ( real32 ) :: execution_time , min_execution_time , max_execution_time , avg_execution_time , best_time_ , total_time integer ( int32 ) :: iter , comm_size , mpi_ierr , b , ierr type ( transpose_handle_cuda ), allocatable :: plans (:) integer ( int8 ) :: i , n_transpose_plans type ( c_ptr ) :: in , out , aux real ( real32 ), pointer :: pin (:), pout (:), paux (:) logical :: is_aux_alloc ! , need_aux integer ( int64 ) :: alloc_size type ( cudaEvent ) :: timer_start , timer_stop character ( len = :), allocatable :: testing_phase type ( backend_helper ) :: helper integer ( int32 ) :: n_warmup_iters , n_iters integer ( int64 ) :: min_buffer_size ! integer(int64)                                :: scaler         !! Scaling data amount to float size ! integer(cuda_count_kind) :: free, total if ( present ( backend ) ) then allocate ( backends_to_run ( 1 ) ) backends_to_run ( 1 ) = backend is_udb = . true . else allocate ( backends_to_run ( size ( VALID_GPU_BACKENDS ( 2 :)))) do b = 1 , size ( VALID_GPU_BACKENDS ( 2 :)) backends_to_run ( b ) = VALID_GPU_BACKENDS ( b + 1 ) enddo is_udb = . false . endif best_backend_ = backends_to_run ( 1 ) if ( is_z_slab ) then n_transpose_plans = 1 else n_transpose_plans = size ( pencils , kind = int8 ) - 1_int8 endif allocate ( plans ( 2 * n_transpose_plans ) ) call get_local_sizes ( pencils , alloc_size = alloc_size ) alloc_size = alloc_size * base_storage min_buffer_size = alloc_size / FLOAT_STORAGE_SIZE CUDA_CALL ( \"cudaEventCreate\" , cudaEventCreate ( timer_start ) ) CUDA_CALL ( \"cudaEventCreate\" , cudaEventCreate ( timer_stop ) ) call MPI_Comm_size ( cart_comm , comm_size , mpi_ierr ) call helper % create ( cart_comm , comms , any ( is_backend_nccl ( backends_to_run )), pencils ) n_warmup_iters = get_iters_from_env (. true .) n_iters = get_iters_from_env (. false .) best_time_ = MaxR4P do b = 1 , size ( backends_to_run ) current_backend_id = backends_to_run ( b ) if ( ( is_backend_pipelined ( current_backend_id ) . and . . not . get_pipelined_enabled () & . or . is_backend_mpi ( current_backend_id ) . and . . not . get_mpi_enabled () & . or . is_backend_nvshmem ( current_backend_id ) . and . . not . get_nvshmem_enabled ()) & . and . . not . is_udb ) cycle if ( is_z_slab ) then call plans ( 1 )% create ( helper , pencils ( 1 ), pencils ( 3 ), base_storage , current_backend_id ) call plans ( 2 )% create ( helper , pencils ( 3 ), pencils ( 1 ), base_storage , current_backend_id ) else do i = 1 , n_transpose_plans call plans ( i )% create ( helper , pencils ( i ), pencils ( i + 1 ), base_storage , current_backend_id ) call plans ( i + n_transpose_plans )% create ( helper , pencils ( i + 1 ), pencils ( i ), base_storage , current_backend_id ) enddo endif call alloc_mem ( helper , current_backend_id , cart_comm , alloc_size , in , ierr ); DTFFT_CHECK ( ierr ) call alloc_mem ( helper , current_backend_id , cart_comm , alloc_size , out , ierr ); DTFFT_CHECK ( ierr ) call c_f_pointer ( in , pin , [ min_buffer_size ]) call c_f_pointer ( out , pout , [ min_buffer_size ]) is_aux_alloc = alloc_and_set_aux ( helper , current_backend_id , cart_comm , aux , paux , plans ) testing_phase = \"Testing backend \" // dtfft_get_backend_string ( current_backend_id ) PHASE_BEGIN ( testing_phase , COLOR_AUTOTUNE ) WRITE_INFO ( testing_phase ) PHASE_BEGIN ( \"Warmup, \" // int_to_str ( n_warmup_iters ) // \" iterations\" , COLOR_TRANSPOSE ) do iter = 1 , n_warmup_iters do i = 1 , 2_int8 * n_transpose_plans call plans ( i )% execute ( pin , pout , stream , paux ) enddo enddo CUDA_CALL ( \"cudaStreamSynchronize\" , cudaStreamSynchronize ( stream ) ) PHASE_END ( \"Warmup, \" // int_to_str ( n_warmup_iters ) // \" iterations\" ) call MPI_Barrier ( cart_comm , mpi_ierr ) PHASE_BEGIN ( \"Testing, \" // int_to_str ( n_iters ) // \" iterations\" , COLOR_EXECUTE ) total_time = 0.0 CUDA_CALL ( \"cudaEventRecord\" , cudaEventRecord ( timer_start , stream ) ) do iter = 1 , n_iters do i = 1 , 2_int8 * n_transpose_plans call plans ( i )% execute ( pin , pout , stream , paux ) enddo enddo CUDA_CALL ( \"cudaEventRecord\" , cudaEventRecord ( timer_stop , stream ) ) CUDA_CALL ( \"cudaEventSynchronize\" , cudaEventSynchronize ( timer_stop ) ) CUDA_CALL ( \"cudaEventElapsedTime\" , cudaEventElapsedTime ( execution_time , timer_start , timer_stop ) ) execution_time = execution_time / real ( n_iters , real32 ) total_time = total_time + execution_time PHASE_END ( \"Testing, \" // int_to_str ( n_iters ) // \" iterations\" ) call MPI_Allreduce ( total_time , min_execution_time , 1 , MPI_REAL4 , MPI_MIN , cart_comm , mpi_ierr ) call MPI_Allreduce ( total_time , max_execution_time , 1 , MPI_REAL4 , MPI_MAX , cart_comm , mpi_ierr ) call MPI_Allreduce ( total_time , avg_execution_time , 1 , MPI_REAL4 , MPI_SUM , cart_comm , mpi_ierr ) avg_execution_time = avg_execution_time / real ( comm_size , real32 ) WRITE_INFO ( \"  max: \" // double_to_str ( real ( max_execution_time , real64 )) // \" [ms]\" ) WRITE_INFO ( \"  min: \" // double_to_str ( real ( min_execution_time , real64 )) // \" [ms]\" ) WRITE_INFO ( \"  avg: \" // double_to_str ( real ( avg_execution_time , real64 )) // \" [ms]\" ) if ( avg_execution_time < best_time_ ) then best_time_ = avg_execution_time best_backend_ = current_backend_id endif call free_mem ( helper , current_backend_id , in , ierr ) call free_mem ( helper , current_backend_id , out , ierr ) if ( is_aux_alloc ) call free_mem ( helper , current_backend_id , aux , ierr ) do i = 1 , 2_int8 * n_transpose_plans call plans ( i )% destroy () enddo PHASE_END ( \"Testing backend \" // dtfft_get_backend_string ( current_backend_id )) enddo deallocate ( plans ) CUDA_CALL ( \"cudaEventDestroy\" , cudaEventDestroy ( timer_start ) ) CUDA_CALL ( \"cudaEventDestroy\" , cudaEventDestroy ( timer_stop ) ) call helper % destroy () if ( present ( best_time )) best_time = best_time_ if ( present ( best_backend ) ) best_backend = best_backend_ end subroutine run_autotune_backend function get_aux_size ( self ) result ( aux_size ) class ( transpose_plan_cuda ), intent ( in ) :: self !! Transposition class integer ( int64 ) :: aux_size integer ( int8 ) :: n_transpose_plans , i , n_fplans , n_bplans integer ( int64 ), allocatable :: worksizes (:) n_fplans = size ( self % fplans , kind = int8 ) n_bplans = size ( self % bplans , kind = int8 ) n_transpose_plans = n_fplans + n_bplans allocate ( worksizes ( n_transpose_plans ) ) do i = 1 , n_fplans worksizes ( i ) = self % fplans ( i )% get_aux_size () enddo do i = 1 , n_bplans worksizes ( i + n_fplans ) = self % bplans ( i )% get_aux_size () enddo aux_size = maxval ( worksizes ) deallocate ( worksizes ) end function get_aux_size function alloc_and_set_aux ( helper , backend , cart_comm , aux , paux , plans , bplans ) result ( is_aux_alloc ) !! Allocates auxiliary memory according to the backend and sets it to the plans type ( backend_helper ), intent ( inout ) :: helper !! Backend helper type ( dtfft_backend_t ), intent ( in ) :: backend !! GPU backend TYPE_MPI_COMM , intent ( in ) :: cart_comm !! Cartesian communicator type ( c_ptr ), intent ( inout ) :: aux !! Allocatable auxiliary memory real ( real32 ), pointer , intent ( inout ) :: paux (:) !! Pointer to auxiliary memory type ( transpose_handle_cuda ), intent ( inout ) :: plans (:) !! Plans type ( transpose_handle_cuda ), intent ( inout ), optional :: bplans (:) !! Backward plans logical :: is_aux_alloc !! Is auxiliary memory allocated integer ( int64 ), allocatable :: worksizes (:) integer ( int64 ) :: max_work_size_local , max_work_size_global integer ( int32 ) :: mpi_ierr , n_transpose_plans , i , n_fplans , n_bplans integer ( int32 ) :: alloc_ierr n_fplans = size ( plans ) n_bplans = 0 ; if ( present ( bplans ) ) n_bplans = size ( bplans ) n_transpose_plans = n_fplans + n_bplans allocate ( worksizes ( n_transpose_plans ) ) do i = 1 , n_fplans worksizes ( i ) = plans ( i )% get_aux_size () enddo do i = 1 , n_bplans worksizes ( i + n_fplans ) = bplans ( i )% get_aux_size () enddo max_work_size_local = maxval ( worksizes ) call MPI_Allreduce ( max_work_size_local , max_work_size_global , 1 , MPI_INTEGER8 , MPI_MAX , cart_comm , mpi_ierr ) is_aux_alloc = . false . if ( max_work_size_global > 0 ) then call alloc_mem ( helper , backend , cart_comm , max_work_size_global , aux , alloc_ierr ) DTFFT_CHECK ( alloc_ierr ) call c_f_pointer ( aux , paux , [ max_work_size_global / 4_int64 ]) is_aux_alloc = . true . endif deallocate ( worksizes ) end function alloc_and_set_aux end module dtfft_transpose_plan_cuda","tags":"","loc":"sourcefile/dtfft_transpose_plan_cuda.f90.html"},{"title":"dtfft_interface_cuda_runtime.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_cuda_runtime.f90~~EfferentGraph sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_cuda_runtime.f90~~AfferentGraph sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_cuda_runtime !! CUDA Runtime Interfaces use iso_c_binding use dtfft_parameters , only : dtfft_stream_t use dtfft_utils implicit none private public :: cudaGetErrorString public :: dim3 type , bind ( C ) :: dim3 !! Dimension specification type integer ( c_int ) :: x , y , z end type public :: cudaSuccess , cudaErrorNotReady enum , bind ( c ) enumerator :: cudaSuccess = 0 enumerator :: cudaErrorInvalidValue = 1 enumerator :: cudaErrorMemoryAllocation = 2 enumerator :: cudaErrorInitializationError = 3 enumerator :: cudaErrorCudartUnloading = 4 enumerator :: cudaErrorProfilerDisabled = 5 enumerator :: cudaErrorProfilerNotInitialized = 6 enumerator :: cudaErrorProfilerAlreadyStarted = 7 enumerator :: cudaErrorProfilerAlreadyStopped = 8 enumerator :: cudaErrorInvalidConfiguration = 9 enumerator :: cudaErrorInvalidPitchValue = 12 enumerator :: cudaErrorInvalidSymbol = 13 enumerator :: cudaErrorInvalidHostPointer = 16 enumerator :: cudaErrorInvalidDevicePointer = 17 enumerator :: cudaErrorInvalidTexture = 18 enumerator :: cudaErrorInvalidTextureBinding = 19 enumerator :: cudaErrorInvalidChannelDescriptor = 20 enumerator :: cudaErrorInvalidMemcpyDirection = 21 enumerator :: cudaErrorAddressOfConstant = 22 enumerator :: cudaErrorTextureFetchFailed = 23 enumerator :: cudaErrorTextureNotBound = 24 enumerator :: cudaErrorSynchronizationError = 25 enumerator :: cudaErrorInvalidFilterSetting = 26 enumerator :: cudaErrorInvalidNormSetting = 27 enumerator :: cudaErrorMixedDeviceExecution = 28 enumerator :: cudaErrorNotYetImplemented = 31 enumerator :: cudaErrorMemoryValueTooLarge = 32 enumerator :: cudaErrorInsufficientDriver = 35 enumerator :: cudaErrorInvalidSurface = 37 enumerator :: cudaErrorDuplicateVariableName = 43 enumerator :: cudaErrorDuplicateTextureName = 44 enumerator :: cudaErrorDuplicateSurfaceName = 45 enumerator :: cudaErrorDevicesUnavailable = 46 enumerator :: cudaErrorIncompatibleDriverContext = 49 enumerator :: cudaErrorMissingConfiguration = 52 enumerator :: cudaErrorPriorLaunchFailure = 53 enumerator :: cudaErrorLaunchMaxDepthExceeded = 65 enumerator :: cudaErrorLaunchFileScopedTex = 66 enumerator :: cudaErrorLaunchFileScopedSurf = 67 enumerator :: cudaErrorSyncDepthExceeded = 68 enumerator :: cudaErrorLaunchPendingCountExceeded = 69 enumerator :: cudaErrorInvalidDeviceFunction = 98 enumerator :: cudaErrorNoDevice = 100 enumerator :: cudaErrorInvalidDevice = 101 enumerator :: cudaErrorStartupFailure = 127 enumerator :: cudaErrorInvalidKernelImage = 200 enumerator :: cudaErrorDeviceUninitialized = 201 enumerator :: cudaErrorMapBufferObjectFailed = 205 enumerator :: cudaErrorUnmapBufferObjectFailed = 206 enumerator :: cudaErrorArrayIsMapped = 207 enumerator :: cudaErrorAlreadyMapped = 208 enumerator :: cudaErrorNoKernelImageForDevice = 209 enumerator :: cudaErrorAlreadyAcquired = 210 enumerator :: cudaErrorNotMapped = 211 enumerator :: cudaErrorNotMappedAsArray = 212 enumerator :: cudaErrorNotMappedAsPointer = 213 enumerator :: cudaErrorECCUncorrectable = 214 enumerator :: cudaErrorUnsupportedLimit = 215 enumerator :: cudaErrorDeviceAlreadyInUse = 216 enumerator :: cudaErrorPeerAccessUnsupported = 217 enumerator :: cudaErrorInvalidPtx = 218 enumerator :: cudaErrorInvalidGraphicsContext = 219 enumerator :: cudaErrorNvlinkUncorrectable = 220 enumerator :: cudaErrorJitCompilerNotFound = 221 enumerator :: cudaErrorInvalidSource = 300 enumerator :: cudaErrorFileNotFound = 301 enumerator :: cudaErrorSharedObjectSymbolNotFound = 302 enumerator :: cudaErrorSharedObjectInitFailed = 303 enumerator :: cudaErrorOperatingSystem = 304 enumerator :: cudaErrorInvalidResourceHandle = 400 enumerator :: cudaErrorIllegalState = 401 enumerator :: cudaErrorSymbolNotFound = 500 enumerator :: cudaErrorNotReady = 600 enumerator :: cudaErrorIllegalAddress = 700 enumerator :: cudaErrorLaunchOutOfResources = 701 enumerator :: cudaErrorLaunchTimeout = 702 enumerator :: cudaErrorLaunchIncompatibleTexturing = 703 enumerator :: cudaErrorPeerAccessAlreadyEnabled = 704 enumerator :: cudaErrorPeerAccessNotEnabled = 705 enumerator :: cudaErrorSetOnActiveProcess = 708 enumerator :: cudaErrorContextIsDestroyed = 709 enumerator :: cudaErrorAssert = 710 enumerator :: cudaErrorTooManyPeers = 711 enumerator :: cudaErrorHostMemoryAlreadyRegistered = 712 enumerator :: cudaErrorHostMemoryNotRegistered = 713 enumerator :: cudaErrorHardwareStackError = 714 enumerator :: cudaErrorIllegalInstruction = 715 enumerator :: cudaErrorMisalignedAddress = 716 enumerator :: cudaErrorInvalidAddressSpace = 717 enumerator :: cudaErrorInvalidPc = 718 enumerator :: cudaErrorLaunchFailure = 719 enumerator :: cudaErrorCooperativeLaunchTooLarge = 720 enumerator :: cudaErrorNotPermitted = 800 enumerator :: cudaErrorNotSupported = 801 enumerator :: cudaErrorSystemNotReady = 802 enumerator :: cudaErrorSystemDriverMismatch = 803 enumerator :: cudaErrorCompatNotSupportedOnDevice = 804 enumerator :: cudaErrorStreamCaptureUnsupported = 900 enumerator :: cudaErrorStreamCaptureInvalidated = 901 enumerator :: cudaErrorStreamCaptureMerge = 902 enumerator :: cudaErrorStreamCaptureUnmatched = 903 enumerator :: cudaErrorStreamCaptureUnjoined = 904 enumerator :: cudaErrorStreamCaptureIsolation = 905 enumerator :: cudaErrorStreamCaptureImplicit = 906 enumerator :: cudaErrorCapturedEvent = 907 enumerator :: cudaErrorStreamCaptureWrongThread = 908 enumerator :: cudaErrorTimeout = 909 enumerator :: cudaErrorGraphExecUpdateFailure = 910 enumerator :: cudaErrorUnknown = 999 enumerator :: cudaErrorApiFailureBase = 10000 end enum public :: cudaMemcpyHostToHost , & cudaMemcpyHostToDevice , & cudaMemcpyDeviceToHost , & cudaMemcpyDeviceToDevice , & cudaMemcpyDefault enum , bind ( C ) enumerator :: cudaMemcpyHostToHost = 0 enumerator :: cudaMemcpyHostToDevice = 1 enumerator :: cudaMemcpyDeviceToHost = 2 enumerator :: cudaMemcpyDeviceToDevice = 3 enumerator :: cudaMemcpyDefault = 4 end enum public :: cudaEvent type , bind ( C ) :: cudaEvent !! CUDA event types type ( c_ptr ) :: event !! Handle end type cudaEvent integer ( c_int ), parameter , public :: cudaEventDisableTiming = 2 public :: cudaStreamQuery interface !! Queries an asynchronous stream for completion status. function cudaStreamQuery ( stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamQuery\" ) import type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if all operations in stream have completed, !! or `cudaErrorNotReady` if not. end function cudaStreamQuery endinterface public :: cudaStreamCreate interface !! Creates an asynchronous stream. function cudaStreamCreate ( stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamCreate\" ) import type ( dtfft_stream_t ) :: stream !! Pointer to the created stream integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the stream was created successfully, !! or an error code if there was an issue. end function cudaStreamCreate end interface public :: cudaStreamDestroy interface !! Destroys an asynchronous stream. function cudaStreamDestroy ( stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamDestroy\" ) import type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the stream was destroyed successfully, !! or an error code if there was an issue. end function cudaStreamDestroy end interface public :: cudaStreamSynchronize interface !! Waits for stream tasks to complete. function cudaStreamSynchronize ( stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamSynchronize\" ) import type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the stream tasks completed successfully, !! or an error code if there was an issue. end function cudaStreamSynchronize end interface interface !! Returns the string representation of an error code. function cudaGetErrorString_c ( errcode ) & result ( string ) & bind ( C , name = \"cudaGetErrorString\" ) import integer ( c_int ), value :: errcode !! Error code type ( c_ptr ) :: string !! Pointer to the error string end function cudaGetErrorString_c end interface public :: cudaMalloc interface !! Allocates memory on the device. function cudaMalloc ( ptr , count ) & result ( cudaError_t ) & bind ( C , name = \"cudaMalloc\" ) import type ( c_ptr ) :: ptr !! Pointer to allocated device memory integer ( c_size_t ), value :: count !! Requested allocation size in bytes integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if memory was allocated successfully, !! or `cudaErrorMemoryAllocation` if the memory could not be allocated. end function cudaMalloc end interface public :: cudaFree interface !! Frees memory on the device. function cudaFree ( ptr ) & result ( cudaError_t ) & bind ( C , name = \"cudaFree\" ) import type ( c_ptr ), value :: ptr !! Pointer to memory to free integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if memory was freed successfully, !! or an error code if there was an issue. end function cudaFree end interface public :: cudaMemset interface !! Initializes or sets device memory to a value. function cudaMemset ( ptr , val , count ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemset\" ) import type ( c_ptr ), value :: ptr !! Pointer to device memory integer ( c_int ), value :: val !! Value to set integer ( c_size_t ), value :: count !! Size in bytes to set integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the memory was set successfully, !! or an error code if there was an issue. end function cudaMemset end interface public :: cudaEventCreateWithFlags interface !! Creates an event with the specified flags. function cudaEventCreateWithFlags ( event , flags ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventCreateWithFlags\" ) import type ( cudaEvent ) :: event !! Event identifier integer ( c_int ), value :: flags !! Flags for event creation integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event was created successfully, !! or an error code if there was an issue. end function cudaEventCreateWithFlags end interface public :: cudaEventRecord interface !! Records an event in a stream. function cudaEventRecord ( event , stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventRecord\" ) import type ( cudaEvent ), value :: event !! Event identifier type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event was recorded successfully, !! or an error code if there was an issue. end function cudaEventRecord end interface public :: cudaStreamWaitEvent interface !! Makes a stream wait on an event. function cudaStreamWaitEvent ( stream , event , flags ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamWaitEvent\" ) import type ( dtfft_stream_t ), value :: stream !! Stream identifier type ( cudaEvent ), value :: event !! Event identifier integer ( c_int ), value :: flags !! Flags for the wait operation integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the stream is waiting successfully, !! or an error code if there was an issue. end function cudaStreamWaitEvent end interface public :: cudaEventDestroy interface !! Destroys an event. function cudaEventDestroy ( event ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventDestroy\" ) import type ( cudaEvent ), value :: event !! Event identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event was destroyed successfully, !! or an error code if there was an issue. end function cudaEventDestroy end interface public :: cudaEventCreate interface !! Creates an event. function cudaEventCreate ( event ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventCreate\" ) import type ( cudaEvent ) :: event !! Event identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event was created successfully, !! or an error code if there was an issue. end function cudaEventCreate end interface public :: cudaEventSynchronize interface !! Waits for an event to complete. function cudaEventSynchronize ( event ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventSynchronize\" ) import type ( cudaEvent ), value :: event !! Event identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event completed successfully, !! or an error code if there was an issue. end function cudaEventSynchronize end interface public :: cudaEventElapsedTime interface !! Computes the elapsed time between two events. function cudaEventElapsedTime ( time , start , end ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventElapsedTime\" ) import real ( c_float ) :: time !! Elapsed time in milliseconds type ( cudaEvent ), value :: start !! Starting event type ( cudaEvent ), value :: end !! Ending event integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the elapsed time was computed successfully, !! or an error code if there was an issue. end function cudaEventElapsedTime end interface public :: cudaMemcpyAsync interface cudaMemcpyAsync !! Copies data asynchronously between host and device. function cudaMemcpyAsync_ptr ( dst , src , count , kdir , stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpyAsync\" ) import type ( c_ptr ), value :: dst !! Destination pointer type ( c_ptr ), value :: src !! Source pointer integer ( c_size_t ), value :: count !! Size in bytes to copy integer ( c_int ), value :: kdir !! Direction of copy (host-to-device, device-to-host, etc.) type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was initiated successfully, !! or an error code if there was an issue. end function cudaMemcpyAsync_ptr function cudaMemcpyAsync_r32 ( dst , src , count , kdir , stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpyAsync\" ) import real ( c_float ) :: dst !! Destination array (32-bit float) real ( c_float ) :: src !! Source array (32-bit float) integer ( c_size_t ), value :: count !! Number of elements to copy integer ( c_int ), value :: kdir !! Direction of copy type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was initiated successfully, !! or an error code if there was an issue. end function cudaMemcpyAsync_r32 end interface public :: cudaMemcpy interface cudaMemcpy !! Copies data synchronously between host and device. function cudaMemcpy_ptr ( dst , src , count , kdir ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpy\" ) import type ( c_ptr ), value :: dst !! Destination pointer type ( c_ptr ), value :: src !! Source pointer integer ( c_size_t ), value :: count !! Size in bytes to copy integer ( c_int ), value :: kdir !! Direction of copy integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was completed successfully, !! or an error code if there was an issue. end function cudaMemcpy_ptr function cudaMemcpy_r64 ( dst , src , count , kdir ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpy\" ) import real ( c_double ) :: dst ( * ) !! Destination array (64-bit float) real ( c_double ) :: src ( * ) !! Source array (64-bit float) integer ( c_size_t ), value :: count !! Number of bytes to copy integer ( c_int ), value :: kdir !! Direction of copy integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was completed successfully, !! or an error code if there was an issue. end function cudaMemcpy_r64 function cudaMemcpy_r32 ( dst , src , count , kdir ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpy\" ) import real ( c_float ) :: dst ( * ) !! Destination array (32-bit float) real ( c_float ) :: src ( * ) !! Source array (32-bit float) integer ( c_size_t ), value :: count !! Number of bytes to copy integer ( c_int ), value :: kdir !! Direction of copy integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was completed successfully, !! or an error code if there was an issue. end function cudaMemcpy_r32 end interface public :: cudaGetDevice interface !! Returns the current device. function cudaGetDevice ( num ) & result ( cudaError_t ) & bind ( C , name = \"cudaGetDevice\" ) import integer ( c_int ) :: num !! Device number integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the device was retrieved successfully, !! or an error code if there was an issue. end function cudaGetDevice end interface public :: cudaGetDeviceCount interface !! Returns the number of available devices. function cudaGetDeviceCount ( num ) & result ( cudaError_t ) & bind ( C , name = \"cudaGetDeviceCount\" ) import integer ( c_int ) :: num !! Number of devices integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the device count was retrieved successfully, !! or an error code if there was an issue. end function cudaGetDeviceCount end interface public :: cudaSetDevice interface !! Sets the current device. function cudaSetDevice ( num ) & result ( cudaError_t ) & bind ( C , name = \"cudaSetDevice\" ) import integer ( c_int ), value :: num !! Device number integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the device was set successfully, !! or an error code if there was an issue. end function cudaSetDevice end interface public :: get_cuda_architecture interface !! Returns the CUDA architecture for a given device. subroutine get_cuda_architecture ( device , major , minor ) & bind ( C , name = \"get_cuda_architecture\" ) import integer ( c_int ), value :: device !! Device number integer ( c_int ) :: major !! Major compute capability integer ( c_int ) :: minor !! Minor compute capability end subroutine get_cuda_architecture end interface public :: cudaMemGetInfo interface !! Returns the amount of free and total memory on the device. function cudaMemGetInfo ( free , total ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemGetInfo\" ) import integer ( c_size_t ) :: free !! Free memory in bytes integer ( c_size_t ) :: total !! Total memory in bytes integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the memory information was retrieved successfully, !! or an error code if there was an issue. end function cudaMemGetInfo end interface public :: cudaDeviceSynchronize interface !! Synchronizes the device, blocking until all preceding tasks in all streams have completed. function cudaDeviceSynchronize () & result ( cudaError_t ) & bind ( C , name = \"cudaDeviceSynchronize\" ) import integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the device was set successfully, !! or an error code if there was an issue. end function cudaDeviceSynchronize end interface contains function cudaGetErrorString ( errcode ) result ( string ) !! Helper function that returns a string describing the given nvrtcResult code !! If the error code is not recognized, \"unrecognized error code\" is returned. integer ( c_int ), intent ( in ) :: errcode !! CUDA Runtime Compilation API result code. character ( len = :), allocatable :: string !! Result string call string_c2f ( cudaGetErrorString_c ( errcode ), string ) end function cudaGetErrorString end module dtfft_interface_cuda_runtime","tags":"","loc":"sourcefile/dtfft_interface_cuda_runtime.f90.html"},{"title":"dtfft_interface_nvshmem.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_nvshmem.f90~~EfferentGraph sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_nvshmem.f90~~AfferentGraph sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_nvshmem !! NVSHMEM Interfaces use iso_c_binding use iso_fortran_env use dtfft_parameters use dtfft_utils implicit none private public :: nvshmem_team_t public :: is_nvshmem_ptr ! public :: load_nvshmem type , bind ( C ) :: nvshmem_team_t !! NVSHMEM team. integer ( c_int32_t ) :: val !! Internal representation of the NVSHMEM team. end type nvshmem_team_t type ( nvshmem_team_t ), parameter , public :: NVSHMEM_TEAM_WORLD = nvshmem_team_t ( 0 ) public :: nvshmem_malloc public :: nvshmem_free public :: nvshmemx_sync_all_on_stream public :: nvshmemx_float_alltoall_on_stream public :: nvshmem_ptr public :: nvshmem_my_pe public :: nvshmemx_init_status interface function nvshmem_malloc ( size ) result ( ptr ) bind ( C ) !! Allocates symmetric memory in the NVSHMEM heap. import type ( c_ptr ) :: ptr !! Pointer to the allocated memory. integer ( c_size_t ), value :: size !! Size of the allocation in bytes. end function nvshmem_malloc subroutine nvshmem_free ( ptr ) bind ( C ) !! Frees symmetric memory allocated by nvshmem_malloc. import type ( c_ptr ), value :: ptr !! Pointer to the memory to free. end subroutine nvshmem_free subroutine nvshmemx_sync_all_on_stream ( stream ) bind ( C ) !! Synchronizes all PEs (Processing Elements) on the specified stream. import type ( dtfft_stream_t ), intent ( in ), value :: stream !! CUDA stream for synchronization. end subroutine nvshmemx_sync_all_on_stream function nvshmemx_float_alltoall_on_stream ( team , dest , source , nelems , stream ) result ( ierr ) bind ( C ) !! Performs an all-to-all exchange of floating-point data on the specified stream. import integer ( c_int ) :: ierr !! Completion status. type ( nvshmem_team_t ), intent ( in ), value :: team !! NVSHMEM team. type ( c_ptr ), value :: dest !! Destination buffer. type ( c_ptr ), value :: source !! Source buffer. integer ( c_size_t ), intent ( in ), value :: nelems !! Number of elements to exchange. type ( dtfft_stream_t ), intent ( in ), value :: stream !! CUDA stream for the operation. end function nvshmemx_float_alltoall_on_stream function nvshmem_ptr ( ptr , pe ) result ( pe_ptr ) bind ( C ) !! Returns a pointer to a symmetric memory location on a specified PE. import type ( c_ptr ) :: pe_ptr !! Pointer to the symmetric memory on the specified PE. type ( c_ptr ), value :: ptr !! Local pointer to the symmetric memory. integer ( c_int ), value :: pe !! PE (Processing Element) number. end function nvshmem_ptr function nvshmem_my_pe () result ( pe ) bind ( C ) !! Returns the PE (Processing Element) number of the calling thread. import integer ( c_int ) :: pe !! PE number of the calling thread. end function nvshmem_my_pe function nvshmemx_init_status () result ( status ) bind ( C ) import integer ( c_int ) :: status !! Completion status. end function nvshmemx_init_status end interface ! logical, save :: is_loaded = .false. !   !! Flag indicating whether the library is loaded ! type(c_ptr), save :: libnvshmem !   !! Handle to the loaded library ! type(c_funptr), save :: nvshmemFunctions(7) !   !! Array of pointers to the NVSHMEM functions ! procedure(nvshmem_malloc_interface),              pointer, public :: nvshmem_malloc !   !! Fortran pointer to the nvshmem_malloc function ! procedure(nvshmem_free_interface),                pointer, public :: nvshmem_free !   !! Fortran pointer to the nvshmem_free function ! procedure(nvshmemx_sync_all_on_stream_interface), pointer, public :: nvshmemx_sync_all_on_stream !   !! Fortran pointer to the nvshmemx_sync_all_on_stream function ! procedure(nvshmemx_float_alltoall_on_stream_interface), pointer, public :: nvshmemx_float_alltoall_on_stream !   !! Fortran pointer to the nvshmemx_float_alltoall_on_stream function ! procedure(nvshmem_ptr_interface),                 pointer, public :: nvshmem_ptr !   !! Fortran pointer to the nvshmem_ptr function ! procedure(nvshmem_my_pe_interface),               pointer, public :: nvshmem_my_pe !   !! Fortran pointer to the nvshmem_my_pe function ! procedure(nvshmemx_init_status_interface),                pointer,  public  :: nvshmemx_init_status contains ! function load_nvshmem(cufftmp_handle) result(error_code) ! !! Loads the NVSHMEM library and needed symbols !   type(c_ptr),  intent(in)  :: cufftmp_handle !   integer(int32)  :: error_code !! Error code !   type(string), allocatable :: func_names(:) !   integer(int32) :: i !   error_code = DTFFT_SUCCESS ! if ( is_loaded ) return ! allocate(func_names(7)) ! func_names(1) = string(\"nvshmem_malloc\") ! func_names(2) = string(\"nvshmem_free\") ! func_names(3) = string(\"nvshmemx_sync_all_on_stream\") ! func_names(4) = string(\"nvshmemx_float_alltoall_on_stream\") ! func_names(5) = string(\"nvshmem_ptr\") ! func_names(6) = string(\"nvshmem_my_pe\") ! func_names(7) = string(\"nvshmemx_init_status\") ! ! error_code = dynamic_load(NVSHMEM_HOST_LIB, func_names, libnvshmem, nvshmemFunctions) ! ! call destroy_strings(func_names) ! ! if ( error_code /= DTFFT_SUCCESS ) return ! do i = 1, size(func_names) !   nvshmemFunctions(i) = load_symbol(cufftmp_handle, func_names(i)%raw) ! enddo ! call c_f_procpointer(nvshmemFunctions(1), nvshmem_malloc) ! call c_f_procpointer(nvshmemFunctions(2), nvshmem_free) ! call c_f_procpointer(nvshmemFunctions(3), nvshmemx_sync_all_on_stream) ! call c_f_procpointer(nvshmemFunctions(4), nvshmemx_float_alltoall_on_stream) ! call c_f_procpointer(nvshmemFunctions(5), nvshmem_ptr) ! call c_f_procpointer(nvshmemFunctions(6), nvshmem_my_pe) ! call c_f_procpointer(nvshmemFunctions(7), nvshmemx_init_status) ! print*, 'nvshmemx_init_status after load = ', nvshmemx_init_status() ! is_loaded = .true. ! end function load_nvshmem function is_nvshmem_ptr ( ptr ) result ( bool ) !! Checks if pointer is a symmetric nvshmem allocated pointer type ( c_ptr ) :: ptr !! Device pointer logical :: bool !! Result bool = . not . is_null_ptr ( nvshmem_ptr ( ptr , nvshmem_my_pe ()) ) end function is_nvshmem_ptr end module dtfft_interface_nvshmem","tags":"","loc":"sourcefile/dtfft_interface_nvshmem.f90.html"},{"title":"dtfft_abstract_backend.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_abstract_backend.f90~~EfferentGraph sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_abstract_backend.f90~~AfferentGraph sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_abstract_backend !! This module describes Abstraction for all GPU Backends: [[abstract_backend]] use iso_c_binding use iso_fortran_env use dtfft_interface_cuda_runtime #ifdef DTFFT_WITH_NCCL use dtfft_interface_nccl #endif use dtfft_nvrtc_kernel , only : nvrtc_kernel use dtfft_parameters use dtfft_pencil , only : pencil use dtfft_utils #include \"dtfft_mpi.h\" #include \"dtfft_cuda.h\" #include \"dtfft_private.h\" implicit none private public :: abstract_backend , backend_helper #ifdef NCCL_HAVE_COMMREGISTER integer ( int32 ), parameter , public :: NCCL_REGISTER_PREALLOC_SIZE = 8 #endif type :: backend_helper !! Helper with nccl, mpi and nvshmem communicators logical :: is_nccl_created = . false . !! Flag is `nccl_comm` has been created #ifdef DTFFT_WITH_NCCL type ( ncclComm ) :: nccl_comm !! NCCL communicator #endif #ifdef NCCL_HAVE_COMMREGISTER logical :: should_register !! If NCCL buffer should be registered type ( c_ptr ), allocatable :: nccl_register (:,:) !! NCCL register cache integer ( int32 ) :: nccl_register_size !! Number of elements in `nccl_register` #endif TYPE_MPI_COMM , allocatable :: comms (:) !! MPI communicators integer ( int32 ), allocatable :: comm_mappings (:,:) !! Mapping of 1d comm ranks to global comm type ( dtfft_transpose_t ) :: tranpose_type !! Type of transpose to create type ( pencil ), pointer :: pencils (:) !! Pencils contains procedure , pass ( self ) :: create => create_helper !! Creates helper procedure , pass ( self ) :: destroy => destroy_helper !! Destroys helper end type backend_helper type , abstract :: abstract_backend !! The most Abstract GPU Backend type ( dtfft_backend_t ) :: backend !! Backend type logical :: is_selfcopy !! If backend is self-copying logical :: is_pipelined !! If backend is pipelined integer ( int64 ) :: aux_size !! Number of bytes required by aux buffer integer ( int64 ) :: send_recv_buffer_size !! Number of float elements used in ``c_f_pointer`` TYPE_MPI_COMM :: comm !! MPI Communicator integer ( int32 ), allocatable :: comm_mapping (:) !! Mapping of 1d comm ranks to global comm integer ( int32 ) :: comm_size !! Size of MPI Comm integer ( int32 ) :: comm_rank !! Rank in MPI Comm integer ( int64 ), allocatable :: send_displs (:) !! Send data displacements, in float elements integer ( int64 ), allocatable :: send_floats (:) !! Send data elements, in float elements integer ( int64 ), allocatable :: recv_displs (:) !! Recv data displacements, in float elements integer ( int64 ), allocatable :: recv_floats (:) !! Recv data elements, in float elements ! Self copy params type ( cudaEvent ) :: execution_event !! Event for main execution stream type ( cudaEvent ) :: copy_event !! Event for copy stream type ( dtfft_stream_t ) :: copy_stream !! Stream for copy operations integer ( int64 ) :: self_copy_bytes !! Number of bytes to copy it itself integer ( int64 ) :: self_send_displ !! Displacement for send buffer integer ( int64 ) :: self_recv_displ !! Displacement for recv buffer ! Pipelined params type ( nvrtc_kernel ), pointer :: unpack_kernel !! Kernel for unpacking data type ( nvrtc_kernel ), pointer :: unpack_kernel2 !! Kernel for unpacking data contains procedure , non_overridable , pass ( self ) :: create !! Creates Abstract GPU Backend procedure , non_overridable , pass ( self ) :: execute !! Executes GPU Backend procedure , non_overridable , pass ( self ) :: destroy !! Destroys Abstract GPU Backend procedure , non_overridable , pass ( self ) :: get_aux_size !! Returns number of bytes required by aux buffer procedure , non_overridable , pass ( self ) :: set_unpack_kernel !! Sets unpack kernel for pipelined backend procedure ( create_interface ), deferred , pass ( self ) :: create_private !! Creates overring class procedure ( execute_interface ), deferred , pass ( self ) :: execute_private !! Executes GPU Backend procedure ( destroy_interface ), deferred , pass ( self ) :: destroy_private !! Destroys overring class end type abstract_backend abstract interface subroutine create_interface ( self , helper , tranpose_type , base_storage ) !! Creates overring class import class ( abstract_backend ), intent ( inout ) :: self !! Abstract GPU Backend type ( backend_helper ), intent ( in ) :: helper !! Backend helper type ( dtfft_transpose_t ), intent ( in ) :: tranpose_type !! Type of transpose to create integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element end subroutine create_interface subroutine execute_interface ( self , in , out , stream , aux ) !! Executes GPU Backend import class ( abstract_backend ), intent ( inout ) :: self !! Abstract GPU Backend real ( real32 ), target , intent ( inout ) :: in (:) !! Send pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Main execution CUDA stream real ( real32 ), target , intent ( inout ) :: aux (:) !! Aux pointer end subroutine execute_interface subroutine destroy_interface ( self ) !! Destroys overring class import class ( abstract_backend ), intent ( inout ) :: self !! Abstract GPU Backend end subroutine destroy_interface end interface contains subroutine create ( self , backend , tranpose_type , helper , comm_id , send_displs , send_counts , recv_displs , recv_counts , base_storage ) !! Creates Abstract GPU Backend class ( abstract_backend ), intent ( inout ) :: self !! Abstract GPU Backend type ( dtfft_backend_t ), intent ( in ) :: backend !! GPU Backend type type ( dtfft_transpose_t ), intent ( in ) :: tranpose_type !! Type of transpose to create type ( backend_helper ), intent ( in ) :: helper !! Backend helper integer ( int8 ), intent ( in ) :: comm_id !! Id of communicator to use integer ( int32 ), intent ( in ) :: send_displs (:) !! Send data displacements, in original elements integer ( int32 ), intent ( in ) :: send_counts (:) !! Send data elements, in float elements integer ( int32 ), intent ( in ) :: recv_displs (:) !! Recv data displacements, in float elements integer ( int32 ), intent ( in ) :: recv_counts (:) !! Recv data elements, in float elements integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element integer ( int64 ) :: send_size !! Total number of floats to send integer ( int64 ) :: recv_size !! Total number of floats to recv integer ( int32 ) :: ierr !! MPI Error code integer ( int64 ) :: scaler !! Scaling data amount to float size scaler = base_storage / FLOAT_STORAGE_SIZE send_size = sum ( send_counts ) * scaler recv_size = sum ( recv_counts ) * scaler self % send_recv_buffer_size = max ( send_size , recv_size ) self % comm = helper % comms ( comm_id ) call MPI_Comm_size ( self % comm , self % comm_size , ierr ) call MPI_Comm_rank ( self % comm , self % comm_rank , ierr ) if ( allocated ( helper % comm_mappings ) ) then allocate ( self % comm_mapping ( 0 : self % comm_size - 1 ), source = helper % comm_mappings ( 0 : self % comm_size - 1 , comm_id ) ) endif allocate ( self % send_displs ( 0 : self % comm_size - 1 ) ) allocate ( self % send_floats ( 0 : self % comm_size - 1 ) ) self % send_displs (:) = int ( send_displs (:), int64 ) * scaler self % send_displs (:) = self % send_displs (:) + 1 self % send_floats (:) = int ( send_counts (:), int64 ) * scaler allocate ( self % recv_displs ( 0 : self % comm_size - 1 ) ) allocate ( self % recv_floats ( 0 : self % comm_size - 1 ) ) self % recv_displs (:) = int ( recv_displs (:), int64 ) * scaler self % recv_displs (:) = self % recv_displs (:) + 1 self % recv_floats (:) = int ( recv_counts (:), int64 ) * scaler self % backend = backend self % is_pipelined = is_backend_pipelined ( backend ) self % is_selfcopy = self % is_pipelined . or . is_backend_mpi ( backend ) self % aux_size = 0_int64 if ( self % is_pipelined ) then self % aux_size = self % send_recv_buffer_size * FLOAT_STORAGE_SIZE endif if ( self % is_selfcopy ) then self % self_send_displ = self % send_displs ( self % comm_rank ) self % self_recv_displ = self % recv_displs ( self % comm_rank ) self % self_copy_bytes = self % send_floats ( self % comm_rank ) * FLOAT_STORAGE_SIZE self % send_floats ( self % comm_rank ) = 0 self % recv_floats ( self % comm_rank ) = 0 CUDA_CALL ( \"cudaEventCreateWithFlags\" , cudaEventCreateWithFlags ( self % execution_event , cudaEventDisableTiming ) ) CUDA_CALL ( \"cudaEventCreateWithFlags\" , cudaEventCreateWithFlags ( self % copy_event , cudaEventDisableTiming ) ) CUDA_CALL ( \"cudaStreamCreate\" , cudaStreamCreate ( self % copy_stream ) ) endif call self % create_private ( helper , tranpose_type , base_storage ) end subroutine create subroutine execute ( self , in , out , stream , aux ) !! Executes GPU Backend class ( abstract_backend ), intent ( inout ) :: self !! Self-copying backend real ( real32 ), intent ( inout ) :: in (:) !! Send pointer real ( real32 ), intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! CUDA stream real ( real32 ), intent ( inout ) :: aux (:) !! Aux pointer if ( . not . self % is_selfcopy ) then call self % execute_private ( in , out , stream , aux ) return endif CUDA_CALL ( \"cudaEventRecord\" , cudaEventRecord ( self % execution_event , stream ) ) ! Waiting for transpose kernel to finish execution on stream `stream` CUDA_CALL ( \"cudaStreamWaitEvent\" , cudaStreamWaitEvent ( self % copy_stream , self % execution_event , 0 ) ) if ( self % self_copy_bytes > 0 ) then if ( self % is_pipelined ) then ! Tranposed data is actually located in aux buffer for pipelined algorithm CUDA_CALL ( \"cudaMemcpyAsync\" , cudaMemcpyAsync ( aux ( self % self_recv_displ ), in ( self % self_send_displ ), self % self_copy_bytes , cudaMemcpyDeviceToDevice , self % copy_stream ) ) ! Data can be unpacked in same stream as `cudaMemcpyAsync` call self % unpack_kernel % execute ( aux , out , self % copy_stream , self % comm_rank + 1 ) else CUDA_CALL ( \"cudaMemcpyAsync\" , cudaMemcpyAsync ( out ( self % self_recv_displ ), in ( self % self_send_displ ), self % self_copy_bytes , cudaMemcpyDeviceToDevice , self % copy_stream ) ) endif endif call self % execute_private ( in , out , stream , aux ) ! Making future events, like FFT, on `stream` to wait for `copy_event` CUDA_CALL ( \"cudaEventRecord\" , cudaEventRecord ( self % copy_event , self % copy_stream ) ) CUDA_CALL ( \"cudaStreamWaitEvent\" , cudaStreamWaitEvent ( stream , self % copy_event , 0 ) ) end subroutine execute subroutine destroy ( self ) !! Destroys Abstract GPU Backend class ( abstract_backend ), intent ( inout ) :: self !! Abstract GPU backend if ( allocated ( self % send_displs ) ) deallocate ( self % send_displs ) if ( allocated ( self % send_floats ) ) deallocate ( self % send_floats ) if ( allocated ( self % recv_displs ) ) deallocate ( self % recv_displs ) if ( allocated ( self % recv_floats ) ) deallocate ( self % recv_floats ) if ( allocated ( self % comm_mapping ) ) deallocate ( self % comm_mapping ) self % comm = MPI_COMM_NULL if ( self % is_selfcopy ) then CUDA_CALL ( \"cudaEventDestroy\" , cudaEventDestroy ( self % execution_event ) ) CUDA_CALL ( \"cudaEventDestroy\" , cudaEventDestroy ( self % copy_event ) ) CUDA_CALL ( \"cudaStreamDestroy\" , cudaStreamDestroy ( self % copy_stream ) ) endif if ( self % is_pipelined ) then nullify ( self % unpack_kernel ) if ( associated ( self % unpack_kernel2 ) ) nullify ( self % unpack_kernel2 ) endif self % is_pipelined = . false . self % is_selfcopy = . false . call self % destroy_private () end subroutine destroy integer ( int64 ) function get_aux_size ( self ) !! Returns number of bytes required by aux buffer class ( abstract_backend ), intent ( in ) :: self !! Abstract GPU backend get_aux_size = self % aux_size end function get_aux_size subroutine set_unpack_kernel ( self , unpack_kernel , unpack_kernel2 ) !! Sets unpack kernel for pipelined backend class ( abstract_backend ), intent ( inout ) :: self !! Pipelined backend type ( nvrtc_kernel ), target , intent ( in ) :: unpack_kernel !! Kernel for unpacking data type ( nvrtc_kernel ), target , intent ( in ), optional :: unpack_kernel2 !! Kernel for unpacking data self % unpack_kernel => unpack_kernel if ( present ( unpack_kernel2 ) ) self % unpack_kernel2 => unpack_kernel2 end subroutine set_unpack_kernel subroutine create_helper ( self , base_comm , comms , is_nccl_needed , pencils ) !! Creates helper class ( backend_helper ), intent ( inout ) :: self !! Backend helper TYPE_MPI_COMM , intent ( in ) :: base_comm !! MPI communicator TYPE_MPI_COMM , intent ( in ) :: comms (:) !! 1D Communicators logical , intent ( in ) :: is_nccl_needed !! If nccl communicator will be needed type ( pencil ), target , intent ( in ) :: pencils (:) !! Pencils integer :: i , n_comms call self % destroy () self % pencils => pencils (:) n_comms = size ( comms ) allocate ( self % comms ( n_comms ) ) self % comms ( 1 ) = base_comm do i = 2 , n_comms self % comms ( i ) = comms ( i ) enddo self % is_nccl_created = . false . if ( . not . is_nccl_needed ) return #ifdef DTFFT_WITH_NCCL block type ( ncclUniqueId ) :: id ! NCCL unique id integer ( int32 ) :: max_size , comm_size , comm_rank , ierr max_size = - 1 do i = 1 , n_comms call MPI_Comm_size ( self % comms ( i ), comm_size , ierr ) max_size = max ( max_size , comm_size ) enddo call MPI_Comm_rank ( base_comm , comm_rank , ierr ) allocate ( self % comm_mappings ( 0 : max_size - 1 , n_comms ), source =- 1 ) do i = 1 , n_comms call MPI_Allgather ( comm_rank , 1 , MPI_INTEGER , self % comm_mappings (:, i ), 1 , MPI_INTEGER , self % comms ( i ), ierr ) enddo if ( comm_rank == 0 ) then NCCL_CALL ( \"ncclGetUniqueId\" , ncclGetUniqueId ( id ) ) end if call MPI_Bcast ( id , int ( c_sizeof ( id )), MPI_BYTE , 0 , base_comm , ierr ) NCCL_CALL ( \"ncclCommInitRank\" , ncclCommInitRank ( self % nccl_comm , max_size , id , comm_rank ) ) self % is_nccl_created = . true . endblock # ifdef NCCL_HAVE_COMMREGISTER self % should_register = get_env ( \"NCCL_BUFFER_REGISTER\" , . true .) if ( self % should_register ) then self % nccl_register_size = 0 allocate ( self % nccl_register ( 2 , NCCL_REGISTER_PREALLOC_SIZE ) ) do i = 1 , NCCL_REGISTER_PREALLOC_SIZE self % nccl_register ( 1 , i ) = c_null_ptr self % nccl_register ( 2 , i ) = c_null_ptr enddo endif # endif #endif end subroutine create_helper subroutine destroy_helper ( self ) !! Destroys helper class ( backend_helper ), intent ( inout ) :: self !! Backend helper if ( allocated ( self % comms ) ) deallocate ( self % comms ) if ( allocated ( self % comm_mappings ) ) deallocate ( self % comm_mappings ) nullify ( self % pencils ) #ifdef DTFFT_WITH_NCCL if ( self % is_nccl_created ) then NCCL_CALL ( \"ncclCommDestroy\" , ncclCommDestroy ( self % nccl_comm ) ) endif self % is_nccl_created = . false . #endif #ifdef NCCL_HAVE_COMMREGISTER if ( self % nccl_register_size > 0 ) then WRITE_ERROR ( \"NCCL register is not empty\" ) endif if ( allocated ( self % nccl_register ) ) deallocate ( self % nccl_register ) self % nccl_register_size = 0 #endif end subroutine destroy_helper end module dtfft_abstract_backend","tags":"","loc":"sourcefile/dtfft_abstract_backend.f90.html"},{"title":"dtfft_executor_vkfft_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_executor_vkfft_m.f90~~EfferentGraph sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_executor_vkfft_m.f90~~AfferentGraph sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_executor_vkfft_m !! This module describes VkFFT based FFT Executor: [[vkfft_executor]] !! !! https://github.com/DTolm/VkFFT/tree/master use iso_c_binding , only : c_ptr , c_int , c_int8_t use iso_fortran_env , only : int8 , int32 , int64 use dtfft_abstract_executor , only : abstract_executor , FFT_C2C , FFT_R2C , FFT_R2R use dtfft_config , only : get_user_stream , get_user_platform use dtfft_errors use dtfft_interface_vkfft_m use dtfft_parameters implicit none private #include \"dtfft_private.h\" public :: vkfft_executor type , extends ( abstract_executor ) :: vkfft_executor !! vkFFT FFT Executor private type ( vkfft_wrapper ), pointer :: wrapper => null () !! VkFFT Wrapper logical :: is_inverse_required !! Should be create separate inverse FFT Plan or not contains procedure , pass ( self ) :: create_private => create !! Creates FFT plan via vkFFT Interface procedure , pass ( self ) :: execute_private => execute !! Executes vkFFT plan procedure , pass ( self ) :: destroy_private => destroy !! Destroys vkFFT plan procedure , nopass :: mem_alloc !! Dummy method. Raises `error stop` procedure , nopass :: mem_free !! Dummy method. Raises `error stop` end type vkfft_executor contains subroutine create ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan via vkFFT Interface class ( vkfft_executor ), intent ( inout ) :: self !! vkFFT FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform integer ( c_int8_t ) :: r2c !! Is R2C transform required integer ( c_int8_t ) :: dct !! Is DCT transform required integer ( c_int8_t ) :: dst !! Is DST transform required integer ( c_int ) :: knd !! Kind of r2r transform integer ( c_int ) :: i !! Loop index integer ( c_int ) :: dims ( 2 ) !! Dimensions of transform integer ( c_int ) :: double_precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type ( dtfft_platform_t ) :: platfrom !! Platform of the executor error_code = DTFFT_SUCCESS do i = 1 , fft_rank dims ( i ) = fft_sizes ( fft_rank - i + 1 ) enddo platfrom = get_user_platform () CHECK_CALL ( load_vkfft ( platfrom ), error_code ) if ( platfrom == DTFFT_PLATFORM_CUDA ) then self % wrapper => cuda_wrapper endif r2c = 0 dct = 0 dst = 0 self % is_inverse_required = . false . select case ( fft_type ) case ( FFT_R2C ) r2c = 1 self % is_inverse_required = . true . case ( FFT_R2R ) knd = r2r_kinds ( 1 )% val do i = 2 , fft_rank if ( knd /= r2r_kinds ( i )% val ) then error_code = DTFFT_ERROR_VKFFT_R2R_2D_PLAN return endif enddo select case ( knd ) case ( DTFFT_DCT_1 % val ) dct = 1 case ( DTFFT_DCT_2 % val ) dct = 2 case ( DTFFT_DCT_3 % val ) dct = 3 case ( DTFFT_DCT_4 % val ) dct = 4 case ( DTFFT_DST_1 % val ) dst = 1 case ( DTFFT_DST_2 % val ) dst = 2 case ( DTFFT_DST_3 % val ) dst = 3 case ( DTFFT_DST_4 % val ) dst = 4 endselect endselect if ( precision == DTFFT_DOUBLE ) then double_precision = 1 else double_precision = 0 endif call self % wrapper % create ( fft_rank , dims , double_precision , how_many , r2c , int ( 0 , int8 ), dct , dst , get_user_stream (), self % plan_forward ) if ( self % is_inverse_required ) then call self % wrapper % create ( fft_rank , dims , double_precision , how_many , int ( 0 , int8 ), r2c , dct , dst , get_user_stream (), self % plan_backward ) else self % plan_backward = self % plan_forward endif end subroutine create subroutine execute ( self , a , b , sign ) !! Executes vkFFT plan class ( vkfft_executor ), intent ( in ) :: self !! vkFFT FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform if ( self % is_inverse_required . and . sign == FFT_BACKWARD ) then call self % wrapper % execute ( self % plan_backward , a , b , sign ) else call self % wrapper % execute ( self % plan_forward , a , b , sign ) endif end subroutine execute subroutine destroy ( self ) !! Destroys vkFFT plan class ( vkfft_executor ), intent ( inout ) :: self !! vkFFT FFT Executor call self % wrapper % destroy ( self % plan_forward ) if ( self % is_inverse_required ) then call self % wrapper % destroy ( self % plan_backward ) endif end subroutine destroy subroutine mem_alloc ( alloc_bytes , ptr ) !! Dummy method. Raises `error stop` integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer INTERNAL_ERROR ( \"mem_alloc for VkFFT called\" ) end subroutine mem_alloc subroutine mem_free ( ptr ) !! Dummy method. Raises `error stop` type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free INTERNAL_ERROR ( \"mem_free for VkFFT called\" ) end subroutine mem_free end module dtfft_executor_vkfft_m","tags":"","loc":"sourcefile/dtfft_executor_vkfft_m.f90.html"},{"title":"dtfft_transpose_plan_host.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_transpose_plan_host.f90~~EfferentGraph sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_transpose_plan_host.f90~~AfferentGraph sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_transpose_plan_host !! This module describes [[transpose_plan_host]] class use iso_fortran_env , only : int8 , int32 , int64 , real32 , real64 , output_unit use dtfft_abstract_transpose_plan , only : abstract_transpose_plan , create_pencils_and_comm use dtfft_errors use dtfft_pencil , only : pencil , pencil_init , get_local_sizes use dtfft_parameters use dtfft_transpose_handle_host , only : transpose_handle_host use dtfft_utils #include \"dtfft_mpi.h\" #include \"dtfft_profile.h\" #include \"dtfft_private.h\" implicit none private public :: transpose_plan_host integer ( int8 ), save :: FORWARD_PLAN_IDS ( 3 ) integer ( int8 ), save :: BACKWARD_PLAN_IDS ( 3 ) type , extends ( abstract_transpose_plan ) :: transpose_plan_host !! Host transpose plan private type ( transpose_handle_host ), allocatable :: fplans (:) !! Forward plans type ( transpose_handle_host ), allocatable :: bplans (:) !! Backward plans contains ! private procedure :: create_private procedure :: execute_private procedure :: destroy procedure , nopass , private :: get_plan_execution_time procedure , pass ( self ), private :: autotune_transpose_id procedure , pass ( self ), private :: autotune_mpi_datatypes procedure , pass ( self ), private :: autotune_grid_decomposition procedure , pass ( self ), private :: autotune_grid end type transpose_plan_host contains function create_private ( self , dims , transposed_dims , base_comm , comm_dims , effort , base_dtype , base_storage , is_custom_cart_comm , cart_comm , comms , pencils , ipencil ) result ( error_code ) !! Creates transposition plans class ( transpose_plan_host ), intent ( inout ) :: self !! Transposition class integer ( int32 ), intent ( in ) :: dims (:) !! Global sizes of the transform requested integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Transposed sizes of the transform requested TYPE_MPI_COMM , intent ( in ) :: base_comm !! Base communicator integer ( int32 ), intent ( in ) :: comm_dims (:) !! Number of MPI Processes in all directions type ( dtfft_effort_t ), intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element logical , intent ( in ) :: is_custom_cart_comm !! Is custom Cartesian communicator provided by user TYPE_MPI_COMM , intent ( out ) :: cart_comm !! Cartesian communicator TYPE_MPI_COMM , intent ( out ) :: comms (:) !! Array of 1d communicators type ( pencil ), intent ( out ) :: pencils (:) !! Pencils type ( pencil_init ), optional , intent ( in ) :: ipencil integer ( int32 ) :: error_code !! Error code integer ( int32 ), allocatable :: best_comm_dims (:) integer ( int8 ) :: d , ndims , n_transpose_plans integer ( int8 ), allocatable :: best_forward_ids (:), best_backward_ids (:) integer ( int32 ) :: comm_size , ierr FORWARD_PLAN_IDS ( 1 ) = get_datatype_from_env ( \"DTYPE_X_Y\" ); BACKWARD_PLAN_IDS ( 1 ) = get_datatype_from_env ( \"DTYPE_Y_X\" ) FORWARD_PLAN_IDS ( 2 ) = get_datatype_from_env ( \"DTYPE_Y_Z\" ); BACKWARD_PLAN_IDS ( 2 ) = get_datatype_from_env ( \"DTYPE_Z_Y\" ) FORWARD_PLAN_IDS ( 3 ) = get_datatype_from_env ( \"DTYPE_X_Z\" ); BACKWARD_PLAN_IDS ( 3 ) = get_datatype_from_env ( \"DTYPE_Z_X\" ) ndims = size ( dims , kind = int8 ) allocate ( best_comm_dims , source = comm_dims ) n_transpose_plans = ndims - 1_int8 ; if ( self % is_z_slab ) n_transpose_plans = n_transpose_plans + 1_int8 allocate ( best_forward_ids ( n_transpose_plans ), best_backward_ids ( n_transpose_plans ) ) ! Setting default values ! Values are defined during compilation do d = 1 , n_transpose_plans best_forward_ids ( d ) = FORWARD_PLAN_IDS ( d ) best_backward_ids ( d ) = BACKWARD_PLAN_IDS ( d ) enddo call MPI_Comm_size ( base_comm , comm_size , ierr ) ! With custom cart comm we can only search for best Datatypes ! only if effort == DTFFT_PATIENT if ( ( is_custom_cart_comm & . or . comm_size == 1 & . or . ndims == 2_int8 & . or . self % is_z_slab & ) . and . effort == DTFFT_PATIENT ) then block integer ( int32 ) :: dummy real ( real64 ) :: dummy_timer ( 1 ) integer ( int32 ) :: dummy_decomp ( size ( comm_dims ), 1 ) integer ( int8 ) :: forw_ids ( n_transpose_plans , 1 ), back_ids ( n_transpose_plans , 1 ) dummy = 1 forw_ids (:, 1 ) = best_forward_ids (:) back_ids (:, 1 ) = best_backward_ids (:) call self % autotune_grid ( & base_comm , comm_dims , & dims , transposed_dims , & effort , base_dtype , base_storage , & dummy , dummy_timer , dummy_decomp , forw_ids , back_ids , & ipencil = ipencil & ) best_forward_ids (:) = forw_ids (:, 1 ) best_backward_ids (:) = back_ids (:, 1 ) endblock else if ( ndims == 3 & . and . . not . is_custom_cart_comm & . and . . not . self % is_z_slab & . and . effort % val >= DTFFT_MEASURE % val & . and . comm_size > 1 ) then call self % autotune_grid_decomposition ( & dims , transposed_dims , base_comm , & effort , n_transpose_plans , & base_dtype , base_storage , & best_comm_dims , best_forward_ids , best_backward_ids & ) endif if ( effort == DTFFT_PATIENT ) then WRITE_INFO ( repeat ( \"*\" , 50 )) WRITE_INFO ( \"DTFFT_PATIENT: Selected transpose ids:\" ) do d = 1 , n_transpose_plans WRITE_INFO ( \"    \" // TRANSPOSE_NAMES ( d ) // \": \" // int_to_str ( best_forward_ids ( d ) )) WRITE_INFO ( \"    \" // TRANSPOSE_NAMES ( - d ) // \": \" // int_to_str ( best_backward_ids ( d ) )) enddo WRITE_INFO ( repeat ( \"*\" , 50 )) endif call create_pencils_and_comm ( transposed_dims , base_comm , best_comm_dims , cart_comm , comms , pencils , ipencil = ipencil ) allocate ( self % fplans ( n_transpose_plans ), self % bplans ( n_transpose_plans ) ) do d = 1_int8 , ndims - 1_int8 call self % fplans ( d )% create ( comms ( d + 1 ), pencils ( d ), pencils ( d + 1 ), base_dtype , base_storage , best_forward_ids ( d )) call self % bplans ( d )% create ( comms ( d + 1 ), pencils ( d + 1 ), pencils ( d ), base_dtype , base_storage , best_backward_ids ( d )) enddo if ( self % is_z_slab ) then call self % fplans ( 3 )% create ( cart_comm , pencils ( 1 ), pencils ( 3 ), base_dtype , base_storage , best_forward_ids ( 3 )) call self % bplans ( 3 )% create ( cart_comm , pencils ( 3 ), pencils ( 1 ), base_dtype , base_storage , best_backward_ids ( 3 )) endif #ifdef DTFFT_WITH_CUDA self % backend = DTFFT_BACKEND_MPI_DATATYPE #endif deallocate ( best_comm_dims ) deallocate ( best_forward_ids , best_backward_ids ) error_code = DTFFT_SUCCESS end function create_private subroutine execute_private ( self , in , out , transpose_type ) !! Executes single transposition class ( transpose_plan_host ), intent ( inout ) :: self !! Transposition class real ( real32 ), intent ( inout ) :: in (:) !! Incoming buffer real ( real32 ), intent ( inout ) :: out (:) !! Resulting buffer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transpose to execute if ( transpose_type % val > 0 ) then call self % fplans ( transpose_type % val )% execute ( in , out ) else call self % bplans ( abs ( transpose_type % val ))% execute ( in , out ) endif end subroutine execute_private subroutine destroy ( self ) !! Destroys transposition plans class ( transpose_plan_host ), intent ( inout ) :: self !! Transposition class integer ( int8 ) :: i if ( allocated ( self % bplans ) ) then do i = 1 , size ( self % bplans , kind = int8 ) call self % fplans ( i )% destroy () call self % bplans ( i )% destroy () enddo deallocate ( self % fplans ) deallocate ( self % bplans ) endif end subroutine destroy subroutine autotune_grid_decomposition ( self , dims , transposed_dims , base_comm , effort , n_transpose_plans , base_dtype , base_storage , best_comm_dims , best_forward_ids , best_backward_ids ) !! Runs through all possible grid decompositions and selects the best one based on the lowest average execution time class ( transpose_plan_host ), intent ( in ) :: self !! Abstract plan integer ( int32 ), intent ( in ) :: dims (:) !! Global dims integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Transposed dims TYPE_MPI_COMM , intent ( in ) :: base_comm !! Base communicator type ( dtfft_effort_t ), intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan integer ( int8 ), intent ( in ) :: n_transpose_plans !! Number of transpose plans to test TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ), intent ( out ) :: best_comm_dims (:) !! Best communicator dimensions integer ( int8 ), intent ( inout ) :: best_forward_ids (:) !! Best Datatype ids for forward plan integer ( int8 ), intent ( inout ) :: best_backward_ids (:) !! Best Datatype ids for backward plan integer ( int8 ) :: ndims integer ( int32 ) :: comm_size , square_root , i , current_timer , k , ierr real ( real64 ) :: min_time real ( real64 ), allocatable :: timers (:) integer ( int32 ), allocatable :: decomps (:,:) integer ( int8 ), allocatable :: forw_ids (:,:), back_ids (:,:) real ( real64 ), parameter :: MaxR8P = huge ( 1._real64 ) call MPI_Comm_size ( base_comm , comm_size , ierr ) ndims = size ( dims , kind = int8 ) square_root = int ( sqrt ( real ( comm_size , real64 ))) + 1 allocate ( timers ( 2 * square_root )) allocate ( decomps ( 2 , 2 * square_root )) allocate ( forw_ids ( n_transpose_plans , 2 * square_root )) allocate ( back_ids ( n_transpose_plans , 2 * square_root )) do i = 1 , 2 * square_root do k = 1 , n_transpose_plans forw_ids ( k , i ) = FORWARD_PLAN_IDS ( k ) back_ids ( k , i ) = BACKWARD_PLAN_IDS ( k ) enddo enddo current_timer = 1 do i = 1 , square_root - 1 if ( mod ( comm_size , i ) /= 0 ) cycle call self % autotune_grid ( base_comm , [ 1 , i , comm_size / i ], dims , transposed_dims , effort , base_dtype , base_storage , current_timer , timers , decomps , forw_ids , back_ids ) if ( i /= comm_size / i ) then call self % autotune_grid ( base_comm , [ 1 , comm_size / i , i ], dims , transposed_dims , effort , base_dtype , base_storage , current_timer , timers , decomps , forw_ids , back_ids ) endif enddo min_time = MaxR8P k = 1 do i = 1 , current_timer - 1 if ( timers ( i ) < min_time ) then min_time = timers ( i ) k = i endif enddo best_comm_dims ( 1 ) = 1 best_comm_dims ( 2 ) = decomps ( 1 , k ) best_comm_dims ( 3 ) = decomps ( 2 , k ) WRITE_INFO ( repeat ( \"*\" , 50 )) WRITE_INFO ( \"DTFFT_MEASURE: Selected MPI grid 1x\" // int_to_str ( best_comm_dims ( 2 )) // \"x\" // int_to_str ( best_comm_dims ( 3 ))) if ( effort == DTFFT_PATIENT ) then best_forward_ids (:) = forw_ids (:, k ) best_backward_ids (:) = back_ids (:, k ) else WRITE_INFO ( repeat ( \"*\" , 50 )) endif deallocate ( timers , decomps , forw_ids , back_ids ) end subroutine autotune_grid_decomposition subroutine autotune_grid ( self , base_comm , comm_dims , dims , transposed_dims , effort , base_dtype , base_storage , latest_timer_id , timers , decomps , forw_ids , back_ids , ipencil ) !! Creates cartesian communicator and executes various datatypes on it class ( transpose_plan_host ), intent ( in ) :: self !! Abstract plan TYPE_MPI_COMM , intent ( in ) :: base_comm !! Base communicator integer ( int32 ), intent ( in ) :: comm_dims (:) !! Number of MPI Processes in Y and Z directions integer ( int32 ), intent ( in ) :: dims (:) !! Global dims integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Transposed dims type ( dtfft_effort_t ), intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Basic MPI Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store Basic MPI Datatype integer ( int32 ), intent ( inout ) :: latest_timer_id !! Current timer id real ( real64 ), intent ( inout ) :: timers (:) !! Time of current function execution is stored in timers(latest_timer_id) integer ( int32 ), intent ( inout ) :: decomps (:,:) !! Current decomposition is stored in decomps(:, latest_timer_id) integer ( int8 ), intent ( inout ) :: forw_ids (:,:) !! Best Forward ids are stored in forw_ids(:, latest_timer_id) integer ( int8 ), intent ( inout ) :: back_ids (:,:) !! Best Backward ids are stored in back_ids(:, latest_timer_id) type ( pencil_init ), optional , intent ( in ) :: ipencil character ( len = :), allocatable :: phase_name !! Caliper phase name integer ( int32 ) :: ierr integer ( int8 ) :: d type ( pencil ), allocatable :: pencils (:) TYPE_MPI_COMM :: comm real ( real64 ) :: tf , tb TYPE_MPI_COMM , allocatable :: comms (:) real ( real32 ), allocatable :: a (:), b (:) integer ( int64 ) :: alloc_size integer ( int8 ) :: ndims ndims = size ( comm_dims , kind = int8 ) if ( ndims == 3 ) then if ( comm_dims ( 2 ) > dims ( 2 ) . or . comm_dims ( 3 ) > dims ( 3 ) ) return allocate ( phase_name , source = \"Testing grid 1x\" // int_to_str ( comm_dims ( 2 )) // \"x\" // int_to_str ( comm_dims ( 3 )) ) else allocate ( phase_name , source = \"Testing grid 1x\" // int_to_str ( comm_dims ( 2 )) ) endif WRITE_INFO ( repeat ( \"=\" , 50 )) WRITE_INFO ( phase_name ) PHASE_BEGIN ( phase_name , 0 ) ! comm_dims(1) = 1 ! comm_dims(2) = ny ! comm_dims(3) = nz allocate ( pencils ( ndims ) ) allocate ( comms ( ndims ) ) call create_pencils_and_comm ( transposed_dims , base_comm , comm_dims , comm , comms , pencils , ipencil = ipencil ) call get_local_sizes ( pencils , alloc_size = alloc_size ) alloc_size = alloc_size * base_storage / FLOAT_STORAGE_SIZE allocate ( a ( alloc_size )) allocate ( b ( alloc_size )) if ( effort == DTFFT_PATIENT ) then call self % autotune_mpi_datatypes ( pencils , comm , comms , base_dtype , base_storage , a , b , forw_ids (:, latest_timer_id ), back_ids (:, latest_timer_id ), timers ( latest_timer_id )) WRITE_INFO ( \"Execution time on a grid using fastest transpositions: \" // double_to_str ( timers ( latest_timer_id ))) else timers ( latest_timer_id ) = 0.0_real64 do d = 1_int8 , ndims - 1_int8 tf = self % get_plan_execution_time ( comms ( d + 1 ), comm , pencils ( d ), pencils ( d + 1 ), base_dtype , base_storage , FORWARD_PLAN_IDS ( d ), d , a , b ) tb = self % get_plan_execution_time ( comms ( d + 1 ), comm , pencils ( d + 1 ), pencils ( d ), base_dtype , base_storage , BACKWARD_PLAN_IDS ( d ), d , a , b ) timers ( latest_timer_id ) = timers ( latest_timer_id ) + tf + tb enddo WRITE_INFO ( \"Average execution time on a grid: \" // double_to_str ( timers ( latest_timer_id ))) endif do d = 1_int8 , ndims - 1_int8 decomps ( d , latest_timer_id ) = comm_dims ( d + 1 ) ! decomps(1, latest_timer_id) = comm_dims(2) ! decomps(2, latest_timer_id) = comm_dims(3) enddo WRITE_INFO ( repeat ( \"=\" , 50 )) latest_timer_id = latest_timer_id + 1 deallocate ( a , b ) do d = 1 , ndims call pencils ( d )% destroy () call MPI_Comm_free ( comms ( d ), ierr ) enddo call MPI_Comm_free ( comm , ierr ) deallocate ( pencils , comms ) PHASE_END ( phase_name ) end subroutine autotune_grid subroutine autotune_mpi_datatypes ( self , pencils , cart_comm , comms , base_dtype , base_storage , a , b , forward_ids , backward_ids , elapsed_time ) !! class ( transpose_plan_host ), intent ( in ) :: self !! Host plan type ( pencil ), intent ( in ) :: pencils (:) !! Array of pencils TYPE_MPI_COMM , intent ( in ) :: cart_comm !! 3D Cartesian comm TYPE_MPI_COMM , intent ( in ) :: comms (:) !! Array of 1d communicators TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Basic MPI Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store Basic MPI Datatype real ( real32 ), intent ( inout ) :: a (:) !! Work buffer real ( real32 ), intent ( inout ) :: b (:) !! Work buffer integer ( int8 ), intent ( inout ) :: forward_ids (:) !! Forward plan IDs integer ( int8 ), intent ( inout ) :: backward_ids (:) !! Backward plan IDs real ( real64 ), intent ( out ) :: elapsed_time !! Elapsed time integer ( int8 ) :: dim !! Counter integer ( int8 ) :: ndims !! Number of dimensions ndims = size ( pencils , kind = int8 ) elapsed_time = 0._real64 if ( self % is_z_slab ) then elapsed_time = self % autotune_transpose_id ( cart_comm , cart_comm , pencils ( 1 ), pencils ( 3 ), base_dtype , base_storage , 3_int8 , a , b , forward_ids ( 3 ), backward_ids ( 3 )) else do dim = 1_int8 , size ( pencils , kind = int8 ) - 1_int8 elapsed_time = elapsed_time + & self % autotune_transpose_id ( comms ( dim + 1 ), cart_comm , pencils ( dim ), pencils ( dim + 1 ), base_dtype , base_storage , dim , a , b , forward_ids ( dim ), backward_ids ( dim )) enddo endif end subroutine autotune_mpi_datatypes function autotune_transpose_id ( self , comm , cart_comm , from , to , base_dtype , base_storage , transpose_name_id , a , b , forward_id , backward_id ) result ( elapsed_time ) !! Creates forward and backward transpose plans bases on source and target data distributing, !! executes them `DTFFT_MEASURE_ITERS` times ( 4 * `DTFFT_MEASURE_ITERS` iterations total ) !! !! Returns elapsed time for best plans selected class ( transpose_plan_host ), intent ( in ) :: self !! Abstract plan TYPE_MPI_COMM , intent ( in ) :: comm !! 1D comm in case of pencils, 3D comm in case of z_slabs TYPE_MPI_COMM , intent ( in ) :: cart_comm !! 3D Cartesian comm type ( pencil ), intent ( in ) :: from !! Source meta type ( pencil ), intent ( in ) :: to !! Target meta TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Basic MPI Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store Basic MPI Datatype integer ( int8 ), intent ( in ) :: transpose_name_id !! ID of transpose name (from -3 to 3, except 0) real ( real32 ), intent ( inout ) :: a (:) !! Source buffer real ( real32 ), intent ( inout ) :: b (:) !! Target buffer integer ( int8 ), intent ( out ) :: forward_id !! Best forward plan ID integer ( int8 ), intent ( out ) :: backward_id !! Best backward plan ID real ( real64 ) :: elapsed_time !! Elapsed time for best plans selected real ( real64 ) :: forward_time !! Forward plan execution time real ( real64 ) :: backward_time !! Backward plan execution time real ( real64 ) :: time !! Timer integer ( int8 ) :: datatype_id !! Counter forward_time = huge ( 1._real64 ) backward_time = huge ( 1._real64 ) do datatype_id = 1 , 2 time = self % get_plan_execution_time ( comm , cart_comm , from , to , base_dtype , base_storage , datatype_id , transpose_name_id , a , b ) if ( time < forward_time ) then forward_time = time forward_id = datatype_id endif time = self % get_plan_execution_time ( comm , cart_comm , to , from , base_dtype , base_storage , datatype_id , - 1_int8 * transpose_name_id , a , b ) if ( time < backward_time ) then backward_time = time backward_id = datatype_id endif enddo elapsed_time = forward_time + backward_time end function autotune_transpose_id function get_plan_execution_time ( comm , cart_comm , from , to , base_dtype , base_storage , datatype_id , transpose_name_id , a , b ) result ( elapsed_time ) !! Creates transpose plan and executes it `DTFFT_MEASURE_WARMUP_ITERS` + `DTFFT_MEASURE_ITERS` times !! !! Returns elapsed time TYPE_MPI_COMM , intent ( in ) :: comm !! 1D comm in case of pencils, 3D comm in case of z_slabs TYPE_MPI_COMM , intent ( in ) :: cart_comm !! 3D Cartesian comm type ( pencil ), intent ( in ) :: from !! Source meta type ( pencil ), intent ( in ) :: to !! Target meta TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Basic MPI Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store Basic MPI Datatype integer ( int8 ), intent ( in ) :: datatype_id !! ID of transpose (1 or 2) integer ( int8 ), intent ( in ) :: transpose_name_id !! ID of transpose name (from -3 to 3, except 0) real ( real32 ), intent ( inout ) :: a (:) !! Source buffer real ( real32 ), intent ( inout ) :: b (:) !! Target buffer real ( real64 ) :: elapsed_time !! Execution time character ( len = :), allocatable :: phase_name !! Caliper phase name type ( transpose_handle_host ) :: plan !! Transpose plan real ( real64 ) :: ts , te !! Timers integer ( int32 ) :: iter !! Counter integer ( int32 ) :: ierr !! Error code integer ( int32 ) :: comm_size !! Size of ``cart_comm`` integer ( int32 ) :: n_warmup_iters integer ( int32 ) :: n_iters allocate ( phase_name , source = \"    Testing plan \" // TRANSPOSE_NAMES ( transpose_name_id ) // \", datatype_id = \" // int_to_str ( datatype_id ) ) PHASE_BEGIN ( phase_name , 0 ) WRITE_INFO ( phase_name ) call plan % create ( comm , from , to , base_dtype , base_storage , datatype_id ) n_warmup_iters = get_iters_from_env (. true .) n_iters = get_iters_from_env (. false .) do iter = 1 , n_warmup_iters call plan % execute ( a , b ) enddo ts = MPI_Wtime () do iter = 1 , n_iters call plan % execute ( a , b ) enddo te = MPI_Wtime () call MPI_Allreduce ( te - ts , elapsed_time , 1 , MPI_REAL8 , MPI_SUM , cart_comm , ierr ) call MPI_Comm_size ( cart_comm , comm_size , ierr ) elapsed_time = real ( elapsed_time , real64 ) / real ( comm_size , real64 ) call plan % destroy () PHASE_END ( phase_name ) deallocate ( phase_name ) WRITE_INFO ( \"        Average execution time: \" // double_to_str ( elapsed_time )) end function get_plan_execution_time end module dtfft_transpose_plan_host","tags":"","loc":"sourcefile/dtfft_transpose_plan_host.f90.html"},{"title":"dtfft_interface_fftw_m.F90 – dtFFT","text":"Files dependent on this one sourcefile~~dtfft_interface_fftw_m.f90~~AfferentGraph sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_fftw_m !! This module creates interface with fftw3 library use iso_c_binding , only : c_ptr , c_int use dtfft_interface_fftw_native_m , only : C_FFTW_R2R_KIND , FFTW_MEASURE , FFTW_DESTROY_INPUT use dtfft_interface_fftw_native_m , only : fftw_destroy_plan , fftwf_destroy_plan use dtfft_interface_fftw_native_m , only : fftw_malloc , fftw_free implicit none private public :: C_FFTW_R2R_KIND , FFTW_MEASURE , FFTW_DESTROY_INPUT public :: fftw_destroy_plan , fftwf_destroy_plan public :: fftw_execute_dft , fftwf_execute_dft public :: fftw_execute_dft_r2c , fftwf_execute_dft_r2c public :: fftw_execute_dft_c2r , fftwf_execute_dft_c2r public :: fftw_execute_r2r , fftwf_execute_r2r public :: fftw_plan_many_dft , fftwf_plan_many_dft public :: fftw_plan_many_dft_r2c , fftwf_plan_many_dft_r2c public :: fftw_plan_many_dft_c2r , fftwf_plan_many_dft_c2r public :: fftw_plan_many_r2r , fftwf_plan_many_r2r public :: fftw_malloc , fftw_free interface subroutine fftw_execute_dft ( plan , in , out ) bind ( C ) !! Executes C2C plan, double precision. #include \"args_execute.i90\" end subroutine fftw_execute_dft subroutine fftwf_execute_dft ( plan , in , out ) bind ( C ) !! Executes C2C plan, single precision. #include \"args_execute.i90\" end subroutine fftwf_execute_dft subroutine fftw_execute_dft_r2c ( plan , in , out ) bind ( C ) !! Executes R2C plan, double precision. #include \"args_execute.i90\" end subroutine fftw_execute_dft_r2c subroutine fftwf_execute_dft_r2c ( plan , in , out ) bind ( C ) !! Executes R2C plan, single precision. #include \"args_execute.i90\" end subroutine fftwf_execute_dft_r2c subroutine fftw_execute_dft_c2r ( plan , in , out ) bind ( C ) !! Executes C2R plan, double precision. #include \"args_execute.i90\" end subroutine fftw_execute_dft_c2r subroutine fftwf_execute_dft_c2r ( plan , in , out ) bind ( C ) !! Executes C2R plan, single precision. #include \"args_execute.i90\" end subroutine fftwf_execute_dft_c2r subroutine fftw_execute_r2r ( plan , in , out ) bind ( C ) !! Executes R2R plan, double precision. #include \"args_execute.i90\" end subroutine fftw_execute_r2r subroutine fftwf_execute_r2r ( plan , in , out ) bind ( C ) !! Executes R2R plan, single precision. #include \"args_execute.i90\" end subroutine fftwf_execute_r2r type ( c_ptr ) function fftw_plan_many_dft ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , sign , flags ) bind ( C ) !! Creates C2C plan, double precision. #include \"args_create.i90\" integer ( C_INT ), value :: sign end function fftw_plan_many_dft type ( c_ptr ) function fftwf_plan_many_dft ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , sign , flags ) bind ( C ) !! Creates C2C plan, single precision. #include \"args_create.i90\" integer ( C_INT ), value :: sign end function fftwf_plan_many_dft type ( c_ptr ) function fftw_plan_many_dft_r2c ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates R2C plan, double precision. #include \"args_create.i90\" end function fftw_plan_many_dft_r2c type ( c_ptr ) function fftwf_plan_many_dft_r2c ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates R2C plan, single precision. #include \"args_create.i90\" end function fftwf_plan_many_dft_r2c type ( c_ptr ) function fftw_plan_many_dft_c2r ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates C2R plan, double precision. #include \"args_create.i90\" end function fftw_plan_many_dft_c2r type ( c_ptr ) function fftwf_plan_many_dft_c2r ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates C2R plan, single precision. #include \"args_create.i90\" end function fftwf_plan_many_dft_c2r type ( c_ptr ) function fftw_plan_many_r2r ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , kind , flags ) bind ( C ) !! Creates R2R plan, double precision. #include \"args_create.i90\" integer ( C_FFTW_R2R_KIND ), intent ( in ) :: kind ( * ) end function fftw_plan_many_r2r type ( c_ptr ) function fftwf_plan_many_r2r ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , kind , flags ) bind ( C ) !! Creates R2R plan, single precision. #include \"args_create.i90\" integer ( C_FFTW_R2R_KIND ), intent ( in ) :: kind ( * ) end function fftwf_plan_many_r2r end interface end module dtfft_interface_fftw_m","tags":"","loc":"sourcefile/dtfft_interface_fftw_m.f90.html"},{"title":"dtfft_executor_cufft_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_executor_cufft_m.f90~~EfferentGraph sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_executor_cufft_m.f90~~AfferentGraph sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_executor_cufft_m !! This module describes cuFFT based FFT Executor: [[vkfft_executor]] !! !! https://docs.nvidia.com/cuda/cufft/index.html use iso_c_binding , only : c_ptr , c_int , c_null_ptr , c_loc use iso_fortran_env , only : int8 , int32 , int64 use dtfft_parameters use dtfft_abstract_executor , only : abstract_executor , FFT_C2C , FFT_R2C use dtfft_errors use dtfft_interface_cufft use dtfft_interface_cuda_runtime use dtfft_utils , only : int_to_str use dtfft_config , only : get_user_stream #include \"dtfft_mpi.h\" #include \"dtfft_cuda.h\" #include \"dtfft_private.h\" implicit none private public :: cufft_executor type , extends ( abstract_executor ) :: cufft_executor !! cuFFT FFT Executor private contains procedure :: create_private => create !! Creates FFT plan via cuFFT Interface procedure :: execute_private => execute !! Executes cuFFT plan procedure :: destroy_private => destroy !! Destroys cuFFT plan procedure , nopass :: mem_alloc !! Dummy method. Raises `error stop` procedure , nopass :: mem_free !! Dummy method. Raises `error stop` end type cufft_executor contains subroutine create ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan via cuFFT Interface class ( cufft_executor ), intent ( inout ) :: self !! cuFFT FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform integer ( c_int ) :: cufft_type , rnk ! CHECK_CALL( load_cufft(), error_code ) rnk = int ( fft_rank , c_int ) select case ( fft_type ) case ( FFT_C2C ) if ( precision == DTFFT_SINGLE ) then cufft_type = CUFFT_C2C else cufft_type = CUFFT_Z2Z endif CUFFT_CALL ( \"cufftPlanMany\" , cufftPlanMany ( self % plan_forward , rnk , fft_sizes , inembed , 1 , idist , onembed , 1 , odist , cufft_type , how_many ) ) self % plan_backward = self % plan_forward self % is_inverse_copied = . true . case ( FFT_R2C ) if ( precision == DTFFT_SINGLE ) then cufft_type = CUFFT_R2C else cufft_type = CUFFT_D2Z endif CUFFT_CALL ( \"cufftPlanMany\" , cufftPlanMany ( self % plan_forward , rnk , fft_sizes , inembed , 1 , idist , onembed , 1 , odist , cufft_type , how_many ) ) if ( precision == DTFFT_SINGLE ) then cufft_type = CUFFT_C2R else cufft_type = CUFFT_Z2D endif CUFFT_CALL ( \"cufftPlanMany\" , cufftPlanMany ( self % plan_backward , rnk , fft_sizes , onembed , 1 , odist , inembed , 1 , idist , cufft_type , how_many ) ) case default error_code = DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED if ( present ( r2r_kinds )) then endif return endselect CUFFT_CALL ( \"cufftSetStream\" , cufftSetStream ( self % plan_forward , get_user_stream ()) ) if ( . not . self % is_inverse_copied ) then CUFFT_CALL ( \"cufftSetStream\" , cufftSetStream ( self % plan_backward , get_user_stream ()) ) endif end subroutine create subroutine execute ( self , a , b , sign ) !! Executes cuFFT plan class ( cufft_executor ), intent ( in ) :: self !! cuFFT FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform integer ( c_int ) :: sign_ sign_ = int ( sign , c_int ) if ( self % is_inverse_copied ) then CUFFT_CALL ( \"cufftXtExec\" , cufftXtExec ( self % plan_forward , a , b , sign_ ) ) return endif if ( sign == FFT_FORWARD ) then CUFFT_CALL ( \"cufftXtExec\" , cufftXtExec ( self % plan_forward , a , b , sign_ ) ) else CUFFT_CALL ( \"cufftXtExec\" , cufftXtExec ( self % plan_backward , a , b , sign_ ) ) endif end subroutine execute subroutine destroy ( self ) !! Destroys cuFFT plan class ( cufft_executor ), intent ( inout ) :: self !! cuFFT FFT Executor CUFFT_CALL ( \"cufftDestroy\" , cufftDestroy ( self % plan_forward ) ) if ( . not . self % is_inverse_copied ) then CUFFT_CALL ( \"cufftDestroy\" , cufftDestroy ( self % plan_backward ) ) endif end subroutine destroy subroutine mem_alloc ( alloc_bytes , ptr ) !! Dummy method. Raises `error stop` integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer INTERNAL_ERROR ( \"mem_alloc for cuFFT called\" ) end subroutine mem_alloc subroutine mem_free ( ptr ) !! Dummy method. Raises `error stop` type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free INTERNAL_ERROR ( \"mem_free for cuFFT called\" ) end subroutine mem_free end module dtfft_executor_cufft_m","tags":"","loc":"sourcefile/dtfft_executor_cufft_m.f90.html"},{"title":"dtfft_backend_mpi.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_backend_mpi.f90~~EfferentGraph sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_backend_mpi.f90~~AfferentGraph sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_backend_mpi !! MPI Based GPU Backends [[backend_mpi]] use iso_fortran_env use iso_c_binding use dtfft_abstract_backend use dtfft_interface_cuda_runtime use dtfft_parameters use dtfft_utils #include \"dtfft_mpi.h\" #include \"dtfft_cuda.h\" #include \"dtfft_private.h\" implicit none private public :: backend_mpi type :: mpi_backend_helper !! MPI Helper integer ( CNT_KIND ), allocatable :: counts (:) !! Counts of data to send or recv integer ( ADDR_KIND ), allocatable :: displs (:) !! Displacements of data to send or recv TYPE_MPI_REQUEST , allocatable :: requests (:) !! MPI Requests integer ( int32 ) :: n_requests !! Number of requests #ifdef ENABLE_PERSISTENT_COMM logical :: is_request_created = . false . !! Request created flag. Used for persistent functions #endif contains procedure , pass ( self ) :: create => create_helper !! Creates MPI helper procedure , pass ( self ) :: destroy => destoy_helper !! Destroys MPI helper endtype mpi_backend_helper type , extends ( abstract_backend ) :: backend_mpi !! MPI Backend private type ( mpi_backend_helper ) :: send !! MPI Helper for send data type ( mpi_backend_helper ) :: recv !! MPI Helper for recv data contains procedure :: create_private => create_mpi !! Creates MPI backend procedure :: execute_private => execute_mpi !! Executes MPI backend procedure :: destroy_private => destroy_mpi !! Destroys MPI backend end type backend_mpi contains subroutine create_helper ( self , counts , displs , max_requests ) !! Creates MPI helper class ( mpi_backend_helper ), intent ( inout ) :: self !! MPI Helper integer ( int64 ), intent ( in ) :: counts (:) !! Counts of data to send or recv integer ( int64 ), intent ( in ) :: displs (:) !! Displacements of data to send or recv integer ( int32 ), intent ( in ) :: max_requests !! Maximum number of requests required integer ( int32 ) :: n_counts n_counts = size ( counts ) allocate ( self % counts ( 0 : n_counts - 1 ), self % displs ( 0 : n_counts - 1 ) ) self % counts ( 0 :) = int ( counts (:), CNT_KIND ) self % displs ( 0 :) = int ( displs (:), ADDR_KIND ) if ( max_requests > 0 ) then allocate ( self % requests ( max_requests ) ) #ifdef ENABLE_PERSISTENT_COMM self % is_request_created = . false . #endif endif end subroutine create_helper subroutine destoy_helper ( self ) !! Destroys MPI helper class ( mpi_backend_helper ), intent ( inout ) :: self !! MPI Helper if ( allocated ( self % counts ) ) deallocate ( self % counts ) if ( allocated ( self % displs ) ) deallocate ( self % displs ) #ifdef ENABLE_PERSISTENT_COMM block integer ( int32 ) :: mpi_ierr , i if ( self % is_request_created ) then do i = 1 , self % n_requests call MPI_Request_free ( self % requests ( i ), mpi_ierr ) enddo endif self % is_request_created = . false . endblock #endif if ( allocated ( self % requests ) ) deallocate ( self % requests ) self % n_requests = 0 end subroutine destoy_helper subroutine create_mpi ( self , helper , tranpose_type , base_storage ) !! Creates MPI backend class ( backend_mpi ), intent ( inout ) :: self !! MPI GPU Backend type ( backend_helper ), intent ( in ) :: helper !! Backend helper (unused) type ( dtfft_transpose_t ), intent ( in ) :: tranpose_type !! Type of transpose to create (unused) integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element (unused) if ( . not . is_backend_mpi ( self % backend ) ) INTERNAL_ERROR ( \".not. is_backend_mpi\" ) if ( self % backend == DTFFT_BACKEND_MPI_A2A ) then call self % send % create ( self % send_floats , self % send_displs - 1 , 1 ) call self % recv % create ( self % recv_floats , self % recv_displs - 1 , 0 ) else call self % send % create ( self % send_floats , self % send_displs , self % comm_size ) call self % recv % create ( self % recv_floats , self % recv_displs , self % comm_size ) endif end subroutine create_mpi subroutine destroy_mpi ( self ) !! Destroys MPI backend class ( backend_mpi ), intent ( inout ) :: self !! MPI GPU Backend call self % send % destroy () call self % recv % destroy () end subroutine destroy_mpi subroutine execute_mpi ( self , in , out , stream , aux ) !! Executes MPI backend class ( backend_mpi ), intent ( inout ) :: self !! MPI GPU Backend real ( real32 ), target , intent ( inout ) :: in (:) !! Send pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Main execution CUDA stream real ( real32 ), target , intent ( inout ) :: aux (:) !! Aux pointer integer ( int32 ) :: mpi_ierr !! MPI error code logical , allocatable :: is_complete_comm (:) !! Testing for request completion integer ( int32 ) :: request_counter !! Request counter integer ( int32 ) :: i !! Loop index ! Need to sync stream since there is no way pass current stream to MPI CUDA_CALL ( \"cudaStreamSynchronize\" , cudaStreamSynchronize ( stream ) ) select case ( self % backend % val ) case ( DTFFT_BACKEND_MPI_A2A % val ) call run_mpi_a2a ( self % comm , self % send , self % recv , in , out ) ! All-to-all request is stored in `send%requests(1)`, so no need to wait for recv requests case ( DTFFT_BACKEND_MPI_P2P % val ) call run_mpi_p2p ( self % comm , self % send , self % recv , in , out ) ! Waiting for all recv requests to finish call MPI_Waitall ( self % recv % n_requests , self % recv % requests , MPI_STATUSES_IGNORE , mpi_ierr ) case ( DTFFT_BACKEND_MPI_P2P_PIPELINED % val ) call run_mpi_p2p ( self % comm , self % send , self % recv , in , aux ) allocate ( is_complete_comm ( self % recv % n_requests ), source = . false . ) ! do while (.true.) ! Testing that all data has been recieved so we can unpack it request_counter = 0 do i = 0 , self % comm_size - 1 if ( self % recv_floats ( i ) == 0 ) cycle request_counter = request_counter + 1 call MPI_Wait ( self % recv % requests ( request_counter ), MPI_STATUS_IGNORE , mpi_ierr ) call self % unpack_kernel % execute ( aux , out , stream , i + 1 ) !   if ( is_complete_comm( request_counter ) ) cycle !   call MPI_Test(self%recv%requests(request_counter), is_complete_comm( request_counter ), MPI_STATUS_IGNORE, mpi_ierr) !   if ( is_complete_comm( request_counter ) ) then !     call self%unpack_kernel%execute(aux, out, stream, i + 1) !   endif enddo ! if ( all( is_complete_comm ) ) exit ! enddo endselect call MPI_Waitall ( self % send % n_requests , self % send % requests , MPI_STATUSES_IGNORE , mpi_ierr ) end subroutine execute_mpi subroutine run_mpi_p2p ( comm , send , recv , in , out ) !! Executes MPI point-to-point communication TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator type ( mpi_backend_helper ), intent ( inout ) :: send !! MPI Helper for send data type ( mpi_backend_helper ), intent ( inout ) :: recv !! MPI Helper for recv data real ( real32 ), intent ( in ) :: in (:) !! Data to be sent real ( real32 ), intent ( inout ) :: out (:) !! Data to be received integer ( int32 ) :: send_request_counter , recv_request_counter integer ( int32 ) :: i , comm_size , mpi_ierr send_request_counter = 0 recv_request_counter = 0 call MPI_Comm_size ( comm , comm_size , mpi_ierr ) #ifdef ENABLE_PERSISTENT_COMM if ( . not . send % is_request_created ) then do i = 0 , comm_size - 1 if ( recv % counts ( i ) > 0 ) then recv_request_counter = recv_request_counter + 1 call MPI_Recv_init ( out ( recv % displs ( i ) ), recv % counts ( i ), MPI_REAL , i , 0 , & comm , recv % requests ( recv_request_counter ), mpi_ierr ) endif enddo recv % n_requests = recv_request_counter ; recv % is_request_created = . true . do i = 0 , comm_size - 1 if ( send % counts ( i ) > 0 ) then send_request_counter = send_request_counter + 1 call MPI_Send_init ( in ( send % displs ( i ) ), send % counts ( i ), MPI_REAL , i , 0 , & comm , send % requests ( send_request_counter ), mpi_ierr ) endif enddo send % n_requests = send_request_counter ; send % is_request_created = . true . endif call MPI_Startall ( recv % n_requests , recv % requests , mpi_ierr ) call MPI_Startall ( send % n_requests , send % requests , mpi_ierr ) #else do i = 0 , comm_size - 1 if ( recv % counts ( i ) > 0 ) then recv_request_counter = recv_request_counter + 1 call MPI_Irecv ( out ( recv % displs ( i ) ), recv % counts ( i ), MPI_REAL , i , 0 , & comm , recv % requests ( recv_request_counter ), mpi_ierr ) endif enddo recv % n_requests = recv_request_counter do i = 0 , comm_size - 1 if ( send % counts ( i ) > 0 ) then send_request_counter = send_request_counter + 1 call MPI_Isend ( in ( send % displs ( i ) ), send % counts ( i ), MPI_REAL , i , 0 , & comm , send % requests ( send_request_counter ), mpi_ierr ) endif enddo send % n_requests = send_request_counter #endif end subroutine run_mpi_p2p subroutine run_mpi_a2a ( comm , send , recv , in , out ) !! Executes MPI all-to-all communication TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator type ( mpi_backend_helper ), intent ( inout ) :: send !! MPI Helper for send data type ( mpi_backend_helper ), intent ( inout ) :: recv !! MPI Helper for recv data real ( real32 ), intent ( in ) :: in (:) !! Data to be sent real ( real32 ), intent ( inout ) :: out (:) !! Data to be received integer ( int32 ) :: mpi_ierr #if defined(ENABLE_PERSISTENT_COLLECTIVES) if ( . not . send % is_request_created ) then call MPI_Alltoallv_init ( in , send % counts , send % displs , MPI_REAL , & out , recv % counts , recv % displs , MPI_REAL , & comm , MPI_INFO_NULL , send % requests ( 1 ), mpi_ierr ) send % is_request_created = . true . endif call MPI_Start ( send % requests ( 1 ), mpi_ierr ) #else call MPI_Ialltoallv ( in , send % counts , send % displs , MPI_REAL , & out , recv % counts , recv % displs , MPI_REAL , & comm , send % requests ( 1 ), mpi_ierr ) #endif send % n_requests = 1 end subroutine run_mpi_a2a end module dtfft_backend_mpi","tags":"","loc":"sourcefile/dtfft_backend_mpi.f90.html"},{"title":"dtfft_interface_nvtx.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_nvtx.f90~~EfferentGraph sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_nvtx.f90~~AfferentGraph sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_nvtx !! nvtx3 Interfaces use iso_c_binding use dtfft_utils implicit none private public :: push_nvtx_domain_range , pop_nvtx_domain_range type , bind ( C ) :: nvtxDomainHandle type ( c_ptr ) :: handle end type nvtxDomainHandle type ( nvtxDomainHandle ), save :: domain_nvtx !! NVTX domain handle logical , save :: domain_created = . false . !! Has domain been created? interface !! Creates an NVTX domain with the specified name. subroutine nvtxDomainCreate_c ( name , domain ) bind ( C , name = \"nvtxDomainCreate_c\" ) import character ( c_char ), intent ( in ) :: name ( * ) !! Name of the NVTX domain. type ( nvtxDomainHandle ) :: domain !! Handle to the created NVTX domain. end subroutine nvtxDomainCreate_c end interface interface !! Pushes a range with a custom message and color onto the specified NVTX domain. subroutine nvtxDomainRangePushEx_c ( domain , message , color ) bind ( C , name = \"nvtxDomainRangePushEx_c\" ) import type ( nvtxDomainHandle ), value :: domain !! NVTX domain handle. character ( c_char ), intent ( in ) :: message ( * ) !! Custom message for the range. integer ( c_int ), value , intent ( in ) :: color !! Color for the range. end subroutine nvtxDomainRangePushEx_c end interface interface !! Pops a range from the specified NVTX domain. subroutine nvtxDomainRangePop_c ( domain ) bind ( C , name = \"nvtxDomainRangePop_c\" ) import type ( nvtxDomainHandle ), value :: domain !! NVTX domain handle. end subroutine nvtxDomainRangePop_c end interface contains subroutine create_nvtx_domain !! Creates a new NVTX domain character ( c_char ), allocatable :: cstr (:) call astring_f2c ( \"dtFFT\" , cstr ) call nvtxDomainCreate_c ( cstr , domain_nvtx ) domain_created = . true . deallocate ( cstr ) end subroutine create_nvtx_domain subroutine push_nvtx_domain_range ( message , color ) !! Pushes a range to the NVTX domain character ( len =* ), intent ( in ) :: message !! Message to push integer ( c_int ), intent ( in ) :: color !! Color of the range character ( c_char ), allocatable :: cstr (:) if ( . not . domain_created ) call create_nvtx_domain () call astring_f2c ( message , cstr ) call nvtxDomainRangePushEx_c ( domain_nvtx , cstr , color ) deallocate ( cstr ) end subroutine push_nvtx_domain_range subroutine pop_nvtx_domain_range () !! Pops a range from the NVTX domain call nvtxDomainRangePop_c ( domain_nvtx ) end subroutine pop_nvtx_domain_range end module dtfft_interface_nvtx","tags":"","loc":"sourcefile/dtfft_interface_nvtx.f90.html"},{"title":"dtfft_plan.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_plan.f90~~EfferentGraph sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_plan.f90~~AfferentGraph sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. #include \"dtfft_config.h\" #include \"dtfft.f03\" !------------------------------------------------------------------------------------------------ module dtfft_plan !! This module describes [[dtfft_plan_t]], [[dtfft_plan_c2c_t]], [[dtfft_plan_r2c_t]] and [[dtfft_plan_r2r_t]] types use iso_c_binding , only : c_loc , c_f_pointer , c_ptr , c_bool , c_null_ptr use iso_fortran_env , only : int8 , int32 , int64 , real32 , real64 , output_unit , error_unit use dtfft_abstract_executor , only : abstract_executor , FFT_1D , FFT_2D , FFT_C2C , FFT_R2C , FFT_R2R use dtfft_abstract_transpose_plan , only : abstract_transpose_plan #ifdef DTFFT_WITH_FFTW use dtfft_executor_fftw_m , only : fftw_executor #endif #ifdef DTFFT_WITH_MKL use dtfft_executor_mkl_m , only : mkl_executor #endif #ifdef DTFFT_WITH_CUFFT use dtfft_executor_cufft_m , only : cufft_executor #endif #ifdef DTFFT_WITH_VKFFT use dtfft_executor_vkfft_m , only : vkfft_executor #endif use dtfft_config use dtfft_errors use dtfft_pencil , only : pencil , pencil_init , get_local_sizes_private => get_local_sizes , dtfft_pencil_t use dtfft_parameters use dtfft_transpose_plan_host , only : transpose_plan_host use dtfft_utils #ifdef DTFFT_WITH_CUDA use dtfft_interface_cuda_runtime use dtfft_nvrtc_kernel , only : clean_unused_cache use dtfft_transpose_plan_cuda , only : transpose_plan_cuda #endif #ifdef DTFFT_WITH_NVSHMEM use dtfft_interface_nvshmem , only : is_nvshmem_ptr #endif #include \"dtfft_cuda.h\" #include \"dtfft_mpi.h\" #include \"dtfft_private.h\" #include \"dtfft_profile.h\" implicit none private public :: dtfft_plan_t public :: dtfft_plan_c2c_t public :: dtfft_plan_r2c_t public :: dtfft_plan_r2r_t type :: fft_executor !! FFT handle class ( abstract_executor ), allocatable :: fft !! Executor end type fft_executor type , abstract :: dtfft_plan_t !! Abstract class for all ``dtFFT`` plans private integer ( int8 ) :: ndims !! Number of global dimensions integer ( int32 ), allocatable :: dims (:) !! Global dimensions type ( dtfft_precision_t ) :: precision !! Precision of transform logical :: is_created = . false . !! Plan creation flag logical :: is_transpose_plan = . false . !! Plan is transpose only logical :: is_aux_alloc = . false . !! Auxiliary buffer is allocated internally logical :: is_z_slab = . false . !! Using Z-slab optimization !! !! Only 3D plan. !! !! When .true., then data is distributed only Z direction and it creates a possibility for optimization: !! !! - 2 dimensional FFT plan is created for both X and Y dimensions !! - Single call to MPI_Alltoall is required to transpose data from X-align to Z align !! !! For CUDA build this optimization means single CUDA kernel that tranposes data directly from X to Z type ( dtfft_effort_t ) :: effort !! User defined type of effort integer ( int64 ) :: storage_size !! Single element size in bytes type ( dtfft_executor_t ) :: executor !! FFT executor type TYPE_MPI_COMM :: comm !! Grid communicator TYPE_MPI_COMM , allocatable :: comms (:) !! Local 1d communicators class ( abstract_transpose_plan ), allocatable :: plan !! Transpose plan handle type ( pencil ), allocatable :: pencils (:) !! Information about data aligment and datatypes type ( dtfft_platform_t ) :: platform !! Execution platform #ifdef DTFFT_WITH_CUDA type ( dtfft_stream_t ) :: stream !! CUDA Stream associated with current plan #endif type ( c_ptr ) :: aux_ptr !! Auxiliary pointer type ( fft_executor ), allocatable :: fft (:) !! Internal fft runners integer ( int32 ), allocatable :: fft_mapping (:) !! Memory and plan creation optimization. !! In case same FFTs needs to be run in different dimensions !! only single FFT plan needs to be created contains private procedure , pass ( self ), non_overridable , public :: transpose !! Performs single transposition procedure , pass ( self ), non_overridable , public :: transpose_ptr !! Performs single transposition using type(c_ptr) pointers instead of buffers procedure , pass ( self ), non_overridable , public :: execute !! Executes plan procedure , pass ( self ), non_overridable , public :: execute_ptr !! Executes plan using type(c_ptr) pointers instead of buffers procedure , pass ( self ), non_overridable , public :: destroy !! Destroys plan procedure , pass ( self ), non_overridable , public :: get_local_sizes !! Returns local starts and counts in `real` and `fourier` spaces procedure , pass ( self ), non_overridable , public :: get_alloc_size !! Wrapper around ``get_local_sizes`` to obtain number of elements only procedure , pass ( self ), non_overridable , public :: get_z_slab_enabled !! Returns logical value is Z-slab optimization is enabled procedure , pass ( self ), non_overridable , public :: get_pencil !! Returns pencil decomposition procedure , pass ( self ), non_overridable , public :: get_element_size !! Returns number of bytes required to store single element. procedure , pass ( self ), non_overridable , public :: get_alloc_bytes !! Returns minimum number of bytes required to execute plan procedure , pass ( self ), non_overridable , public :: get_executor !! Returns FFT Executor associated with plan procedure , pass ( self ), non_overridable , public :: get_dims !! Returns global dimensions procedure , pass ( self ), non_overridable , public :: get_precision !! Returns precision of plan procedure , pass ( self ), non_overridable , public :: report !! Prints plan details procedure , pass ( self ), non_overridable , public :: mem_alloc_ptr !! Allocates memory for type(c_ptr) generic , public :: mem_alloc => & mem_alloc_r32_1d , & mem_alloc_r64_1d , & mem_alloc_r32_2d , & mem_alloc_r64_2d , & mem_alloc_r32_3d , & mem_alloc_r64_3d , & mem_alloc_c32_1d , & mem_alloc_c64_1d , & mem_alloc_c32_2d , & mem_alloc_c64_2d , & mem_alloc_c32_3d , & mem_alloc_c64_3d !! Allocates memory specific for this plan procedure , pass ( self ), non_overridable , public :: mem_free_ptr !! Frees previously allocated memory for type(c_ptr) generic , public :: mem_free => & mem_free_r32_1d , & mem_free_r32_2d , & mem_free_r32_3d , & mem_free_r64_1d , & mem_free_r64_2d , & mem_free_r64_3d , & mem_free_c32_1d , & mem_free_c32_2d , & mem_free_c32_3d , & mem_free_c64_1d , & mem_free_c64_2d , & mem_free_c64_3d !! Frees previously allocated memory specific for this plan #ifdef DTFFT_WITH_CUDA procedure , pass ( self ), non_overridable , public :: get_platform !! Returns plan execution platform procedure , pass ( self ), non_overridable , public :: get_backend !! Returns selected GPU backend during autotuning generic , public :: get_stream & !! Returns CUDA stream associated with plan => get_stream_ptr , & get_stream_int64 procedure , pass ( self ), non_overridable :: get_stream_ptr !! Returns CUDA stream associated with plan procedure , pass ( self ), non_overridable :: get_stream_int64 !! Returns CUDA stream associated with plan #endif procedure , pass ( self ), non_overridable :: execute_private !! Executes plan procedure , pass ( self ), non_overridable :: check_create_args !! Check arguments provided to `create` subroutines procedure , pass ( self ), non_overridable :: create_private !! Creates core procedure , pass ( self ), non_overridable :: alloc_fft_plans !! Allocates `fft_executor` classes procedure , pass ( self ), non_overridable :: check_aux !! Checks if aux buffer was passed !! and if not will allocate one internally procedure , pass ( self ), non_overridable :: mem_alloc_r32_1d !! Allocates memory for 1d real32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r64_1d !! Allocates memory for 1d real64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r32_2d !! Allocates memory for 2d real32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r64_2d !! Allocates memory for 2d real64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r32_3d !! Allocates memory for 2d real32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r64_3d !! Allocates memory for 2d real64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c32_1d !! Allocates memory for 1d complex32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c64_1d !! Allocates memory for 1d complex64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c32_2d !! Allocates memory for 2d complex32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c64_2d !! Allocates memory for 2d complex64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c32_3d !! Allocates memory for 3d complex32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c64_3d !! Allocates memory for 3d complex64 pointer procedure , pass ( self ), non_overridable :: mem_free_r32_1d !! Frees real32 1d pointer procedure , pass ( self ), non_overridable :: mem_free_r64_1d !! Frees real64 1d pointer procedure , pass ( self ), non_overridable :: mem_free_r32_2d !! Frees real32 2d pointer procedure , pass ( self ), non_overridable :: mem_free_r64_2d !! Frees real64 2d pointer procedure , pass ( self ), non_overridable :: mem_free_r32_3d !! Frees real32 3d pointer procedure , pass ( self ), non_overridable :: mem_free_r64_3d !! Frees real64 3d pointer procedure , pass ( self ), non_overridable :: mem_free_c32_1d !! Frees complex32 1d pointer procedure , pass ( self ), non_overridable :: mem_free_c64_1d !! Frees complex64 1d pointer procedure , pass ( self ), non_overridable :: mem_free_c32_2d !! Frees complex32 2d pointer procedure , pass ( self ), non_overridable :: mem_free_c64_2d !! Frees complex64 2d pointer procedure , pass ( self ), non_overridable :: mem_free_c32_3d !! Frees complex32 3d pointer procedure , pass ( self ), non_overridable :: mem_free_c64_3d !! Frees complex64 3d pointer end type dtfft_plan_t type , abstract , extends ( dtfft_plan_t ) :: dtfft_core_c2c !! Abstract C2C Plan private contains private procedure , pass ( self ), non_overridable :: create_c2c_core !! Creates plan for both C2C and R2C end type dtfft_core_c2c type , extends ( dtfft_core_c2c ) :: dtfft_plan_c2c_t !! C2C Plan private contains private generic , public :: create => create_c2c , & create_c2c_pencil !! Creates C2C plan procedure , pass ( self ) :: create_c2c !! Creates C2C plan using global dimensions procedure , pass ( self ) :: create_c2c_pencil !! Creates C2C plan using Pencil of local data procedure , pass ( self ) :: create_c2c_internal !! Private method that combines common logic for C2C plan creation end type dtfft_plan_c2c_t type , extends ( dtfft_core_c2c ) :: dtfft_plan_r2c_t !! R2C Plan private type ( pencil ) :: real_pencil !! \"Real\" pencil decomposition info contains private generic , public :: create => create_r2c , & create_r2c_pencil !! Creates R2C plan procedure , pass ( self ) :: create_r2c !! Creates R2C plan using global dimensions procedure , pass ( self ) :: create_r2c_pencil !! Creates R2C plan using Pencil of local data procedure , pass ( self ) :: create_r2c_internal !! Private method that combines common logic for R2C plan creation end type dtfft_plan_r2c_t type , extends ( dtfft_plan_t ) :: dtfft_plan_r2r_t !! R2R Plan private contains private generic , public :: create => create_r2r , & create_r2r_pencil !! Creates R2R plan procedure , pass ( self ) :: create_r2r !! Creates R2R plan using global dimensions procedure , pass ( self ) :: create_r2r_pencil !! Creates R2R plan using Pencil of local data procedure , pass ( self ) :: create_r2r_internal !! Private method that combines common logic for R2R plan creation end type dtfft_plan_r2r_t contains subroutine transpose ( self , in , out , transpose_type , error_code ) !! Performs single transposition !! !! @note !! Buffers `in` and `out` cannot be the same !! @endnote class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( * ), target , intent ( inout ) :: in (..) !! Incoming buffer of any rank and kind. Note that this buffer !! will be modified in GPU build type ( * ), target , intent ( inout ) :: out (..) !! Resulting buffer of any rank and kind type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user call self % transpose_ptr ( c_loc ( in ), c_loc ( out ), transpose_type , error_code ) end subroutine transpose subroutine transpose_ptr ( self , in , out , transpose_type , error_code ) !! Performs single transposition using type(c_ptr) pointers instead of buffers !! !! @note !! Buffers `in` and `out` cannot be the same !! @endnote class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Incoming pointer. Note that values of this pointer !! will be modified in GPU build type ( c_ptr ), intent ( in ) :: out !! Resulting pointer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( . not . is_valid_transpose_type ( transpose_type ) & . or . ( self % ndims == 2 . and . abs ( transpose_type % val ) > 1 ) & . or . ( abs ( transpose_type % val ) == DTFFT_TRANSPOSE_X_TO_Z % val . and .. not . self % is_z_slab )) & ierr = DTFFT_ERROR_INVALID_TRANSPOSE_TYPE CHECK_ERROR_AND_RETURN if ( is_same_ptr ( in , out ) ) & ierr = DTFFT_ERROR_INPLACE_TRANSPOSE CHECK_ERROR_AND_RETURN select type ( self ) class is ( dtfft_plan_r2c_t ) ierr = DTFFT_ERROR_R2C_TRANSPOSE_CALLED CHECK_ERROR_AND_RETURN endselect #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_CUDA ) then ierr = check_device_pointers ( in , out , self % plan % get_backend (), c_null_ptr ) CHECK_ERROR_AND_RETURN endif #endif REGION_BEGIN ( \"dtfft_transpose\" , COLOR_TRANSPOSE ) call self % plan % execute ( in , out , transpose_type ) REGION_END ( \"dtfft_transpose\" ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine transpose_ptr subroutine execute ( self , in , out , execute_type , aux , error_code ) !! Executes plan class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( * ), target , intent ( inout ) :: in (..) !! Incoming buffer of any rank and kind type ( * ), target , intent ( inout ) :: out (..) !! Resulting buffer of any rank and kind type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution. type ( * ), target , optional , intent ( inout ) :: aux (..) !! Optional auxiliary buffer. !! Size of buffer must be greater than value !! returned by `alloc_size` parameter of [[dtfft_plan_t(type):get_local_sizes]] subroutine integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user type ( c_ptr ) :: aux_ptr aux_ptr = c_null_ptr ; if ( present ( aux ) ) aux_ptr = c_loc ( aux ) call self % execute_ptr ( c_loc ( in ), c_loc ( out ), execute_type , aux_ptr , error_code ) end subroutine execute subroutine execute_ptr ( self , in , out , execute_type , aux , error_code ) !! Executes plan using type(c_ptr) pointers instead of buffers class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Incoming pointer. Note that values of this pointer !! will be modified in GPU build type ( c_ptr ), intent ( in ) :: out !! Resulting pointer type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution. type ( c_ptr ), intent ( in ) :: aux !! Optional auxiliary buffer. !! Size of buffer must be greater than value !! returned by `alloc_size` parameter of [[dtfft_plan_t(type):get_local_sizes]] subroutine integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code logical :: inplace !! Inplace execution flag inplace = is_same_ptr ( in , out ) ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( . not . is_valid_execute_type ( execute_type ) ) ierr = DTFFT_ERROR_INVALID_TRANSPOSE_TYPE CHECK_ERROR_AND_RETURN if ( self % is_transpose_plan . and . self % ndims == 2 . and . inplace ) ierr = DTFFT_ERROR_INPLACE_TRANSPOSE CHECK_ERROR_AND_RETURN if ( is_same_ptr ( in , aux ) . or . is_same_ptr ( out , aux ) ) ierr = DTFFT_ERROR_INVALID_AUX CHECK_ERROR_AND_RETURN #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_CUDA ) then ierr = check_device_pointers ( in , out , self % plan % get_backend (), aux ) CHECK_ERROR_AND_RETURN endif #endif REGION_BEGIN ( \"dtfft_execute\" , COLOR_EXECUTE ) call self % check_aux ( aux ) if ( . not . is_null_ptr ( aux ) ) then call self % execute_private ( in , out , execute_type , aux , inplace ) else call self % execute_private ( in , out , execute_type , self % aux_ptr , inplace ) endif REGION_END ( \"dtfft_execute\" ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine execute_ptr subroutine execute_private ( self , in , out , execute_type , aux , inplace ) !! Executes plan with specified auxiliary buffer class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Source pointer type ( c_ptr ), intent ( in ) :: out !! Target pointer type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution. type ( c_ptr ), intent ( in ) :: aux !! Auxiliary pointer. logical , intent ( in ) :: inplace !! Inplace execution flag if ( self % is_transpose_plan ) then select case ( self % ndims ) case ( 2 ) select case ( execute_type % val ) case ( DTFFT_EXECUTE_FORWARD % val ) call self % plan % execute ( in , out , DTFFT_TRANSPOSE_X_TO_Y ) case ( DTFFT_EXECUTE_BACKWARD % val ) call self % plan % execute ( in , out , DTFFT_TRANSPOSE_Y_TO_X ) endselect case ( 3 ) select case ( execute_type % val ) case ( DTFFT_EXECUTE_FORWARD % val ) if ( inplace . or . . not . self % is_z_slab ) then call self % plan % execute ( in , aux , DTFFT_TRANSPOSE_X_TO_Y ) call self % plan % execute ( aux , out , DTFFT_TRANSPOSE_Y_TO_Z ) return endif call self % plan % execute ( in , out , DTFFT_TRANSPOSE_X_TO_Z ) case ( DTFFT_EXECUTE_BACKWARD % val ) if ( inplace . or . . not . self % is_z_slab ) then call self % plan % execute ( in , aux , DTFFT_TRANSPOSE_Z_TO_Y ) call self % plan % execute ( aux , out , DTFFT_TRANSPOSE_Y_TO_X ) return endif call self % plan % execute ( in , out , DTFFT_TRANSPOSE_Z_TO_X ) endselect endselect return endif ! self%is_transpose_plan select case ( execute_type % val ) case ( DTFFT_EXECUTE_FORWARD % val ) ! 1d direct FFT X direction || 2d X-Y FFT call self % fft ( 1 )% fft % execute ( in , aux , FFT_FORWARD ) if ( self % is_z_slab ) then ! Transpose X -> Z call self % plan % execute ( aux , out , DTFFT_TRANSPOSE_X_TO_Z ) ! 1d direct FFT Z direction call self % fft ( 3 )% fft % execute ( out , out , FFT_FORWARD ) return endif ! Transpose X -> Y call self % plan % execute ( aux , out , DTFFT_TRANSPOSE_X_TO_Y ) ! 1d FFT Y direction call self % fft ( self % fft_mapping ( 2 ))% fft % execute ( out , out , FFT_FORWARD ) if ( self % ndims == 2 ) then return endif ! Transpose Y -> Z call self % plan % execute ( out , aux , DTFFT_TRANSPOSE_Y_TO_Z ) ! 1d direct FFT Z direction call self % fft ( self % fft_mapping ( 3 ))% fft % execute ( aux , out , FFT_FORWARD ) case ( DTFFT_EXECUTE_BACKWARD % val ) if ( self % is_z_slab ) then ! 1d inverse FFT Z direction call self % fft ( 3 )% fft % execute ( in , in , FFT_BACKWARD ) ! Transpose Z -> X call self % plan % execute ( in , aux , DTFFT_TRANSPOSE_Z_TO_X ) ! 2d inverse FFT X-Y direction call self % fft ( 1 )% fft % execute ( aux , out , FFT_BACKWARD ) return endif if ( self % ndims == 3 ) then ! 1d inverse FFT Z direction call self % fft ( self % fft_mapping ( 3 ))% fft % execute ( in , aux , FFT_BACKWARD ) ! Transpose Z -> Y call self % plan % execute ( aux , in , DTFFT_TRANSPOSE_Z_TO_Y ) endif ! 1d inverse FFT Y direction call self % fft ( self % fft_mapping ( 2 ))% fft % execute ( in , in , FFT_BACKWARD ) ! Transpose Y -> X call self % plan % execute ( in , aux , DTFFT_TRANSPOSE_Y_TO_X ) ! 1d inverse FFT X direction call self % fft ( 1 )% fft % execute ( aux , out , FFT_BACKWARD ) endselect end subroutine execute_private subroutine destroy ( self , error_code ) !! Destroys plan, frees all memory class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: d !! Counter integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN REGION_BEGIN ( \"dtfft_destroy\" , COLOR_DESTROY ) if ( allocated ( self % dims ) ) deallocate ( self % dims ) select type ( self ) class is ( dtfft_plan_r2c_t ) call self % real_pencil % destroy () endselect if ( allocated ( self % pencils ) ) then do d = 1 , self % ndims call self % pencils ( d )% destroy () enddo deallocate ( self % pencils ) endif if ( self % is_aux_alloc ) then call self % mem_free_ptr ( self % aux_ptr ) self % is_aux_alloc = . false . endif if ( allocated ( self % fft ) ) then do d = 1 , self % ndims call self % fft ( d )% fft % destroy () if ( allocated ( self % fft ( d )% fft ) ) deallocate ( self % fft ( d )% fft ) enddo deallocate ( self % fft ) endif self % is_created = . false . self % is_aux_alloc = . false . #ifdef DTFFT_WITH_CUDA call destroy_stream () #endif block logical :: is_finalized call MPI_Finalized ( is_finalized , ierr ) if ( is_finalized ) ierr = DTFFT_ERROR_MPI_FINALIZED CHECK_ERROR_AND_RETURN end block if ( allocated ( self % plan ) ) then call self % plan % destroy () deallocate ( self % plan ) endif #ifdef DTFFT_WITH_CUDA call clean_unused_cache () #endif if ( allocated ( self % comms ) ) then do d = 1 , self % ndims call MPI_Comm_free ( self % comms ( d ), ierr ) enddo deallocate ( self % comms ) endif call MPI_Comm_free ( self % comm , ierr ) self % ndims = - 1 if ( present ( error_code ) ) error_code = DTFFT_SUCCESS REGION_END ( \"dtfft_destroy\" ) end subroutine destroy logical function get_z_slab_enabled ( self , error_code ) !! Returns logical value is Z-slab optimization enabled internally class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_z_slab_enabled = . false . if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED if ( present ( error_code ) ) error_code = ierr if ( ierr /= DTFFT_SUCCESS ) return get_z_slab_enabled = self % is_z_slab end function get_z_slab_enabled type ( dtfft_pencil_t ) function get_pencil ( self , dim , error_code ) !! Returns pencil decomposition class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), intent ( in ) :: dim !! Required dimension: !! !!  - 0 for XYZ layout (real space, R2C only) !!  - 1 for XYZ layout !!  - 2 for YXZ layout !!  - 3 for ZXY layout !! !! [//]: # (ListBreak) integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code integer ( int32 ) :: min_dim ierr = DTFFT_SUCCESS ! get_pencil = dtfft_pencil_t(-1,-1,-1,-1) if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN select type ( self ) class is ( dtfft_plan_r2c_t ) min_dim = 0 class default min_dim = 1 endselect if ( dim < min_dim . or . dim > self % ndims ) ierr = DTFFT_ERROR_INVALID_DIM CHECK_ERROR_AND_RETURN if ( dim == 0 ) then select type ( self ) class is ( dtfft_plan_r2c_t ) get_pencil = self % real_pencil % make_public () endselect else get_pencil = self % pencils ( dim )% make_public () endif if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_pencil integer ( int64 ) function get_element_size ( self , error_code ) !! Returns number of bytes required to store single element. class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_element_size = 0 if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN select type ( self ) class is ( dtfft_plan_r2c_t ) get_element_size = self % storage_size / 2 class default get_element_size = self % storage_size endselect if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_element_size integer ( int64 ) function get_alloc_bytes ( self , error_code ) !! Returns minimum number of bytes required to execute plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code integer ( int64 ) :: alloc_size !! Number of elements required integer ( int64 ) :: element_size !! Size of each element ierr = DTFFT_SUCCESS get_alloc_bytes = 0 if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN alloc_size = self % get_alloc_size () element_size = self % get_element_size () get_alloc_bytes = alloc_size * element_size if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_alloc_bytes type ( dtfft_executor_t ) function get_executor ( self , error_code ) !! Returns FFT Executor associated with plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_executor = dtfft_executor_t ( VARIABLE_NOT_SET ) if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN get_executor = self % executor if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_executor subroutine get_dims ( self , dims , error_code ) !! Returns global dimensions class ( dtfft_plan_t ), target , intent ( in ) :: self !! Abstract plan integer ( int32 ), pointer , intent ( out ) :: dims (:) !! Global dimensions integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN dims => self % dims if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine get_dims type ( dtfft_precision_t ) function get_precision ( self , error_code ) !! Returns precision of the plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_precision = dtfft_precision_t ( VARIABLE_NOT_SET ) if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN get_precision = self % precision if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_precision subroutine report ( self , error_code ) !! Prints plan-related information to stdout class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code integer ( int32 ) :: comm_dims ( self % ndims ) !! Communicator dimensions integer ( int32 ) :: d !! Counter ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN WRITE_REPORT ( \"**Plan report**\" ) WRITE_REPORT ( \"  dtFFT Version        :  \" // int_to_str ( dtfft_get_version ())) WRITE_REPORT ( \"  Number of dimensions :  \" // int_to_str ( self % ndims )) do d = 2 , self % ndims call MPI_Comm_size ( self % comms ( d ), comm_dims ( d ), ierr ) enddo if ( self % ndims == 2 ) then WRITE_REPORT ( \"  Global dimensions    :  \" // int_to_str ( self % dims ( 1 )) // \"x\" // int_to_str ( self % dims ( 2 ))) WRITE_REPORT ( \"  Grid decomposition   :  1x\" // int_to_str ( comm_dims ( 2 ))) else WRITE_REPORT ( \"  Global dimensions    :  \" // int_to_str ( self % dims ( 1 )) // \"x\" // int_to_str ( self % dims ( 2 )) // \"x\" // int_to_str ( self % dims ( 3 ))) WRITE_REPORT ( \"  Grid decomposition   :  1x\" // int_to_str ( comm_dims ( 2 )) // \"x\" // int_to_str ( comm_dims ( 3 ))) endif #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_HOST ) then WRITE_REPORT ( \"  Execution platform   :  HOST\" ) else WRITE_REPORT ( \"  Execution platform   :  CUDA\" ) endif #endif select type ( self ) class is ( dtfft_plan_c2c_t ) WRITE_REPORT ( \"  Plan type            :  Complex-to-Complex\" ) class is ( dtfft_plan_r2r_t ) WRITE_REPORT ( \"  Plan type            :  Real-to-Real\" ) class is ( dtfft_plan_r2c_t ) WRITE_REPORT ( \"  Plan type            :  Real-to-Complex\" ) endselect WRITE_REPORT ( \"  Plan precision       :  \" // dtfft_get_precision_string ( self % precision )) WRITE_REPORT ( \"  FFT Executor type    :  \" // dtfft_get_executor_string ( self % executor )) if ( self % ndims == 3 ) then if ( self % is_z_slab ) then WRITE_REPORT ( \"  Z-slab enabled       :  True\" ) else WRITE_REPORT ( \"  Z-slab enabled       :  False\" ) endif endif #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_CUDA ) then WRITE_REPORT ( \"  GPU Backend          :  \" // dtfft_get_backend_string ( self % plan % get_backend ())) endif #endif WRITE_REPORT ( \"**End of report**\" ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine report #ifdef DTFFT_WITH_CUDA type ( dtfft_platform_t ) function get_platform ( self , error_code ) !! Returns execution platform of the plan (HOST or CUDA) class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_platform = PLATFORM_NOT_SET if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED if ( present ( error_code ) ) error_code = ierr if ( ierr /= DTFFT_SUCCESS ) return get_platform = self % platform end function get_platform type ( dtfft_backend_t ) function get_backend ( self , error_code ) !! Returns selected GPU backend during autotuning class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_backend = BACKEND_NOT_SET if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED if ( present ( error_code ) ) error_code = ierr if ( ierr /= DTFFT_SUCCESS ) return get_backend = self % plan % get_backend () end function get_backend subroutine get_stream_ptr ( self , stream , error_code ) !! Returns CUDA stream associated with plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan type ( dtfft_stream_t ), intent ( out ) :: stream !! dtFFT Stream integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS stream = NULL_STREAM if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( self % platform == DTFFT_PLATFORM_HOST ) ierr = DTFFT_ERROR_INVALID_USAGE CHECK_ERROR_AND_RETURN stream = self % stream if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine get_stream_ptr subroutine get_stream_int64 ( self , stream , error_code ) !! Returns CUDA stream associated with plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int64 ), intent ( out ) :: stream !! CUDA-Fortran Stream integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code type ( dtfft_stream_t ) :: stream_ !! dtFFT Stream call self % get_stream ( stream_ , error_code = ierr ) if ( ierr == DTFFT_SUCCESS ) stream = dtfft_get_cuda_stream ( stream_ ) if ( present ( error_code ) ) error_code = ierr end subroutine get_stream_int64 integer ( int32 ) function check_device_pointers ( in , out , backend , aux ) result ( error_code ) !! Checks if device pointers are provided by user type ( c_ptr ), intent ( in ) :: in !! First pointer type ( c_ptr ), intent ( in ) :: out !! Second pointer type ( dtfft_backend_t ), intent ( in ) :: backend !! Backend. Required to check for `nvshmem` pointer type ( c_ptr ), intent ( in ) :: aux !! Optional auxiliary pointer. logical ( c_bool ) :: is_devptr !! Are pointers device pointers? error_code = DTFFT_SUCCESS if ( is_backend_nvshmem ( backend ) ) then #ifdef DTFFT_WITH_NVSHMEM is_devptr = is_nvshmem_ptr ( in ) . and . is_nvshmem_ptr ( out ) if ( . not . is_null_ptr ( aux ) ) is_devptr = is_devptr . and . is_nvshmem_ptr ( aux ) if ( . not . is_devptr ) error_code = DTFFT_ERROR_NOT_NVSHMEM_PTR #endif else is_devptr = is_device_ptr ( in ) . and . is_device_ptr ( out ) if ( . not . is_null_ptr ( aux ) ) is_devptr = is_devptr . and . is_device_ptr ( aux ) if ( . not . is_devptr ) error_code = DTFFT_ERROR_NOT_DEVICE_PTR endif end function check_device_pointers #endif subroutine get_local_sizes ( self , in_starts , in_counts , out_starts , out_counts , alloc_size , error_code ) !! Obtain local starts and counts in ``real`` and ``fourier`` spaces class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: in_starts (:) !! Starts of local portion of data in ``real`` space (0-based) integer ( int32 ), optional , intent ( out ) :: in_counts (:) !! Number of elements of local portion of data in 'real' space integer ( int32 ), optional , intent ( out ) :: out_starts (:) !! Starts of local portion of data in ``fourier`` space (0-based) integer ( int32 ), optional , intent ( out ) :: out_counts (:) !! Number of elements of local portion of data in ``fourier`` space integer ( int64 ), optional , intent ( out ) :: alloc_size !! Minimal number of elements required to execute plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( . not . present ( in_starts ) & . and .. not . present ( in_counts ) & . and .. not . present ( out_starts ) & . and .. not . present ( out_counts ) & . and .. not . present ( alloc_size )) ierr = DTFFT_ERROR_INVALID_USAGE CHECK_ERROR_AND_RETURN select type ( self ) class is ( dtfft_plan_r2c_t ) if ( present ( in_starts ) ) in_starts ( 1 : self % ndims ) = self % real_pencil % starts ( 1 : self % ndims ) if ( present ( in_counts ) ) in_counts ( 1 : self % ndims ) = self % real_pencil % counts ( 1 : self % ndims ) call get_local_sizes_private ( self % pencils , out_starts = out_starts , out_counts = out_counts , alloc_size = alloc_size ) if ( present ( alloc_size ) ) alloc_size = max ( int ( product ( self % real_pencil % counts ), int64 ), 2 * alloc_size ) class default call get_local_sizes_private ( self % pencils , in_starts , in_counts , out_starts , out_counts , alloc_size ) endselect #ifdef DTFFT_WITH_CUDA if ( is_backend_nvshmem ( self % plan % get_backend () ) . and . present ( alloc_size ) ) then block integer ( int64 ) :: aux_size ! cufftMp pipelined may require aux buffer that is larger than ! required by dtfft. in such case we must make sure that ! buffer allocated by user is large enough aux_size = self % plan % get_aux_size () alloc_size = max ( alloc_size , aux_size / self % storage_size ) call MPI_Allreduce ( MPI_IN_PLACE , alloc_size , 1 , MPI_INTEGER8 , MPI_MAX , self % comm , ierr ) endblock endif #endif if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine get_local_sizes function get_alloc_size ( self , error_code ) result ( alloc_size ) !! Wrapper around ``get_local_sizes`` to obtain number of elements only class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int64 ) :: alloc_size !! Minimal number of elements required to execute plan call self % get_local_sizes ( alloc_size = alloc_size , error_code = error_code ) end function get_alloc_size integer ( int32 ) function create_private ( self , sngl_type , sngl_storage_size , dbl_type , dbl_storage_size , dims , pencil , comm , precision , effort , executor , kinds ) #define __FUNC__ create_private !! Creates core class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan TYPE_MPI_DATATYPE , intent ( in ) :: sngl_type !! MPI_Datatype for single precision plan integer ( int64 ), intent ( in ) :: sngl_storage_size !! Number of bytes needed to store single element (single precision) TYPE_MPI_DATATYPE , intent ( in ) :: dbl_type !! MPI_Datatype for double precision plan integer ( int64 ), intent ( in ) :: dbl_storage_size !! Number of bytes needed to store single element (double precision) integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of local portion of data TYPE_MPI_COMM , optional , intent ( in ) :: comm !! User-defined communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Precision of transform: `DTFFT_SINGLE` or `DTFFT_DOUBLE` type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform TYPE_MPI_DATATYPE :: base_dtype !! MPI_Datatype for current precision integer ( int64 ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_COMM :: comm_ !! MPI Communicator integer ( int8 ) :: d !! Counter create_private = DTFFT_SUCCESS CHECK_INTERNAL_CALL ( self % check_create_args ( dims , pencil , comm , precision , effort , executor , kinds ) ) select case ( self % precision % val ) case ( DTFFT_SINGLE % val ) base_storage = sngl_storage_size base_dtype = sngl_type case ( DTFFT_DOUBLE % val ) base_storage = dbl_storage_size base_dtype = dbl_type case default INTERNAL_ERROR ( \"unknown precision\" ) endselect self % storage_size = base_storage if ( allocated ( self % pencils ) ) then do d = 1 , size ( self % pencils ) call self % pencils ( d )% destroy () enddo deallocate ( self % pencils ) endif if ( allocated ( self % comms ) ) then ! Can potentially lose some memory deallocate ( self % comms ) endif if ( allocated ( self % plan ) ) then call self % plan % destroy () deallocate ( self % plan ) endif allocate ( self % pencils ( self % ndims )) allocate ( self % comms ( self % ndims )) comm_ = MPI_COMM_WORLD ; if ( present ( comm ) ) comm_ = comm #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_CUDA ) then block TYPE_MPI_COMM :: local_comm integer ( int32 ) :: n_devices , current_device , local_rank , local_size , ierr integer ( int32 ), allocatable :: local_devices (:) call MPI_Comm_split_Type ( comm_ , MPI_COMM_TYPE_SHARED , 0 , MPI_INFO_NULL , local_comm , ierr ) call MPI_Comm_size ( local_comm , local_size , ierr ) call MPI_Comm_rank ( local_comm , local_rank , ierr ) allocate ( local_devices ( local_size ) ) CUDA_CALL ( \"cudaGetDeviceCount\" , cudaGetDeviceCount ( n_devices ) ) CUDA_CALL ( \"cudaGetDevice\" , cudaGetDevice ( current_device ) ) call MPI_Allgather ( current_device , 1 , MPI_INTEGER4 , local_devices , 1 , MPI_INTEGER4 , local_comm , ierr ) call MPI_Comm_free ( local_comm , ierr ) if ( count_unique ( local_devices ) /= local_size ) then create_private = DTFFT_ERROR_GPU_NOT_SET return endif deallocate ( local_devices ) endblock endif if ( get_user_gpu_backend () == DTFFT_BACKEND_MPI_DATATYPE . or . self % platform == DTFFT_PLATFORM_HOST ) then allocate ( transpose_plan_host :: self % plan ) else allocate ( transpose_plan_cuda :: self % plan ) self % stream = get_user_stream () endif #else allocate ( transpose_plan_host :: self % plan ) #endif if ( present ( pencil ) ) then block integer ( int32 ), allocatable :: fixed_dims (:) type ( pencil_init ) :: ipencil CHECK_INTERNAL_CALL ( ipencil % create ( pencil , comm_ ) ) ! After creating internal pencil and validating user passed pencil ! We finally know global dimensions `dims` allocate ( self % dims , source = ipencil % dims ) allocate ( fixed_dims , source = self % dims ) select type ( self ) class is ( dtfft_plan_r2c_t ) fixed_dims ( 1 ) = fixed_dims ( 1 ) / 2 + 1 ipencil % counts ( 1 ) = ipencil % counts ( 1 ) / 2 + 1 endselect CHECK_INTERNAL_CALL ( self % plan % create ( fixed_dims , comm_ , self % effort , base_dtype , base_storage , self % comm , self % comms , self % pencils , ipencil ) ) select type ( self ) class is ( dtfft_plan_r2c_t ) ipencil % counts ( 1 ) = ( ipencil % counts ( 1 ) - 1 ) * 2 call self % real_pencil % create ( self % ndims , 1_int8 , self % dims , self % comms , ipencil % starts , ipencil % counts ) endselect deallocate ( fixed_dims ) call ipencil % destroy () endblock else CHECK_INTERNAL_CALL ( self % plan % create ( dims , comm_ , self % effort , base_dtype , base_storage , self % comm , self % comms , self % pencils ) ) endif self % is_z_slab = self % plan % is_z_slab call self % alloc_fft_plans ( kinds ) self % is_aux_alloc = . false . #undef __FUNC__ end function create_private integer ( int32 ) function check_create_args ( self , dims , pencil , comm , precision , effort , executor , kinds ) #define __FUNC__ check_create_args !! Check arguments provided by user and sets private variables class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of local portion of data TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Optional MPI Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Precision of transform: `DTFFT_SINGLE` or `DTFFT_DOUBLE` type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform integer ( int32 ) :: ierr !! Error code integer ( int32 ) :: top_type !! MPI Comm topology type integer ( int32 ) :: dim !! Counter CHECK_INTERNAL_CALL ( init_internal () ) self % platform = get_user_platform () if ( . not . present ( dims ) . and . . not . present ( pencil ) ) INTERNAL_ERROR ( \".not.present(dims) .and. .not.present(pencil)\" ) if ( present ( dims ) . and . present ( pencil ) ) INTERNAL_ERROR ( \"present(dims) .and. present(pencil)\" ) if ( allocated ( self % dims ) ) deallocate ( self % dims ) if ( present ( dims ) ) then self % ndims = size ( dims , kind = int8 ) CHECK_INPUT_PARAMETER ( self % ndims , is_valid_dimension , DTFFT_ERROR_INVALID_N_DIMENSIONS ) if ( any ([( dims ( dim ) <= 0 , dim = 1 , self % ndims )]) ) then check_create_args = DTFFT_ERROR_INVALID_DIMENSION_SIZE return endif allocate ( self % dims , source = dims ) else self % ndims = pencil % ndims if ( self % ndims == 0 ) then check_create_args = DTFFT_ERROR_PENCIL_NOT_INITIALIZED return endif endif if ( present ( comm ) ) then call MPI_Topo_test ( comm , top_type , ierr ) CHECK_INPUT_PARAMETER ( top_type , is_valid_comm_type , DTFFT_ERROR_INVALID_COMM_TYPE ) endif self % precision = DTFFT_DOUBLE if ( present ( precision ) ) then CHECK_INPUT_PARAMETER ( precision , is_valid_precision , DTFFT_ERROR_INVALID_PRECISION ) self % precision = precision endif self % effort = DTFFT_ESTIMATE if ( present ( effort ) ) then CHECK_INPUT_PARAMETER ( effort , is_valid_effort , DTFFT_ERROR_INVALID_EFFORT ) self % effort = effort endif self % is_transpose_plan = . false . self % executor = DTFFT_EXECUTOR_NONE if ( present ( executor ) ) then CHECK_INPUT_PARAMETER ( executor , is_valid_executor , DTFFT_ERROR_INVALID_EXECUTOR ) #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_HOST ) then CHECK_INPUT_PARAMETER ( executor , is_host_executor , DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR_TYPE ) else if ( self % platform == DTFFT_PLATFORM_CUDA ) then CHECK_INPUT_PARAMETER ( executor , is_cuda_executor , DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR_TYPE ) endif #endif self % executor = executor endif if ( self % executor == DTFFT_EXECUTOR_NONE ) self % is_transpose_plan = . true . if ( present ( kinds ) . and . . not . self % is_transpose_plan ) then do dim = 1 , self % ndims CHECK_INPUT_PARAMETER ( kinds ( dim ), is_valid_r2r_kind , DTFFT_ERROR_INVALID_R2R_KINDS ) enddo endif #undef __FUNC__ end function check_create_args subroutine alloc_fft_plans ( self , kinds ) !! Allocates [[abstract_executor]] with required FFT class !! and populates [[dtfft_plan_t(type):fft_mapping]] with similar FFT ids class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform integer ( int8 ) :: dim , dim2 !! Counters type ( dtfft_r2r_kind_t ), allocatable :: kinds_ (:) !! Dummy kinds if ( self % is_transpose_plan ) return allocate ( self % fft ( self % ndims )) allocate ( self % fft_mapping ( self % ndims )) do dim = 1 , self % ndims self % fft_mapping ( dim ) = dim select case ( self % executor % val ) #ifdef DTFFT_WITH_FFTW case ( DTFFT_EXECUTOR_FFTW3 % val ) if ( dim == 1 ) then WRITE_DEBUG ( \"Using FFTW3 executor\" ) endif allocate ( fftw_executor :: self % fft ( dim )% fft ) #endif #ifdef DTFFT_WITH_MKL case ( DTFFT_EXECUTOR_MKL % val ) if ( dim == 1 ) then WRITE_DEBUG ( \"Using MKL executor\" ) endif allocate ( mkl_executor :: self % fft ( dim )% fft ) #endif #ifdef DTFFT_WITH_CUFFT case ( DTFFT_EXECUTOR_CUFFT % val ) if ( dim == 1 ) then WRITE_DEBUG ( \"Using CUFFT executor\" ) endif allocate ( cufft_executor :: self % fft ( dim )% fft ) #endif #ifdef DTFFT_WITH_VKFFT case ( DTFFT_EXECUTOR_VKFFT % val ) if ( dim == 1 ) then WRITE_DEBUG ( \"Using VkFFT executor\" ) endif allocate ( vkfft_executor :: self % fft ( dim )% fft ) #endif case default INTERNAL_ERROR ( \"Executor type unrecognized\" ) endselect enddo if ( self % is_z_slab ) return allocate ( kinds_ ( self % ndims )) kinds_ (:) = dtfft_r2r_kind_t ( - 1 ); if ( present ( kinds ) ) kinds_ (:) = kinds (:) ! Searching for similar FFT transforms in order to reduce time of plan creation ! and reduce memory usage ! Most profitable in GPU build do dim = 1_int8 , self % ndims do dim2 = 1_int8 , dim - 1_int8 if ( dim == dim2 ) cycle select type ( self ) class is ( dtfft_plan_r2c_t ) if ( dim == 1 ) cycle endselect if ( self % pencils ( dim )% counts ( 1 ) == self % pencils ( dim2 )% counts ( 1 ) & . and . product ( self % pencils ( dim )% counts ) == product ( self % pencils ( dim2 )% counts ) & . and . kinds_ ( dim ) == kinds_ ( dim2 ) ) then self % fft_mapping ( dim ) = dim2 endif enddo enddo deallocate ( kinds_ ) end subroutine alloc_fft_plans subroutine check_aux ( self , aux ) !! Checks if aux buffer was passed by user and if not will allocate one internally class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: aux !! Optional auxiliary buffer. integer ( int64 ) :: alloc_size !! Number of elements to be allocated character ( len = 100 ) :: debug_msg !! Logging allocation size integer ( int32 ) :: ierr if ( self % is_aux_alloc . or . . not . is_null_ptr ( aux ) ) return alloc_size = self % get_alloc_size () * self % get_element_size () write ( debug_msg , '(a, i0, a)' ) \"Allocating auxiliary buffer of \" , alloc_size , \" bytes\" WRITE_DEBUG ( debug_msg ) ! self%aux_ptr = self%mem_alloc(alloc_size, error_code=ierr); DTFFT_CHECK(ierr) call self % mem_alloc_ptr ( alloc_size , self % aux_ptr , ierr ); DTFFT_CHECK ( ierr ) self % is_aux_alloc = . true . end subroutine check_aux subroutine create_r2r ( self , dims , kinds , comm , precision , effort , executor , error_code ) !! R2R Plan Constructor class ( dtfft_plan_r2r_t ), intent ( inout ) :: self !! R2R Plan integer ( int32 ), intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_r2r_internal ( dims = dims , kinds = kinds , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_r2r subroutine create_r2r_pencil ( self , pencil , kinds , comm , precision , effort , executor , error_code ) !! R2R Plan Constructor class ( dtfft_plan_r2r_t ), intent ( inout ) :: self !! R2R Plan type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Local pencil of data to be transformed type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_r2r_internal ( pencil = pencil , kinds = kinds , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_r2r_pencil integer ( int32 ) function create_r2r_internal ( self , dims , pencil , kinds , comm , precision , effort , executor ) !! Creates plan for R2R plans #define __FUNC__ create_r2r_internal class ( dtfft_plan_r2r_t ), intent ( inout ) :: self !! R2R Plan integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of data to be transformed type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int8 ) :: fft_rank !! Rank of FFT transform integer ( int32 ) :: dim !! Counter type ( dtfft_r2r_kind_t ) :: r2r_kinds ( 2 ) !! Transposed Kinds of R2R transform create_r2r_internal = DTFFT_SUCCESS if ( self % is_created ) then create_r2r_internal = DTFFT_ERROR_PLAN_IS_CREATED return endif REGION_BEGIN ( \"dtfft_create_r2r\" , COLOR_CREATE ) CHECK_INTERNAL_CALL ( self % create_private ( MPI_REAL , FLOAT_STORAGE_SIZE , MPI_REAL8 , DOUBLE_STORAGE_SIZE , dims = dims , pencil = pencil , comm = comm , precision = precision , effort = effort , executor = executor , kinds = kinds ) ) if ( . not . self % is_transpose_plan ) then if ( . not . present ( kinds ) ) then create_r2r_internal = DTFFT_ERROR_MISSING_R2R_KINDS return endif do dim = 1 , self % ndims r2r_kinds ( 1 ) = kinds ( dim ) fft_rank = FFT_1D if ( self % is_z_slab . and . dim == 1 ) then r2r_kinds ( 1 ) = kinds ( 2 ) r2r_kinds ( 2 ) = kinds ( 1 ) fft_rank = FFT_2D endif if ( self % is_z_slab . and . dim == 2 ) cycle CHECK_INTERNAL_CALL ( self % fft ( self % fft_mapping ( dim ))% fft % create ( fft_rank , FFT_R2R , self % precision , real_pencil = self % pencils ( dim ), r2r_kinds = r2r_kinds ) ) enddo endif self % is_created = . true . REGION_END ( \"dtfft_create_r2r\" ) #undef __FUNC__ end function create_r2r_internal subroutine create_c2c ( self , dims , comm , precision , effort , executor , error_code ) !! C2C Plan Constructor class ( dtfft_plan_c2c_t ), intent ( inout ) :: self !! C2C Plan integer ( int32 ), intent ( in ) :: dims (:) !! Global dimensions of transform TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( self % is_created ) ierr = DTFFT_ERROR_PLAN_IS_CREATED CHECK_ERROR_AND_RETURN REGION_BEGIN ( \"create_c2c\" , COLOR_CREATE ) CHECK_OPTIONAL_CALL ( self % create_c2c_core ( dims , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS self % is_created = . true . REGION_END ( \"create_c2c\" ) end subroutine create_c2c subroutine create_c2c_pencil ( self , pencil , comm , precision , effort , executor , error_code ) !! C2C Plan Constructor class ( dtfft_plan_c2c_t ), intent ( inout ) :: self !! C2C Plan type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Local pencil of data to be transformed TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_c2c_internal ( pencil = pencil , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_c2c_pencil integer ( int32 ) function create_c2c_internal ( self , dims , pencil , comm , precision , effort , executor ) !! Private method that combines common logic for C2C plan creation #define __FUNC__ create_c2c_internal class ( dtfft_plan_c2c_t ), intent ( inout ) :: self !! C2C Plan integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of data to be transformed TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor create_c2c_internal = DTFFT_SUCCESS if ( self % is_created ) then create_c2c_internal = DTFFT_ERROR_PLAN_IS_CREATED return endif REGION_BEGIN ( \"create_c2c\" , COLOR_CREATE ) CHECK_INTERNAL_CALL ( self % create_c2c_core ( dims , pencil , comm , precision , effort , executor ) ) self % is_created = . true . REGION_END ( \"create_c2c\" ) #undef __FUNC__ end function create_c2c_internal integer ( int32 ) function create_c2c_core ( self , dims , pencil , comm , precision , effort , executor ) !! Creates plan for both C2C and R2C #define __FUNC__ create_c2c_core class ( dtfft_core_c2c ), intent ( inout ) :: self !! C2C Plan integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of data to be transformed TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int8 ) :: dim !! Counter integer ( int8 ) :: fft_start !! 1 for c2c, 2 for r2c integer ( int8 ) :: fft_rank !! Rank of FFT transform CHECK_INTERNAL_CALL ( self % create_private ( MPI_COMPLEX , COMPLEX_STORAGE_SIZE , MPI_DOUBLE_COMPLEX , DOUBLE_COMPLEX_STORAGE_SIZE , dims = dims , pencil = pencil , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( self % is_transpose_plan ) return fft_start = 1 select type ( self ) class is ( dtfft_plan_r2c_t ) fft_start = 2 endselect do dim = fft_start , self % ndims fft_rank = FFT_1D ; if ( self % is_z_slab . and . dim == 1 ) fft_rank = FFT_2D if ( self % is_z_slab . and . dim == 2_int8 ) cycle CHECK_INTERNAL_CALL ( self % fft ( self % fft_mapping ( dim ))% fft % create ( fft_rank , FFT_C2C , self % precision , complex_pencil = self % pencils ( dim )) ) enddo #undef __FUNC__ end function create_c2c_core subroutine create_r2c ( self , dims , executor , comm , precision , effort , error_code ) !! R2C Generic Plan Constructor class ( dtfft_plan_r2c_t ), intent ( inout ) :: self !! C2C Plan integer ( int32 ), intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_r2c_internal ( executor , dims = dims , comm = comm , precision = precision , effort = effort ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_r2c subroutine create_r2c_pencil ( self , pencil , executor , comm , precision , effort , error_code ) !! R2C Plan Constructor with pencil class ( dtfft_plan_r2c_t ), intent ( inout ) :: self !! R2C Plan type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Local pencil of data to be transformed type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_r2c_internal ( executor , pencil = pencil , comm = comm , precision = precision , effort = effort ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_r2c_pencil integer ( int32 ) function create_r2c_internal ( self , executor , dims , pencil , comm , precision , effort ) !! Private method that combines common logic for R2C plan creation #define __FUNC__ create_r2c_internal class ( dtfft_plan_r2c_t ), intent ( inout ) :: self !! R2C Plan type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Local pencil of data to be transformed TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan integer ( int32 ), allocatable :: fixed_dims (:) !! Fixed dimensions for R2C integer ( int8 ) :: fft_rank !! Rank of FFT transform create_r2c_internal = DTFFT_SUCCESS if ( self % is_created ) then create_r2c_internal = DTFFT_ERROR_PLAN_IS_CREATED return endif REGION_BEGIN ( \"create_r2c\" , COLOR_CREATE ) if ( present ( dims ) ) then allocate ( fixed_dims , source = dims ) fixed_dims ( 1 ) = int ( dims ( 1 ) / 2 , int32 ) + 1 CHECK_INTERNAL_CALL ( self % create_c2c_core ( dims = fixed_dims , comm = comm , precision = precision , effort = effort , executor = executor ) ) deallocate ( fixed_dims ) call self % real_pencil % create ( self % ndims , 1_int8 , dims , self % comms ) else ! Do not know global dimensions ! They are computed when private pencil is created CHECK_INTERNAL_CALL ( self % create_c2c_core ( pencil = pencil , comm = comm , precision = precision , effort = effort , executor = executor ) ) endif if ( self % is_transpose_plan ) then create_r2c_internal = DTFFT_ERROR_R2C_TRANSPOSE_PLAN return endif fft_rank = FFT_1D ; if ( self % is_z_slab ) fft_rank = FFT_2D CHECK_INTERNAL_CALL ( self % fft ( 1 )% fft % create ( fft_rank , FFT_R2C , self % precision , real_pencil = self % real_pencil , complex_pencil = self % pencils ( 1 )) ) REGION_END ( \"create_r2c\" ) self % is_created = . true . #undef __FUNC__ end function create_r2c_internal subroutine mem_alloc_ptr ( self , alloc_bytes , ptr , error_code ) !! Allocates memory specific for this plan class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS ptr = c_null_ptr if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( alloc_bytes < FLOAT_STORAGE_SIZE ) ierr = DTFFT_ERROR_INVALID_ALLOC_BYTES CHECK_ERROR_AND_RETURN if ( self % platform == DTFFT_PLATFORM_HOST ) then if ( self % is_transpose_plan ) then call mem_alloc_host ( alloc_bytes , ptr ) else call self % fft ( 1 )% fft % mem_alloc ( alloc_bytes , ptr ) endif if ( is_null_ptr ( ptr ) ) ierr = DTFFT_ERROR_ALLOC_FAILED #ifdef DTFFT_WITH_CUDA else call self % plan % mem_alloc ( self % comm , alloc_bytes , ptr , ierr ) #endif endif CHECK_ERROR_AND_RETURN if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine mem_alloc_ptr subroutine mem_free_ptr ( self , ptr , error_code ) !! Frees previously allocated memory specific for this plan class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: ptr !! Pointer allocated with [[dtfft_plan_t(type):mem_alloc]] integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( self % platform == DTFFT_PLATFORM_HOST ) then if ( self % is_transpose_plan ) then call mem_free_host ( ptr ) else call self % fft ( 1 )% fft % mem_free ( ptr ) endif #ifdef DTFFT_WITH_CUDA else call self % plan % mem_free ( ptr , ierr ) #endif endif CHECK_ERROR_AND_RETURN if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine mem_free_ptr #define STORAGE_BYTES FLOAT_STORAGE_SIZE #define BUFFER_TYPE real(real32) #define ALLOC_1D mem_alloc_r32_1d #define ALLOC_2D mem_alloc_r32_2d #define ALLOC_3D mem_alloc_r32_3d #define FREE_1D mem_free_r32_1d #define FREE_2D mem_free_r32_2d #define FREE_3D mem_free_r32_3d #include \"_dtfft_mem_alloc_free.inc\" #define STORAGE_BYTES DOUBLE_STORAGE_SIZE #define BUFFER_TYPE real(real64) #define ALLOC_1D mem_alloc_r64_1d #define ALLOC_2D mem_alloc_r64_2d #define ALLOC_3D mem_alloc_r64_3d #define FREE_1D mem_free_r64_1d #define FREE_2D mem_free_r64_2d #define FREE_3D mem_free_r64_3d #include \"_dtfft_mem_alloc_free.inc\" #define STORAGE_BYTES COMPLEX_STORAGE_SIZE #define BUFFER_TYPE complex(real32) #define ALLOC_1D mem_alloc_c32_1d #define ALLOC_2D mem_alloc_c32_2d #define ALLOC_3D mem_alloc_c32_3d #define FREE_1D mem_free_c32_1d #define FREE_2D mem_free_c32_2d #define FREE_3D mem_free_c32_3d #include \"_dtfft_mem_alloc_free.inc\" #define STORAGE_BYTES DOUBLE_COMPLEX_STORAGE_SIZE #define BUFFER_TYPE complex(real64) #define ALLOC_1D mem_alloc_c64_1d #define ALLOC_2D mem_alloc_c64_2d #define ALLOC_3D mem_alloc_c64_3d #define FREE_1D mem_free_c64_1d #define FREE_2D mem_free_c64_2d #define FREE_3D mem_free_c64_3d #include \"_dtfft_mem_alloc_free.inc\" end module dtfft_plan","tags":"","loc":"sourcefile/dtfft_plan.f90.html"},{"title":"dtfft.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft.f90~~EfferentGraph sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft !! Main ``dtFFT`` module. Should be used in a Fortran program. use dtfft_config use dtfft_errors use dtfft_parameters use dtfft_pencil use dtfft_plan implicit none private public :: dtfft_get_version public :: DTFFT_VERSION_MAJOR public :: DTFFT_VERSION_MINOR public :: DTFFT_VERSION_PATCH ! Plans public :: dtfft_plan_t public :: dtfft_plan_c2c_t #ifndef DTFFT_TRANSPOSE_ONLY public :: dtfft_plan_r2c_t #endif public :: dtfft_plan_r2r_t public :: dtfft_pencil_t public :: dtfft_get_error_string public :: dtfft_get_precision_string public :: dtfft_get_executor_string public :: dtfft_execute_t , dtfft_transpose_t public :: dtfft_executor_t , dtfft_effort_t public :: dtfft_precision_t , dtfft_r2r_kind_t public :: operator ( == ) public :: operator ( /= ) ! Execute types public :: DTFFT_EXECUTE_FORWARD , & DTFFT_EXECUTE_BACKWARD ! Transpose types public :: DTFFT_TRANSPOSE_X_TO_Y , & DTFFT_TRANSPOSE_Y_TO_X , & DTFFT_TRANSPOSE_Y_TO_Z , & DTFFT_TRANSPOSE_Z_TO_Y , & DTFFT_TRANSPOSE_X_TO_Z , & DTFFT_TRANSPOSE_Z_TO_X ! 1d FFT External Executor types public :: DTFFT_EXECUTOR_NONE public :: DTFFT_EXECUTOR_FFTW3 public :: DTFFT_EXECUTOR_MKL public :: DTFFT_EXECUTOR_CUFFT public :: DTFFT_EXECUTOR_VKFFT ! Effort flags public :: DTFFT_ESTIMATE , & DTFFT_MEASURE , & DTFFT_PATIENT ! Precision flags public :: DTFFT_SINGLE , & DTFFT_DOUBLE ! Types of R2R Transform public :: DTFFT_DCT_1 , & DTFFT_DCT_2 , & DTFFT_DCT_3 , & DTFFT_DCT_4 , & DTFFT_DST_1 , & DTFFT_DST_2 , & DTFFT_DST_3 , & DTFFT_DST_4 public :: DTFFT_SUCCESS public :: DTFFT_ERROR_MPI_FINALIZED public :: DTFFT_ERROR_PLAN_NOT_CREATED public :: DTFFT_ERROR_INVALID_TRANSPOSE_TYPE public :: DTFFT_ERROR_INVALID_N_DIMENSIONS public :: DTFFT_ERROR_INVALID_DIMENSION_SIZE public :: DTFFT_ERROR_INVALID_COMM_TYPE public :: DTFFT_ERROR_INVALID_PRECISION public :: DTFFT_ERROR_INVALID_EFFORT public :: DTFFT_ERROR_INVALID_EXECUTOR public :: DTFFT_ERROR_INVALID_COMM_DIMS public :: DTFFT_ERROR_INVALID_COMM_FAST_DIM public :: DTFFT_ERROR_MISSING_R2R_KINDS public :: DTFFT_ERROR_INVALID_R2R_KINDS public :: DTFFT_ERROR_R2C_TRANSPOSE_PLAN public :: DTFFT_ERROR_INPLACE_TRANSPOSE public :: DTFFT_ERROR_INVALID_AUX public :: DTFFT_ERROR_INVALID_DIM public :: DTFFT_ERROR_INVALID_USAGE public :: DTFFT_ERROR_PLAN_IS_CREATED public :: DTFFT_ERROR_ALLOC_FAILED public :: DTFFT_ERROR_FREE_FAILED public :: DTFFT_ERROR_INVALID_ALLOC_BYTES public :: DTFFT_ERROR_DLOPEN_FAILED public :: DTFFT_ERROR_DLSYM_FAILED public :: DTFFT_ERROR_R2C_TRANSPOSE_CALLED public :: DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH public :: DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES public :: DTFFT_ERROR_PENCIL_INVALID_COUNTS public :: DTFFT_ERROR_PENCIL_INVALID_STARTS public :: DTFFT_ERROR_PENCIL_SHAPE_MISMATCH public :: DTFFT_ERROR_PENCIL_OVERLAP public :: DTFFT_ERROR_PENCIL_NOT_CONTINUOUS public :: DTFFT_ERROR_PENCIL_NOT_INITIALIZED public :: DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED public :: DTFFT_ERROR_GPU_INVALID_STREAM public :: DTFFT_ERROR_GPU_INVALID_BACKEND public :: DTFFT_ERROR_GPU_NOT_SET public :: DTFFT_ERROR_VKFFT_R2R_2D_PLAN public :: DTFFT_ERROR_GPU_BACKENDS_DISABLED public :: DTFFT_ERROR_NOT_DEVICE_PTR public :: DTFFT_ERROR_NOT_NVSHMEM_PTR public :: DTFFT_ERROR_INVALID_PLATFORM public :: DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR_TYPE public :: dtfft_config_t public :: dtfft_create_config , dtfft_set_config #ifdef DTFFT_WITH_CUDA public :: dtfft_stream_t , dtfft_get_cuda_stream public :: dtfft_platform_t public :: DTFFT_PLATFORM_HOST , DTFFT_PLATFORM_CUDA public :: DTFFT_BACKEND_MPI_DATATYPE public :: DTFFT_BACKEND_MPI_P2P public :: DTFFT_BACKEND_MPI_P2P_PIPELINED public :: DTFFT_BACKEND_MPI_A2A public :: DTFFT_BACKEND_NCCL public :: DTFFT_BACKEND_NCCL_PIPELINED public :: DTFFT_BACKEND_CUFFTMP public :: DTFFT_BACKEND_CUFFTMP_PIPELINED public :: dtfft_backend_t public :: dtfft_get_backend_string #endif end module dtfft","tags":"","loc":"sourcefile/dtfft.f90.html"},{"title":"dtfft_nvrtc_kernel.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_nvrtc_kernel.f90~~EfferentGraph sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_nvrtc_kernel.f90~~AfferentGraph sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_nvrtc_kernel !! This module describes NVRTC Kernel class [[nvrtc_kernel]] !! It uses caching of compiled kernels to avoid recompilation similar kernels: [[nvrtc_cache]] use iso_c_binding use iso_fortran_env use dtfft_utils use dtfft_interface_cuda use dtfft_interface_cuda_runtime use dtfft_interface_nvrtc use dtfft_parameters #include \"dtfft_mpi.h\" #include \"dtfft_cuda.h\" #include \"dtfft_profile.h\" #include \"dtfft_private.h\" implicit none private public :: nvrtc_kernel public :: DEF_TILE_SIZE public :: clean_unused_cache integer ( int32 ), parameter :: DEF_TILE_SIZE = 16 !! Default tile size integer ( int32 ), parameter :: MIN_TILE_SIZE = 8 !! Minimum tile size. Will launch 2 warps integer ( int32 ), parameter :: TARGET_THREADS_PER_BLOCK = DEF_TILE_SIZE * DEF_TILE_SIZE !! Maximum number of threads to run in a block (256) character ( len =* ), parameter :: DEFAULT_KERNEL_NAME = \"dtfft_kernel\" !! Basic kernel name integer ( int8 ), parameter , public :: KERNEL_DUMMY = - 1 !! Dummy kernel, does nothing integer ( int8 ), parameter , public :: KERNEL_TRANSPOSE = 1 !! Basic transpose kernel type. integer ( int8 ), parameter , public :: KERNEL_TRANSPOSE_PACKED = 2 !! Transposes data and packs it into contiguous buffer. !! Should be used only in X-Y 3D plans. integer ( int8 ), parameter , public :: KERNEL_UNPACK = 3 !! Unpacks contiguous buffer. integer ( int8 ), parameter , public :: KERNEL_UNPACK_SIMPLE_COPY = 4 !! Doesn't actually unpacks anything. Performs ``cudaMemcpyAsync`` call. !! Should be used only when backend is ``DTFFT_GPU_BACKEND_CUFFTMP``. integer ( int8 ), parameter , public :: KERNEL_UNPACK_PIPELINED = 5 !! Unpacks pack of contiguous buffer recieved from rank. integer ( int8 ), parameter , public :: KERNEL_UNPACK_PARTIAL = 6 !! Unpacks contiguous buffer recieved from everyone except myself. type :: kernel_code !! Class to build CUDA kernel code private character ( len = :), allocatable :: raw !! String that holds CUDA code contains private procedure , pass ( self ), public :: to_cstr !! Converts Fortran CUDA code to C pointer procedure , pass ( self ), public :: add_line !! Adds new line to CUDA code procedure , pass ( self ), public :: destroy => destroy_code !! Frees all memory end type kernel_code type :: nvrtc_kernel !! nvRTC Compiled kernel class private logical :: is_created = . false . !! Kernel is created flag. logical :: is_dummy = . false . !! If kernel should do anything or not. type ( CUfunction ) :: cuda_kernel !! Pointer to CUDA kernel. type ( dim3 ) :: num_blocks !! Grid of blocks. type ( dim3 ) :: block_size !! Thread block. integer ( int8 ) :: kernel_type !! Type of kernel to execute. type ( kernelArgs ) :: args !! Kernel arguments. integer ( int32 ), allocatable :: pointers (:,:) !! Optional pointers that hold info about counts and displacements !! in ``KERNEL_UNPACK_PIPELINED`` kernel. contains private procedure , pass ( self ), public :: create !! Creates kernel procedure , pass ( self ), public :: execute !! Executes kernel procedure , pass ( self ), public :: destroy !! Destroys kernel end type nvrtc_kernel type :: nvrtc_cache !! Class to cache compiled kernels private integer ( int32 ) :: ref_count = 0 !! Number of references to this kernel type ( CUmodule ) :: cuda_module = CUmodule ( c_null_ptr ) !! Pointer to CUDA Module. type ( CUfunction ) :: cuda_kernel = CUfunction ( c_null_ptr ) !! Pointer to CUDA kernel. integer ( int8 ) :: kernel_type !! Type of kernel to execute. type ( dtfft_transpose_t ) :: transpose_type !! Type of transpose integer ( int32 ) :: tile_size !! Tile size of transpose kernel integer ( int64 ) :: base_storage !! Number of bytes needed to store single element logical :: has_inner_loop !! If kernel has inner loop end type nvrtc_cache integer ( int32 ), parameter :: CACHE_PREALLOC_SIZE = 10 !! Number of preallocated cache entries type ( nvrtc_cache ), allocatable , save :: cache (:) !! Cache of compiled kernels integer ( int32 ), save :: cache_size = 0 !! Number of entries in cache contains subroutine to_cstr ( self , c_code ) !! Converts Fortran CUDA code to C pointer class ( kernel_code ), intent ( in ) :: self !! Kernel code character ( c_char ), allocatable , intent ( out ) :: c_code (:) !! C pointer to code call astring_f2c ( self % raw , c_code ) end subroutine to_cstr subroutine add_line ( self , line ) !! Adds new line to CUDA code class ( kernel_code ), intent ( inout ) :: self !! Kernel code character ( len =* ), intent ( in ) :: line !! Line to add if ( . not . allocated ( self % raw ) ) allocate ( self % raw , source = \"\" ) self % raw = self % raw // line // c_new_line end subroutine add_line subroutine destroy_code ( self ) !! Frees all memory class ( kernel_code ), intent ( inout ) :: self !! Kernel code if ( allocated ( self % raw ) ) deallocate ( self % raw ) end subroutine destroy_code subroutine create_device_pointer ( ptr , values ) !! Allocates memory on a device and copies ``values`` to it. type ( c_ptr ), intent ( inout ) :: ptr !! Device pointer integer ( c_int ), intent ( in ), target :: values (:) !! Values to copy integer ( c_size_t ) :: n_bytes !! Number of bytes to copy n_bytes = size ( values ) * c_sizeof ( c_int ) CUDA_CALL ( \"cudaMalloc\" , cudaMalloc ( ptr , n_bytes ) ) CUDA_CALL ( \"cudaMemcpy\" , cudaMemcpy ( ptr , c_loc ( values ), n_bytes , cudaMemcpyHostToDevice ) ) end subroutine create_device_pointer integer ( int32 ) function get_tile_size ( x , y ) !! Returns tile size to use in a tranpose kernel integer ( int32 ), intent ( in ) :: x !! Number of elements in x direction integer ( int32 ), intent ( in ) :: y !! Number of elements in y direction if ( minval ([ x , y ]) >= DEF_TILE_SIZE ) then get_tile_size = DEF_TILE_SIZE else get_tile_size = MIN_TILE_SIZE endif end function get_tile_size subroutine get_contiguous_execution_blocks ( size , num_blocks , block_sizes ) integer ( int32 ), intent ( in ) :: size !! Total amount of iterations required type ( dim3 ), intent ( out ) :: num_blocks !! Grid of blocks. type ( dim3 ), intent ( out ) :: block_sizes !! Thread block. integer ( int32 ) :: block_size !! Number of threads in a block if ( size < TARGET_THREADS_PER_BLOCK ) then block_size = size else block_size = TARGET_THREADS_PER_BLOCK endif block_sizes % x = block_size block_sizes % y = 1 block_sizes % z = 1 num_blocks % x = ( size + block_size - 1 ) / block_size num_blocks % y = 1 num_blocks % z = 1 end subroutine get_contiguous_execution_blocks subroutine create ( self , comm , dims , base_storage , transpose_type , kernel_type , pointers ) !! Creates kernel class ( nvrtc_kernel ), intent ( inout ) :: self !! nvRTC Compiled kernel class TYPE_MPI_COMM , intent ( in ) :: comm !! MPI Communicator integer ( int32 ), target , intent ( in ) :: dims ( 0 :) !! Global dimensions to process integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition to perform integer ( int8 ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int32 ), optional , intent ( in ) :: pointers (:,:) !! Optional pointers to unpack kernels integer ( int32 ) :: comm_size !! Number of processes in current MPI communicator integer ( int32 ) :: comm_rank !! Rank of current process integer ( int32 ) :: mpi_ierr !! Error code integer ( int32 ) :: tile_dim !! Dimension to tile integer ( int32 ) :: other_dim !! Dimension not used to tile integer ( int32 ) :: tile_size !! Tile size integer ( int32 ) :: scaler !! Scaler to adjust number of blocks logical :: has_inner_loop !! If kernel has inner loop call self % destroy () if ( any ( dims == 0 ) ) then self % is_created = . true . self % is_dummy = . true . return endif self % is_dummy = . false . self % kernel_type = kernel_type if ( kernel_type == KERNEL_DUMMY ) then self % is_dummy = . true . return endif if ( kernel_type == KERNEL_UNPACK_SIMPLE_COPY ) then self % is_created = . true . self % args % ints ( 1 ) = product ( dims ) * int ( base_storage , int32 ) return endif call MPI_Comm_size ( comm , comm_size , mpi_ierr ) call MPI_Comm_rank ( comm , comm_rank , mpi_ierr ) has_inner_loop = . false . tile_size = 0 if ( kernel_type == KERNEL_UNPACK . or . kernel_type == KERNEL_UNPACK_PARTIAL ) then call get_contiguous_execution_blocks ( product ( dims ), self % num_blocks , self % block_size ) else if ( ( kernel_type == KERNEL_TRANSPOSE ) . or . ( kernel_type == KERNEL_TRANSPOSE_PACKED ) ) then if ( abs ( transpose_type % val ) == DTFFT_TRANSPOSE_X_TO_Y % val . or . transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then tile_dim = 1 other_dim = 2 else tile_dim = 2 other_dim = 1 endif tile_size = get_tile_size ( dims ( 0 ), dims ( tile_dim )) self % block_size % x = tile_size self % block_size % y = tile_size self % block_size % z = 1 self % num_blocks % x = ( dims ( 0 ) + tile_size - 1 ) / tile_size self % num_blocks % y = ( dims ( tile_dim ) + tile_size - 1 ) / tile_size scaler = 1 if ( size ( dims ) == 3 ) then if ( tile_size == MIN_TILE_SIZE . and . dims ( other_dim ) > TARGET_THREADS_PER_BLOCK ) then has_inner_loop = . true . select case ( base_storage ) case ( FLOAT_STORAGE_SIZE ) scaler = 8 case ( DOUBLE_STORAGE_SIZE ) scaler = 4 case ( DOUBLE_COMPLEX_STORAGE_SIZE ) scaler = 2 endselect endif self % num_blocks % z = ( dims ( other_dim ) + scaler - 1 ) / scaler else self % num_blocks % z = 1 endif endif if ( kernel_type == KERNEL_UNPACK . or . kernel_type == KERNEL_UNPACK_PARTIAL ) then self % args % n_ints = 3 self % args % ints ( 1 ) = product ( dims ) if ( transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then self % args % ints ( 2 ) = dims ( 0 ) * dims ( 1 ) else self % args % ints ( 2 ) = dims ( 0 ) endif self % args % ints ( 3 ) = comm_size if ( kernel_type == KERNEL_UNPACK_PARTIAL ) then self % args % ints ( 4 ) = comm_rank self % args % n_ints = 4 endif else if ( kernel_type == KERNEL_UNPACK_PIPELINED ) then self % args % n_ints = 5 ! All 5 ints are populated during kernel execution based on sender pointers else self % args % n_ints = size ( dims ) self % args % ints ( 1 ) = dims ( 0 ) self % args % ints ( 2 ) = dims ( 1 ) if ( size ( dims ) == 3 ) then self % args % ints ( 3 ) = dims ( 2 ) if ( kernel_type == KERNEL_TRANSPOSE_PACKED ) then self % args % n_ints = 4 self % args % ints ( 4 ) = comm_size endif endif endif self % args % n_ptrs = 0 if ( any ([ kernel_type == [ KERNEL_TRANSPOSE_PACKED , KERNEL_UNPACK , KERNEL_UNPACK_PIPELINED , KERNEL_UNPACK_PARTIAL ]]) ) then if ( . not . present ( pointers ) ) INTERNAL_ERROR ( \"Pointer required\" ) if ( kernel_type == KERNEL_UNPACK_PIPELINED ) then allocate ( self % pointers , source = pointers ) else block integer ( int32 ) :: i self % args % n_ptrs = size ( self % args % ptrs ) do i = 1 , self % args % n_ptrs call create_device_pointer ( self % args % ptrs ( i ), pointers ( i , :)) enddo endblock endif endif self % cuda_kernel = compile_and_cache ( comm , dims , transpose_type , kernel_type , base_storage , tile_size , has_inner_loop ) self % is_created = . true . end subroutine create subroutine execute ( self , in , out , stream , source ) !! Executes kernel on stream class ( nvrtc_kernel ), intent ( inout ) :: self !! nvRTC Compiled kernel class real ( real32 ), target , intent ( in ) :: in (:) !! Source pointer real ( real32 ), target , intent ( in ) :: out (:) !! Target pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! CUDA Stream integer ( int32 ), optional , intent ( in ) :: source !! Source rank for pipelined unpacking integer ( int32 ) :: n_align_sent !! Number of aligned elements sent integer ( int32 ) :: displ_in !! Displacement in source buffer integer ( int32 ) :: displ_out !! Displacement in target buffer integer :: comm_rank , ierr call MPI_Comm_rank ( MPI_COMM_WORLD , comm_rank , ierr ) if ( self % is_dummy ) return if ( . not . self % is_created ) INTERNAL_ERROR ( \"`execute` called while plan not created\" ) if ( self % kernel_type == KERNEL_UNPACK_SIMPLE_COPY ) then CUDA_CALL ( \"cudaMemcpyAsync\" , cudaMemcpyAsync ( c_loc ( out ), c_loc ( in ), int ( self % args % ints ( 1 ), c_size_t ), cudaMemcpyDeviceToDevice , stream ) ) return endif if ( self % kernel_type == KERNEL_UNPACK_PIPELINED ) then if ( . not . present ( source ) ) INTERNAL_ERROR ( \"Source is not passed\" ) displ_in = self % pointers ( 1 , source ) displ_out = self % pointers ( 2 , source ) n_align_sent = self % pointers ( 3 , source ) self % args % ints ( 1 ) = self % pointers ( 4 , source ) self % args % ints ( 2 ) = self % pointers ( 5 , source ) self % args % ints ( 3 ) = n_align_sent self % args % ints ( 4 ) = displ_in self % args % ints ( 5 ) = displ_out call get_contiguous_execution_blocks ( self % pointers ( 4 , source ), self % num_blocks , self % block_size ) endif CUDA_CALL ( \"cuLaunchKernel\" , cuLaunchKernel ( self % cuda_kernel , c_loc ( in ), c_loc ( out ), self % num_blocks , self % block_size , stream , self % args ) ) end subroutine execute subroutine destroy ( self ) !! Destroys kernel class ( nvrtc_kernel ), intent ( inout ) :: self !! nvRTC Compiled kernel class integer ( int32 ) :: i !! Counter if ( . not . self % is_created ) return if ( self % is_dummy . or . self % kernel_type == KERNEL_UNPACK_SIMPLE_COPY ) return call mark_unused ( self % cuda_kernel ) do i = 1 , self % args % n_ptrs CUDA_CALL ( \"cudaFree\" , cudaFree ( self % args % ptrs ( i )) ) enddo if ( allocated ( self % pointers ) ) deallocate ( self % pointers ) self % args % n_ints = 0 self % args % n_ptrs = 0 self % cuda_kernel = CUfunction ( c_null_ptr ) self % is_created = . false . end subroutine destroy function get_cached_kernel ( transpose_type , kernel_type , base_storage , tile_size , has_inner_loop ) result ( kernel ) !! Returns cached kernel if it exists. !! If not returns null pointer. type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition to perform integer ( int8 ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ), intent ( in ) :: tile_size !! Tile size logical , intent ( in ) :: has_inner_loop !! If kernel has inner loop type ( CUfunction ) :: kernel !! Cached kernel type ( dtfft_transpose_t ) :: transpose_type_ !! Fixed id of transposition integer ( int32 ) :: i !! Counter kernel = CUfunction ( c_null_ptr ) transpose_type_ = get_true_transpose_type ( transpose_type ) if ( . not . allocated ( cache ) ) return do i = 1 , cache_size if ( cache ( i )% transpose_type == transpose_type_ & . and . cache ( i )% kernel_type == kernel_type & . and . cache ( i )% base_storage == base_storage & . and . cache ( i )% tile_size == tile_size & . and . ( ( cache ( i )% has_inner_loop . and . has_inner_loop ) . or . (. not . cache ( i )% has_inner_loop . and . . not . has_inner_loop )) & . or . ( cache ( i )% kernel_type == kernel_type . and . ( kernel_type == KERNEL_UNPACK . or . kernel_type == KERNEL_UNPACK_PIPELINED ) ) & ) then kernel = cache ( i )% cuda_kernel cache ( i )% ref_count = cache ( i )% ref_count + 1 return endif end do end function get_cached_kernel function get_true_transpose_type ( transpose_type ) result ( transpose_type_ ) !! Returns generic transpose id. !! Since X-Y and Y-Z transpositions are symmectric, it returns only one of them. !! X-Z and Z-X are not symmetric type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition to perform type ( dtfft_transpose_t ) :: transpose_type_ !! Fixed id of transposition if ( transpose_type == DTFFT_TRANSPOSE_X_TO_Z . or . transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then transpose_type_ = transpose_type else transpose_type_ % val = abs ( transpose_type % val ) endif end function get_true_transpose_type function compile_and_cache ( comm , dims , transpose_type , kernel_type , base_storage , tile_size , has_inner_loop ) result ( kernel ) !! Compiles kernel and caches it. Returns compiled kernel. TYPE_MPI_COMM , intent ( in ) :: comm !! MPI Communicator integer ( int32 ), target , intent ( in ) :: dims (:) !! Global dimensions to process type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition to perform integer ( int8 ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ), intent ( in ) :: tile_size !! Tile size logical , intent ( in ) :: has_inner_loop !! If kernel has inner loop type ( CUfunction ) :: kernel !! Compiled kernel to return type ( nvrtc_cache ), allocatable :: temp (:) !! Temporary cache integer ( int32 ) :: i !! Counter character ( len = :), allocatable :: kernel_name !! Name of kernel type ( kernel_code ) :: code !! CUDA Code to compile character ( c_char ), allocatable :: c_code (:) !! CUDA C Code to compile type ( string ), target , allocatable :: options (:) !! Compilation options type ( c_ptr ), allocatable :: c_options (:) !! C style, null-string terminated options integer ( int32 ) :: num_options !! Number of compilation options type ( dtfft_transpose_t ) :: transpose_type_ !! Fixed id of transposition integer ( int32 ) :: device_id !! Current device number integer ( int32 ) :: ierr !! Error code integer ( int32 ) :: mpi_ierr !! MPI Error code type ( nvrtcProgram ) :: prog !! nvRTC Program integer ( c_size_t ) :: cubinSizeRet !! Size of cubin character ( c_char ), allocatable :: cubin (:) !! Compiled binary character ( c_char ), allocatable :: cstr (:) !! Temporary string integer ( int32 ) :: major , minor ! Check if kernel already been compiled kernel = get_cached_kernel ( transpose_type , kernel_type , base_storage , tile_size , has_inner_loop ) if ( . not . is_null_ptr ( kernel % ptr ) ) return PHASE_BEGIN ( \"Building nvRTC kernel\" , COLOR_EXECUTE ) if ( . not . allocated ( cache ) ) allocate ( cache ( CACHE_PREALLOC_SIZE ) ) ! Need more cache if ( cache_size == size ( cache ) ) then allocate ( temp ( cache_size + CACHE_PREALLOC_SIZE ), source = cache ) deallocate ( cache ) call move_alloc ( temp , cache ) endif transpose_type_ = get_true_transpose_type ( transpose_type ) kernel_name = DEFAULT_KERNEL_NAME // \"_\" if ( kernel_type == KERNEL_TRANSPOSE . or . kernel_type == KERNEL_TRANSPOSE_PACKED ) then select case ( transpose_type_ % val ) case ( DTFFT_TRANSPOSE_X_TO_Y % val ) kernel_name = kernel_name // \"xy\" case ( DTFFT_TRANSPOSE_X_TO_Z % val ) kernel_name = kernel_name // \"xz\" case ( DTFFT_TRANSPOSE_Z_TO_X % val ) kernel_name = kernel_name // \"zx\" case ( DTFFT_TRANSPOSE_Y_TO_Z % val ) kernel_name = kernel_name // \"yz\" endselect else if ( kernel_type == KERNEL_UNPACK ) then kernel_name = kernel_name // \"unpack\" else if ( kernel_type == KERNEL_UNPACK_PIPELINED ) then kernel_name = kernel_name // \"unpack_pipelined\" else if ( kernel_type == KERNEL_UNPACK_PARTIAL ) then kernel_name = kernel_name // \"unpack_partial\" else INTERNAL_ERROR ( \"Unknown kernel type\" ) endif if ( kernel_type == KERNEL_UNPACK . or . kernel_type == KERNEL_UNPACK_PARTIAL ) then code = get_unpack_kernel_code ( kernel_name , base_storage , kernel_type == KERNEL_UNPACK_PARTIAL ) else if ( kernel_type == KERNEL_UNPACK_PIPELINED ) then code = get_unpack_pipelined_kernel_code ( kernel_name , base_storage ) else code = get_transpose_kernel_code ( kernel_name , size ( dims , kind = int8 ), base_storage , transpose_type , kernel_type == KERNEL_TRANSPOSE_PACKED , has_inner_loop ) endif call code % to_cstr ( c_code ) #ifdef __DEBUG num_options = 4 #else num_options = 2 #endif CUDA_CALL ( \"cudaGetDevice\" , cudaGetDevice ( device_id ) ) call get_cuda_architecture ( device_id , major , minor ) allocate ( c_options ( num_options ), options ( num_options ) ) options ( 1 ) = string ( \"--gpu-architecture=sm_\" // int_to_str ( major ) // int_to_str ( minor ) // c_null_char ) options ( 2 ) = string ( \"-DTILE_DIM=\" // int_to_str ( tile_size ) // c_null_char ) #ifdef __DEBUG options ( 3 ) = string ( \"--device-debug\" // c_null_char ) options ( 4 ) = string ( \"--generate-line-info\" // c_null_char ) #endif do i = 1 , num_options c_options ( i ) = c_loc ( options ( i )% raw ) enddo NVRTC_CALL ( \"nvrtcCreateProgram\" , nvrtcCreateProgram ( prog , c_code , \"dtfft_kernel.cu\" // c_null_char , 0 , c_null_ptr , c_null_ptr ) ) ierr = nvrtcCompileProgram ( prog , num_options , c_options ) ! It is assumed here that ierr can only be positive call MPI_Allreduce ( MPI_IN_PLACE , ierr , 1 , MPI_INTEGER4 , MPI_MAX , comm , mpi_ierr ) if ( ierr /= 0 ) then block type ( c_ptr ) :: c_log character ( len = :), allocatable :: f_log integer ( int32 ) :: global_rank NVRTC_CALL ( \"nvrtcGetProgramLog\" , nvrtcGetProgramLog ( prog , c_log )) call string_c2f ( c_log , f_log ) call MPI_Comm_rank ( comm , global_rank , mpi_ierr ) if ( global_rank == 0 ) then write ( error_unit , \"(a)\" ) \"dtFFT Internal Error: failed to compile kernel\" write ( error_unit , \"(a)\" ) \"CUDA Code:\" write ( error_unit , \"(a)\" ) code % raw write ( error_unit , \"(a)\" ) \"Compilation log:\" write ( error_unit , \"(a)\" ) f_log endif call MPI_Abort ( MPI_COMM_WORLD , ierr , mpi_ierr ) endblock endif NVRTC_CALL ( \"nvrtcGetCUBINSize\" , nvrtcGetCUBINSize ( prog , cubinSizeRet ) ) allocate ( cubin ( cubinSizeRet ) ) NVRTC_CALL ( \"nvrtcGetCUBIN\" , nvrtcGetCUBIN ( prog , cubin ) ) NVRTC_CALL ( \"nvrtcDestroyProgram\" , nvrtcDestroyProgram ( prog ) ) cache_size = cache_size + 1 cache ( cache_size )% base_storage = base_storage cache ( cache_size )% kernel_type = kernel_type cache ( cache_size )% tile_size = tile_size cache ( cache_size )% transpose_type = transpose_type_ cache ( cache_size )% has_inner_loop = has_inner_loop cache ( cache_size )% ref_count = 1 CUDA_CALL ( \"cuModuleLoadDataEx\" , cuModuleLoadDataEx ( cache ( cache_size )% cuda_module , cubin , 0 , c_null_ptr , c_null_ptr ) ) call astring_f2c ( kernel_name // c_null_char , cstr ) CUDA_CALL ( \"cuModuleGetFunction\" , cuModuleGetFunction ( cache ( cache_size )% cuda_kernel , cache ( cache_size )% cuda_module , cstr ) ) deallocate ( cstr ) ! Result -- compiled function kernel = cache ( cache_size )% cuda_kernel deallocate ( c_code ) do i = 1 , num_options deallocate ( options ( i )% raw ) enddo deallocate ( options ) deallocate ( c_options ) deallocate ( cubin ) deallocate ( kernel_name ) call code % destroy () PHASE_END ( \"Building nvRTC kernel\" ) end function compile_and_cache subroutine mark_unused ( kernel ) !! Takes CUDA kernel as an argument and searches for it in cache !! If kernel is found than reduces `ref_count` and return null pointer type ( CUfunction ), intent ( inout ) :: kernel !! CUDA kernel to search for integer ( int32 ) :: i !! Counter if ( . not . allocated ( cache ) ) return do i = 1 , cache_size if ( is_same_ptr ( cache ( i )% cuda_kernel % ptr , kernel % ptr ) ) then kernel = CUfunction ( c_null_ptr ) cache ( i )% ref_count = cache ( i )% ref_count - 1 return endif end do end subroutine mark_unused subroutine clean_unused_cache () !! Removes unused modules from cuda context integer ( int32 ) :: i !! Counter if ( . not . allocated ( cache ) ) return do i = 1 , cache_size if ( cache ( i )% ref_count == 0 . and . . not . is_null_ptr ( cache ( i )% cuda_module % ptr ) ) then CUDA_CALL ( \"cuModuleUnload\" , cuModuleUnload ( cache ( i )% cuda_module ) ) cache ( i )% cuda_module = CUmodule ( c_null_ptr ) cache ( i )% cuda_kernel = CUfunction ( c_null_ptr ) cache ( i )% base_storage = 0 cache ( i )% kernel_type = 0 cache ( i )% tile_size = - 1 cache ( i )% transpose_type % val = 0 endif enddo if ( all ( cache (:)% ref_count == 0 ) ) then deallocate ( cache ) cache_size = 0 endif end subroutine clean_unused_cache subroutine get_neighbor_function_code ( code ) !! Generated device function that is used to determite id of process that to which data is being sent or from which data has been recieved !! based on local element coordinate type ( kernel_code ), intent ( inout ) :: code !! Resulting code call code % add_line ( \"__device__\" ) call code % add_line ( \"int findNeighborIdx(const int *a, int n, int val) {\" ) ! call code%add_line(\"  if ( a[0] == val ) return 0;\") call code % add_line ( \"  if ( a[n - 1] <= val) return n - 1;\" ) call code % add_line ( \"  if ( n == 2 ) {\" ) call code % add_line ( \"    // Since [n - 1] already been handled\" ) call code % add_line ( \"    return 0;\" ) call code % add_line ( \"  }\" ) call code % add_line ( \"  int low = 0, high = n - 1;\" ) call code % add_line ( \"  while (1) {\" ) call code % add_line ( \"    int mid = (low + high) / 2;\" ) call code % add_line ( \"    if (a[mid] <= val && a[mid + 1] > val) {\" ) call code % add_line ( \"      return mid;\" ) call code % add_line ( \"    } else if (a[mid] < val) {\" ) call code % add_line ( \"      low = mid;\" ) call code % add_line ( \"    } else {\" ) call code % add_line ( \"      high = mid;\" ) call code % add_line ( \"    }\" ) call code % add_line ( \"  }\" ) call code % add_line ( \"}\" ) end subroutine get_neighbor_function_code subroutine get_code_init ( kernel_name , base_storage , code , buffer_type ) !! Generates basic code that is used in all other kernels character ( len =* ), intent ( in ) :: kernel_name !! Name of CUDA kernel integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( kernel_code ), intent ( inout ) :: code !! Resulting code character ( len = :), optional , allocatable , intent ( out ) :: buffer_type !! Type of buffer that should be used character ( len = :), allocatable :: buffer_type_ !! Type of buffer that should be used select case ( base_storage ) case ( FLOAT_STORAGE_SIZE ) allocate ( buffer_type_ , source = \"float\" ) case ( DOUBLE_STORAGE_SIZE ) allocate ( buffer_type_ , source = \"double\" ) case ( DOUBLE_COMPLEX_STORAGE_SIZE ) allocate ( buffer_type_ , source = \"double2\" ) case default INTERNAL_ERROR ( \"unknown `base_storage`\" ) endselect call code % add_line ( 'extern \"C\" __global__' ) call code % add_line ( \"void\" ) call code % add_line ( \"__launch_bounds__(\" // int_to_str ( TARGET_THREADS_PER_BLOCK ) // \")\" ) call code % add_line ( kernel_name ) call code % add_line ( \"(\" ) call code % add_line ( \"  \" // buffer_type_ // \" * __restrict__ out\" ) call code % add_line ( \"   ,const \" // buffer_type_ // \" * __restrict__ in\" ) if ( present ( buffer_type ) ) allocate ( buffer_type , source = buffer_type_ ) deallocate ( buffer_type_ ) end subroutine get_code_init function get_transpose_kernel_code ( kernel_name , ndims , base_storage , transpose_type , enable_packing , enable_multiprocess ) result ( code ) !! Generates code that will be used to locally tranpose data and prepares to send it to other processes character ( len =* ), intent ( in ) :: kernel_name !! Name of CUDA kernel integer ( int8 ), intent ( in ) :: ndims !! Number of dimensions integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Transpose id logical , intent ( in ) :: enable_packing !! If data should be manually packed or not logical , intent ( in ) :: enable_multiprocess !! If thread should process more then one element type ( kernel_code ) :: code !! Resulting code character ( len = :), allocatable :: buffer_type !! Type of buffer that should be used character ( len = 2 ) :: temp !! Temporary string if ( ndims == 2 . and . ( enable_packing . or . enable_multiprocess ) ) INTERNAL_ERROR ( \"ndims == 2 .and. (enable_packing .or. enable_multiprocess)\" ) if ( enable_packing ) then call get_neighbor_function_code ( code ) endif call get_code_init ( kernel_name , base_storage , code , buffer_type ) call code % add_line ( \"   ,const int nx\" ) call code % add_line ( \"   ,const int ny\" ) if ( ndims == 3 ) call code % add_line ( \"   ,const int nz\" ) if ( enable_packing ) then call code % add_line ( \"   ,const int n_neighbors\" ) call code % add_line ( \"   ,const int * __restrict__ local_starts\" ) call code % add_line ( \"   ,const int * __restrict__ local_counts\" ) call code % add_line ( \"   ,const int * __restrict__ pack_displs\" ) endif call code % add_line ( \")\" ) call code % add_line ( \"{\" ) call code % add_line ( \"__shared__ \" // buffer_type // \" tile[TILE_DIM][TILE_DIM + 1];\" ) call code % add_line ( \"int x_in, x_out, ind_in, ind_out;\" ) call code % add_line ( \"int y_in, y_out;\" ) call code % add_line ( \"int lx = threadIdx.x;\" ) call code % add_line ( \"int ly = threadIdx.y;\" ) call code % add_line ( \"int bx = blockIdx.x;\" ) call code % add_line ( \"int by = blockIdx.y;\" ) call code % add_line ( \"x_in = lx + TILE_DIM * bx;\" ) call code % add_line ( \"y_in = ly + TILE_DIM * by;\" ) if ( . not . enable_multiprocess ) then call code % add_line ( \"int z = blockIdx.z;\" ) endif call code % add_line ( \"x_out = ly + TILE_DIM * bx;\" ) call code % add_line ( \"y_out = lx + TILE_DIM * by;\" ) if ( ndims == 3 ) then if ( enable_packing ) then ! Only X-Y 3d transpose call code % add_line ( \"int neighbor_idx = findNeighborIdx(local_starts, n_neighbors, x_out);\" ) call code % add_line ( \"int shift_out = pack_displs[neighbor_idx];\" ) call code % add_line ( \"int target_count = local_counts[neighbor_idx];\" ) endif if ( enable_multiprocess ) then if ( abs ( transpose_type % val ) == DTFFT_TRANSPOSE_X_TO_Y % val . or . transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then call code % add_line ( \" for (int z = blockIdx.z; z < nz; z += gridDim.z) { \" ) else call code % add_line ( \" for (int z = blockIdx.z; z < ny; z += gridDim.z) { \" ) endif endif if ( abs ( transpose_type % val ) == DTFFT_TRANSPOSE_X_TO_Y % val . or . transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then call code % add_line ( \"ind_in = x_in + (y_in + z * ny) * nx;\" ) else call code % add_line ( \"ind_in = x_in + (z + y_in * ny) * nx;\" ) endif if ( enable_packing ) then call code % add_line ( \"ind_out = shift_out + (z * ny * target_count) + x_out * ny + y_out;\" ) else select case ( transpose_type % val ) case ( DTFFT_TRANSPOSE_X_TO_Y % val , DTFFT_TRANSPOSE_Y_TO_X % val ) call code % add_line ( \"ind_out = y_out + (x_out + z * nx) * ny;\" ) case ( DTFFT_TRANSPOSE_X_TO_Z % val ) call code % add_line ( \"ind_out = y_out + (x_out + z * nx) * nz;\" ) case ( DTFFT_TRANSPOSE_Z_TO_X % val ) call code % add_line ( \"ind_out = y_out + (z + x_out * nz) * ny;\" ) case ( DTFFT_TRANSPOSE_Y_TO_Z % val , DTFFT_TRANSPOSE_Z_TO_Y % val ) call code % add_line ( \"ind_out = y_out + (z + x_out * ny) * nz;\" ) endselect endif else !! ndims == 2 call code % add_line ( \"ind_in = x_in + y_in * nx;\" ) call code % add_line ( \"ind_out = y_out + x_out * ny;\" ) endif if ( abs ( transpose_type % val ) == DTFFT_TRANSPOSE_X_TO_Y % val . or . transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then temp = \"ny\" else temp = \"nz\" endif call code % add_line ( \"if( x_in < nx && y_in < \" // temp // \")\" ) call code % add_line ( \"    tile[lx][ly] = in[ind_in];\" ) call code % add_line ( \"__syncthreads();\" ) call code % add_line ( \"if( x_out < nx && y_out < \" // temp // \")\" ) call code % add_line ( \"    out[ind_out] = tile[ly][lx];\" ) if ( enable_multiprocess ) then call code % add_line ( \"__syncthreads(); \" ) call code % add_line ( \"}\" ) endif call code % add_line ( \"}\" ) deallocate ( buffer_type ) end function get_transpose_kernel_code function get_unpack_kernel_code ( kernel_name , base_storage , is_partial ) result ( code ) !! Generates code that will be used to unpack data when it is recieved character ( len =* ), intent ( in ) :: kernel_name !! Name of CUDA kernel integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element logical , intent ( in ) :: is_partial type ( kernel_code ) :: code !! Resulting code call get_neighbor_function_code ( code ) call get_code_init ( kernel_name , base_storage , code ) call code % add_line ( \"  ,const int n_total\" ) call code % add_line ( \"  ,const int n_align\" ) call code % add_line ( \"  ,const int n_neighbors\" ) if ( is_partial ) then call code % add_line ( \"  ,const int me\" ) endif call code % add_line ( \"  ,const int* __restrict__ recv_displs\" ) call code % add_line ( \"  ,const int* __restrict__ recv_starts\" ) call code % add_line ( \"  ,const int* __restrict__ send_sizes\" ) call code % add_line ( \") {\" ) call code % add_line ( \"  int idx = blockIdx.x * blockDim.x + threadIdx.x;\" ) call code % add_line ( \"\" ) call code % add_line ( \"  if (idx < n_total) {\" ) call code % add_line ( \"    int neighbor = findNeighborIdx(recv_displs, n_neighbors, idx);\" ) if ( is_partial ) then call code % add_line ( \"    if (neighbor == me) return;\" ) endif call code % add_line ( \"    int start = recv_starts[neighbor];\" ) call code % add_line ( \"    int shift_out = idx - recv_displs[neighbor];\" ) call code % add_line ( \"    int sent_size = send_sizes[neighbor];\" ) call code % add_line ( \"    int mod_sent_size = shift_out - (shift_out / sent_size) * sent_size;\" ) ! call code%add_line(\"    int mod_sent_size = shift_out % sent_size;\") call code % add_line ( \"    int div_sent_size = (shift_out - mod_sent_size) / sent_size;\" ) call code % add_line ( \"    int ind_out = start + div_sent_size * n_align + mod_sent_size;\" ) call code % add_line ( \"    out[ind_out] = in[idx];\" ) call code % add_line ( \"\t}\" ) call code % add_line ( \"}\" ) end function get_unpack_kernel_code function get_unpack_pipelined_kernel_code ( kernel_name , base_storage ) result ( code ) !! Generates code that will be used to partially unpack data when it is recieved from other process character ( len =* ), intent ( in ) :: kernel_name !! Name of CUDA kernel integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( kernel_code ) :: code !! Resulting code integer :: comm_rank , ierr call MPI_Comm_rank ( MPI_COMM_WORLD , comm_rank , ierr ) call get_code_init ( kernel_name , base_storage , code ) call code % add_line ( \"  ,const int n_total\" ) call code % add_line ( \"  ,const int n_align\" ) call code % add_line ( \"  ,const int sent_size\" ) call code % add_line ( \"  ,const int displ_in\" ) call code % add_line ( \"  ,const int displ_out\" ) call code % add_line ( \") {\" ) call code % add_line ( \"  int idx = blockIdx.x * blockDim.x + threadIdx.x;\" ) call code % add_line ( \"  if ( idx < n_total ) {\" ) ! call code%add_line(\"    int ind_mod = (idx % sent_size);\") call code % add_line ( \"    int ind_mod = idx - (idx / sent_size) * sent_size;\" ) call code % add_line ( \"    int ind_out = (idx - ind_mod) / sent_size * n_align + ind_mod;\" ) call code % add_line ( \"    out[displ_out + ind_out] = in[displ_in + idx];\" ) call code % add_line ( \"  }\" ) call code % add_line ( \"}\" ) end function get_unpack_pipelined_kernel_code end module dtfft_nvrtc_kernel","tags":"","loc":"sourcefile/dtfft_nvrtc_kernel.f90.html"},{"title":"dtfft_utils.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_utils.f90~~EfferentGraph sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_utils.f90~~AfferentGraph sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_utils !! All Utilities functions are located here use iso_c_binding use iso_fortran_env , only : int8 , int32 , int64 , real64 , output_unit , error_unit use dtfft_errors use dtfft_parameters #include \"dtfft_mpi.h\" #include \"dtfft_cuda.h\" #include \"dtfft_private.h\" implicit none private public :: string_f2c , string_c2f public :: int_to_str , double_to_str public :: write_message , init_internal , get_log_enabled public :: get_env , get_iters_from_env , get_datatype_from_env public :: get_inverse_kind public :: get_platform_from_env , get_z_slab_from_env public :: is_same_ptr , is_null_ptr public :: mem_alloc_host , mem_free_host #ifdef DTFFT_WITH_CUDA public :: destroy_strings public :: astring_f2c public :: count_unique public :: Comm_f2c public :: is_device_ptr public :: get_backend_from_env public :: get_mpi_enabled_from_env , get_nccl_enabled_from_env , get_nvshmem_enabled_from_env , get_pipe_enabled_from_env public :: load_library , load_symbol , unload_library , dynamic_load #endif logical , save :: is_init_called = . false . !! Has [[init_internal]] already been called or not logical , save :: is_log_enabled !! Should we log messages to stdout or not type ( dtfft_platform_t ), save :: platform_from_env = PLATFORM_NOT_SET !! Platform obtained from environ integer ( int32 ), save :: z_slab_from_env !! Should Z-slab be used if possible #ifdef DTFFT_WITH_CUDA type ( dtfft_backend_t ), save :: backend_from_env !! Backend obtained from environ integer ( int32 ), save :: mpi_enabled_from_env !! Should we use MPI backends during autotune or not integer ( int32 ), save :: nccl_enabled_from_env !! Should we use NCCL backends during autotune or not integer ( int32 ), save :: nvshmem_enabled_from_env !! Should we use NVSHMEM backends during autotune or not integer ( int32 ), save :: pipe_enabled_from_env !! Should we use pipelined backends during autotune or not #endif character ( len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! Upper case alphabet. character ( len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !! Lower case alphabet. interface int_to_str !! Converts integer to string module procedure int_to_str_int8 module procedure int_to_str_int32 module procedure int_to_str_int64 end interface int_to_str interface is_null_ptr !! Checks if pointer is NULL module procedure is_null_ptr #ifdef DTFFT_WITH_CUDA module procedure is_null_funptr #endif end interface is_null_ptr interface get_env !! Obtains environment variable module procedure :: get_env_base #ifdef DTFFT_WITH_CUDA module procedure :: get_env_string #endif module procedure :: get_env_int32 module procedure :: get_env_int8 module procedure :: get_env_logical end interface get_env #ifdef DTFFT_WITH_CUDA public :: string type :: string !! Class used to create array of strings character ( len = :), allocatable :: raw !! String end type string interface string !! Creates [[string]] object module procedure :: string_constructor end interface string integer ( c_int ), parameter :: RTLD_LAZY = 1_c_int !! Each external function reference is bound the first time the function is called. integer ( c_int ), parameter :: RTLD_NOW = 2_c_int !! All external function references are bound when the library is loaded. interface !! Load and link a dynamic library or bundle function dlopen ( filename , mode ) bind ( C ) import type ( c_ptr ) :: dlopen !! Handle to the library character ( c_char ) :: filename ( * ) !! Name of the library integer ( c_int ), value :: mode !! Options to dlopen end function dlopen end interface interface !! Get address of a symbol function dlsym ( handle , name ) bind ( C ) import type ( c_funptr ) :: dlsym !! Address of the symbol type ( c_ptr ), value :: handle !! Handle to the library character ( c_char ) :: name ( * ) !! Name of the symbol end function dlsym end interface interface !! Close a dynamic library or bundle function dlclose ( handle ) bind ( C ) import integer ( c_int ) :: dlclose !! Result of the operation type ( c_ptr ), value :: handle !! Handle to the library end function dlclose end interface interface !! Get diagnostic information function dlerror () bind ( C ) import type ( c_ptr ) :: dlerror !! Error message end function dlerror end interface #endif interface !! Allocates memory using C11 Standard alloc_align with 16 bytes alignment subroutine mem_alloc_host ( alloc_size , ptr ) bind ( C ) import integer ( c_size_t ), value :: alloc_size !! Number of bytes to allocate type ( c_ptr ) :: ptr !! Pointer to allocate end subroutine mem_alloc_host end interface interface !! Frees memory allocated with [[mem_alloc_host]] subroutine mem_free_host ( ptr ) bind ( C ) import type ( c_ptr ), value :: ptr !! Pointer to free end subroutine mem_free_host end interface #ifdef DTFFT_WITH_CUDA interface !! Converts Fortran communicator to C type ( c_ptr ) function Comm_f2c ( fcomm ) bind ( C , name = \"Comm_f2c\" ) import integer ( c_int ), value :: fcomm !! Fortran communicator end function Comm_f2c end interface interface !! Checks if pointer can be accessed from device function is_device_ptr ( ptr ) result ( bool ) bind ( C ) import type ( c_ptr ), value :: ptr !! Device pointer logical ( c_bool ) :: bool !! Result end function is_device_ptr end interface #endif contains #ifdef DTFFT_WITH_CUDA type ( string ) function string_constructor ( str ) !! Creates [[string]] object character ( len =* ), intent ( in ) :: str !! String allocate ( string_constructor % raw , source = str ) end function string_constructor subroutine destroy_strings ( strings ) !! Destroys array of [[string]] objects type ( string ), intent ( inout ), allocatable :: strings (:) !! Array of strings integer ( int32 ) :: i if ( . not . allocated ( strings ) ) return do i = 1 , size ( strings ) if ( allocated ( strings ( i )% raw ) ) deallocate ( strings ( i )% raw ) end do deallocate ( strings ) end subroutine destroy_strings #endif integer ( int32 ) function init_internal () !! Checks if MPI is initialized and loads environment variables integer ( int32 ) :: ierr !! Error code logical :: is_mpi_init !! Is MPI initialized? init_internal = DTFFT_SUCCESS call MPI_Initialized ( is_mpi_init , ierr ) if ( . not . is_mpi_init ) then init_internal = DTFFT_ERROR_MPI_FINALIZED return endif ! Processing environment variables once if ( is_init_called ) return is_log_enabled = get_env ( \"ENABLE_LOG\" , . false .) z_slab_from_env = get_env ( \"ENABLE_Z_SLAB\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) #ifdef DTFFT_WITH_CUDA block type ( string ), allocatable :: platforms (:) character ( len = :), allocatable :: pltfrm_env allocate ( platforms ( 2 ) ) platforms ( 1 ) = string ( \"host\" ) platforms ( 2 ) = string ( \"cuda\" ) allocate ( pltfrm_env , source = get_env ( \"PLATFORM\" , \"undefined\" , platforms ) ) if ( pltfrm_env == \"undefined\" ) then platform_from_env = PLATFORM_NOT_SET else if ( pltfrm_env == \"host\" ) then platform_from_env = DTFFT_PLATFORM_HOST else if ( pltfrm_env == \"cuda\" ) then platform_from_env = DTFFT_PLATFORM_CUDA endif deallocate ( pltfrm_env ) call destroy_strings ( platforms ) endblock block type ( string ), allocatable :: backends (:) character ( len = :), allocatable :: bcknd_env allocate ( backends ( 8 ) ) backends ( 1 ) = string ( \"mpi_dt\" ) backends ( 2 ) = string ( \"mpi_p2p\" ) backends ( 3 ) = string ( \"mpi_a2a\" ) backends ( 4 ) = string ( \"mpi_p2p_pipe\" ) backends ( 5 ) = string ( \"nccl\" ) backends ( 6 ) = string ( \"nccl_pipe\" ) backends ( 7 ) = string ( \"cufftmp\" ) backends ( 8 ) = string ( \"cufftmp_pipe\" ) allocate ( bcknd_env , source = get_env ( \"BACKEND\" , \"undefined\" , backends ) ) select case ( bcknd_env ) case ( \"undefined\" ) backend_from_env = BACKEND_NOT_SET case ( \"mpi_dt\" ) backend_from_env = DTFFT_BACKEND_MPI_DATATYPE case ( \"mpi_p2p\" ) backend_from_env = DTFFT_BACKEND_MPI_P2P case ( \"mpi_a2a\" ) backend_from_env = DTFFT_BACKEND_MPI_A2A case ( \"mpi_p2p_pipe\" ) backend_from_env = DTFFT_BACKEND_MPI_P2P_PIPELINED case ( \"nccl\" ) backend_from_env = DTFFT_BACKEND_NCCL case ( \"nccl_pipe\" ) backend_from_env = DTFFT_BACKEND_NCCL_PIPELINED case ( \"cufftmp\" ) backend_from_env = DTFFT_BACKEND_CUFFTMP case ( \"cufftmp_pipe\" ) backend_from_env = DTFFT_BACKEND_CUFFTMP_PIPELINED endselect deallocate ( bcknd_env ) call destroy_strings ( backends ) endblock mpi_enabled_from_env = get_env ( \"ENABLE_MPI\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) nccl_enabled_from_env = get_env ( \"ENABLE_NCCL\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) nvshmem_enabled_from_env = get_env ( \"ENABLE_NVSHMEM\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) pipe_enabled_from_env = get_env ( \"ENABLE_PIPE\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) #endif is_init_called = . true . end function init_internal pure type ( dtfft_platform_t ) function get_platform_from_env () !! Returns execution platform set by environment variable get_platform_from_env = platform_from_env end function get_platform_from_env pure integer ( int32 ) function get_z_slab_from_env () !! Returns Z-slab to be used set by environment variable get_z_slab_from_env = z_slab_from_env end function get_z_slab_from_env #ifdef DTFFT_WITH_CUDA pure type ( dtfft_backend_t ) function get_backend_from_env () !! Returns GPU backend to use set by environment variable get_backend_from_env = backend_from_env end function get_backend_from_env pure integer ( int32 ) function get_mpi_enabled_from_env () !! Returns usage of MPI Backends during autotune set by environment variable get_mpi_enabled_from_env = mpi_enabled_from_env end function get_mpi_enabled_from_env pure integer ( int32 ) function get_nccl_enabled_from_env () !! Returns usage of NCCL Backends during autotune set by environment variable get_nccl_enabled_from_env = nccl_enabled_from_env end function get_nccl_enabled_from_env pure integer ( int32 ) function get_nvshmem_enabled_from_env () !! Returns usage of NVSHMEM Backends during autotune set by environment variable get_nvshmem_enabled_from_env = nvshmem_enabled_from_env end function get_nvshmem_enabled_from_env pure integer ( int32 ) function get_pipe_enabled_from_env () !! Returns usage of Pipelined Backends during autotune set by environment variable get_pipe_enabled_from_env = pipe_enabled_from_env end function get_pipe_enabled_from_env #endif function get_env_base ( name ) result ( env ) !! Base function of obtaining dtFFT environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix character ( len = :), allocatable :: full_name !! Prefixed environment variable name character ( len = :), allocatable :: env !! Environment variable value integer ( int32 ) :: env_val_len !! Length of the environment variable allocate ( full_name , source = \"DTFFT_\" // name ) call get_environment_variable ( full_name , length = env_val_len ) allocate ( character ( env_val_len ) :: env ) if ( env_val_len == 0 ) then deallocate ( full_name ) return endif call get_environment_variable ( full_name , env ) deallocate ( full_name ) end function get_env_base #ifdef DTFFT_WITH_CUDA function get_env_string ( name , default , valid_values ) result ( env ) !! Obtains string environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix character ( len =* ), intent ( in ) :: default !! Name of environment variable without prefix type ( string ), intent ( in ) :: valid_values (:) !! List of valid variable values character ( len = :), allocatable :: env !! Environment variable value character ( len = :), allocatable :: env_val_str !! String value of the environment variable logical :: is_correct !! Is env value is correct integer ( int32 ) :: i , j allocate ( env_val_str , source = get_env ( name ) ) if ( len ( env_val_str ) == 0 ) then deallocate ( env_val_str ) allocate ( env , source = default ) return endif ! Converting to lowercase do i = 1 , len ( env_val_str ) j = index ( UPPER_ALPHABET , env_val_str ( i : i )) if ( j > 0 ) env_val_str ( i : i ) = LOWER_ALPHABET ( j : j ) enddo is_correct = any ([( env_val_str == valid_values ( i )% raw , i = 1 , size ( valid_values ))]) if ( is_correct ) then allocate ( env , source = env_val_str ) deallocate ( env_val_str ) return endif WRITE_ERROR ( \"Invalid environment variable: `DTFFT_\" // name // \"`, it has been ignored\" ) allocate ( env , source = default ) deallocate ( env_val_str ) end function get_env_string #endif integer ( int32 ) function get_env_int32 ( name , default , valid_values , min_valid_value ) result ( env ) !! Base Integer function of obtaining dtFFT environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix integer ( int32 ), intent ( in ) :: default !! Default value in case env is not set or it has wrong value integer ( int32 ), intent ( in ), optional :: valid_values (:) !! List of valid values integer ( int32 ), intent ( in ), optional :: min_valid_value !! Mininum valid value. Usually 0 or 1 character ( len = :), allocatable :: env_val_str !! String value of the environment variable logical :: is_correct !! Is env value is correct integer ( int32 ) :: env_val_passed !! Value of the environment variable if ( ( present ( valid_values ). and . present ( min_valid_value ) ) & . or .(. not . present ( valid_values ). and .. not . present ( min_valid_value )) & ) then INTERNAL_ERROR ( \"`get_env_int32`\" ) endif allocate ( env_val_str , source = get_env ( name ) ) if ( len ( env_val_str ) == 0 ) then deallocate ( env_val_str ) env = default return endif read ( env_val_str , * ) env_val_passed is_correct = . false . if ( present ( valid_values ) ) then is_correct = any ( env_val_passed == valid_values ) endif if ( present ( min_valid_value ) ) then is_correct = env_val_passed >= min_valid_value endif if ( is_correct ) then env = env_val_passed deallocate ( env_val_str ) return endif WRITE_ERROR ( \"Invalid environment variable: `DTFFT_\" // name // \"`, it has been ignored\" ) env = default deallocate ( env_val_str ) end function get_env_int32 integer ( int8 ) function get_env_int8 ( name , default , valid_values ) result ( env ) !! Obtains int8 environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix integer ( int8 ), intent ( in ) :: default !! Default value in case env is not set or it has wrong value integer ( int32 ), intent ( in ) :: valid_values (:) !! List of valid values integer ( int32 ) :: val !! Value of the environment variable val = get_env ( name , int ( default , int32 ), valid_values ) env = int ( val , int8 ) end function get_env_int8 logical function get_env_logical ( name , default ) result ( env ) !! Obtains logical environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix logical , intent ( in ) :: default !! Default value in case env is not set or it has wrong value integer ( int32 ) :: def , val if ( default ) then def = 1 else def = 0 endif val = get_env ( name , def , [ 0 , 1 ]) env = val == 1 end function get_env_logical integer ( int32 ) function get_iters_from_env ( is_warmup ) result ( n_iters ) !! Obtains number of iterations from environment variable logical , intent ( in ) :: is_warmup !! Warmup variable flag if ( is_warmup ) then n_iters = get_env ( \"MEASURE_WARMUP_ITERS\" , 2 , min_valid_value = 0 ) else n_iters = get_env ( \"MEASURE_ITERS\" , 5 , min_valid_value = 1 ) endif end function get_iters_from_env integer ( int8 ) function get_datatype_from_env ( name ) result ( env ) !! Obtains datatype id from environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix env = get_env ( name , 2_int8 , [ 1 , 2 ]) end function get_datatype_from_env pure function get_log_enabled () result ( log ) !! Returns the value of the log_enabled variable logical :: log !! Value of the log_enabled variable log = is_log_enabled end function get_log_enabled subroutine string_f2c ( fstring , cstring , string_size ) !! Convert Fortran string to C string character ( len =* ), intent ( in ) :: fstring !! Fortran string character ( kind = c_char ), intent ( inout ) :: cstring ( * ) !! C string integer ( int64 ), optional , intent ( out ) :: string_size !! Size of the C string integer :: i , j !! Loop indices logical :: met_non_blank !! Have we met a non-blank character? j = 1 met_non_blank = . false . do i = 1 , len_trim ( fstring ) if ( met_non_blank ) then cstring ( j ) = fstring ( i : i ) j = j + 1 else if ( fstring ( i : i ) /= ' ' ) then met_non_blank = . true . cstring ( j ) = fstring ( i : i ) j = j + 1 end if end do cstring ( j ) = c_null_char if ( present ( string_size )) string_size = j end subroutine string_f2c subroutine string_c2f ( cstring , string ) !! Convert C string to Fortran string type ( c_ptr ) :: cstring !! C string character ( len = :), allocatable :: string !! Fortran string character ( len = 256 ), pointer :: fstring !! Temporary Fortran string call c_f_pointer ( cstring , fstring ) allocate ( string , source = fstring ( 1 : index ( fstring , c_null_char ) - 1 ) ) end subroutine string_c2f #ifdef DTFFT_WITH_CUDA subroutine astring_f2c ( fstring , cstring , string_size ) !! Convert Fortran string to C allocatable string character ( len =* ), intent ( in ) :: fstring !! Fortran string character ( kind = c_char ), allocatable , intent ( out ) :: cstring (:) !! C string integer ( int64 ), optional , intent ( out ) :: string_size !! Size of the C string allocate ( cstring ( len_trim ( fstring ) + 1 )) call string_f2c ( fstring , cstring , string_size ) end subroutine astring_f2c subroutine dl_error ( message ) !! Writes error message to the error unit character ( len =* ), intent ( in ) :: message !! Message to write character ( len = :), allocatable :: err_msg !! Error string call string_c2f ( dlerror (), err_msg ) WRITE_ERROR ( message // \": \" // err_msg ) deallocate ( err_msg ) end subroutine dl_error function load_library ( name ) result ( lib_handle ) !! Dynamically loads library character ( len =* ), intent ( in ) :: name !! Name of library to load type ( c_ptr ) :: lib_handle !! Loaded handle character ( c_char ), allocatable :: cname (:) !! Temporary string WRITE_DEBUG ( \"Loading library: \" // name ) call astring_f2c ( name // c_null_char , cname ) lib_handle = dlopen ( cname , RTLD_LAZY ) deallocate ( cname ) if ( is_null_ptr ( lib_handle )) then call dl_error ( \"Failed to load library '\" // name // \"'\" ) endif end function load_library function load_symbol ( handle , name ) result ( symbol_handle ) !! Dynamically loads symbol from library type ( c_ptr ), intent ( in ) :: handle !! Loaded handle character ( len =* ), intent ( in ) :: name !! Name of function to load type ( c_funptr ) :: symbol_handle !! Function pointer character ( c_char ), allocatable :: cname (:) !! Temporary string if ( is_null_ptr ( handle ) ) INTERNAL_ERROR ( \"is_null_ptr(handle)\" ) call astring_f2c ( name // c_null_char , cname ) symbol_handle = dlsym ( handle , cname ) deallocate ( cname ) if ( is_null_ptr ( symbol_handle )) then call dl_error ( \"Failed to load symbol '\" // name // \"'\" ) endif end function load_symbol subroutine unload_library ( handle ) !! Unloads library type ( c_ptr ), intent ( in ) :: handle !! Loaded handle integer ( int32 ) :: ierr !! Error code ierr = dlclose ( handle ) if ( ierr /= 0 ) then call dl_error ( \"Failed to unload library\" ) endif end subroutine unload_library function dynamic_load ( name , symbol_names , handle , symbols ) result ( error_code ) !! Dynamically loads library and its symbols character ( len =* ), intent ( in ) :: name !! Name of library to load type ( string ), intent ( in ) :: symbol_names (:) !! Names of functions to load type ( c_ptr ), intent ( out ) :: handle !! Loaded handle type ( c_funptr ), intent ( out ) :: symbols (:) !! Function pointers integer ( int32 ) :: error_code !! Error code integer ( int32 ) :: i !! Loop index error_code = DTFFT_SUCCESS handle = load_library ( name ) if ( is_null_ptr ( handle ) ) then error_code = DTFFT_ERROR_DLOPEN_FAILED return endif do i = 1 , size ( symbol_names ) symbols ( i ) = load_symbol ( handle , symbol_names ( i )% raw ) if ( is_null_ptr ( symbols ( i )) ) then call unload_library ( handle ) symbols ( 1 : i ) = c_null_funptr error_code = DTFFT_ERROR_DLSYM_FAILED return endif end do end function dynamic_load #endif function int_to_str_int8 ( n ) result ( string ) !! Convert 8-bit integer to string integer ( int8 ), intent ( in ) :: n !! Integer to convert character ( len = :), allocatable :: string !! Resulting string character ( len = 3 ) :: temp !! Temporary string write ( temp , '(I3)' ) n allocate ( string , source = trim ( adjustl ( temp )) ) end function int_to_str_int8 function int_to_str_int32 ( n ) result ( string ) !! Convert 32-bit integer to string integer ( int32 ), intent ( in ) :: n !! Integer to convert character ( len = :), allocatable :: string !! Resulting string character ( len = 11 ) :: temp !! Temporary string write ( temp , '(I11)' ) n allocate ( string , source = trim ( adjustl ( temp )) ) end function int_to_str_int32 function int_to_str_int64 ( n ) result ( string ) !! Convert 64-bit integer to string integer ( int64 ), intent ( in ) :: n !! Integer to convert character ( len = :), allocatable :: string !! Resulting string character ( len = 20 ) :: temp !! Temporary string write ( temp , '(I20)' ) n allocate ( string , source = trim ( adjustl ( temp )) ) end function int_to_str_int64 function double_to_str ( n ) result ( string ) !! Convert double to string real ( real64 ), intent ( in ) :: n !! Double to convert character ( len = :), allocatable :: string !! Resulting string character ( len = 23 ) :: temp !! Temporary string write ( temp , '(F15.5)' ) n allocate ( string , source = trim ( adjustl ( temp ))) end function double_to_str subroutine write_message ( unit , message , prefix ) !! Write message to the specified unit integer ( int32 ), intent ( in ) :: unit !! Unit number character ( len =* ), intent ( in ) :: message !! Message to write character ( len =* ), intent ( in ), optional :: prefix !! Prefix to the message character ( len = :), allocatable :: prefix_ !! Dummy prefix integer ( int32 ) :: comm_rank !! Size of world communicator integer ( int32 ) :: ierr !! Error code logical :: is_finalized !! Is MPI Already finalized? call MPI_Finalized ( is_finalized , ierr ) if ( is_finalized ) then comm_rank = 0 else call MPI_Comm_rank ( MPI_COMM_WORLD , comm_rank , ierr ) endif if ( comm_rank /= 0 ) return if ( present ( prefix ) ) then allocate ( prefix_ , source = prefix ) else allocate ( prefix_ , source = \"\" ) endif write ( unit , '(a)' ) prefix_ // trim ( message ) flush ( unit ) deallocate ( prefix_ ) end subroutine write_message elemental function get_inverse_kind ( r2r_kind ) result ( result_kind ) !! Get the inverse R2R kind of transform for the given R2R kind type ( dtfft_r2r_kind_t ), intent ( in ) :: r2r_kind !! R2R kind type ( dtfft_r2r_kind_t ) :: result_kind result_kind = dtfft_r2r_kind_t ( - 1 ) select case ( r2r_kind % val ) case ( DTFFT_DCT_1 % val ) result_kind = DTFFT_DCT_1 case ( DTFFT_DCT_2 % val ) result_kind = DTFFT_DCT_3 case ( DTFFT_DCT_3 % val ) result_kind = DTFFT_DCT_2 case ( DTFFT_DCT_4 % val ) result_kind = DTFFT_DCT_4 case ( DTFFT_DST_1 % val ) result_kind = DTFFT_DST_1 case ( DTFFT_DST_2 % val ) result_kind = DTFFT_DST_3 case ( DTFFT_DST_3 % val ) result_kind = DTFFT_DST_2 case ( DTFFT_DST_4 % val ) result_kind = DTFFT_DST_4 endselect end function get_inverse_kind elemental logical function is_null_ptr ( ptr ) !! Checks if pointer is NULL type ( c_ptr ), intent ( in ) :: ptr !! Pointer to check is_null_ptr = . not . c_associated ( ptr ) end function is_null_ptr #ifdef DTFFT_WITH_CUDA elemental logical function is_null_funptr ( ptr ) !! Checks if pointer is NULL type ( c_funptr ), intent ( in ) :: ptr !! Pointer to check is_null_funptr = . not . c_associated ( ptr ) end function is_null_funptr #endif elemental logical function is_same_ptr ( ptr1 , ptr2 ) !! Checks if two pointer are the same type ( c_ptr ), intent ( in ) :: ptr1 !! First pointer type ( c_ptr ), intent ( in ) :: ptr2 !! Second pointer is_same_ptr = c_associated ( ptr1 , ptr2 ) end function is_same_ptr #ifdef DTFFT_WITH_CUDA integer ( int32 ) function count_unique ( x ) result ( n ) !! Count the number of unique elements in the array integer ( int32 ), intent ( in ) :: x (:) !! Array of integers integer ( int32 ), allocatable :: y (:) !! Array of unique integers allocate ( y , source = x ) n = 0 do while ( size ( y ) > 0 ) n = n + 1 y = pack ( y , mask = ( y (:) /= y ( 1 ))) ! drops all elements that are ! equals to the 1st one (included) end do deallocate ( y ) end function count_unique #endif end module dtfft_utils","tags":"","loc":"sourcefile/dtfft_utils.f90.html"},{"title":"dtfft_interface_cuda.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_cuda.f90~~EfferentGraph sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_cuda.f90~~AfferentGraph sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_cuda !! CUDA Driver Interfaces !! !! CUDA Driver is loaded at runtime via dynamic loading. use iso_c_binding use iso_fortran_env , only : int32 use dtfft_errors use dtfft_parameters use dtfft_interface_cuda_runtime , only : dim3 use dtfft_utils implicit none private #include \"dtfft_private.h\" public :: load_cuda public :: cuLaunchKernel public :: kernelArgs type , bind ( C ) :: kernelArgs !! Arguments passed to nvrtc-compiled kernels integer ( c_int ) :: n_ints = 0 !! Number of integers provided integer ( c_int ) :: ints ( 5 ) !! Integer array integer ( c_int ) :: n_ptrs = 0 !! Number of pointers provided type ( c_ptr ) :: ptrs ( 3 ) !! Pointer array end type kernelArgs public :: CUmodule type , bind ( C ) :: CUmodule !! CUDA module type ( c_ptr ) :: ptr !! Actual pointer end type CUmodule public :: CUfunction type , bind ( C ) :: CUfunction !! CUDA function type ( c_ptr ) :: ptr !! Actual pointer end type CUfunction abstract interface function cuModuleLoadDataEx_interface ( mod , image , numOptions , options , optionValues ) & result ( cuResult ) !! Load a module's data with options. !! !! Takes a pointer image and loads the corresponding module module into the current context. !! The image may be a cubin or fatbin as output by nvcc, or a NULL-terminated PTX, either as output by nvcc or hand-written. import type ( CUmodule ) :: mod !! Returned module character ( c_char ) :: image ( * ) !! Module data to load integer ( c_int ), value :: numOptions !! Number of options type ( c_ptr ), value :: options !! Options for JIT type ( c_ptr ) :: optionValues !! Option values for JIT integer ( c_int ) :: cuResult !! Driver result code end function cuModuleLoadDataEx_interface function cuModuleUnload_interface ( hmod ) & result ( cuResult ) !! Unloads a module. !! !! Unloads a module ``hmod`` from the current context. !! Attempting to unload a module which was obtained from the Library Management API !! such as ``cuLibraryGetModule`` will return ``CUDA_ERROR_NOT_PERMITTED``. import type ( CUmodule ), value :: hmod !! Module to unload integer ( c_int ) :: cuResult !! Driver result code end function cuModuleUnload_interface function cuModuleGetFunction_interface ( hfunc , hmod , name ) & result ( cuResult ) !! Returns a function handle. !! !! Returns in ``hfunc`` the handle of the function of name name located in module hmod. !! If no function of that name exists, ``cuModuleGetFunction`` returns ``CUDA_ERROR_NOT_FOUND``. import type ( CUfunction ) :: hfunc !! Returns a function handle. type ( CUmodule ), value :: hmod !! Module to retrieve function from character ( c_char ) :: name ( * ) !! Name of function to retrieve integer ( c_int ) :: cuResult !! Driver result code end function cuModuleGetFunction_interface end interface interface !! Launches a CUDA function CUfunction or a CUDA kernel CUkernel. function run_cuda_kernel ( func , in , out , blocks , threads , stream , args , funptr ) & result ( cuResult ) & bind ( C , name = \"run_cuda_kernel\" ) !! Wrapper around ``cuLaunchKernel``, since I have to idea how to pass array of pointers to ``cuLaunchKernel``. !! !! Launches a CUDA function CUfunction or a CUDA kernel CUkernel. import type ( CUfunction ), value :: func !! Function CUfunction or Kernel CUkernel to launch type ( c_ptr ), value :: in !! Input pointer type ( c_ptr ), value :: out !! Output pointer type ( dim3 ) :: blocks !! Grid in blocks type ( dim3 ) :: threads !! Thread block type ( dtfft_stream_t ), value :: stream !! Stream identifier type ( kernelArgs ) :: args !! Kernel parameters type ( c_funptr ), value :: funptr !! Pointer to ``cuLaunchKernel`` integer ( c_int ) :: cuResult !! Driver result code end function run_cuda_kernel end interface logical , save :: is_loaded = . false . !! Flag indicating whether the library is loaded type ( c_ptr ), save :: libcuda !! Handle to the loaded library type ( c_funptr ), save :: cuFunctions ( 4 ) !! Array of pointers to the CUDA functions procedure ( cuModuleLoadDataEx_interface ), pointer , public :: cuModuleLoadDataEx !! Fortran pointer to the cuModuleLoadDataEx function procedure ( cuModuleUnload_interface ), pointer , public :: cuModuleUnload !! Fortran pointer to the cuModuleUnload function procedure ( cuModuleGetFunction_interface ), pointer , public :: cuModuleGetFunction !! Fortran pointer to the cuModuleGetFunction function contains function load_cuda () result ( error_code ) !! Loads the CUDA Driver library and needed symbols integer ( int32 ) :: error_code !! Error code type ( string ), allocatable :: func_names (:) error_code = DTFFT_SUCCESS if ( is_loaded ) return allocate ( func_names ( 4 )) func_names ( 1 ) = string ( \"cuModuleLoadDataEx\" ) func_names ( 2 ) = string ( \"cuModuleUnload\" ) func_names ( 3 ) = string ( \"cuModuleGetFunction\" ) func_names ( 4 ) = string ( \"cuLaunchKernel\" ) error_code = dynamic_load ( \"libcuda.so\" , func_names , libcuda , cuFunctions ) call destroy_strings ( func_names ) if ( error_code /= DTFFT_SUCCESS ) return call c_f_procpointer ( cuFunctions ( 1 ), cuModuleLoadDataEx ) call c_f_procpointer ( cuFunctions ( 2 ), cuModuleUnload ) call c_f_procpointer ( cuFunctions ( 3 ), cuModuleGetFunction ) is_loaded = . true . end function load_cuda function cuLaunchKernel ( func , in , out , blocks , threads , stream , args ) result ( cuResult ) !! Launches a CUDA function CUfunction or a CUDA kernel CUkernel. type ( CUfunction ) :: func !! Function CUfunction or Kernel CUkernel to launch type ( c_ptr ) :: in !! Input pointer type ( c_ptr ) :: out !! Output pointer type ( dim3 ) :: blocks !! Grid in blocks type ( dim3 ) :: threads !! Thread block type ( dtfft_stream_t ) :: stream !! Stream identifier type ( kernelArgs ) :: args !! Kernel parameters integer ( c_int ) :: cuResult !! Driver result code cuResult = run_cuda_kernel ( func , in , out , blocks , threads , stream , args , cuFunctions ( 4 )) end function cuLaunchKernel end module dtfft_interface_cuda","tags":"","loc":"sourcefile/dtfft_interface_cuda.f90.html"},{"title":"dtfft_interface_nccl.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_nccl.f90~~EfferentGraph sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_nccl.f90~~AfferentGraph sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_nccl !! NCCL Interfaces use iso_c_binding use dtfft_parameters , only : dtfft_stream_t use dtfft_utils , only : string_c2f implicit none private public :: ncclGetErrorString public :: ncclUniqueId type , bind ( c ) :: ncclUniqueId character ( c_char ) :: internal ( 128 ) end type ncclUniqueId public :: ncclComm type , bind ( c ) :: ncclComm type ( c_ptr ) :: member end type ncclComm public :: ncclDataType type , bind ( c ) :: ncclDataType integer ( c_int ) :: member end type ncclDataType type ( ncclDataType ), parameter , public :: ncclFloat = ncclDataType ( 7 ) interface !! Returns a human-readable string corresponding to the passed error code. function ncclGetErrorString_c ( ncclResult_t ) & result ( message ) & bind ( C , name = \"ncclGetErrorString\" ) import integer ( c_int32_t ), intent ( in ), value :: ncclResult_t !! Completion status of a NCCL function. type ( c_ptr ) :: message !! Pointer to message end function ncclGetErrorString_c endinterface public :: ncclGetUniqueId interface !! Generates an Id to be used in ncclCommInitRank. !! ncclGetUniqueId should be called once when creating a communicator and the Id should be !! distributed to all ranks in the communicator before calling ncclCommInitRank. !! uniqueId should point to a ncclUniqueId object allocated by the user. function ncclGetUniqueId ( uniqueId ) & result ( ncclResult_t ) & bind ( C , name = \"ncclGetUniqueId\" ) import type ( ncclUniqueId ), intent ( out ) :: uniqueId !! Unique ID integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclGetUniqueId end interface public :: ncclMemAlloc interface !! Allocate a GPU buffer with size. !! Allocated buffer head address will be returned by ptr, and the actual allocated size can be larger !! than requested because of the buffer granularity requirements from all types of NCCL optimizations. function ncclMemAlloc ( ptr , alloc_bytes ) & result ( ncclResult_t ) & bind ( C , name = \"ncclMemAlloc\" ) import type ( c_ptr ), intent ( out ) :: ptr !! Buffer address integer ( c_size_t ), intent ( in ), value :: alloc_bytes !! Number of bytes to allocate integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclMemAlloc end interface public :: ncclMemFree interface !! Free memory allocated by ncclMemAlloc(). function ncclMemFree ( ptr ) & result ( ncclResult_t ) & bind ( C , name = \"ncclMemFree\" ) import type ( c_ptr ), intent ( in ), value :: ptr !! Buffer address integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclMemFree end interface public :: ncclCommInitRank interface !! Creates a new communicator (multi thread/process version). !! !! rank must be between 0 and nranks-1 and unique within a communicator clique. !! Each rank is associated to a CUDA device, which has to be set before calling ncclCommInitRank. !! !! ncclCommInitRank implicitly synchronizes with other ranks, hence it must be called by different !! threads/processes or used within ncclGroupStart/ncclGroupEnd. function ncclCommInitRank ( comm , nranks , uniqueId , rank ) & result ( ncclResult_t ) & bind ( C , name = \"ncclCommInitRank\" ) import type ( ncclComm ) :: comm !! Communicator integer ( c_int ), value :: nranks !! Number of ranks in communicator type ( ncclUniqueId ), value :: uniqueId !! Unique ID integer ( c_int ), value :: rank !! Calling rank integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclCommInitRank end interface public :: ncclSend interface !! Send data from sendbuff to rank peer. !! !! Rank peer needs to call ncclRecv with the same datatype and the same count as this rank. !! !! This operation is blocking for the GPU. !! If multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, !! they must be fused within a ncclGroupStart()/ ncclGroupEnd() section. function ncclSend ( sendbuff , count , datatype , peer , comm , stream ) & result ( ncclResult_t ) & bind ( c , name = 'ncclSend' ) import real ( c_float ) :: sendbuff !! Buffer to send data from integer ( c_size_t ), value :: count !! Number of elements to send type ( ncclDataType ), value :: datatype !! Datatype to send integer ( c_int ), value :: peer !! Target GPU type ( ncclComm ), value :: comm !! Communicator type ( dtfft_stream_t ), value :: stream !! CUDA Stream integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclSend end interface public :: ncclRecv interface !! Receive data from rank peer into recvbuff. !! !! Rank peer needs to call ncclSend with the same datatype and the same count as this rank. !! This operation is blocking for the GPU. !! If multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, !! they must be fused within a ncclGroupStart()/ ncclGroupEnd() section. function ncclRecv ( recvbuff , count , datatype , peer , comm , stream ) & result ( ncclResult_t ) & bind ( c , name = 'ncclRecv' ) import real ( c_float ) :: recvbuff !! Buffer to recv data into integer ( c_size_t ), value :: count !! Number of elements to recv type ( ncclDataType ), value :: datatype !! Datatype to recv integer ( c_int ), value :: peer !! Source GPU type ( ncclComm ), value :: comm !! Communicator type ( dtfft_stream_t ), value :: stream !! CUDA Stream integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclRecv end interface public :: ncclGroupStart interface !! Start a group call. !! !! All subsequent calls to NCCL until ncclGroupEnd will not block due to inter-CPU synchronization. function ncclGroupStart () & result ( ncclResult_t ) & bind ( C , name = \"ncclGroupStart\" ) import integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclGroupStart end interface public :: ncclGroupEnd interface !! End a group call. !! !! Returns when all operations since ncclGroupStart have been processed. !! This means the communication primitives have been enqueued to the provided streams, !! but are not necessarily complete. function ncclGroupEnd () & result ( ncclResult_t ) & bind ( C , name = \"ncclGroupEnd\" ) import integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclGroupEnd end interface public :: ncclCommDestroy interface !! Destroy a communicator object comm. function ncclCommDestroy ( comm ) & result ( ncclResult_t ) & bind ( C , name = \"ncclCommDestroy\" ) import type ( ncclComm ), value :: comm !! Communicator integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclCommDestroy end interface public :: ncclCommRegister interface !! Register a buffer for collective communication. function ncclCommRegister ( comm , buff , size , handle ) & result ( ncclResult_t ) & bind ( C , name = \"ncclCommRegister\" ) import type ( ncclComm ), value :: comm !! Communicator type ( c_ptr ), value :: buff !! Buffer to register integer ( c_size_t ), value :: size !! Size of the buffer in bytes type ( c_ptr ) :: handle !! Handle to the registered buffer integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclCommRegister end interface public :: ncclCommDeregister interface !! Deregister a buffer for collective communication. function ncclCommDeregister ( comm , handle ) & result ( ncclResult_t ) & bind ( C , name = \"ncclCommDeregister\" ) import type ( ncclComm ), value :: comm !! Communicator type ( c_ptr ), value :: handle !! Handle to the registered buffer integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclCommDeregister end interface contains function ncclGetErrorString ( ncclResult_t ) result ( string ) !! Generates an error message. integer ( c_int32_t ), intent ( in ) :: ncclResult_t !! Completion status of a function. character ( len = :), allocatable :: string !! Error message call string_c2f ( ncclGetErrorString_c ( ncclResult_t ), string ) end function ncclGetErrorString end module dtfft_interface_nccl","tags":"","loc":"sourcefile/dtfft_interface_nccl.f90.html"},{"title":"dtfft_backend_nccl.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_backend_nccl.f90~~EfferentGraph sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_backend_nccl.f90~~AfferentGraph sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_backend_nccl_m !! NCCL Based GPU Backends [[backend_nccl]] use iso_fortran_env use iso_c_binding , only : c_ptr , c_f_pointer use dtfft_interface_cuda_runtime use dtfft_interface_nccl use dtfft_abstract_backend , only : abstract_backend , backend_helper use dtfft_parameters use dtfft_utils #include \"dtfft_mpi.h\" #include \"dtfft_cuda.h\" #include \"dtfft_private.h\" implicit none private public :: backend_nccl type , extends ( abstract_backend ) :: backend_nccl !! NCCL backend private type ( ncclComm ) :: nccl_comm !! NCCL Communicator contains procedure :: create_private => create_nccl !! Creates NCCL backend procedure :: execute_private => execute_nccl !! Executes NCCL backend procedure :: destroy_private => destroy_nccl !! Destroys NCCL backend end type backend_nccl contains subroutine create_nccl ( self , helper , tranpose_type , base_storage ) !! Creates NCCL backend class ( backend_nccl ), intent ( inout ) :: self !! NCCL backend type ( backend_helper ), intent ( in ) :: helper !! Backend helper type ( dtfft_transpose_t ), intent ( in ) :: tranpose_type !! Type of transpose to create (unused) integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element (unused) if ( . not . is_backend_nccl ( self % backend ) ) INTERNAL_ERROR ( \".not. is_backend_nccl\" ) if ( . not . helper % is_nccl_created ) INTERNAL_ERROR ( \".not. helper%is_nccl_created\" ) self % nccl_comm = helper % nccl_comm end subroutine create_nccl subroutine execute_nccl ( self , in , out , stream , aux ) !! Executes NCCL backend class ( backend_nccl ), intent ( inout ) :: self !! NCCL backend real ( real32 ), target , intent ( inout ) :: in (:) !! Send pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Main execution CUDA stream real ( real32 ), target , intent ( inout ) :: aux (:) !! Auxiliary pointer integer ( int32 ) :: i !! Counter integer ( int32 ) :: rnk !! Rank to send-recv real ( real32 ), pointer :: pin (:), pout (:) if ( self % is_pipelined ) then pin => in (:) pout => aux (:) else pin => in (:) pout => out (:) endif NCCL_CALL ( \"ncclGroupStart\" , ncclGroupStart () ) do i = 0 , self % comm_size - 1 if ( i == self % comm_rank . and . self % is_pipelined ) cycle rnk = self % comm_mapping ( i ) if ( self % send_floats ( i ) > 0 ) then NCCL_CALL ( \"ncclSend\" , ncclSend ( pin ( self % send_displs ( i ) ), self % send_floats ( i ), ncclFloat , rnk , self % nccl_comm , stream ) ) endif if ( self % recv_floats ( i ) > 0 ) then NCCL_CALL ( \"ncclRecv\" , ncclRecv ( pout ( self % recv_displs ( i ) ), self % recv_floats ( i ), ncclFloat , rnk , self % nccl_comm , stream ) ) endif enddo NCCL_CALL ( \"ncclGroupEnd\" , ncclGroupEnd () ) if ( self % is_pipelined ) then call self % unpack_kernel2 % execute ( pout , out , stream ) endif end subroutine execute_nccl subroutine destroy_nccl ( self ) !! Destroys NCCL backend class ( backend_nccl ), intent ( inout ) :: self !! NCCL backend end subroutine destroy_nccl end module dtfft_backend_nccl_m","tags":"","loc":"sourcefile/dtfft_backend_nccl.f90.html"},{"title":"dtfft_transpose_handle_cuda.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_transpose_handle_cuda.f90~~EfferentGraph sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_transpose_handle_cuda.f90~~AfferentGraph sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_transpose_handle_cuda !! This module describes [[transpose_handle_cuda]] class use iso_c_binding , only : c_ptr use iso_fortran_env , only : int8 , int32 , int64 , real32 use dtfft_interface_cuda_runtime use dtfft_abstract_backend , only : abstract_backend , backend_helper #ifdef DTFFT_WITH_NVSHMEM use dtfft_backend_cufftmp_m , only : backend_cufftmp #endif #ifdef DTFFT_WITH_NCCL use dtfft_backend_nccl_m , only : backend_nccl #endif use dtfft_backend_mpi , only : backend_mpi use dtfft_nvrtc_kernel use dtfft_pencil , only : pencil , get_transpose_type use dtfft_parameters use dtfft_utils #include \"dtfft_mpi.h\" #include \"dtfft_profile.h\" #include \"dtfft_cuda.h\" #include \"dtfft_private.h\" implicit none private public :: transpose_handle_cuda type :: data_handle !! Helper class used to obtain displacements and !! counts needed to send to other processes integer ( int32 ), allocatable :: ls (:,:) !! Starts of my data that I should send or recv !! while communicating with other processes integer ( int32 ), allocatable :: ln (:,:) !! Counts of my data that I should send or recv !! while communicating with other processes integer ( int32 ), allocatable :: sizes (:,:) !! Counts of every rank in a comm integer ( int32 ), allocatable :: starts (:,:) !! Starts of every rank in a comm integer ( int32 ), allocatable :: displs (:) !! Local buffer displacement integer ( int32 ), allocatable :: counts (:) !! Number of elements to send or recv contains procedure , pass ( self ) :: create => create_data_handle !! Creates handle procedure , pass ( self ) :: destroy => destroy_data_handle !! Destroys handle end type data_handle type :: transpose_handle_cuda !! CUDA Transpose Handle private type ( dtfft_transpose_t ) :: transpose_type logical :: has_exchange = . false . !! If current handle has exchanges between GPUs logical :: is_pipelined = . false . !! If underlying exchanges are pipelined type ( nvrtc_kernel ) :: transpose_kernel !! Transposes data type ( nvrtc_kernel ) :: unpack_kernel !! Unpacks data type ( nvrtc_kernel ) :: unpack_kernel2 class ( abstract_backend ), allocatable :: comm_handle !! Communication handle contains procedure , pass ( self ) :: create !! Creates CUDA Transpose Handle procedure , pass ( self ) :: execute !! Executes transpose - exchange - unpack procedure , pass ( self ) :: destroy !! Destroys CUDA Transpose Handle procedure , pass ( self ) :: get_aux_size !! Returns number of bytes required by aux buffer procedure , pass ( self ) :: get_tranpose_type !! Returns transpose_type, associated with handle end type transpose_handle_cuda contains subroutine create_data_handle ( self , info , comm , comm_size ) !! Creates handle class ( data_handle ), intent ( inout ) :: self !! Helper class type ( pencil ), intent ( in ) :: info !! Pencil info TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator integer ( int32 ), intent ( in ) :: comm_size !! Size of ``comm`` integer ( int32 ) :: ierr !! MPI error flag allocate ( self % ls ( info % rank , 0 : comm_size - 1 ), source = 0_int32 ) allocate ( self % ln ( info % rank , 0 : comm_size - 1 ), source = 0_int32 ) allocate ( self % sizes ( info % rank , 0 : comm_size - 1 ) ) allocate ( self % starts ( info % rank , 0 : comm_size - 1 ) ) allocate ( self % displs ( 0 : comm_size - 1 ), source = 0_int32 ) allocate ( self % counts ( 0 : comm_size - 1 ), source = 0_int32 ) call MPI_Allgather ( info % counts , int ( info % rank , int32 ), MPI_INTEGER , self % sizes , int ( info % rank , int32 ), MPI_INTEGER , comm , ierr ) call MPI_Allgather ( info % starts , int ( info % rank , int32 ), MPI_INTEGER , self % starts , int ( info % rank , int32 ), MPI_INTEGER , comm , ierr ) end subroutine create_data_handle subroutine destroy_data_handle ( self ) !! Destroys handle class ( data_handle ), intent ( inout ) :: self !! Helper class if ( allocated ( self % ls )) deallocate ( self % ls ) if ( allocated ( self % ln )) deallocate ( self % ln ) if ( allocated ( self % sizes )) deallocate ( self % sizes ) if ( allocated ( self % starts )) deallocate ( self % starts ) if ( allocated ( self % displs )) deallocate ( self % displs ) if ( allocated ( self % counts )) deallocate ( self % counts ) end subroutine destroy_data_handle subroutine create ( self , helper , send , recv , base_storage , backend ) !! Creates CUDA Transpose Handle class ( transpose_handle_cuda ), intent ( inout ) :: self !! CUDA Transpose Handle type ( backend_helper ), intent ( in ) :: helper !! Backend helper ! TYPE_MPI_COMM,                  intent(in)    :: comm               !! 1d communicator type ( pencil ), intent ( in ) :: send !! Send pencil type ( pencil ), intent ( in ) :: recv !! Recv pencil integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( dtfft_backend_t ), intent ( in ) :: backend !! Backend type integer ( int8 ) :: ndims !! Number of dimensions type ( dtfft_transpose_t ) :: transpose_type !! Type of transpose based on ``send`` and ``recv`` integer ( int32 ) :: comm_size !! Size of ``comm`` integer ( int32 ) :: comm_rank !! Rank in ``comm`` integer ( int32 ) :: ierr !! MPI error flag logical :: packing_required !! If transpose kernel requires packing. X-Y 3d only integer ( int32 ) :: sdispl !! Send displacement integer ( int32 ) :: rdispl !! Recv displacement integer ( int32 ) :: sendsize !! Number of elements to send integer ( int32 ) :: recvsize !! Number of elements to recieve integer ( int32 ) :: i !! Counter TYPE_MPI_REQUEST :: sr !! Send request TYPE_MPI_REQUEST :: rr !! Recv request integer ( int8 ) :: kernel_type !! Type of kernel integer ( int32 ), allocatable :: k1 (:,:) !! Pack kernel arguments integer ( int32 ), allocatable :: k2 (:,:) !! Unpack kernel arguments type ( data_handle ) :: in !! Send helper type ( data_handle ) :: out !! Recv helper integer ( int8 ) :: comm_id TYPE_MPI_COMM :: comm transpose_type = get_transpose_type ( send , recv ) select case ( abs ( transpose_type % val ) ) case ( DTFFT_TRANSPOSE_X_TO_Y % val ) comm_id = 2 case ( DTFFT_TRANSPOSE_Y_TO_Z % val ) comm_id = 3 case ( DTFFT_TRANSPOSE_X_TO_Z % val ) comm_id = 1 case default INTERNAL_ERROR ( \"unknown `abs(transpose_type)`\" ) endselect comm = helper % comms ( comm_id ) call MPI_Comm_size ( comm , comm_size , ierr ) call MPI_Comm_rank ( comm , comm_rank , ierr ) self % has_exchange = comm_size > 1 self % transpose_type = transpose_type ndims = send % rank packing_required = ( abs ( transpose_type % val ) == DTFFT_TRANSPOSE_X_TO_Y % val ) & . and . self % has_exchange & . and . ndims == 3 & . and . (. not . backend == DTFFT_BACKEND_CUFFTMP ) kernel_type = KERNEL_TRANSPOSE if ( packing_required ) kernel_type = KERNEL_TRANSPOSE_PACKED if ( . not . self % has_exchange ) then call self % transpose_kernel % create ( comm , send % counts , base_storage , transpose_type , kernel_type ) return endif allocate ( k1 ( 3 , comm_size ), source = 0_int32 ) allocate ( k2 ( 5 , comm_size ), source = 0_int32 ) call in % create ( send , comm , comm_size ) call out % create ( recv , comm , comm_size ) sdispl = 0 do i = 0 , comm_size - 1 select case ( transpose_type % val ) case ( DTFFT_TRANSPOSE_X_TO_Y % val , DTFFT_TRANSPOSE_Y_TO_X % val ) in % ln ( 1 , i ) = out % sizes ( 2 , i ) in % ln ( 2 , i ) = in % sizes ( 2 , comm_rank ) in % ls ( 1 , i ) = out % starts ( 2 , i ) in % ls ( 2 , i ) = in % starts ( 2 , comm_rank ) if ( ndims == 3 ) then in % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) in % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) endif case ( DTFFT_TRANSPOSE_Y_TO_Z % val , DTFFT_TRANSPOSE_Z_TO_Y % val ) in % ln ( 1 , i ) = out % sizes ( 3 , i ) in % ln ( 2 , i ) = in % sizes ( 2 , comm_rank ) in % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) in % ls ( 1 , i ) = out % starts ( 3 , i ) in % ls ( 2 , i ) = in % starts ( 2 , comm_rank ) in % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) case ( DTFFT_TRANSPOSE_X_TO_Z % val ) in % ln ( 1 , i ) = in % sizes ( 1 , comm_rank ) in % ln ( 2 , i ) = out % sizes ( 3 , i ) in % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) in % ls ( 1 , i ) = in % starts ( 1 , comm_rank ) in % ls ( 2 , i ) = out % starts ( 3 , i ) in % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) case ( DTFFT_TRANSPOSE_Z_TO_X % val ) in % ln ( 1 , i ) = out % sizes ( 3 , i ) in % ln ( 2 , i ) = in % sizes ( 2 , comm_rank ) in % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) in % ls ( 1 , i ) = out % starts ( 3 , i ) in % ls ( 2 , i ) = in % starts ( 2 , comm_rank ) in % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) endselect if ( packing_required ) then k1 ( 1 , i + 1 ) = in % ls ( 1 , i ) k1 ( 2 , i + 1 ) = in % ln ( 1 , i ) k1 ( 3 , i + 1 ) = sdispl if ( sdispl > 0 ) then k1 ( 3 , i + 1 ) = k1 ( 3 , i + 1 ) - in % ls ( 1 , i ) * in % ln ( 2 , i ) endif endif sendsize = product ( in % ln (:, i ) ) in % counts ( i ) = sendsize in % displs ( i ) = sdispl sdispl = sdispl + sendsize ! Sending with tag = me to rank i call MPI_Isend ( sendsize , 1 , MPI_INTEGER4 , i , comm_rank , comm , sr , ierr ) call MPI_Wait ( sr , MPI_STATUS_IGNORE , ierr ) enddo rdispl = 0 do i = 0 , comm_size - 1 ! Recieving from i with tag i call MPI_Irecv ( recvsize , 1 , MPI_INTEGER4 , i , i , comm , rr , ierr ) call MPI_Wait ( rr , MPI_STATUS_IGNORE , ierr ) if ( recvsize > 0 ) then select case ( transpose_type % val ) case ( DTFFT_TRANSPOSE_X_TO_Y % val , DTFFT_TRANSPOSE_Y_TO_X % val ) out % ln ( 1 , i ) = in % sizes ( 2 , i ) out % ln ( 2 , i ) = out % sizes ( 2 , comm_rank ) out % ls ( 1 , i ) = in % starts ( 2 , i ) out % ls ( 2 , i ) = out % starts ( 2 , comm_rank ) if ( ndims == 3 ) then out % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) out % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) endif case ( DTFFT_TRANSPOSE_Y_TO_Z % val , DTFFT_TRANSPOSE_Z_TO_Y % val ) out % ln ( 1 , i ) = in % sizes ( 3 , i ) out % ln ( 2 , i ) = out % sizes ( 2 , comm_rank ) out % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) out % ls ( 1 , i ) = in % starts ( 3 , i ) out % ls ( 2 , i ) = out % starts ( 2 , comm_rank ) out % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) case ( DTFFT_TRANSPOSE_X_TO_Z % val ) out % ln ( 1 , i ) = in % sizes ( 3 , i ) out % ln ( 2 , i ) = out % sizes ( 2 , comm_rank ) out % ln ( 3 , i ) = out % sizes ( 3 , comm_rank ) out % ls ( 1 , i ) = in % starts ( 3 , i ) out % ls ( 2 , i ) = out % starts ( 2 , comm_rank ) out % ls ( 3 , i ) = out % starts ( 3 , comm_rank ) case ( DTFFT_TRANSPOSE_Z_TO_X % val ) out % ln ( 1 , i ) = out % sizes ( 1 , comm_rank ) out % ln ( 2 , i ) = in % sizes ( 3 , i ) out % ln ( 3 , i ) = out % sizes ( 3 , comm_rank ) out % ls ( 1 , i ) = out % starts ( 1 , comm_rank ) out % ls ( 2 , i ) = in % starts ( 3 , i ) out % ls ( 3 , i ) = out % starts ( 3 , comm_rank ) endselect endif k2 ( 1 , i + 1 ) = rdispl if ( transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then k2 ( 2 , i + 1 ) = out % ln ( 1 , i ) * out % ls ( 2 , i ) k2 ( 3 , i + 1 ) = out % ln ( 1 , i ) * out % ln ( 2 , i ) k2 ( 5 , i + 1 ) = out % sizes ( 1 , comm_rank ) * out % sizes ( 2 , comm_rank ) else k2 ( 2 , i + 1 ) = out % ls ( 1 , i ) k2 ( 3 , i + 1 ) = out % ln ( 1 , i ) k2 ( 5 , i + 1 ) = out % sizes ( 1 , comm_rank ) endif k2 ( 4 , i + 1 ) = recvsize out % counts ( i ) = recvsize out % displs ( i ) = rdispl rdispl = rdispl + recvsize enddo call self % transpose_kernel % create ( comm , send % counts , base_storage , transpose_type , kernel_type , k1 ) self % is_pipelined = is_backend_pipelined ( backend ) kernel_type = KERNEL_UNPACK if ( self % is_pipelined ) kernel_type = KERNEL_UNPACK_PIPELINED if ( backend == DTFFT_BACKEND_CUFFTMP ) kernel_type = KERNEL_UNPACK_SIMPLE_COPY if ( backend == DTFFT_BACKEND_CUFFTMP_PIPELINED ) kernel_type = KERNEL_DUMMY call self % unpack_kernel % create ( comm , recv % counts , base_storage , transpose_type , kernel_type , k2 ) if ( backend == DTFFT_BACKEND_NCCL_PIPELINED ) then call self % unpack_kernel2 % create ( comm , recv % counts , base_storage , transpose_type , KERNEL_UNPACK_PARTIAL , k2 ) endif if ( is_backend_mpi ( backend ) ) then allocate ( backend_mpi :: self % comm_handle ) else if ( is_backend_nccl ( backend ) ) then #ifdef DTFFT_WITH_NCCL allocate ( backend_nccl :: self % comm_handle ) #else INTERNAL_ERROR ( \"not DTFFT_WITH_NCCL\" ) #endif else if ( is_backend_cufftmp ( backend ) ) then #ifdef DTFFT_WITH_NVSHMEM allocate ( backend_cufftmp :: self % comm_handle ) #else INTERNAL_ERROR ( \"not DTFFT_WITH_NVSHMEM\" ) #endif else INTERNAL_ERROR ( \"Unknown backend\" ) endif call self % comm_handle % create ( backend , transpose_type , helper , comm_id , in % displs , in % counts , out % displs , out % counts , base_storage ) if ( self % is_pipelined ) then if ( backend == DTFFT_BACKEND_NCCL_PIPELINED ) then call self % comm_handle % set_unpack_kernel ( self % unpack_kernel , self % unpack_kernel2 ) else call self % comm_handle % set_unpack_kernel ( self % unpack_kernel ) endif endif call in % destroy () call out % destroy () deallocate ( k1 , k2 ) end subroutine create subroutine execute ( self , in , out , stream , aux ) !! Executes transpose - exchange - unpack class ( transpose_handle_cuda ), intent ( inout ) :: self !! CUDA Transpose Handle real ( real32 ), intent ( inout ) :: in (:) !! Send pointer real ( real32 ), intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Main execution CUDA stream real ( real32 ), intent ( inout ) :: aux (:) !! Aux pointer if ( self % is_pipelined ) then call self % transpose_kernel % execute ( in , aux , stream ) #ifdef __DEBUG CUDA_CALL ( \"cudaStreamSynchronize\" , cudaStreamSynchronize ( stream ) ) #endif call self % comm_handle % execute ( aux , out , stream , in ) #ifdef __DEBUG CUDA_CALL ( \"cudaStreamSynchronize\" , cudaStreamSynchronize ( stream ) ) #endif return endif call self % transpose_kernel % execute ( in , out , stream ) #ifdef __DEBUG CUDA_CALL ( \"cudaStreamSynchronize\" , cudaStreamSynchronize ( stream ) ) #endif if ( . not . self % has_exchange ) return call self % comm_handle % execute ( out , in , stream , aux ) #ifdef __DEBUG CUDA_CALL ( \"cudaStreamSynchronize\" , cudaStreamSynchronize ( stream ) ) #endif call self % unpack_kernel % execute ( in , out , stream ) #ifdef __DEBUG CUDA_CALL ( \"cudaStreamSynchronize\" , cudaStreamSynchronize ( stream ) ) #endif end subroutine execute subroutine destroy ( self ) !! Destroys CUDA Transpose Handle class ( transpose_handle_cuda ), intent ( inout ) :: self !! CUDA Transpose Handle call self % transpose_kernel % destroy () if ( . not . self % has_exchange ) return call self % comm_handle % destroy () deallocate ( self % comm_handle ) call self % unpack_kernel % destroy () call self % unpack_kernel2 % destroy () end subroutine destroy integer ( int64 ) function get_aux_size ( self ) !! Returns number of bytes required by aux buffer class ( transpose_handle_cuda ), intent ( in ) :: self !! CUDA Transpose Handle if ( . not . self % has_exchange ) then get_aux_size = 0 return endif get_aux_size = self % comm_handle % get_aux_size () end function get_aux_size function get_tranpose_type ( self ) result ( tranpose_type ) !! Returns transpose_type, associated with handle class ( transpose_handle_cuda ), intent ( in ) :: self !! CUDA Transpose Handle type ( dtfft_transpose_t ) :: tranpose_type tranpose_type = self % transpose_type end function get_tranpose_type end module dtfft_transpose_handle_cuda","tags":"","loc":"sourcefile/dtfft_transpose_handle_cuda.f90.html"},{"title":"dtfft_interface_mkl_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_mkl_m.f90~~EfferentGraph sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_mkl_m.f90~~AfferentGraph sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_mkl_m !! This module creates C interface with MKL library use iso_c_binding , only : c_long , c_int , c_ptr , c_f_pointer , c_null_char , c_size_t use dtfft_utils , only : string_c2f implicit none private public :: mkl_dfti_create_desc , & mkl_dfti_set_value , & mkl_dfti_commit_desc , & mkl_dfti_execute , & mkl_dfti_free_desc , & mkl_dfti_mem_alloc , & mkl_dfti_mem_free public :: DftiErrorMessage interface !! Generates an error message. function DftiErrorMessage_c ( error_code ) & result ( message ) & bind ( C , name = \"DftiErrorMessage\" ) import integer ( c_long ), intent ( in ), value :: error_code !! Completion status of a function. type ( c_ptr ) :: message !! Pointer to message end function DftiErrorMessage_c end interface interface mkl_dfti_set_value !! Sets one particular configuration parameter with the specified configuration value. function mkl_dfti_set_integer ( desc , param , value ) & result ( status ) & bind ( C ) !! Sets one particular configuration parameter with integer value. import type ( c_ptr ), value :: desc !! FFT descriptor. integer ( c_int ), intent ( in ), value :: param !! Configuration parameter. integer ( c_int ), intent ( in ), value :: value !! Configuration value. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_set_integer function mkl_dfti_set_pointer ( desc , param , value ) & result ( status ) & bind ( C ) !! Sets one particular configuration parameter with pointer value. import type ( c_ptr ), value :: desc !! FFT descriptor. integer ( c_int ), intent ( in ), value :: param !! Configuration parameter. integer ( c_long ), intent ( in ) :: value ( * ) !! Configuration value. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_set_pointer end interface mkl_dfti_set_value interface !! Allocates the descriptor data structure and initializes it with default configuration values. function mkl_dfti_create_desc ( precision , domain , dim , length , desc ) & result ( status ) & bind ( C ) import integer ( c_int ), intent ( in ), value :: precision !! Precision of the transform: DFTI_SINGLE or DFTI_DOUBLE. integer ( c_int ), intent ( in ), value :: domain !! Forward domain of the transform: DFTI_COMPLEX or DFTI_REAL. integer ( c_long ), intent ( in ), value :: dim !! Dimension of the transform. integer ( c_long ), intent ( in ) :: length ( * ) !! Length of the transform for a one-dimensional transform. !! Lengths of each dimension for a multi-dimensional transform. type ( c_ptr ) :: desc !! FFT descriptor. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_create_desc end interface interface !! Performs all initialization for the actual FFT computation. function mkl_dfti_commit_desc ( desc ) & result ( status ) & bind ( C ) import type ( c_ptr ), value :: desc !! FFT descriptor. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_commit_desc end interface interface !! Computes FFT. function mkl_dfti_execute ( desc , in , out , sign ) & result ( status ) & bind ( C ) import type ( c_ptr ), value :: desc !! FFT descriptor. type ( c_ptr ), value :: in !! Data to be transformed type ( c_ptr ), value :: out !! The transformed data integer ( c_int ), intent ( in ), value :: sign !! Sign of transform integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_execute end interface interface !! Frees the memory allocated for a descriptor. function mkl_dfti_free_desc ( desc ) & result ( status ) & bind ( C ) import type ( c_ptr ), value :: desc !! FFT descriptor. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_free_desc end interface interface !! Allocates pointer via `mkl_malloc` function mkl_dfti_mem_alloc ( alloc_bytes , ptr ) & result ( status ) & bind ( C ) import integer ( c_size_t ), value :: alloc_bytes !! Number of bytes to allocate. type ( c_ptr ) :: ptr !! Pointer to allocated memory. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_mem_alloc end interface interface !! Frees pointer via `mkl_free` function mkl_dfti_mem_free ( ptr ) & result ( status ) & bind ( C ) import type ( c_ptr ), value :: ptr !! Pointer to allocated memory. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_mem_free end interface contains function DftiErrorMessage ( error_code ) result ( string ) !! Generates an error message. integer ( c_long ), intent ( in ) :: error_code !! Completion status of a function. character ( len = :), allocatable :: string !! Error message call string_c2f ( DftiErrorMessage_c ( error_code ), string ) end function DftiErrorMessage end module dtfft_interface_mkl_m","tags":"","loc":"sourcefile/dtfft_interface_mkl_m.f90.html"},{"title":"dtfft_pencil.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_pencil.f90~~EfferentGraph sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_pencil.f90~~AfferentGraph sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_pencil !! This module describes private [[pencil]] and public [[dtfft_pencil_t]] classes use iso_fortran_env use iso_c_binding use dtfft_errors use dtfft_parameters use dtfft_utils #include \"dtfft_mpi.h\" #include \"dtfft_private.h\" #ifdef DTFFT_WITH_CUDA use dtfft_interface_cuda_runtime #include \"dtfft_cuda.h\" #endif implicit none private public :: pencil , pencil_init public :: dtfft_pencil_t , dtfft_pencil_c public :: get_local_sizes public :: get_transpose_type public :: pencil_c2f , pencil_f2c type :: dtfft_pencil_t !! Structure to hold pencil decomposition info integer ( int8 ) :: dim !! Aligned dimension id integer ( int8 ) :: ndims = 0 !! Number of dimensions integer ( int32 ), allocatable :: starts (:) !! Local starts, starting from 0 for both C and Fortran integer ( int32 ), allocatable :: counts (:) !! Local counts of data, in elements integer ( int64 ) :: size !! Total number of elements in a pencil logical , private :: is_created = . false . !! Is pencil created contains final :: destroy_pencil_t procedure , pass ( self ), private :: destroy => destroy_pencil_t_private end type dtfft_pencil_t interface dtfft_pencil_t !! Type bound constuctor for dtfft_pencil_t module procedure create_pencil_t end interface dtfft_pencil_t type , bind ( C ) :: dtfft_pencil_c !! Structure to hold pencil decomposition info integer ( c_int8_t ) :: dim !! Aligned dimension id integer ( c_int8_t ) :: ndims !! Number of dimensions integer ( c_int32_t ) :: starts ( 3 ) !! Local starts, starting from 0 for both C and Fortran integer ( c_int32_t ) :: counts ( 3 ) !! Local counts of data, in elements integer ( c_size_t ) :: size !! Total number of elements in a pencil end type dtfft_pencil_c type :: pencil !! Class that describes information about data layout integer ( int8 ) :: aligned_dim !! Position of aligned dimension. For example: X pencil aligned_dim = 1, Z pencil aligned_dim = 3 integer ( int8 ) :: rank !! Rank of buffer: 2 or 3 integer ( int32 ), allocatable :: starts (:) !! Local starts, starting from 0 for both C and Fortran integer ( int32 ), allocatable :: counts (:) !! Local counts of data, in elements logical :: is_even !! Is data evenly distributed across processes contains private procedure , pass ( self ), public :: create !! Creates pencil procedure , pass ( self ), public :: destroy !! Destroys pencil ! procedure, pass(self),  public  :: output         !! Writes pencil data to stdout !                                                   !! Used only for debugging purposes procedure , pass ( self ), public :: make_public !! Creates public object that users can use to create own FFT backends end type pencil type :: pencil_init !! Class that describes information about data layout !! !! It is an extension of dtfft_pencil_t with additional fields TYPE_MPI_COMM , allocatable :: comms (:) !! 1D communicators for each dimension integer ( int32 ), allocatable :: starts (:) !! Local starts integer ( int32 ), allocatable :: counts (:) !! Local counts integer ( int32 ), allocatable :: dims (:) !! Global dimensions of entire region contains private procedure , pass ( self ), public :: create => create_pencil_init !! Creates and validates pencil passed by user to plan constructors procedure , pass ( self ), public :: destroy => destroy_pencil_init !! Destroys pencil_init end type pencil_init contains subroutine create ( self , rank , aligned_dim , counts , comms , lstarts , lcounts ) !! Creates pencil class ( pencil ), intent ( inout ) :: self !! Pencil integer ( int8 ), intent ( in ) :: rank !! Rank of buffer integer ( int8 ), intent ( in ) :: aligned_dim !! Position of aligned dimension integer ( int32 ), intent ( in ) :: counts (:) !! Global counts TYPE_MPI_COMM , intent ( in ) :: comms (:) !! Grid communicators integer ( int32 ), optional , intent ( in ) :: lstarts (:) !! Local starts integer ( int32 ), optional , intent ( in ) :: lcounts (:) !! Local counts integer ( int8 ) :: d !! Counter logical , allocatable :: is_even (:) !! Even distribution flag call self % destroy () allocate ( self % counts ( rank )) allocate ( self % starts ( rank )) allocate ( is_even ( rank )) self % aligned_dim = aligned_dim self % rank = rank if ( present ( lstarts ) . and . present ( lcounts ) ) then if ( aligned_dim == 1 ) then self % starts (:) = lstarts (:) self % counts (:) = lcounts (:) else do d = 1 , rank if ( aligned_dim == 2 . and . rank == 3 . and . d == 3 ) then call get_local_size ( counts ( d ), comms ( d ), self % starts ( d ), self % counts ( d ), lstarts ( 3 ), lcounts ( 3 )) else if ( aligned_dim == 3 . and . rank == 3 . and . d == 2 ) then call get_local_size ( counts ( d ), comms ( d ), self % starts ( d ), self % counts ( d ), lstarts ( 2 ), lcounts ( 2 )) else call get_local_size ( counts ( d ), comms ( d ), self % starts ( d ), self % counts ( d )) endif enddo endif else do d = 1 , rank call get_local_size ( counts ( d ), comms ( d ), self % starts ( d ), self % counts ( d )) enddo endif do d = 1 , rank is_even ( d ) = check_if_even ( self % counts ( d ), comms ( d )) enddo self % is_even = all ( is_even ) deallocate ( is_even ) end subroutine create subroutine destroy ( self ) !! Destroys pencil class ( pencil ), intent ( inout ) :: self !! Pencil if ( allocated ( self % counts ) ) deallocate ( self % counts ) if ( allocated ( self % starts ) ) deallocate ( self % starts ) end subroutine destroy subroutine get_local_size ( n_global , comm , start , count , start_to_keep , size_to_keep ) !! Computes local portions of data based on global count and position inside grid communicator integer ( int32 ), intent ( in ) :: n_global !! Global number of points TYPE_MPI_COMM , intent ( in ) :: comm !! Grid communicator integer ( int32 ), intent ( out ) :: start !! Local start integer ( int32 ), intent ( out ) :: count !! Local count integer ( int32 ), optional , intent ( in ) :: start_to_keep !! Start to keep in case of user defined decomposition integer ( int32 ), optional , intent ( in ) :: size_to_keep !! Size to keep in case of user defined decomposition integer ( int32 ), allocatable :: shift (:) !! Work buffer integer ( int32 ) :: comm_dim !! Number of MPI processes along n_global integer ( int32 ) :: comm_rank !! Rank of current MPI process integer ( int32 ) :: res !! Residual from n_global / comm_dim integer ( int32 ) :: i !! Counter integer ( int32 ) :: ierr !! Error code call MPI_Comm_size ( comm , comm_dim , ierr ) call MPI_Comm_rank ( comm , comm_rank , ierr ) res = mod ( n_global , comm_dim ) start = 0 if ( comm_dim == 1 ) then count = n_global return elseif ( present ( size_to_keep ) ) then count = size_to_keep elseif ( comm_rank >= comm_dim - res ) then count = int ( n_global / comm_dim , int32 ) + 1 else count = int ( n_global / comm_dim , int32 ) endif if ( present ( start_to_keep ) ) then start = start_to_keep else allocate ( shift ( comm_dim ) ) call MPI_Allgather ( count , 1 , MPI_INTEGER , shift , 1 , MPI_INTEGER , comm , ierr ) do i = 0 , comm_rank - 1 start = start + shift ( i + 1 ) end do deallocate ( shift ) endif end subroutine get_local_size logical function check_if_even ( count , comm ) !! Checks if data is evenly distributed across processes integer ( int32 ), intent ( in ) :: count !! Local count TYPE_MPI_COMM , intent ( in ) :: comm !! Grid communicator integer ( int32 ) :: comm_size !! Number of MPI processes integer ( int32 ), allocatable :: shift (:) !! Work buffer integer ( int32 ) :: ierr !! Error code call MPI_Comm_size ( comm , comm_size , ierr ) if ( comm_size == 1 ) then check_if_even = . true . return end if allocate ( shift ( comm_size ) ) call MPI_Allgather ( count , 1 , MPI_INTEGER , shift , 1 , MPI_INTEGER , comm , ierr ) check_if_even = all ( shift == shift ( 1 )) deallocate ( shift ) end function check_if_even !   subroutine output(self, name, vec) !   !! Writes pencil data to stdout !     class(pencil),                intent(in)  :: self                 !! Pencil !     character(len=*),             intent(in)  :: name                 !! Name of pencil !     type(c_ptr),                  intent(in)  :: vec               !! Device pointer to data !     integer(int32)                            :: iter                 !! Iteration counter !     integer(int32)                            :: i,j,k,ijk            !! Counters !     integer(int32)                            :: comm_size            !! Number of MPI processes !     integer(int32)                            :: comm_rank            !! Rank of current MPI process !     integer(int32)                            :: ierr                 !! Error code ! #ifdef DTFFT_WITH_CUDA !     real(real32),    target,      allocatable :: buf(:)               !! Host buffer ! #endif !     call MPI_Comm_rank(MPI_COMM_WORLD, comm_rank, ierr) !     call MPI_Comm_size(MPI_COMM_WORLD, comm_size, ierr) !     allocate( buf( product(self%counts) ) ) ! #ifdef DTFFT_WITH_CUDA !     if ( is_device_ptr(vec) ) then !       CUDA_CALL( \"cudaDeviceSynchronize\", cudaDeviceSynchronize()) !       CUDA_CALL( \"cudaMemcpy\", cudaMemcpy(c_loc(buf), vec, int(real32, int64) * product(self%counts), cudaMemcpyDeviceToHost) ) !     endif ! #endif !     do iter = 0, comm_size - 1 !       call MPI_Barrier(MPI_COMM_WORLD, ierr) !       if ( iter == comm_rank ) then !         write(output_unit,'(a)') name !         do k = 0, self%counts(3) - 1 !           do j = 0, self%counts(2) - 1 !             ijk = k * self%counts(2) * self%counts(1) + j * self%counts(1) ! #ifdef DTFFT_WITH_CUDA !             write(output_unit,'(2i5, *(f9.2))') j, k, (buf(ijk + i + 1), i=0,self%counts(1) - 1) ! #else !             write(output_unit,'(2i5, *(f9.2))') j, k, (vec(ijk + i + 1), i=0,self%counts(1) - 1) ! #endif !           enddo !           write(output_unit, '(a)') ' ' !           flush(output_unit) !         enddo !         write(output_unit, '(a)') ' ' !         write(output_unit, '(a)') ' ' !         flush(output_unit) !       endif !       call MPI_Barrier(MPI_COMM_WORLD, ierr) !     enddo ! #ifdef DTFFT_WITH_CUDA !     deallocate(buf) ! #endif !   end subroutine output type ( dtfft_pencil_t ) function make_public ( self ) !! Creates public object that users can use to create own FFT backends class ( pencil ), intent ( in ) :: self !! Pencil integer ( int8 ) :: i !! Counter make_public % dim = self % aligned_dim make_public % ndims = self % rank if ( allocated ( make_public % counts ) ) deallocate ( make_public % counts ) if ( allocated ( make_public % starts ) ) deallocate ( make_public % starts ) allocate ( make_public % counts ( 1 : self % rank ), source = self % counts ) allocate ( make_public % starts ( 1 : self % rank ), source = self % starts ) make_public % size = 1_int64 do i = 1 , make_public % ndims make_public % size = make_public % size * int ( make_public % counts ( i ), int64 ) enddo end function make_public type ( dtfft_pencil_t ) function create_pencil_t ( starts , counts ) !! Creates pencil object, that can be used to create dtFFT plans integer ( int32 ), intent ( in ) :: starts (:) !! Local starts, starting from 0 for both C and Fortran integer ( int32 ), intent ( in ) :: counts (:) !! Local counts of data, in elements call create_pencil_t % destroy () create_pencil_t % ndims = size ( starts , kind = int8 ) allocate ( create_pencil_t % starts , source = starts ) allocate ( create_pencil_t % counts , source = counts ) create_pencil_t % is_created = . true . end function create_pencil_t subroutine destroy_pencil_t_private ( self ) !! Destroys pencil class ( dtfft_pencil_t ), intent ( inout ) :: self !! Public pencil if ( allocated ( self % counts ) ) deallocate ( self % counts ) if ( allocated ( self % starts ) ) deallocate ( self % starts ) self % dim = - 1 self % ndims = - 1 self % size = - 1 self % is_created = . false . end subroutine destroy_pencil_t_private subroutine destroy_pencil_t ( self ) !! Destroys pencil type ( dtfft_pencil_t ), intent ( inout ) :: self !! Public pencil call self % destroy () end subroutine destroy_pencil_t subroutine pencil_f2c ( pencil , c_pencil ) !! Converts Fortran pencil to C pencil type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Fortran pencil type ( dtfft_pencil_c ), intent ( out ) :: c_pencil !! C pencil c_pencil % dim = pencil % dim c_pencil % ndims = pencil % ndims c_pencil % size = pencil % size c_pencil % starts ( 1 : pencil % ndims ) = pencil % starts (:) c_pencil % counts ( 1 : pencil % ndims ) = pencil % counts (:) end subroutine pencil_f2c subroutine pencil_c2f ( c_pencil , pencil ) !! Converts C pencil to Fortran pencil type ( dtfft_pencil_c ), intent ( in ) :: c_pencil !! C pencil type ( dtfft_pencil_t ), intent ( out ) :: pencil !! Fortran pencil pencil = dtfft_pencil_t ( c_pencil % starts ( 1 : c_pencil % ndims ), c_pencil % counts ( 1 : c_pencil % ndims )) end subroutine pencil_c2f subroutine get_local_sizes ( pencils , in_starts , in_counts , out_starts , out_counts , alloc_size ) !! Obtain local starts and counts in `real` and `fourier` spaces type ( pencil ), intent ( in ) :: pencils (:) !! Array of pencils integer ( int32 ), optional , intent ( out ) :: in_starts (:) !! Start indexes in `real` space (0-based) integer ( int32 ), optional , intent ( out ) :: in_counts (:) !! Number of elements in `real` space integer ( int32 ), optional , intent ( out ) :: out_starts (:) !! Start indexes in `fourier` space (0-based) integer ( int32 ), optional , intent ( out ) :: out_counts (:) !! Number of elements in `fourier` space integer ( int64 ), optional , intent ( out ) :: alloc_size !! Minimal number of elements required to execute plan integer ( int8 ) :: d !! Counter integer ( int8 ) :: ndims !! Number of dimensions ndims = size ( pencils , kind = int8 ) if ( present ( in_starts ) ) in_starts ( 1 : ndims ) = pencils ( 1 )% starts ( 1 : ndims ) if ( present ( in_counts ) ) in_counts ( 1 : ndims ) = pencils ( 1 )% counts ( 1 : ndims ) if ( present ( out_starts ) ) out_starts ( 1 : ndims ) = pencils ( ndims )% starts ( 1 : ndims ) if ( present ( out_counts ) ) out_counts ( 1 : ndims ) = pencils ( ndims )% counts ( 1 : ndims ) if ( present ( alloc_size ) ) alloc_size = maxval ([( product ( pencils ( d )% counts ), d = 1 , ndims )]) end subroutine get_local_sizes pure function get_transpose_type ( send , recv ) result ( transpose_type ) !! Determines transpose ID based on pencils type ( pencil ), intent ( in ) :: send !! Send pencil type ( pencil ), intent ( in ) :: recv !! Receive pencil type ( dtfft_transpose_t ) :: transpose_type !! Transpose ID transpose_type = dtfft_transpose_t ( 0 ) if ( send % aligned_dim == 1 . and . recv % aligned_dim == 2 ) then transpose_type = DTFFT_TRANSPOSE_X_TO_Y else if ( recv % aligned_dim == 1 . and . send % aligned_dim == 2 ) then transpose_type = DTFFT_TRANSPOSE_Y_TO_X else if ( send % aligned_dim == 1 . and . recv % aligned_dim == 3 ) then transpose_type = DTFFT_TRANSPOSE_X_TO_Z else if ( recv % aligned_dim == 1 . and . send % aligned_dim == 3 ) then transpose_type = DTFFT_TRANSPOSE_Z_TO_X else if ( send % aligned_dim == 2 . and . recv % aligned_dim == 3 ) then transpose_type = DTFFT_TRANSPOSE_Y_TO_Z else if ( recv % aligned_dim == 2 . and . send % aligned_dim == 3 ) then transpose_type = DTFFT_TRANSPOSE_Z_TO_Y endif end function get_transpose_type function create_pencil_init ( self , pencil , comm ) result ( error_code ) !! Creates and validates pencil passed by user to plan constructors class ( pencil_init ), intent ( inout ) :: self !! Internal pencil representation based on dtfft_pencil_t type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Pencil passed by user to plan constructors TYPE_MPI_COMM , intent ( in ) :: comm !! MPI Communicator passed to plan constructors integer ( int32 ) :: error_code !! Error code integer ( int32 ) :: comm_rank !! Rank of current MPI process integer ( int32 ) :: comm_size !! Size of communicator integer ( int32 ) :: ndims !! Number of dimensions integer ( int32 ) :: ierr !! Error code from MPI calls integer ( int32 ), allocatable :: all_starts (:,:) !! All starts gathered from all processes integer ( int32 ), allocatable :: all_counts (:,:) !! All counts gathered from all processes integer ( int32 ), allocatable :: fixed_dims (:) !! Fixed dimensions for 1D communicators integer ( int32 ) :: i , j , d !! Counters integer ( int32 ) :: p1 , p2 , d1 , d2 !! Counters error_code = DTFFT_SUCCESS if (. not . pencil % is_created ) then error_code = DTFFT_ERROR_PENCIL_NOT_INITIALIZED end if CHECK_ERROR_AND_RETURN_AGG ( comm ) ndims = size ( pencil % starts ) if ( ndims /= size ( pencil % counts )) then error_code = DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH end if CHECK_ERROR_AND_RETURN_AGG ( comm ) if ( ndims < 2 . or . ndims > 3 ) then error_code = DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES end if CHECK_ERROR_AND_RETURN_AGG ( comm ) if ( any ( pencil % starts < 0 )) then error_code = DTFFT_ERROR_PENCIL_INVALID_STARTS end if CHECK_ERROR_AND_RETURN_AGG ( comm ) if ( any ( pencil % counts < 0 )) then error_code = DTFFT_ERROR_PENCIL_INVALID_COUNTS end if CHECK_ERROR_AND_RETURN_AGG ( comm ) call MPI_Comm_rank ( comm , comm_rank , ierr ) call MPI_Comm_size ( comm , comm_size , ierr ) allocate ( self % dims ( ndims )) allocate ( all_starts ( ndims , comm_size )) allocate ( all_counts ( ndims , comm_size )) call MPI_Allgather ( pencil % starts , ndims , MPI_INTEGER , all_starts , ndims , MPI_INTEGER , comm , ierr ) call MPI_Allgather ( pencil % counts , ndims , MPI_INTEGER , all_counts , ndims , MPI_INTEGER , comm , ierr ) ! Computing global dimensions do d = 1 , ndims self % dims ( d ) = maxval ( all_starts ( d ,:) + all_counts ( d ,:)) enddo do p1 = 1 , comm_size do p2 = p1 + 1 , comm_size do d1 = 1 , ndims do d2 = d1 + 1 , ndims ! If two processes have the same start on two different axes, ! then their blocks must have the same size on these axes. if ( all_starts ( d1 , p1 ) == all_starts ( d1 , p2 ) . and . & all_starts ( d2 , p1 ) == all_starts ( d2 , p2 )) then if ( all_counts ( d1 , p1 ) /= all_counts ( d1 , p2 ) . or . & all_counts ( d2 , p1 ) /= all_counts ( d2 , p2 )) then error_code = DTFFT_ERROR_PENCIL_SHAPE_MISMATCH endif endif enddo enddo enddo enddo CHECK_ERROR_AND_RETURN_AGG ( comm ) ! Check intersection of pencils do i = 1 , comm_size do j = i + 1 , comm_size if ( check_overlap ( all_starts (:, i ), all_counts (:, i ), all_starts (:, j ), all_counts (:, j ), ndims )) then error_code = DTFFT_ERROR_PENCIL_OVERLAP endif enddo enddo CHECK_ERROR_AND_RETURN_AGG ( comm ) ! Check continuity of pencils if (. not . check_continuity ( all_starts , all_counts , self % dims , comm_size )) then error_code = DTFFT_ERROR_PENCIL_NOT_CONTINUOUS endif CHECK_ERROR_AND_RETURN_AGG ( comm ) allocate ( self % starts , source = pencil % starts ) allocate ( self % counts , source = pencil % counts ) allocate ( self % comms ( ndims )) allocate ( fixed_dims ( ndims - 1 )) ! Create 1D communicators for each dimension do d = 1 , ndims j = 1 do i = 1 , ndims if ( i /= d ) then fixed_dims ( j ) = i j = j + 1 endif enddo call create_1d_comm ( self % starts , all_starts , fixed_dims , comm , self % comms ( d )) enddo deallocate ( fixed_dims ) deallocate ( all_starts ) deallocate ( all_counts ) end function create_pencil_init subroutine destroy_pencil_init ( self ) !! Destroys pencil_init class ( pencil_init ), intent ( inout ) :: self !!  Internal pencil representation based on dtfft_pencil_t if ( allocated ( self % starts )) deallocate ( self % starts ) if ( allocated ( self % counts )) deallocate ( self % counts ) if ( allocated ( self % comms )) then block integer ( int32 ) :: ierr , i do i = 1 , size ( self % comms ) call MPI_Comm_free ( self % comms ( i ), ierr ) enddo end block deallocate ( self % comms ) end if if ( allocated ( self % dims )) deallocate ( self % dims ) end subroutine destroy_pencil_init pure logical function check_overlap ( lbounds1 , sizes1 , lbounds2 , sizes2 , ndims ) !! Check if two pencols overlap in ndims-dimensional space integer ( int32 ), intent ( in ) :: lbounds1 (:) !! Lower bounds of first pencil integer ( int32 ), intent ( in ) :: sizes1 (:) !! Sizes of first pencil integer ( int32 ), intent ( in ) :: lbounds2 (:) !! Lower bounds of second pencil integer ( int32 ), intent ( in ) :: sizes2 (:) !! Sizes of second pencil integer ( int32 ), intent ( in ) :: ndims !! Number of dimensions integer :: d check_overlap = . true . do d = 1 , ndims ! If there is no intersection in one of the dimensions, then there is no intersection in the whole space if ( lbounds1 ( d ) + sizes1 ( d ) <= lbounds2 ( d ) . or . lbounds2 ( d ) + sizes2 ( d ) <= lbounds1 ( d )) then check_overlap = . false . return endif enddo end function check_overlap logical function check_continuity ( all_lbounds , all_sizes , global_dims , comm_size ) !! Check if the local pencils cover the global space without gaps integer ( int32 ), intent ( in ) :: all_lbounds (:,:) !! Lower bounds of local pencils for each process integer ( int32 ), intent ( in ) :: all_sizes (:,:) !! Sizes of local pencils for each process integer ( int32 ), intent ( in ) :: global_dims (:) !! Global dimensions of the problem integer ( int32 ), intent ( in ) :: comm_size !! Number of processes in the communicator integer ( int64 ) :: total_local_volume , global_volume integer :: i ! 1. Check that local pencils do not exceed global grid limits do i = 1 , comm_size if ( any ( all_lbounds (:, i ) < 0 ) . or . & any ( all_lbounds (:, i ) + all_sizes (:, i ) > global_dims )) then check_continuity = . false . return endif enddo ! 2. Compare the sum of the local block volumes with the volume of the global grid total_local_volume = 0 do i = 1 , comm_size total_local_volume = total_local_volume + product ( int ( all_sizes (:, i ), int64 )) enddo global_volume = product ( int ( global_dims , int64 )) if ( total_local_volume == global_volume ) then check_continuity = . true . else check_continuity = . false . end if end function check_continuity function get_varying_dim ( fixed_dims , total_dims ) result ( varying_dim ) integer ( int32 ), intent ( in ) :: fixed_dims (:) integer ( int32 ), intent ( in ) :: total_dims integer ( int32 ) :: varying_dim do varying_dim = 1 , total_dims if (. not . any ( fixed_dims == varying_dim )) exit enddo end function get_varying_dim subroutine sort_by_varying_dim ( ranks , coords ) integer ( int32 ), intent ( inout ) :: ranks (:) integer ( int32 ), intent ( in ) :: coords (:) integer ( int32 ) :: i , j , tmp_rank , tmp_coord , n n = size ( ranks ) if ( n <= 1 ) return do i = 2 , n tmp_rank = ranks ( i ) tmp_coord = coords ( i ) j = i - 1 do while ( j >= 1 ) if ( coords ( j ) <= tmp_coord ) exit ranks ( j + 1 ) = ranks ( j ) j = j - 1 end do ranks ( j + 1 ) = tmp_rank end do end subroutine sort_by_varying_dim subroutine create_1d_comm ( lbounds , all_lbounds , fixed_dims , comm , new_comm ) !! Creates a new 1D communicator based on the fixed dimensions of the current pencil integer ( int32 ), intent ( in ) :: lbounds (:) !! Local starts of the current pencil integer ( int32 ), intent ( in ) :: all_lbounds (:,:) !! Local starts of all processes integer ( int32 ), intent ( in ) :: fixed_dims (:) !! Indices of fixed coordinates TYPE_MPI_COMM , intent ( in ) :: comm !! Original MPI communicator TYPE_MPI_COMM , intent ( out ) :: new_comm !! New 1D MPI communicator integer ( int32 ) :: comm_size !! Size of `comm` integer ( int32 ) :: ierr !! Error codes for mpi calls integer ( int32 ), allocatable :: neighbors (:) !! Array to neighbors ranks integer ( int32 ), allocatable :: varying_dim (:) !! Coordinates along the non-fixed dimension integer ( int32 ) :: i , j !! Counters integer ( int32 ) :: neighbor_count !! Number of neighboring processes TYPE_MPI_GROUP :: group !! Original MPI group TYPE_MPI_GROUP :: new_group !! New MPI group for 1D communicator call MPI_Comm_size ( comm , comm_size , ierr ) allocate ( neighbors ( comm_size ), varying_dim ( comm_size )) neighbor_count = 0 ! Find processes with matching fixed dimensions do i = 1 , comm_size do j = 1 , size ( fixed_dims ) if ( all_lbounds ( fixed_dims ( j ), i ) /= lbounds ( fixed_dims ( j ))) exit enddo if ( j > size ( fixed_dims )) then neighbor_count = neighbor_count + 1 neighbors ( neighbor_count ) = i - 1 ! MPI ranks are 0-based ! Store the coordinate along the first non-fixed dimension for sorting varying_dim ( neighbor_count ) = all_lbounds ( get_varying_dim ( fixed_dims , size ( lbounds )), i ) endif enddo ! Sort neighbors by their coordinate along the varying dimension call sort_by_varying_dim ( neighbors ( 1 : neighbor_count ), varying_dim ( 1 : neighbor_count )) ! Create the new group and communicator call MPI_Comm_group ( comm , group , ierr ) call MPI_Group_incl ( group , neighbor_count , neighbors ( 1 : neighbor_count ), new_group , ierr ) call MPI_Comm_create ( comm , new_group , new_comm , ierr ) call MPI_Group_free ( group , ierr ) call MPI_Group_free ( new_group , ierr ) deallocate ( neighbors , varying_dim ) end subroutine create_1d_comm end module dtfft_pencil","tags":"","loc":"sourcefile/dtfft_pencil.f90.html"},{"title":"dtfft_transpose_handle_host.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_transpose_handle_host.f90~~EfferentGraph sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_transpose_handle_host.f90~~AfferentGraph sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_transpose_handle_host !! This module describes [[transpose_handle_host]] class use iso_fortran_env use dtfft_parameters use dtfft_pencil , only : pencil , get_transpose_type #include \"dtfft_mpi.h\" #include \"dtfft_profile.h\" #include \"dtfft_cuda.h\" implicit none private public :: transpose_handle_host integer ( MPI_ADDRESS_KIND ), parameter :: LB = 0 !! Lower bound for all derived datatypes type :: handle_t !! Transposition handle class TYPE_MPI_DATATYPE , allocatable :: dtypes (:) !! Datatypes buffer integer ( int32 ), allocatable :: counts (:) !! Number of datatypes (always equals 1) integer ( int32 ), allocatable :: displs (:) !! Displacements is bytes contains procedure , pass ( self ) :: create => create_handle !! Creates transposition handle procedure , pass ( self ) :: destroy => destroy_handle !! Destroys transposition handle end type handle_t type :: transpose_handle_host !! Transposition class private TYPE_MPI_COMM :: comm !! 1d communicator logical :: is_even !! Is decomposition even type ( handle_t ) :: send !! Handle to send data type ( handle_t ) :: recv !! Handle to recieve data #if defined(ENABLE_PERSISTENT_COLLECTIVES) TYPE_MPI_REQUEST :: request !! Request for persistent communication logical :: is_request_created !! Is request created #endif contains private procedure , pass ( self ), public :: create !! Initializes class procedure , pass ( self ), public :: execute !! Performs MPI_Alltoall(w) procedure , pass ( self ), public :: destroy !! Destroys class procedure , pass ( self ) :: create_transpose_2d !! Creates two-dimensional transposition datatypes procedure , pass ( self ) :: create_transpose_XY !! Creates three-dimensional X --> Y, Y --> X transposition datatypes procedure , pass ( self ) :: create_transpose_YZ !! Creates three-dimensional Y --> Z, Z --> Y transposition datatypes procedure , pass ( self ) :: create_transpose_XZ !! Creates three-dimensional X --> Z datatype, only slab! procedure , pass ( self ) :: create_transpose_ZX !! Creates three-dimensional Z --> X datatype, only slab! end type transpose_handle_host contains subroutine create_handle ( self , n ) !! Creates transposition handle class ( handle_t ), intent ( inout ) :: self !! Transposition handle integer ( int32 ), intent ( in ) :: n !! Number of datatypes to be created call self % destroy () allocate ( self % dtypes ( n )) allocate ( self % counts ( n ), source = 1_int32 ) allocate ( self % displs ( n ), source = 0_int32 ) end subroutine create_handle subroutine destroy_handle ( self ) !! Destroys transposition handle class ( handle_t ), intent ( inout ) :: self !! Transposition handle integer ( int32 ) :: i !! Counter integer ( int32 ) :: ierr !! Error code if ( allocated ( self % dtypes ) ) then do i = 1 , size ( self % dtypes ) call MPI_Type_free ( self % dtypes ( i ), ierr ) enddo deallocate ( self % dtypes ) endif if ( allocated ( self % displs ) ) deallocate ( self % displs ) if ( allocated ( self % counts ) ) deallocate ( self % counts ) end subroutine destroy_handle subroutine create ( self , comm , send , recv , base_type , base_storage , datatype_id ) !! Creates `transpose_handle_host` class class ( transpose_handle_host ), intent ( inout ) :: self !! Transposition class TYPE_MPI_COMM , intent ( in ) :: comm !! 1d communicator class ( pencil ), intent ( in ) :: send !! Information about send buffer class ( pencil ), intent ( in ) :: recv !! Information about recv buffer TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int8 ), intent ( in ) :: datatype_id !! Type of datatype to use integer ( int32 ) :: comm_size !! Size of 1d communicator integer ( int32 ) :: n_neighbors !! Number of datatypes to be created integer ( int32 ), allocatable :: recv_counts (:,:) !! Each processor should know how much data each processor recieves integer ( int32 ), allocatable :: send_counts (:,:) !! Each processor should know how much data each processor sends integer ( int32 ) :: i !! Counter integer ( int32 ) :: ierr !! Error code type ( dtfft_transpose_t ) :: transpose_type !! Transpose plan id self % comm = comm call MPI_Comm_size ( self % comm , comm_size , ierr ) self % is_even = send % is_even . and . recv % is_even n_neighbors = comm_size ; if ( self % is_even ) n_neighbors = 1 #if defined(ENABLE_PERSISTENT_COLLECTIVES) self % is_request_created = . false . #endif call self % send % create ( n_neighbors ) call self % recv % create ( n_neighbors ) allocate ( recv_counts ( recv % rank , comm_size ), source = 0_int32 ) allocate ( send_counts , source = recv_counts ) call MPI_Allgather ( recv % counts , int ( recv % rank , int32 ), MPI_INTEGER4 , recv_counts , int ( recv % rank , int32 ), MPI_INTEGER4 , self % comm , ierr ) call MPI_Allgather ( send % counts , int ( send % rank , int32 ), MPI_INTEGER4 , send_counts , int ( send % rank , int32 ), MPI_INTEGER4 , self % comm , ierr ) if ( send % rank == 2 ) then do i = 1 , n_neighbors call self % create_transpose_2d ( n_neighbors , i , send , send_counts (:, i ), recv , recv_counts (:, i ), datatype_id , base_type , base_storage ) enddo else transpose_type = get_transpose_type ( send , recv ) if ( abs ( transpose_type % val ) == DTFFT_TRANSPOSE_X_TO_Y % val ) then do i = 1 , n_neighbors call self % create_transpose_XY ( n_neighbors , i , send , send_counts (:, i ), recv , recv_counts (:, i ), datatype_id , base_type , base_storage ) enddo elseif ( abs ( transpose_type % val ) == DTFFT_TRANSPOSE_Y_TO_Z % val ) then do i = 1 , n_neighbors call self % create_transpose_YZ ( n_neighbors , i , send , send_counts (:, i ), recv , recv_counts (:, i ), datatype_id , base_type , base_storage ) enddo else do i = 1 , n_neighbors ! Since XZ transpose is not symmetric, different DataTypes are needed if ( transpose_type == DTFFT_TRANSPOSE_X_TO_Z ) then call self % create_transpose_XZ ( n_neighbors , i , send , send_counts (:, i ), recv , recv_counts (:, i ), datatype_id , base_type , base_storage ) else call self % create_transpose_ZX ( n_neighbors , i , send , send_counts (:, i ), recv , recv_counts (:, i ), datatype_id , base_type , base_storage ) endif enddo endif endif deallocate ( recv_counts , send_counts ) end subroutine create subroutine execute ( self , send , recv ) !! Executes transposition class ( transpose_handle_host ), intent ( inout ) :: self !! Transposition class real ( real32 ), intent ( in ) :: send (:) !! Incoming buffer real ( real32 ), intent ( inout ) :: recv (:) !! Resulting buffer integer ( int32 ) :: ierr !! Error code #if defined(ENABLE_PERSISTENT_COLLECTIVES) if ( . not . self % is_request_created ) then if ( self % is_even ) then call MPI_Alltoall_init ( send , 1 , self % send % dtypes ( 1 ), recv , 1 , self % recv % dtypes ( 1 ), self % comm , MPI_INFO_NULL , self % request , ierr ) else call MPI_Alltoallw_init ( send , self % send % counts , self % send % displs , self % send % dtypes , & recv , self % recv % counts , self % recv % displs , self % recv % dtypes , self % comm , MPI_INFO_NULL , self % request , ierr ) endif self % is_request_created = . true . endif call MPI_Start ( self % request , ierr ) call MPI_Wait ( self % request , MPI_STATUS_IGNORE , ierr ) #else if ( self % is_even ) then call MPI_Alltoall ( send , 1 , self % send % dtypes ( 1 ), recv , 1 , self % recv % dtypes ( 1 ), self % comm , ierr ) else call MPI_Alltoallw ( send , self % send % counts , self % send % displs , self % send % dtypes , & recv , self % recv % counts , self % recv % displs , self % recv % dtypes , self % comm , ierr ) endif #endif end subroutine execute subroutine destroy ( self ) !! Destroys `transpose_handle_host` class class ( transpose_handle_host ), intent ( inout ) :: self !! Transposition class call self % send % destroy () call self % recv % destroy () #if defined(ENABLE_PERSISTENT_COLLECTIVES) block integer ( int32 ) :: ierr if ( self % is_request_created ) call MPI_Request_free ( self % request , ierr ) self % is_request_created = . false . endblock #endif end subroutine destroy subroutine create_transpose_2d ( self , n_neighbors , i , send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage ) !! Creates two-dimensional transposition datatypes class ( transpose_handle_host ), intent ( inout ) :: self !! Transposition class integer ( int32 ), intent ( in ) :: n_neighbors !! Size of 1d comm integer ( int32 ), intent ( in ) :: i !! Counter class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype integer ( int32 ) :: displ !! Displacement in bytes integer ( int32 ) :: ierr !! Error code if ( datatype_id == 1 ) then call MPI_Type_vector ( send % counts ( 2 ), recv_counts ( 2 ), send % counts ( 1 ), base_type , temp1 , ierr ) displ = recv_counts ( 2 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp1 , LB , int ( displ , MPI_ADDRESS_KIND ), self % send % dtypes ( i ), ierr ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + displ call free_datatypes ( temp1 ) call MPI_Type_vector ( recv % counts ( 2 ), 1 , recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send_counts ( 2 ), temp2 , self % recv % dtypes ( i ), ierr ) call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + send_counts ( 2 ) * int ( base_storage , int32 ) call free_datatypes ( temp1 , temp2 ) else call MPI_Type_vector ( send % counts ( 2 ), 1 , send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 2 ), temp2 , self % send % dtypes ( i ), ierr ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) displ = recv_counts ( 2 ) * int ( base_storage , int32 ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + displ call free_datatypes ( temp1 , temp2 ) call MPI_Type_vector ( recv % counts ( 2 ), send_counts ( 2 ), recv % counts ( 1 ), base_type , temp1 , ierr ) displ = send_counts ( 2 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp1 , LB , int ( displ , MPI_ADDRESS_KIND ), self % recv % dtypes ( i ), ierr ) call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + displ call free_datatypes ( temp1 ) endif end subroutine create_transpose_2d subroutine create_transpose_XY ( self , n_neighbors , i , send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage ) !! Creates three-dimensional X --> Y, Y --> X transposition datatypes class ( transpose_handle_host ), intent ( inout ) :: self !! Transposition class integer ( int32 ), intent ( in ) :: n_neighbors !! Size of 1d comm integer ( int32 ), intent ( in ) :: i !! Counter class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype TYPE_MPI_DATATYPE :: temp3 !! Temporary datatype TYPE_MPI_DATATYPE :: temp4 !! Temporary datatype integer ( int32 ) :: displ !! Rank i is sending / recieving with this displacement in bytes integer ( int32 ) :: ierr !! Error code if ( datatype_id == 1 ) then ! This datatype_id has \"contiguous\" send and strided recieve datatype call MPI_Type_vector ( send % counts ( 2 ) * send % counts ( 3 ), recv_counts ( 2 ), send % counts ( 1 ), base_type , temp1 , ierr ) displ = recv_counts ( 2 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp1 , LB , int ( displ , MPI_ADDRESS_KIND ), self % send % dtypes ( i ), ierr ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + displ call free_datatypes ( temp1 ) call MPI_Type_vector ( recv % counts ( 2 ), 1 , recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send_counts ( 2 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( recv % counts ( 3 ), 1 , int ( recv % counts ( 1 ) * recv % counts ( 2 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) displ = send_counts ( 2 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp4 , LB , int ( displ , MPI_ADDRESS_KIND ), self % recv % dtypes ( i ), ierr ) call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + displ call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) elseif ( datatype_id == 2 ) then ! This datatype_id has strided send and \"contiguous\" recieve datatypes call MPI_Type_vector ( send % counts ( 2 ) * send % counts ( 3 ), 1 , send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 2 ), temp2 , self % send % dtypes ( i ), ierr ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + recv_counts ( 2 ) * int ( base_storage , int32 ) call free_datatypes ( temp1 , temp2 ) call MPI_Type_vector ( recv % counts ( 3 ), send_counts ( 2 ), recv % counts ( 1 ) * recv % counts ( 2 ), base_type , temp1 , ierr ) displ = send_counts ( 2 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp1 , LB , int ( displ , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_create_hvector ( recv % counts ( 2 ), 1 , int ( recv % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp2 , temp3 , ierr ) call MPI_Type_create_resized ( temp3 , LB , int ( displ , MPI_ADDRESS_KIND ), self % recv % dtypes ( i ), ierr ) call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + displ call free_datatypes ( temp1 , temp2 , temp3 ) endif end subroutine create_transpose_XY subroutine create_transpose_YZ ( self , n_neighbors , i , send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage ) !! Creates three-dimensional Y --> Z, Z --> Y transposition datatypes class ( transpose_handle_host ), intent ( inout ) :: self !! Transposition class integer ( int32 ), intent ( in ) :: n_neighbors !! Size of 1d comm integer ( int32 ), intent ( in ) :: i !! Counter class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype TYPE_MPI_DATATYPE :: temp3 !! Temporary datatype TYPE_MPI_DATATYPE :: temp4 !! Temporary datatype integer ( int32 ) :: displ !! Rank i is sending / recieving with this displacement in bytes integer ( int32 ) :: ierr !! Error code if ( datatype_id == 1 ) then call MPI_Type_vector ( send % counts ( 3 ), 1 , send % counts ( 1 ) * send % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 3 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( send % counts ( 2 ), 1 , int ( send % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) displ = recv_counts ( 3 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp4 , LB , int ( displ , MPI_ADDRESS_KIND ), self % send % dtypes ( i ), ierr ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + displ call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) call MPI_Type_vector ( recv % counts ( 3 ), send_counts ( 3 ), recv % counts ( 1 ) * recv % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( send_counts ( 3 ) * base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_create_hvector ( send_counts ( 2 ), 1 , int ( recv % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp2 , temp3 , ierr ) call MPI_Type_create_resized ( temp3 , LB , int ( send_counts ( 3 ) * base_storage , MPI_ADDRESS_KIND ), self % recv % dtypes ( i ), ierr ) call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + send_counts ( 3 ) * int ( base_storage , int32 ) call free_datatypes ( temp1 , temp2 , temp3 ) else call MPI_Type_vector ( send % counts ( 2 ), 1 , send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 3 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( send % counts ( 3 ), 1 , int ( send % counts ( 1 ) * send % counts ( 2 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) call MPI_Type_create_resized ( temp4 , LB , int ( recv_counts ( 3 ) * base_storage , MPI_ADDRESS_KIND ), self % send % dtypes ( i ), ierr ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + recv_counts ( 3 ) * int ( base_storage , int32 ) call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) call MPI_Type_vector ( recv % counts ( 2 ) * recv % counts ( 3 ), 1 , recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send_counts ( 3 ), temp2 , self % recv % dtypes ( i ), ierr ) call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + send_counts ( 3 ) * int ( base_storage , int32 ) call free_datatypes ( temp1 , temp2 ) endif end subroutine create_transpose_YZ subroutine create_transpose_XZ ( self , n_neighbors , i , send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage ) !! Creates three-dimensional X --> Z transposition datatypes !! Can only be used with 3D slab decomposition when slabs are distributed in Z direction class ( transpose_handle_host ), intent ( inout ) :: self !! Transposition class integer ( int32 ), intent ( in ) :: n_neighbors !! Size of 1d comm integer ( int32 ), intent ( in ) :: i !! Counter class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype TYPE_MPI_DATATYPE :: temp3 !! Temporary datatype TYPE_MPI_DATATYPE :: temp4 !! Temporary datatype integer ( int32 ) :: displ !! Rank i is sending / recieving with this displacement in bytes integer ( int32 ) :: ierr !! Error code if ( datatype_id == 1 ) then call MPI_Type_vector ( send % counts ( 3 ), send % counts ( 1 ), send % counts ( 1 ) * send % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( send % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 3 ), temp2 , self % send % dtypes ( i ), ierr ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + send % counts ( 1 ) * recv_counts ( 3 ) * int ( base_storage , int32 ) call free_datatypes ( temp1 , temp2 ) call MPI_Type_vector ( recv % counts ( 2 ), 1 , recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send_counts ( 3 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( recv % counts ( 3 ), 1 , int ( recv % counts ( 1 ) * recv % counts ( 2 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) call MPI_Type_create_resized ( temp4 , LB , int ( send_counts ( 3 ) * base_storage , MPI_ADDRESS_KIND ), self % recv % dtypes ( i ), ierr ) ! call MPI_Type_contiguous(send%counts(1) * send_counts(3) * recv%counts(3), base_type, self%recv%dtypes(i), ierr) call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + send_counts ( 3 ) * int ( base_storage , int32 ) call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) else call MPI_Type_vector ( send % counts ( 3 ), 1 , send % counts ( 1 ) * send % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send % counts ( 1 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( recv_counts ( 3 ), 1 , int ( send % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) displ = send % counts ( 1 ) * recv_counts ( 3 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp4 , LB , int ( displ , MPI_ADDRESS_KIND ), self % send % dtypes ( i ), ierr ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + displ call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) call MPI_Type_vector ( recv % counts ( 2 ) * recv % counts ( 3 ), send_counts ( 3 ), recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( send_counts ( 3 ) * base_storage , MPI_ADDRESS_KIND ), self % recv % dtypes ( i ), ierr ) call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + send_counts ( 3 ) * int ( base_storage , int32 ) call free_datatypes ( temp1 ) endif end subroutine create_transpose_XZ subroutine create_transpose_ZX ( self , n_neighbors , i , send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage ) !! Creates three-dimensional Z --> X transposition datatypes !! Can only be used with 3D slab decomposition when slabs are distributed in Z direction class ( transpose_handle_host ), intent ( inout ) :: self !! Transposition class integer ( int32 ), intent ( in ) :: n_neighbors !! Size of 1d comm integer ( int32 ), intent ( in ) :: i !! Counter class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype TYPE_MPI_DATATYPE :: temp3 !! Temporary datatype TYPE_MPI_DATATYPE :: temp4 !! Temporary datatype integer ( int32 ) :: displ !! Rank i is sending / recieving with this displacement in bytes integer ( int32 ) :: ierr !! Error code if ( datatype_id == 1 ) then call MPI_Type_vector ( send % counts ( 2 ) * send % counts ( 3 ), recv_counts ( 3 ), send % counts ( 1 ), base_type , temp1 , ierr ) displ = recv_counts ( 3 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp1 , LB , int ( displ , MPI_ADDRESS_KIND ), self % send % dtypes ( i ), ierr ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + displ call free_datatypes ( temp1 ) call MPI_Type_vector ( recv % counts ( 3 ), 1 , recv % counts ( 1 ) * recv % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv % counts ( 1 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( send_counts ( 3 ), 1 , int ( recv % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) displ = recv % counts ( 1 ) * send_counts ( 3 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp4 , LB , int ( displ , MPI_ADDRESS_KIND ), self % recv % dtypes ( i ), ierr ) call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + displ call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) else call MPI_Type_vector ( send % counts ( 2 ) * send % counts ( 3 ), 1 , send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 3 ), temp2 , self % send % dtypes ( i ), ierr ) displ = recv_counts ( 3 ) * int ( base_storage , int32 ) call MPI_Type_commit ( self % send % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % send % displs ( i + 1 ) = self % send % displs ( i ) + displ call free_datatypes ( temp1 , temp2 ) call MPI_Type_vector ( recv % counts ( 3 ), recv % counts ( 1 ) * send_counts ( 3 ), recv % counts ( 1 ) * recv % counts ( 2 ), base_type , temp1 , ierr ) displ = recv % counts ( 1 ) * send_counts ( 3 ) * int ( base_storage , int32 ) call MPI_Type_create_resized ( temp1 , LB , int ( displ , MPI_ADDRESS_KIND ), self % recv % dtypes ( i ), ierr ) if ( i < n_neighbors ) self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + displ call MPI_Type_commit ( self % recv % dtypes ( i ), ierr ) call free_datatypes ( temp1 ) endif end subroutine create_transpose_ZX subroutine free_datatypes ( t1 , t2 , t3 , t4 ) !! Frees temporary datatypes TYPE_MPI_DATATYPE , intent ( inout ), optional :: t1 !! Temporary datatype TYPE_MPI_DATATYPE , intent ( inout ), optional :: t2 !! Temporary datatype TYPE_MPI_DATATYPE , intent ( inout ), optional :: t3 !! Temporary datatype TYPE_MPI_DATATYPE , intent ( inout ), optional :: t4 !! Temporary datatype integer ( int32 ) :: ierr !! Error code if ( present ( t1 ) ) call MPI_Type_free ( t1 , ierr ) if ( present ( t2 ) ) call MPI_Type_free ( t2 , ierr ) if ( present ( t3 ) ) call MPI_Type_free ( t3 , ierr ) if ( present ( t4 ) ) call MPI_Type_free ( t4 , ierr ) end subroutine free_datatypes end module dtfft_transpose_handle_host","tags":"","loc":"sourcefile/dtfft_transpose_handle_host.f90.html"},{"title":"dtfft_abstract_transpose_plan.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_abstract_transpose_plan.f90~~EfferentGraph sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_abstract_transpose_plan.f90~~AfferentGraph sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_abstract_transpose_plan !! This module describes Abstraction for all Tranpose plans: [[abstract_transpose_plan]] use iso_c_binding use iso_fortran_env use dtfft_config use dtfft_errors use dtfft_pencil , only : pencil , pencil_init , get_local_sizes use dtfft_parameters use dtfft_utils #ifdef DTFFT_WITH_CUDA use dtfft_abstract_backend , only : backend_helper #ifdef NCCL_HAVE_COMMREGISTER use dtfft_abstract_backend , only : NCCL_REGISTER_PREALLOC_SIZE #endif use dtfft_nvrtc_kernel , only : DEF_TILE_SIZE use dtfft_interface_cuda_runtime # ifdef DTFFT_WITH_NVSHMEM use dtfft_interface_nvshmem # endif # ifdef DTFFT_WITH_NCCL use dtfft_interface_nccl # endif #endif #include \"dtfft_mpi.h\" #include \"dtfft_profile.h\" #include \"dtfft_cuda.h\" #include \"dtfft_private.h\" implicit none private public :: abstract_transpose_plan public :: create_pencils_and_comm #ifdef DTFFT_WITH_CUDA public :: alloc_mem , free_mem #endif type , abstract :: abstract_transpose_plan !! The most Abstract Transpose Plan #ifdef DTFFT_WITH_CUDA type ( dtfft_backend_t ) :: backend = DTFFT_BACKEND_MPI_DATATYPE !! GPU backend type ( backend_helper ) :: helper !! Backend helper #endif logical :: is_z_slab !! Z-slab optimization flag (for 3D transforms) integer ( int64 ) :: min_buffer_size !! Minimal buffer size for transposition contains procedure , non_overridable , pass ( self ), public :: create !! Create transposition plan procedure , non_overridable , pass ( self ), public :: execute !! Executes transposition procedure , pass ( self ), public :: get_aux_size !! Returns auxiliary buffer size procedure ( create_interface ), pass ( self ), deferred :: create_private !! Creates overriding class procedure ( execute_interface ), pass ( self ), deferred :: execute_private !! Executes overriding class procedure ( destroy_interface ), pass ( self ), deferred , public :: destroy !! Destroys overriding class #ifdef DTFFT_WITH_CUDA procedure , non_overridable , pass ( self ), public :: get_backend !! Returns backend id procedure , non_overridable , pass ( self ), public :: mem_alloc !! Allocates memory based on selected backend procedure , non_overridable , pass ( self ), public :: mem_free !! Frees memory allocated with mem_alloc #endif end type abstract_transpose_plan abstract interface function create_interface ( self , dims , transposed_dims , base_comm , comm_dims , effort , base_dtype , base_storage , is_custom_cart_comm , cart_comm , comms , pencils , ipencil ) result ( error_code ) !! Creates transposition plans import class ( abstract_transpose_plan ), intent ( inout ) :: self !! Transposition class integer ( int32 ), intent ( in ) :: dims (:) !! Global sizes of the transform requested integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Transposed sizes of the transform requested TYPE_MPI_COMM , intent ( in ) :: base_comm !! Base MPI communicator integer ( int32 ), intent ( in ) :: comm_dims (:) !! Dims in cartesian communicator type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner type of effort TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element logical , intent ( in ) :: is_custom_cart_comm !! Custom cartesian communicator provided by user TYPE_MPI_COMM , intent ( out ) :: cart_comm !! Cartesian communicator TYPE_MPI_COMM , intent ( out ) :: comms (:) !! Array of 1d communicators type ( pencil ), intent ( out ) :: pencils (:) !! Data distributing meta type ( pencil_init ), optional , intent ( in ) :: ipencil integer ( int32 ) :: error_code !! Error code end function create_interface subroutine execute_interface ( self , in , out , transpose_type ) !! Executes single transposition import class ( abstract_transpose_plan ), intent ( inout ) :: self !! Transposition class real ( real32 ), intent ( inout ) :: in (:) !! Incoming buffer real ( real32 ), intent ( inout ) :: out (:) !! Resulting buffer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transpose end subroutine execute_interface subroutine destroy_interface ( self ) !! Destroys transposition plans import class ( abstract_transpose_plan ), intent ( inout ) :: self !! Transposition class end subroutine destroy_interface endinterface contains function create ( self , dims , base_comm , effort , base_dtype , base_storage , cart_comm , comms , pencils , ipencil ) result ( error_code ) !! Creates transposition plans class ( abstract_transpose_plan ), intent ( inout ) :: self !! Transposition class integer ( int32 ), intent ( in ) :: dims (:) !! Global sizes of the transform requested TYPE_MPI_COMM , intent ( in ) :: base_comm !! Base communicator type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner type of effort TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_COMM , intent ( out ) :: cart_comm !! Cartesian communicator TYPE_MPI_COMM , intent ( out ) :: comms (:) !! Array of 1d communicators type ( pencil ), intent ( out ) :: pencils (:) !! Data distributing meta type ( pencil_init ), optional , intent ( in ) :: ipencil integer ( int32 ) :: error_code !! Error code integer ( int32 ), allocatable :: transposed_dims (:,:) !! Global counts in transposed coordinates logical :: cond1 !! First condition for Z-slab optimization logical :: cond2 !! Second condition for Z-slab optimization integer ( int32 ), allocatable :: comm_dims (:) !! Dims in cartesian communicator integer ( int8 ) :: ndims !! Number of dimensions integer ( int32 ) :: comm_size !! Number of MPI processes integer ( int32 ) :: top_type !! Topology type integer ( int32 ) :: ierr !! Error code logical :: is_custom_cart_comm !! Custom cartesian communicator provided by user integer ( int8 ) :: d TYPE_MPI_COMM :: base_comm_ call MPI_Comm_size ( base_comm , comm_size , ierr ) call MPI_Topo_test ( base_comm , top_type , ierr ) base_comm_ = base_comm ndims = size ( dims , kind = int8 ) allocate ( comm_dims ( ndims ) ) is_custom_cart_comm = . false . self % is_z_slab = . false . if ( present ( ipencil ) ) then is_custom_cart_comm = . true . do d = 1 , ndims call MPI_Comm_size ( ipencil % comms ( d ), comm_dims ( d ), ierr ) enddo if ( comm_dims ( 1 ) /= 1 ) then error_code = DTFFT_ERROR_INVALID_COMM_FAST_DIM return endif if ( ndims == 3 . and . comm_dims ( 2 ) == 1 . and . get_z_slab () ) then self % is_z_slab = . true . base_comm_ = ipencil % comms ( 3 ) endif else ! block not present if ( top_type == MPI_CART ) then is_custom_cart_comm = . true . block integer ( int32 ) :: grid_ndims ! Number of dims in user defined cartesian communicator integer ( int32 ), allocatable :: temp_dims (:) ! Temporary dims needed by MPI_Cart_get integer ( int32 ), allocatable :: temp_coords (:) ! Temporary coordinates needed by MPI_Cart_get logical , allocatable :: temp_periods (:) ! Temporary periods needed by MPI_Cart_get call MPI_Cartdim_get ( base_comm_ , grid_ndims , ierr ) if ( grid_ndims > ndims ) then error_code = DTFFT_ERROR_INVALID_COMM_DIMS return endif comm_dims (:) = 1 allocate ( temp_dims ( grid_ndims ), temp_periods ( grid_ndims ), temp_coords ( grid_ndims )) call MPI_Cart_get ( base_comm_ , grid_ndims , temp_dims , temp_periods , temp_coords , ierr ) if ( grid_ndims == ndims ) then if ( temp_dims ( 1 ) /= 1 ) then error_code = DTFFT_ERROR_INVALID_COMM_FAST_DIM return endif comm_dims (:) = temp_dims elseif ( grid_ndims == ndims - 1 ) then comm_dims ( 2 :) = temp_dims elseif ( grid_ndims == ndims - 2 ) then comm_dims ( 3 ) = temp_dims ( 1 ) endif deallocate ( temp_dims , temp_periods , temp_coords ) do d = 2 , ndims if ( comm_dims ( d ) > dims ( d ) ) then WRITE_WARN ( \"Number of MPI processes in direction \" // int_to_str ( d ) // \" greater then number of physical points: \" // int_to_str ( comm_dims ( d )) // \" > \" // int_to_str ( dims ( d ))) endif enddo if ( ndims == 3 . and . comm_dims ( 2 ) == 1 . and . get_z_slab () ) then self % is_z_slab = . true . endif endblock else !  top_type /= MPI_CART comm_dims (:) = 0 comm_dims ( 1 ) = 1 #ifdef DTFFT_WITH_CUDA if ( get_user_platform () == DTFFT_PLATFORM_HOST ) then cond1 = comm_size <= dims ( ndims ) cond2 = comm_size <= dims ( 1 ) . and . comm_size <= dims ( 2 ) else cond1 = DEF_TILE_SIZE <= dims ( ndims ) / comm_size cond2 = DEF_TILE_SIZE <= dims ( 1 ) / comm_size . and . DEF_TILE_SIZE <= dims ( 2 ) / comm_size endif #else cond1 = comm_size <= dims ( ndims ) cond2 = comm_size <= dims ( 1 ) . and . comm_size <= dims ( 2 ) #endif if ( ndims == 3 . and . cond1 ) then comm_dims ( 2 ) = 1 comm_dims ( 3 ) = comm_size self % is_z_slab = get_z_slab () else if ( ndims == 3 . and . cond2 ) then comm_dims ( 2 ) = comm_size comm_dims ( 3 ) = 1 endif call MPI_Dims_create ( comm_size , int ( ndims , int32 ), comm_dims , ierr ) if ( dims ( ndims - 1 ) < comm_dims ( ndims - 1 ) . or . dims ( ndims ) < comm_dims ( ndims ) ) then WRITE_WARN ( \"Unable to create correct grid decomposition.\" ) ! WRITE_WARN(\"Fallback to Z slab is used\") ! comm_dims(ndims - 1) = 1 ! comm_dims(ndims) = comm_size endif endif endif if ( self % is_z_slab ) then WRITE_INFO ( \"Using Z-slab optimization\" ) endif allocate ( transposed_dims ( ndims , ndims )) if ( ndims == 2 ) then ! Nx x Ny transposed_dims (:, 1 ) = dims (:) ! Ny x Nx transposed_dims ( 1 , 2 ) = dims ( 2 ) transposed_dims ( 2 , 2 ) = dims ( 1 ) else ! Nx x Ny x Nz transposed_dims (:, 1 ) = dims (:) ! Ny x Nx x Nz transposed_dims ( 1 , 2 ) = dims ( 2 ) transposed_dims ( 2 , 2 ) = dims ( 1 ) transposed_dims ( 3 , 2 ) = dims ( 3 ) ! Nz x Nx x Ny transposed_dims ( 1 , 3 ) = dims ( 3 ) transposed_dims ( 2 , 3 ) = dims ( 1 ) transposed_dims ( 3 , 3 ) = dims ( 2 ) endif error_code = self % create_private ( dims , transposed_dims , base_comm_ , comm_dims , effort , base_dtype , base_storage , is_custom_cart_comm , cart_comm , comms , pencils , ipencil = ipencil ) if ( error_code /= DTFFT_SUCCESS ) return call get_local_sizes ( pencils , alloc_size = self % min_buffer_size ) self % min_buffer_size = self % min_buffer_size * ( base_storage / FLOAT_STORAGE_SIZE ) deallocate ( transposed_dims ) deallocate ( comm_dims ) end function create subroutine execute ( self , in , out , transpose_type ) !! Executes single transposition class ( abstract_transpose_plan ), intent ( inout ) :: self !! Transposition class type ( c_ptr ), intent ( in ) :: in !! Incoming pointer type ( c_ptr ), intent ( in ) :: out !! Result pointer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transpose real ( real32 ), pointer :: pin (:) real ( real32 ), pointer :: pout (:) call c_f_pointer ( in , pin , [ self % min_buffer_size ]) call c_f_pointer ( out , pout , [ self % min_buffer_size ]) PHASE_BEGIN ( 'Transpose ' // TRANSPOSE_NAMES ( transpose_type % val ), COLOR_TRANSPOSE_PALLETTE ( transpose_type % val )) call self % execute_private ( pin , pout , transpose_type ) PHASE_END ( 'Transpose ' // TRANSPOSE_NAMES ( transpose_type % val )) end subroutine execute function get_aux_size ( self ) result ( aux_size ) class ( abstract_transpose_plan ), intent ( in ) :: self !! Transposition class integer ( int64 ) :: aux_size aux_size = 0_int64 end function get_aux_size #ifdef DTFFT_WITH_CUDA type ( dtfft_backend_t ) function get_backend ( self ) !! Returns plan GPU backend class ( abstract_transpose_plan ), intent ( in ) :: self !! Transposition class get_backend = self % backend end function get_backend subroutine mem_alloc ( self , comm , alloc_bytes , ptr , error_code ) !! Allocates memory based on selected backend class ( abstract_transpose_plan ), intent ( inout ) :: self !! Transposition class TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Pointer to the allocated memory integer ( int32 ), intent ( out ) :: error_code !! Error code call alloc_mem ( self % helper , self % backend , comm , alloc_bytes , ptr , error_code ) end subroutine mem_alloc subroutine mem_free ( self , ptr , error_code ) !! Frees memory allocated with mem_alloc class ( abstract_transpose_plan ), intent ( inout ) :: self !! Transposition class type ( c_ptr ), intent ( in ) :: ptr !! Pointer to the memory to free integer ( int32 ), intent ( out ) :: error_code !! Error code call free_mem ( self % helper , self % backend , ptr , error_code ) end subroutine mem_free subroutine alloc_mem ( helper , backend , comm , alloc_bytes , ptr , error_code ) !! Allocates memory based on ``backend`` type ( backend_helper ), intent ( inout ) :: helper !! Backend helper type ( dtfft_backend_t ), intent ( in ) :: backend !! GPU backend TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Pointer to the allocated memory integer ( int32 ), intent ( out ) :: error_code !! Error code integer ( int32 ) :: ierr integer ( int64 ) :: free_mem , total_mem , min_mem , max_mem , min_free_mem , max_free_mem error_code = DTFFT_SUCCESS ierr = cudaSuccess CUDA_CALL ( \"cudaMemGetInfo\" , cudaMemGetInfo ( free_mem , total_mem ) ) #ifdef __DEBUG call MPI_Allreduce ( alloc_bytes , max_mem , 1 , MPI_INTEGER8 , MPI_MAX , comm , ierr ) call MPI_Allreduce ( alloc_bytes , min_mem , 1 , MPI_INTEGER8 , MPI_MIN , comm , ierr ) call MPI_Allreduce ( free_mem , max_free_mem , 1 , MPI_INTEGER8 , MPI_MAX , comm , ierr ) call MPI_Allreduce ( free_mem , min_free_mem , 1 , MPI_INTEGER8 , MPI_MIN , comm , ierr ) WRITE_DEBUG ( \"Trying to allocate \" // int_to_str ( min_mem ) // \"/\" // int_to_str ( max_mem ) // \" (min/max) bytes for backend: '\" // dtfft_get_backend_string ( backend ) // \"'\" ) WRITE_DEBUG ( \"Free memory available: \" // int_to_str ( min_free_mem ) // \"/\" // int_to_str ( max_free_mem ) // \" (min/max) bytes\" ) #else WRITE_INFO ( \"Allocating \" // int_to_str ( alloc_bytes ) // \" bytes for backend: '\" // dtfft_get_backend_string ( backend ) // \"'\" // \"; free memory available: \" // int_to_str ( free_mem ) // \" bytes\" ) #endif if ( alloc_bytes > free_mem ) then error_code = DTFFT_ERROR_ALLOC_FAILED return endif if ( is_backend_nccl ( backend ) ) then #ifdef DTFFT_WITH_NCCL # ifdef NCCL_HAVE_MEMALLOC ierr = ncclMemAlloc ( ptr , alloc_bytes ) # else ierr = cudaMalloc ( ptr , alloc_bytes ) # endif # ifdef NCCL_HAVE_COMMREGISTER if ( ierr == cudaSuccess . and . helper % should_register ) then block type ( c_ptr ), allocatable :: temp (:,:) type ( c_ptr ) :: handle if ( size ( helper % nccl_register , dim = 2 ) == helper % nccl_register_size ) then allocate ( temp ( 2 , helper % nccl_register_size + NCCL_REGISTER_PREALLOC_SIZE ), source = helper % nccl_register ) deallocate ( helper % nccl_register ) call move_alloc ( temp , helper % nccl_register ) endif helper % nccl_register_size = helper % nccl_register_size + 1 NCCL_CALL ( \"ncclCommRegister\" , ncclCommRegister ( helper % nccl_comm , ptr , alloc_bytes , handle ) ) helper % nccl_register ( 1 , helper % nccl_register_size ) = ptr helper % nccl_register ( 2 , helper % nccl_register_size ) = handle endblock endif # endif #else INTERNAL_ERROR ( \"not DTFFT_WITH_NCCL\" ) #endif else if ( is_backend_nvshmem ( backend ) ) then #ifdef DTFFT_WITH_NVSHMEM block integer ( int64 ) :: max_alloc_bytes call MPI_Allreduce ( alloc_bytes , max_alloc_bytes , 1 , MPI_INTEGER8 , MPI_MAX , comm , ierr ) ptr = nvshmem_malloc ( max_alloc_bytes ) if ( is_null_ptr ( ptr ) ) error_code = DTFFT_ERROR_ALLOC_FAILED endblock #else INTERNAL_ERROR ( \"not DTFFT_WITH_NVSHMEM\" ) #endif else ierr = cudaMalloc ( ptr , alloc_bytes ) endif if ( ierr /= cudaSuccess ) error_code = DTFFT_ERROR_ALLOC_FAILED end subroutine alloc_mem subroutine free_mem ( helper , backend , ptr , error_code ) !! Frees memory based on ``backend`` type ( backend_helper ), intent ( inout ) :: helper !! Backend helper type ( dtfft_backend_t ), intent ( in ) :: backend !! GPU backend type ( c_ptr ), intent ( in ) :: ptr !! Pointer to the memory to free integer ( int32 ), intent ( out ) :: error_code !! Error code integer ( int32 ) :: ierr error_code = DTFFT_SUCCESS ierr = cudaSuccess if ( is_backend_nccl ( backend ) ) then #ifdef NCCL_HAVE_COMMREGISTER if ( helper % should_register ) then block integer ( int32 ) :: i do i = 1 , size ( helper % nccl_register , dim = 2 ) if ( . not . is_same_ptr ( ptr , helper % nccl_register ( 1 , i )) ) cycle NCCL_CALL ( \"ncclCommDeregister\" , ncclCommDeregister ( helper % nccl_comm , helper % nccl_register ( 2 , i )) ) helper % nccl_register ( 1 , i ) = c_null_ptr helper % nccl_register ( 2 , i ) = c_null_ptr helper % nccl_register_size = helper % nccl_register_size - 1 enddo endblock endif #endif #ifdef DTFFT_WITH_NCCL # ifdef NCCL_HAVE_MEMALLOC ierr = ncclMemFree ( ptr ) # else ierr = cudaFree ( ptr ) # endif #else INTERNAL_ERROR ( \"not DTFFT_WITH_NCCL\" ) #endif else if ( is_backend_nvshmem ( backend ) ) then #ifdef DTFFT_WITH_NVSHMEM call nvshmem_free ( ptr ) #else INTERNAL_ERROR ( \"not DTFFT_WITH_NVSHMEM\" ) #endif else ierr = cudaFree ( ptr ) endif if ( ierr /= cudaSuccess ) error_code = DTFFT_ERROR_FREE_FAILED end subroutine free_mem #endif subroutine create_pencils_and_comm ( transposed_dims , old_comm , comm_dims , comm , local_comms , pencils , ipencil ) !! Creates cartesian communicator integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Global counts in transposed coordinates TYPE_MPI_COMM , intent ( in ) :: old_comm !! Communicator to create cartesian from integer ( int32 ), intent ( in ) :: comm_dims (:) !! Dims in cartesian communicator TYPE_MPI_COMM , intent ( out ) :: comm !! Cartesian communicator TYPE_MPI_COMM , intent ( out ) :: local_comms (:) !! 1d communicators in cartesian communicator type ( pencil ), intent ( out ) :: pencils (:) !! Data distributing meta type ( pencil_init ), intent ( in ), optional :: ipencil integer ( int8 ) :: ndims !! Number of dimensions integer ( int8 ) :: d !! Counter ndims = size ( comm_dims , kind = int8 ) call create_cart_comm ( old_comm , comm_dims , comm , local_comms , ipencil = ipencil ) if ( present ( ipencil ) ) then block integer ( int32 ), allocatable :: lstarts (:), lcounts (:) allocate ( lstarts , source = ipencil % starts ) allocate ( lcounts , source = ipencil % counts ) do d = 1 , ndims call pencils ( d )% create ( ndims , d , transposed_dims (:, d ), local_comms , lstarts = lstarts , lcounts = lcounts ) lcounts (:) = pencils ( d )% counts (:) lstarts (:) = pencils ( d )% starts (:) enddo deallocate ( lstarts , lcounts ) endblock else do d = 1 , ndims call pencils ( d )% create ( ndims , d , transposed_dims (:, d ), local_comms ) enddo endif end subroutine create_pencils_and_comm subroutine create_cart_comm ( old_comm , comm_dims , comm , local_comms , ipencil ) !! Creates cartesian communicator TYPE_MPI_COMM , intent ( in ) :: old_comm !! Communicator to create cartesian from integer ( int32 ), intent ( in ) :: comm_dims (:) !! Dims in cartesian communicator TYPE_MPI_COMM , intent ( out ) :: comm !! Cartesian communicator TYPE_MPI_COMM , intent ( out ) :: local_comms (:) !! 1d communicators in cartesian communicator type ( pencil_init ), intent ( in ), optional :: ipencil logical , allocatable :: periods (:) !! Grid is not periodic logical , allocatable :: remain_dims (:) !! Needed by MPI_Cart_sub integer ( int8 ) :: dim !! Counter integer ( int32 ) :: ierr !! Error code integer ( int8 ) :: ndims ndims = size ( comm_dims , kind = int8 ) if ( present ( ipencil ) ) then call MPI_Comm_dup ( old_comm , comm , ierr ) do dim = 1 , ndims call MPI_Comm_dup ( ipencil % comms ( dim ), local_comms ( dim ), ierr ) enddo return endif allocate ( periods ( ndims ), source = . false .) call MPI_Cart_create ( old_comm , int ( ndims , int32 ), comm_dims , periods , . false ., comm , ierr ) if ( GET_MPI_VALUE ( comm ) == GET_MPI_VALUE ( MPI_COMM_NULL ) ) INTERNAL_ERROR ( \"comm == MPI_COMM_NULL\" ) allocate ( remain_dims ( ndims ), source = . false . ) do dim = 1 , ndims remain_dims ( dim ) = . true . call MPI_Cart_sub ( comm , remain_dims , local_comms ( dim ), ierr ) remain_dims ( dim ) = . false . enddo deallocate ( remain_dims , periods ) ! #ifdef DTFFT_WITH_CUDA !   block !     integer(int32) :: comm_rank, comm_size, host_size, host_rank, proc_name_size, n_ranks_processed, n_names_processed, processing_id, n_total_ranks_processed !     integer(int32) :: min_val, max_val, i, j, k, min_dim, max_dim !     TYPE_MPI_COMM  :: host_comm !     integer(int32) :: top_type !     character(len=MPI_MAX_PROCESSOR_NAME) :: proc_name, processing_name !     character(len=MPI_MAX_PROCESSOR_NAME), allocatable :: all_names(:), processed_names(:) !     integer(int32), allocatable :: all_sizes(:), processed_ranks(:), groups(:,:) !     TYPE_MPI_GROUP :: base_group, temp_group !     call MPI_Comm_rank(comm, comm_rank, ierr) !     call MPI_Comm_size(comm, comm_size, ierr) !     call MPI_Comm_split_type(comm, MPI_COMM_TYPE_SHARED, comm_rank, MPI_INFO_NULL, host_comm, ierr) !     call MPI_Comm_rank(host_comm, host_rank, ierr) !     call MPI_Comm_size(host_comm, host_size, ierr) !     call MPI_Comm_free(host_comm, ierr) !     call MPI_Topo_test(old_comm, top_type, ierr) !     call MPI_Allreduce(MPI_IN_PLACE, host_size, 1, MPI_INTEGER4, MPI_MAX, comm, ierr) !     if ( ndims == 2 .or. host_size == 1 .or. any(comm_dims(2:) == 1) .or. top_type == MPI_CART) then !       return !     endif !     do dim = 2, ndims !       call MPI_Comm_free(local_comms(dim), ierr) !     enddo !     call MPI_Comm_group(comm, base_group, ierr) !     call MPI_Group_rank(base_group, comm_rank, ierr) !     allocate( all_names(comm_size), processed_names(comm_size), all_sizes(comm_size), processed_ranks(comm_size) ) !     call MPI_Get_processor_name(proc_name, proc_name_size, ierr) !     ! Obtaining mapping of which process sits on which node !     call MPI_Allgather(proc_name, MPI_MAX_PROCESSOR_NAME, MPI_CHARACTER, all_names, MPI_MAX_PROCESSOR_NAME, MPI_CHARACTER, comm, ierr) !     call MPI_Allgather(host_size, 1, MPI_INTEGER4, all_sizes, 1, MPI_INTEGER4, comm, ierr) !     if ( comm_dims(2) >= comm_dims(3) ) then !       min_val = comm_dims(3) !       max_val = comm_dims(2) !       min_dim = 3 !       max_dim = 2 !     else !       min_val = comm_dims(2) !       max_val = comm_dims(3) !       min_dim = 2 !       max_dim = 3 !     endif !     allocate( groups(min_val, max_val) ) !     processed_ranks(:) = -1 !     processing_id = 1 !     processing_name = all_names(processing_id) !     n_ranks_processed = 0 !     n_names_processed = 0 !     n_total_ranks_processed = 0 !     do j = 0, max_val - 1 !       do i = 0, min_val - 1 !         if ( n_ranks_processed == all_sizes(processing_id) ) then !           n_names_processed = n_names_processed + 1 !           processed_names(n_names_processed) = processing_name !           processing_id = 0 !           n_ranks_processed = 0 !           do while(.true.) !             processing_id = processing_id + 1 !             if ( processing_id > comm_size ) exit !             processing_name = all_names(processing_id) !             if ( .not. any(processing_name == processed_names(:n_names_processed)) ) exit !           enddo !         endif !         do k = 1, comm_size !           if ( processing_name == all_names(k) .and. .not.any(k - 1 == processed_ranks)) exit !         enddo !         n_ranks_processed = n_ranks_processed + 1 !         groups(i + 1, j + 1) = k - 1 !         n_total_ranks_processed = n_total_ranks_processed + 1 !         processed_ranks(n_total_ranks_processed) = k - 1 !       enddo !     enddo !     do j = 0, max_val - 1 !       do i = 0, min_val - 1 !         if ( any(comm_rank == groups(:, j + 1)) ) then !           call MPI_Group_incl(base_group, min_val, groups(:, j + 1), temp_group, ierr) !           call MPI_Comm_create(comm, temp_group, local_comms(min_dim), ierr) !           call MPI_Group_free(temp_group, ierr) !         endif !       enddo !     enddo !     do i = 0, min_val - 1 !       do j = 0, max_val - 1 !         if ( any(comm_rank == groups(i + 1, :)) ) then !           call MPI_Group_incl(base_group, max_val, groups(i + 1, :), temp_group, ierr) !           call MPI_Comm_create(comm, temp_group, local_comms(max_dim), ierr) !           call MPI_Group_free(temp_group, ierr) !         endif !       enddo !     enddo !     deallocate(all_names, processed_names, all_sizes, processed_ranks, groups) !   endblock ! #endif end subroutine create_cart_comm end module dtfft_abstract_transpose_plan","tags":"","loc":"sourcefile/dtfft_abstract_transpose_plan.f90.html"},{"title":"dtfft_config.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_config.f90~~EfferentGraph sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_config.f90~~AfferentGraph sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_config !! This module handles additional configuration ``dtFFT``, provided by [[dtfft_config_t]] !! or environment variables use iso_c_binding use iso_fortran_env use dtfft_parameters use dtfft_errors use dtfft_utils #ifdef DTFFT_WITH_CUDA use dtfft_interface_cuda_runtime #endif #include \"dtfft_cuda.h\" #include \"dtfft_mpi.h\" implicit none private public :: dtfft_config_t public :: dtfft_create_config , dtfft_set_config public :: get_z_slab public :: get_user_platform #ifdef DTFFT_WITH_CUDA public :: get_user_stream public :: destroy_stream public :: get_user_gpu_backend public :: get_mpi_enabled , get_nvshmem_enabled , get_nccl_enabled , get_pipelined_enabled #endif logical , save :: is_z_slab_enabled = . true . !! Should we use z-slab decomposition or not type ( dtfft_platform_t ), save :: platform = DTFFT_PLATFORM_HOST !! Default platform #ifdef DTFFT_WITH_CUDA # ifdef DTFFT_WITH_NCCL type ( dtfft_backend_t ), parameter :: DEFAULT_GPU_BACKEND = DTFFT_BACKEND_NCCL # else type ( dtfft_backend_t ), parameter :: DEFAULT_GPU_BACKEND = DTFFT_BACKEND_MPI_P2P # endif !! Default GPU backend type ( dtfft_stream_t ), save :: main_stream !! Default dtFFT CUDA stream type ( dtfft_stream_t ), save :: custom_stream !! CUDA stream set by the user logical , save :: is_stream_created = . false . !! Is the default stream created? logical , save :: is_custom_stream = . false . !! Is the custom stream provided by the user? logical , save :: is_pipelined_enabled = . true . !! Should we use pipelined backends or not logical , save :: is_mpi_enabled = . false . !! Should we use MPI backends or not logical , save :: is_nccl_enabled = . true . !! Should we use NCCL backends or not logical , save :: is_nvshmem_enabled = . true . !! Should we use NCCL backends or not type ( dtfft_backend_t ), save :: backend = DEFAULT_GPU_BACKEND !! Default GPU backend #endif type , bind ( C ) :: dtfft_config_t !! Type that can be used to set additional configuration parameters to ``dtFFT`` logical ( c_bool ) :: enable_z_slab !! Should dtFFT use Z-slab optimization or not. !! !! Default is true. !! !! One should consider disabling Z-slab optimization in order to resolve `DTFFT_ERROR_VKFFT_R2R_2D_PLAN` error !! OR when underlying FFT implementation of 2D plan is too slow. !! In all other cases it is considered that Z-slab is always faster, since it reduces number of data transpositions. #ifdef DTFFT_WITH_CUDA type ( dtfft_platform_t ) :: platform !! Selects platform to execute plan. !! !! Default is DTFFT_PLATFORM_HOST !! !! This option is only defined with device support build. !! Even when dtFFT is build with device support it does not nessasary means that all plans must be related to device. !! This enables single library installation to be compiled with both host, CUDA and HIP plans. type ( dtfft_stream_t ) :: stream !! Main CUDA stream that will be used in dtFFT. !! !! This parameter is a placeholder for user to set custom stream. !! !! Stream that is actually used by dtFFT plan is returned by `plan%get_stream` function. !! !! When user sets stream he is responsible of destroying it. !! !! Stream must not be destroyed before call to `plan%destroy`. type ( dtfft_backend_t ) :: backend !! Backend that will be used by dtFFT when `effort` is `DTFFT_ESTIMATE` or `DTFFT_MEASURE`. !! !! Default is `DTFFT_GPU_BACKEND_NCCL` if NCCL is enabled, otherwise `DTFFT_BACKEND_MPI_P2P`. logical ( c_bool ) :: enable_mpi_backends !! Should MPI GPU Backends be enabled when `effort` is `DTFFT_PATIENT` or not. !! !! Default is false. !! !! MPI Backends are disabled by default during autotuning process due to OpenMPI Bug https://github.com/open-mpi/ompi/issues/12849 !! It was noticed that during plan autotuning GPU memory not being freed completely. !! For example: !! 1024x1024x512 C2C, double precision, single GPU, using Z-slab optimization, with MPI backends enabled, plan autotuning will leak 8Gb GPU memory. !! Without Z-slab optimization, running on 4 GPUs, will leak 24Gb on each of the GPUs. !! !! One of the workarounds is to disable MPI Backends by default, which is done here. !! !! Other is to pass \"--mca btl_smcuda_use_cuda_ipc 0\" to `mpiexec`, !! but it was noticed that disabling CUDA IPC seriously affects overall performance of MPI algorithms logical ( c_bool ) :: enable_pipelined_backends !! Should pipelined GPU backends be enabled when `effort` is `DTFFT_PATIENT` or not. !! !! Default is true. !! !! Pipelined backends require additional buffer that user has no control over. logical ( c_bool ) :: enable_nccl_backends !! Should NCCL Backends be enabled when `effort` is `DTFFT_PATIENT` or not. !! !! Default is true. logical ( c_bool ) :: enable_nvshmem_backends !! Should NVSHMEM Backends be enabled when `effort` is `DTFFT_PATIENT` or not. !! !! Default is true. #endif end type dtfft_config_t interface dtfft_config_t !! Interface to create a new configuration module procedure config_constructor end interface dtfft_config_t contains pure subroutine dtfft_create_config ( config ) bind ( C , name = \"dtfft_create_config_c\" ) !! Creates a new configuration with default values. !! !! C interface type ( dtfft_config_t ), intent ( out ) :: config !! Configuration to create config = dtfft_config_t () end subroutine dtfft_create_config #ifdef DTFFT_WITH_CUDA pure function config_constructor ( & enable_z_slab , platform , stream , backend , & enable_mpi_backends , enable_pipelined_backends , & enable_nccl_backends , enable_nvshmem_backends ) result ( config ) #else pure function config_constructor ( enable_z_slab ) result ( config ) #endif !! Creates a new configuration logical , optional , intent ( in ) :: enable_z_slab !! Should dtFFT use Z-slab optimization or not. #ifdef DTFFT_WITH_CUDA type ( dtfft_platform_t ), optional , intent ( in ) :: platform !! Selects platform to execute plan. type ( dtfft_stream_t ), optional , intent ( in ) :: stream !! Main CUDA stream that will be used in dtFFT. type ( dtfft_backend_t ), optional , intent ( in ) :: backend !! Backend that will be used by dtFFT when `effort` is `DTFFT_ESTIMATE` or `DTFFT_MEASURE`. logical , optional , intent ( in ) :: enable_mpi_backends !! Should MPI GPU Backends be enabled when `effort` is `DTFFT_PATIENT` or not. logical , optional , intent ( in ) :: enable_pipelined_backends !! Should pipelined GPU backends be enabled when `effort` is `DTFFT_PATIENT` or not. logical , optional , intent ( in ) :: enable_nccl_backends !! Should NCCL Backends be enabled when `effort` is `DTFFT_PATIENT` or not. logical , optional , intent ( in ) :: enable_nvshmem_backends !! Should NVSHMEM Backends be enabled when `effort` is `DTFFT_PATIENT` or not. #endif type ( dtfft_config_t ) :: config !! Constructed `dtFFT` config ready to be set by call to [[dtfft_set_config]] config % enable_z_slab = . true .; if ( present ( enable_z_slab ) ) config % enable_z_slab = enable_z_slab #ifdef DTFFT_WITH_CUDA config % platform = DTFFT_PLATFORM_HOST ; if ( present ( platform ) ) config % platform = platform config % stream = NULL_STREAM ; if ( present ( stream ) ) config % stream = stream config % backend = DEFAULT_GPU_BACKEND ; if ( present ( backend ) ) config % backend = backend config % enable_mpi_backends = . false .; if ( present ( enable_mpi_backends ) ) config % enable_mpi_backends = enable_mpi_backends config % enable_pipelined_backends = . true .; if ( present ( enable_pipelined_backends ) ) config % enable_pipelined_backends = enable_pipelined_backends config % enable_nccl_backends = . true .; if ( present ( enable_nccl_backends ) ) config % enable_nccl_backends = enable_nccl_backends config % enable_nvshmem_backends = . true .; if ( present ( enable_nvshmem_backends ) ) config % enable_nvshmem_backends = enable_nvshmem_backends #endif end function config_constructor subroutine dtfft_set_config ( config , error_code ) !! Sets configuration parameters type ( dtfft_config_t ), intent ( in ) :: config !! Configuration to set integer ( int32 ), optional , intent ( out ) :: error_code !! Error code is_z_slab_enabled = config % enable_z_slab #ifdef DTFFT_WITH_CUDA if (. not . is_valid_gpu_backend ( config % backend )) then if ( present ( error_code ) ) error_code = DTFFT_ERROR_GPU_INVALID_BACKEND return endif backend = config % backend if ( . not . is_null_ptr ( config % stream % stream ) ) then block integer ( int32 ) :: ierr ierr = cudaStreamQuery ( config % stream ) if ( . not . any ( ierr == [ cudaSuccess , cudaErrorNotReady ]) ) then if ( present ( error_code ) ) error_code = DTFFT_ERROR_GPU_INVALID_STREAM return endif custom_stream = config % stream is_custom_stream = . true . endblock endif if ( . not . is_valid_platform ( config % platform ) ) then if ( present ( error_code ) ) error_code = DTFFT_ERROR_INVALID_PLATFORM return endif platform = config % platform is_mpi_enabled = config % enable_mpi_backends is_pipelined_enabled = config % enable_pipelined_backends is_nccl_enabled = config % enable_nccl_backends is_nvshmem_enabled = config % enable_nvshmem_backends #endif if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine dtfft_set_config pure logical function get_z_slab () !! Whether Z-slab optimization is enabled or not get_z_slab = is_z_slab_enabled if ( get_z_slab_from_env () /= VARIABLE_NOT_SET ) get_z_slab = get_z_slab_from_env () == 1 end function get_z_slab pure type ( dtfft_platform_t ) function get_user_platform () !! Returns platform set by the user or default one get_user_platform = platform if ( get_platform_from_env () /= PLATFORM_NOT_SET ) get_user_platform = get_platform_from_env () end function get_user_platform #ifdef DTFFT_WITH_CUDA type ( dtfft_stream_t ) function get_user_stream () result ( stream ) !! Returns either the custom provided by user or creates a new one if ( is_custom_stream ) then stream = custom_stream return endif if (. not . is_stream_created ) then CUDA_CALL ( \"cudaStreamCreate\" , cudaStreamCreate ( main_stream ) ) is_stream_created = . true . endif stream = main_stream end function get_user_stream subroutine destroy_stream !! Destroy the default stream if it was created if ( is_stream_created ) then CUDA_CALL ( \"cudaStreamDestroy\" , cudaStreamDestroy ( main_stream ) ) is_stream_created = . false . endif end subroutine destroy_stream pure type ( dtfft_backend_t ) function get_user_gpu_backend () !! Returns GPU backend set by the user or default one get_user_gpu_backend = backend if ( get_backend_from_env () /= BACKEND_NOT_SET ) get_user_gpu_backend = get_backend_from_env () end function get_user_gpu_backend pure logical function get_pipelined_enabled () !! Whether pipelined backends are enabled or not get_pipelined_enabled = is_pipelined_enabled if ( get_pipe_enabled_from_env () /= VARIABLE_NOT_SET ) get_pipelined_enabled = get_pipe_enabled_from_env () == 1 end function get_pipelined_enabled pure logical function get_mpi_enabled () !! Whether MPI backends are enabled or not #if !defined(DTFFT_WITH_NCCL) && !defined(DTFFT_WITH_NVSHMEM) get_mpi_enabled = . true . ! Should not be .false. if only MPI backends are possible #else get_mpi_enabled = is_mpi_enabled if ( get_mpi_enabled_from_env () /= VARIABLE_NOT_SET ) get_mpi_enabled = get_mpi_enabled_from_env () == 1 #endif end function get_mpi_enabled pure logical function get_nccl_enabled () !! Whether NCCL backends are enabled or not #ifdef DTFFT_WITH_NCCL get_nccl_enabled = is_nccl_enabled if ( get_nccl_enabled_from_env () /= VARIABLE_NOT_SET ) get_nccl_enabled = get_nccl_enabled_from_env () == 1 #else get_nccl_enabled = . false . #endif end function get_nccl_enabled pure logical function get_nvshmem_enabled () !! Whether nvshmem backends are enabled or not #ifdef DTFFT_WITH_NVSHMEM get_nvshmem_enabled = is_nvshmem_enabled if ( get_nvshmem_enabled_from_env () /= VARIABLE_NOT_SET ) get_nvshmem_enabled = get_nvshmem_enabled_from_env () == 1 #else get_nvshmem_enabled = . false . #endif end function get_nvshmem_enabled #endif end module dtfft_config","tags":"","loc":"sourcefile/dtfft_config.f90.html"},{"title":"dtfft_api.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_api.f90~~EfferentGraph sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_abstract_transpose_plan.f90 dtfft_abstract_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_kernel.f90 dtfft_nvrtc_kernel.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90 dtfft_transpose_plan_cuda.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90 dtfft_transpose_plan_host.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan_host.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_kernel.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_handle_cuda.f90 dtfft_transpose_handle_cuda.F90 sourcefile~dtfft_transpose_plan_cuda.f90->sourcefile~dtfft_transpose_handle_cuda.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_abstract_transpose_plan.f90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_host.f90 dtfft_transpose_handle_host.F90 sourcefile~dtfft_transpose_plan_host.f90->sourcefile~dtfft_transpose_handle_host.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_nvrtc_kernel.f90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_cuda.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_host.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_api !! This module is a Fortran part of C/C++ interface use iso_c_binding , only : c_int8_t , c_int32_t , c_size_t , & c_float , c_bool , c_char , & c_null_ptr , c_ptr , c_loc , & c_f_pointer use iso_fortran_env , only : int8 , int32 use dtfft_config use dtfft_errors use dtfft_parameters use dtfft_pencil , only : dtfft_pencil_t , dtfft_pencil_c , pencil_c2f , pencil_f2c use dtfft_plan , only : dtfft_plan_t , dtfft_plan_r2r_t , dtfft_plan_c2c_t , dtfft_plan_r2c_t use dtfft_utils , only : is_null_ptr , string_f2c #include \"dtfft_mpi.h\" implicit none private #define CHECK_PLAN_CREATED(c_plan, f_plan)      \\ if ( is_null_ptr ( c_plan )) then ; \\ error_code = DTFFT_ERROR_PLAN_NOT_CREATED ; \\ return ; \\ endif ; \\ call c_f_pointer ( c_plan , f_plan ) type :: plan_c !! C pointer to Fortran plan class ( dtfft_plan_t ), allocatable :: p !! Actual Fortran plan end type plan_c contains pure TYPE_MPI_COMM function get_comm ( c_comm ) integer ( c_int32_t ), intent ( in ) :: c_comm GET_MPI_VALUE ( get_comm ) = c_comm end function get_comm function dtfft_create_plan_r2r_c ( ndims , dims , kinds , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates R2R dtFFT Plan, allocates all structures and prepares FFT, C/C++/Python interface integer ( c_int8_t ), intent ( in ) :: ndims !! Rank of transform. Can be 2 or 3. type ( c_ptr ), value , intent ( in ) :: dims !! Global sizes of transform type ( c_ptr ), value , intent ( in ) :: kinds !! FFT R2R kinds integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. integer ( int32 ), pointer :: fdims (:) !! Fortran dims type ( dtfft_r2r_kind_t ), pointer :: fkinds (:) !! Fortran R2R kinds type ( plan_c ), pointer :: plan !! Pointer to Fortran object allocate ( plan ) allocate ( dtfft_plan_r2r_t :: plan % p ) call c_f_pointer ( dims , fdims , [ ndims ]) call c_f_pointer ( kinds , fkinds , [ ndims ]) select type ( p => plan % p ) type is ( dtfft_plan_r2r_t ) call p % create ( fdims , fkinds , get_comm ( comm ), precision , effort , executor , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_r2r_c function dtfft_create_plan_r2r_pencil_c ( pencil , kinds , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates R2R dtFFT Plan from Pencil, allocates all structures and prepares FFT, C/C++/Python interface type ( dtfft_pencil_c ), intent ( in ) :: pencil !! C pointer to Fortran pencil type ( c_ptr ), value , intent ( in ) :: kinds !! FFT R2R kinds integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( dtfft_r2r_kind_t ), pointer :: fkinds (:) !! Fortran R2R kinds type ( plan_c ), pointer :: plan type ( dtfft_pencil_t ) :: pencil_ !! Fortran pencil call pencil_c2f ( pencil , pencil_ ) allocate ( plan ) allocate ( dtfft_plan_r2r_t :: plan % p ) call c_f_pointer ( kinds , fkinds , [ pencil_ % ndims ]) select type ( p => plan % p ) type is ( dtfft_plan_r2r_t ) call p % create ( pencil_ , fkinds , get_comm ( comm ), precision , effort , executor , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_r2r_pencil_c function dtfft_create_plan_c2c_c ( ndims , dims , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates C2C dtFFT Plan, allocates all structures and prepares FFT, C/C++ interface integer ( c_int8_t ), intent ( in ) :: ndims !! Rank of transform. Can be 2 or 3. type ( c_ptr ), value , intent ( in ) :: dims !! Global sizes of transform integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. integer ( int32 ), pointer :: fdims (:) !! Fortran dims type ( plan_c ), pointer :: plan !! Pointer to Fortran object allocate ( plan ) allocate ( dtfft_plan_c2c_t :: plan % p ) call c_f_pointer ( dims , fdims , [ ndims ]) select type ( p => plan % p ) class is ( dtfft_plan_c2c_t ) call p % create ( fdims , get_comm ( comm ), precision , effort , executor , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_c2c_c function dtfft_create_plan_c2c_pencil_c ( pencil , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates C2C dtFFT plan from Pencil, allocates all structures and prepares FFT, C/C++/Python interface type ( dtfft_pencil_c ), intent ( in ) :: pencil !! C pointer to Fortran pencil integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( dtfft_pencil_t ) :: pencil_ !! Fortran pencil type ( plan_c ), pointer :: plan !! Pointer to Fortran object call pencil_c2f ( pencil , pencil_ ) allocate ( plan ) allocate ( dtfft_plan_c2c_t :: plan % p ) select type ( p => plan % p ) class is ( dtfft_plan_c2c_t ) call p % create ( pencil_ , get_comm ( comm ), precision , effort , executor , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_c2c_pencil_c #ifndef DTFFT_TRANSPOSE_ONLY function dtfft_create_plan_r2c_c ( ndims , dims , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates R2C dtFFT Plan, allocates all structures and prepares FFT, C/C++/Python interface integer ( c_int8_t ), intent ( in ) :: ndims !! Rank of transform. Can be 2 or 3. type ( c_ptr ), value , intent ( in ) :: dims !! Global sizes of transform integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. integer ( int32 ), pointer :: fdims (:) !! Fortran dims type ( plan_c ), pointer :: plan !! Pointer to Fortran object allocate ( plan ) allocate ( dtfft_plan_r2c_t :: plan % p ) call c_f_pointer ( dims , fdims , [ ndims ]) select type ( p => plan % p ) class is ( dtfft_plan_r2c_t ) call p % create ( fdims , executor , get_comm ( comm ), precision , effort , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_r2c_c function dtfft_create_plan_r2c_pencil_c ( pencil , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates R2C dtFFT Plan from Block, allocates all structures and prepares FFT, C/C++/Python interface type ( dtfft_pencil_c ), intent ( in ) :: pencil !! C pointer to Fortran pencil integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( dtfft_pencil_t ) :: pencil_ !! Fortran pencil type ( plan_c ), pointer :: plan !! Pointer to Fortran object call pencil_c2f ( pencil , pencil_ ) allocate ( plan ) allocate ( dtfft_plan_r2c_t :: plan % p ) select type ( p => plan % p ) class is ( dtfft_plan_r2c_t ) call p % create ( pencil_ , executor , get_comm ( comm ), precision , effort , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_r2c_pencil_c #endif function dtfft_get_z_slab_enabled_c ( plan_ptr , is_z_slab_enabled ) & result ( error_code ) & bind ( C ) !! Checks if dtFFT Plan is using Z-slab optimization type ( c_ptr ), intent ( in ), value :: plan_ptr !! C pointer to Fortran plan logical ( c_bool ), intent ( out ) :: is_z_slab_enabled !! Is plan internally using Z-slab optimization integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) is_z_slab_enabled = plan % p % get_z_slab_enabled ( error_code ) end function dtfft_get_z_slab_enabled_c function dtfft_execute_c ( plan_ptr , in , out , execute_type , aux ) & result ( error_code ) & bind ( C ) !! Executes dtFFT Plan, C/C++ interface. `aux` can be NULL. type ( c_ptr ), value , intent ( in ) :: plan_ptr !! C pointer to Fortran plan type ( c_ptr ), value , intent ( in ) :: in !! Incomming pointer, not NULL type ( c_ptr ), value , intent ( in ) :: out !! Outgoing buffer, not NULL type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution type ( c_ptr ), value , intent ( in ) :: aux !! Aux buffer, can be NULL integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % execute_ptr ( in , out , execute_type , aux , error_code ) end function dtfft_execute_c function dtfft_transpose_c ( plan_ptr , in , out , transpose_type ) & result ( error_code ) & bind ( C ) !! Executes single transposition, C/C++ interface. type ( c_ptr ), value , intent ( in ) :: plan_ptr !! C pointer to Fortran plan type ( c_ptr ), value , intent ( in ) :: in !! Incomming pointer, not NULL type ( c_ptr ), value , intent ( in ) :: out !! Outgoing buffer, not NULL type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % transpose_ptr ( in , out , transpose_type , error_code ) end function dtfft_transpose_c function dtfft_destroy_c ( plan_ptr ) & result ( error_code ) & bind ( C ) !! Destroys dtFFT Plan, C/C++ interface type ( c_ptr ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % destroy ( error_code ) deallocate ( plan % p ) deallocate ( plan ) plan_ptr = c_null_ptr end function dtfft_destroy_c function dtfft_get_local_sizes_c ( plan_ptr , in_starts , in_counts , out_starts , out_counts , alloc_size ) & result ( error_code ) & bind ( C ) !! Returns local sizes, counts in real and Fourier spaces and number of elements to be allocated for `in` and `out` buffers, !! C/C++ interface. type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ), intent ( out ), optional :: in_starts ( 3 ) !! Starts of local portion of data in 'real' space integer ( c_int32_t ), intent ( out ), optional :: in_counts ( 3 ) !! Counts of local portion of data in 'real' space integer ( c_int32_t ), intent ( out ), optional :: out_starts ( 3 ) !! Starts of local portion of data in 'fourier' space integer ( c_int32_t ), intent ( out ), optional :: out_counts ( 3 ) !! Counts of local portion of data in 'fourier' space integer ( c_size_t ), intent ( out ), optional :: alloc_size !! Minimum data needs to be allocated integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % get_local_sizes ( in_starts , in_counts , out_starts , out_counts , alloc_size , error_code ) end function dtfft_get_local_sizes_c function dtfft_get_alloc_size_c ( plan_ptr , alloc_size ) & result ( error_code ) & bind ( C ) !! Returns minimum number of bytes to be allocated for `in` and `out` buffers, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_size_t ), intent ( out ) :: alloc_size !! Minimum data needs to be allocated integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) alloc_size = plan % p % get_alloc_size ( error_code ) end function dtfft_get_alloc_size_c function dtfft_get_pencil_c ( plan_ptr , dim , pencil ) & result ( error_code ) & bind ( C ) !! Returns pencil decomposition info, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ), intent ( in ) :: dim !! Dimension requested type ( dtfft_pencil_c ) :: pencil !! Pencil pointer integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object type ( dtfft_pencil_t ) :: pencil_ CHECK_PLAN_CREATED ( plan_ptr , plan ) pencil_ = plan % p % get_pencil ( dim , error_code ) call pencil_f2c ( pencil_ , pencil ) end function dtfft_get_pencil_c function dtfft_get_element_size_c ( plan_ptr , element_size ) & result ( error_code ) & bind ( C ) !! Returns size of element in bytes, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_size_t ), intent ( out ) :: element_size !! Size of element in bytes integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) element_size = plan % p % get_element_size ( error_code ) end function dtfft_get_element_size_c function dtfft_get_alloc_bytes_c ( plan_ptr , alloc_bytes ) & result ( error_code ) & bind ( C ) !! Returns minimum number of bytes required to execute plan, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_size_t ), intent ( out ) :: alloc_bytes !! Number of bytes required integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) alloc_bytes = plan % p % get_alloc_bytes ( error_code ) end function dtfft_get_alloc_bytes_c function dtfft_get_executor_c ( plan_ptr , executor ) & result ( error_code ) & bind ( C ) !! Returns executor type used in plan, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_executor_t ), intent ( out ) :: executor !! The enumerated type dtfft_executor_t integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) executor = plan % p % get_executor ( error_code ) end function dtfft_get_executor_c function dtfft_get_precision_c ( plan_ptr , precision ) & result ( error_code ) & bind ( C ) !! Returns precision used in plan, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_precision_t ), intent ( out ) :: precision !! The enumerated type dtfft_precision_t integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) precision = plan % p % get_precision ( error_code ) end function dtfft_get_precision_c function dtfft_get_dims_c ( plan_ptr , ndims , dims ) & result ( error_code ) & bind ( C ) !! Returns dimensions of plan, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_int8_t ), intent ( out ) :: ndims !! Number of dimensions type ( c_ptr ), intent ( out ) :: dims !! Array of dimensions integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object integer ( c_int32_t ), pointer :: dims_ (:) => null () CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % get_dims ( dims_ , error_code = error_code ) if ( error_code == DTFFT_SUCCESS ) then ndims = size ( dims_ , kind = c_int8_t ) dims = c_loc ( dims_ ) endif end function dtfft_get_dims_c function dtfft_set_config_c ( config ) & result ( error_code ) & bind ( C ) !! Sets dtFFT configuration, C/C++ interface type ( dtfft_config_t ), intent ( in ) :: config !! Configuration to set integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. call dtfft_set_config ( config , error_code ) end function dtfft_set_config_c function dtfft_report_c ( plan_ptr ) & result ( error_code ) & bind ( C ) !! Reports dtFFT Plan, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % report ( error_code ) end function dtfft_report_c function dtfft_mem_alloc_c ( plan_ptr , alloc_bytes , ptr ) & result ( error_code ) & bind ( C ) !! Allocates memory for dtFFT Plan, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_size_t ), value :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ) :: ptr !! Allocated pointer integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % mem_alloc_ptr ( alloc_bytes , ptr , error_code ) end function dtfft_mem_alloc_c function dtfft_mem_free_c ( plan_ptr , ptr ) & result ( error_code ) & bind ( C ) !! Frees memory for dtFFT Plan, C/C++ interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( c_ptr ), value :: ptr !! Pointer to deallocate integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % mem_free_ptr ( ptr , error_code ) end function dtfft_mem_free_c subroutine dtfft_get_error_string_c ( error_code , error_string , error_string_size ) bind ( C ) !! Returns an explaination of ``error_code`` that could have been previously returned by one of dtFFT API calls, !! C/C++ interface integer ( c_int32_t ), intent ( in ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. character ( c_char ), intent ( out ) :: error_string ( * ) !! Explanation of error integer ( c_size_t ), intent ( out ) :: error_string_size !! Size of ``error_string`` call string_f2c ( dtfft_get_error_string ( error_code ), error_string , error_string_size ) end subroutine dtfft_get_error_string_c subroutine dtfft_get_precision_string_c ( precision , precision_string , precision_string_size ) bind ( C ) type ( dtfft_precision_t ), intent ( in ) :: precision !! The enumerated type dtfft_precision_t character ( c_char ), intent ( out ) :: precision_string ( * ) !! Resulting string integer ( c_size_t ), intent ( out ) :: precision_string_size !! Size of string call string_f2c ( dtfft_get_precision_string ( precision ), precision_string , precision_string_size ) end subroutine dtfft_get_precision_string_c subroutine dtfft_get_executor_string_c ( executor , executor_string , executor_string_size ) bind ( C ) type ( dtfft_executor_t ), intent ( in ) :: executor !! The enumerated type dtfft_executor_t character ( c_char ), intent ( out ) :: executor_string ( * ) !! Resulting string integer ( c_size_t ), intent ( out ) :: executor_string_size !! Size of string call string_f2c ( dtfft_get_executor_string ( executor ), executor_string , executor_string_size ) end subroutine dtfft_get_executor_string_c #ifdef DTFFT_WITH_CUDA function dtfft_get_stream_c ( plan_ptr , stream ) & result ( error_code ) & bind ( C ) !! Returns Stream associated with plan type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_stream_t ), intent ( out ) :: stream !! CUDA stream integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % get_stream ( stream , error_code ) end function dtfft_get_stream_c function dtfft_get_backend_c ( plan_ptr , backend ) & result ( error_code ) & bind ( C ) !! Returns selected [[dtfft_backend_t]] during autotuning type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_backend_t ), intent ( out ) :: backend !! The enumerated type dtfft_backend_t integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) backend = plan % p % get_backend ( error_code ) end function dtfft_get_backend_c function dtfft_get_platform_c ( plan_ptr , platform ) & result ( error_code ) & bind ( C ) !! Returns selected [[dtfft_platform_t]] during autotuning type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_platform_t ), intent ( out ) :: platform !! The enumerated type dtfft_platform_t integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) platform = plan % p % get_platform ( error_code ) end function dtfft_get_platform_c subroutine dtfft_get_backend_string_c ( backend , backend_string , backend_string_size ) bind ( C ) !! Returns string representation of ``dtfft_backend_t`` type ( dtfft_backend_t ), intent ( in ) :: backend !! The enumerated type dtfft_backend_t character ( c_char ), intent ( out ) :: backend_string ( * ) !! Resulting string integer ( c_size_t ), intent ( out ) :: backend_string_size !! Size of string call string_f2c ( dtfft_get_backend_string ( backend ), backend_string , backend_string_size ) end subroutine dtfft_get_backend_string_c #endif end module dtfft_api","tags":"","loc":"sourcefile/dtfft_api.f90.html"}]}