var tipuesearch = {"pages":[{"title":" dtFFT ","text":"dtFFT Developer Info Oleg Shatrov","tags":"home","loc":"index.html"},{"title":"backend_helper – dtFFT ","text":"type, public :: backend_helper Helper with nccl, mpi and nvshmem communicators Inherits type~~backend_helper~~InheritsGraph type~backend_helper backend_helper MPI_Comm MPI_Comm type~backend_helper->MPI_Comm comms c_ptr c_ptr type~backend_helper->c_ptr nccl_register type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~pencil pencil type~backend_helper->type~pencil pencils type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~backend_helper~~InheritedByGraph type~backend_helper backend_helper type~create_args create_args type~create_args->type~backend_helper helper type~transpose_plan transpose_plan type~transpose_plan->type~backend_helper helper type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~transpose_plan plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: is_nccl_created = .false. Flag is nccl_comm has been created type( ncclComm ), public :: nccl_comm NCCL communicator logical, public :: should_register If NCCL buffer should be registered type(c_ptr), public, allocatable :: nccl_register (:,:) NCCL register cache integer(kind=int32), public :: nccl_register_size Number of elements in nccl_register type(MPI_Comm), public, allocatable :: comms (:) MPI communicators integer(kind=int32), public, allocatable :: comm_mappings (:,:) Mapping of 1d comm ranks to global comm type( dtfft_transpose_t ), public :: tranpose_type Type of transpose to create type( pencil ), public, pointer :: pencils (:) Pencils Type-Bound Procedures procedure, public, pass(self) :: create => create_helper Creates helper private  subroutine create_helper (self, platform, base_comm, comms, is_nccl_needed, pencils) Creates helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper type( dtfft_platform_t ), intent(in) :: platform Platform to use type(MPI_Comm), intent(in) :: base_comm MPI communicator type(MPI_Comm), intent(in) :: comms (:) 1D Communicators logical, intent(in) :: is_nccl_needed If nccl communicator will be needed type( pencil ), intent(in), target :: pencils (:) Pencils procedure, public, pass(self) :: destroy => destroy_helper Destroys helper private  subroutine destroy_helper (self) Destroys helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper","tags":"","loc":"type/backend_helper.html"},{"title":"abstract_backend – dtFFT ","text":"type, public, abstract :: abstract_backend The most Abstract Backend Inherits type~~abstract_backend~~InheritsGraph type~abstract_backend abstract_backend MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~abstract_kernel abstract_kernel type~abstract_backend->type~abstract_kernel unpack_kernel type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_platform_t dtfft_platform_t type~abstract_backend->type~dtfft_platform_t platform type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream type~kernel_type_t kernel_type_t type~abstract_kernel->type~kernel_type_t kernel_type c_ptr c_ptr type~cudaevent->c_ptr event type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~abstract_backend~~InheritedByGraph type~abstract_backend abstract_backend type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~transpose_handle_generic transpose_handle_generic type~transpose_handle_generic->type~abstract_backend comm_handle Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type type( dtfft_platform_t ), public :: platform Platform to use logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer class( abstract_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates Abstract Backend private  subroutine create (self, backend, helper, platform, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend type( dtfft_backend_t ), intent(in) :: backend Backend type type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_platform_t ), intent(in) :: platform Platform to use integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public, non_overridable, pass(self) :: execute Executes Backend private  subroutine execute (self, in, out, stream, aux, exec_type, error_code) Executes Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code procedure, public, non_overridable, pass(self) :: destroy Destroys Abstract Backend private  subroutine destroy (self) Destroys Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend procedure, public, non_overridable, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: set_unpack_kernel Sets unpack kernel for pipelined backend private  subroutine set_unpack_kernel (self, unpack_kernel) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend class( abstract_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data procedure, public, pass(self) :: execute_end Ends execution of Backend private  subroutine execute_end (self, error_code) Ends execution of Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend integer(kind=int32), intent(out) :: error_code Error code procedure, public, pass(self) :: get_async_active Returns if async execution is active private elemental function get_async_active (self) Returns if async execution is active Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value logical procedure( create_interface ), public, deferred, pass(self) :: create_private Creates overriding class subroutine create_interface(self, helper, base_storage) Prototype Creates overriding class Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure( execute_interface ), public, deferred, pass(self) :: execute_private Executes Backend subroutine execute_interface(self, in, out, stream, aux, exec_type, error_code) Prototype Executes Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code procedure( destroy_interface ), public, deferred, pass(self) :: destroy_private Destroys overriding class subroutine destroy_interface(self) Prototype Destroys overriding class Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend","tags":"","loc":"type/abstract_backend.html"},{"title":"fftw_executor – dtFFT ","text":"type, public, extends( abstract_executor ) :: fftw_executor FFTW3 FFT Executor Inherits type~~fftw_executor~~InheritsGraph type~fftw_executor fftw_executor type~abstract_executor abstract_executor type~fftw_executor->type~abstract_executor c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile procedure( apply_interface ), private, nopass, pointer :: apply => NULL() Pointer to FFTW3 function that executes FFT plan procedure( free_interface ), private, nopass, pointer :: free => NULL() Pointer to FFTW3 function that destroys FFT plan procedure( apply_interface ), private, nopass, pointer :: apply_inverse => NULL() Pointer to FFTW3 function that executes inverse FFT plan\nUsed in R2C only Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure, public :: create_private => create Creates FFT plan via FFTW3 Interface private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via FFTW3 Interface Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure, public :: execute_private => execute Executes FFTW3 plan private  subroutine execute (self, a, b, sign) Executes FFTW3 plan Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(in) :: self FFTW FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public :: destroy_private => destroy Destroys FFTW3 plan private  subroutine destroy (self) Destroys FFTW3 plan Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor procedure, public, nopass :: mem_alloc Allocates FFTW3 memory private  subroutine mem_alloc (alloc_bytes, ptr) Allocates FFTW3 memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure, public, nopass :: mem_free Frees FFTW3 aligned memory private  subroutine mem_free (ptr) Frees FFTW3 aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"type/fftw_executor.html"},{"title":"nvrtc_module – dtFFT ","text":"type, public :: nvrtc_module Class for managing nvRTC compiled CUDA kernels Inherits type~~nvrtc_module~~InheritsGraph type~nvrtc_module nvrtc_module type~cumodule CUmodule type~nvrtc_module->type~cumodule cumod type~kernel_config kernel_config type~nvrtc_module->type~kernel_config configs type~kernel_type_t kernel_type_t type~nvrtc_module->type~kernel_type_t kernel_type type~nvrtcprogram nvrtcProgram type~nvrtc_module->type~nvrtcprogram prog c_ptr c_ptr type~cumodule->c_ptr ptr type~nvrtcprogram->c_ptr cptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~nvrtc_module~~InheritedByGraph type~nvrtc_module nvrtc_module type~nvrtc_module_cache nvrtc_module_cache type~nvrtc_module_cache->type~nvrtc_module cache Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, private :: is_created = .false. Is module created character(len=:), private, allocatable :: basic_name Basic kernel name integer(kind=int32), private :: ndims Number of dimensions, used only for forward permutation type( CUmodule ), private :: cumod CUDA module type( nvrtcProgram ), private :: prog nvRTC program type( kernel_type_t ), private :: kernel_type Type of kernel integer(kind=int64), private :: base_storage Number of bytes needed to store single element type( kernel_config ), private, allocatable :: configs (:) Kernel configurations that this module was compiled for Type-Bound Procedures procedure, public, pass(self) :: create Creates module with given parameters private  subroutine create (self, ndims, kernel_type, base_storage, configs, props) Creates module with given parameters, compiles nvRTC program and loads it as CUDA module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(inout) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions, used only for forward permutation type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_config ), intent(in) :: configs (:) Kernel configurations that this module should be compiled for type( device_props ), intent(in) :: props GPU architecture properties procedure, public, pass(self) :: destroy Destroys module and frees resources private  subroutine destroy (self) Destroys module and frees resources Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(inout) :: self procedure, public, pass(self) :: get Returns kernel ready to be executed private  function get (self, ndims, kernel_type, base_storage, tile_size, block_rows) result(fun) Returns kernel ready to be executed Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions, used only for forward permutation type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter Return Value type( CUfunction ) Resulting kernel generic, public :: check => check_instance , check_module Checks if kernel is with given parameters is available in this module private  function check_instance (self, ndims, kernel_type, base_storage, tile_size, block_rows) Checks if kernel with given parameters is available in this module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter Return Value logical private  function check_module (self, ndims, kernel_type, base_storage) Basic check that this module provides kernels of given type Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value logical procedure, private, pass(self) :: check_instance Checks if kernel with given parameters is available in this module private  function check_instance (self, ndims, kernel_type, base_storage, tile_size, block_rows) Checks if kernel with given parameters is available in this module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter Return Value logical procedure, private, pass(self) :: check_module Basic check that this module provides kernels of given type private  function check_module (self, ndims, kernel_type, base_storage) Basic check that this module provides kernels of given type Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value logical","tags":"","loc":"type/nvrtc_module.html"},{"title":"codegen_t – dtFFT ","text":"type, private, extends( string ) :: codegen_t Class for generating CUDA code Inherits type~~codegen_t~~InheritsGraph type~codegen_t codegen_t type~string string type~codegen_t->type~string Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: raw String Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_string private  subroutine destroy_string (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self procedure, public, pass(self) :: add => add_line Adds new line to CUDA code private  subroutine add_line (self, line) Adds new line to CUDA code Arguments Type Intent Optional Attributes Name class( codegen_t ), intent(inout) :: self Kernel code character(len=*), intent(in) :: line Line to add","tags":"","loc":"type/codegen_t.html"},{"title":"mkl_executor – dtFFT ","text":"type, public, extends( abstract_executor ) :: mkl_executor MKL FFT Executor Inherits type~~mkl_executor~~InheritsGraph type~mkl_executor mkl_executor type~abstract_executor abstract_executor type~mkl_executor->type~abstract_executor c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile logical, private :: need_reconfigure Needed for R2C plans integer(kind=c_long), private, allocatable :: istrides (:) Input strides. Needed for R2C plans to reconfigure plan integer(kind=c_long), private, allocatable :: ostrides (:) Output strides. Needed for R2C plans to reconfigure plan integer(kind=int32), private :: idist Input distance between the first data elements of consecutive data sets integer(kind=int32), private :: odist Output distance between the first data elements of consecutive data sets Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure, public :: create_private => create Creates FFT plan via MKL DFTI Interface private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via MKL DFTI Interface Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure, public :: execute_private => execute Executes MKL plan private  subroutine execute (self, a, b, sign) Executes MKL plan Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(in) :: self MKL FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public :: destroy_private => destroy Destroys MKL plan private  subroutine destroy (self) Destroys MKL plan Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor procedure, public, nopass :: mem_alloc Allocates MKL memory private  subroutine mem_alloc (alloc_bytes, ptr) Allocates MKL memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure, public, nopass :: mem_free Frees MKL aligned memory private  subroutine mem_free (ptr) Frees MKL aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"type/mkl_executor.html"},{"title":"dtfft_pencil_t – dtFFT ","text":"type, public :: dtfft_pencil_t Structure to hold pencil decomposition info Components Type Visibility Attributes Name Initial integer(kind=int8), public :: dim Aligned dimension id integer(kind=int8), public :: ndims = 0 Number of dimensions integer(kind=int32), public, allocatable :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), public, allocatable :: counts (:) Local counts of data, in elements integer(kind=int64), public :: size Total number of elements in a pencil logical, private :: is_created = .false. Is pencil created Constructor public        interface dtfft_pencil_t Type bound constuctor for dtfft_pencil_t private  function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t ) Type-Bound Procedures procedure, private, pass(self) :: destroy => destroy_pencil_t_private Destroys pencil private  subroutine destroy_pencil_t_private (self) Destroys pencil Arguments Type Intent Optional Attributes Name class( dtfft_pencil_t ), intent(inout) :: self Public pencil","tags":"","loc":"type/dtfft_pencil_t.html"},{"title":"dtfft_pencil_c – dtFFT ","text":"type, public, bind(C) :: dtfft_pencil_c Structure to hold pencil decomposition info Components Type Visibility Attributes Name Initial integer(kind=c_int8_t), public :: dim Aligned dimension id integer(kind=c_int8_t), public :: ndims Number of dimensions integer(kind=c_int32_t), public :: starts (3) Local starts, starting from 0 for both C and Fortran integer(kind=c_int32_t), public :: counts (3) Local counts of data, in elements integer(kind=c_size_t), public :: size Total number of elements in a pencil","tags":"","loc":"type/dtfft_pencil_c.html"},{"title":"pencil – dtFFT ","text":"type, public :: pencil Class that describes information about data layout Inherited by type~~pencil~~InheritedByGraph type~pencil pencil type~backend_helper backend_helper type~backend_helper->type~pencil pencils type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~pencil real_pencil type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_r2c_t->type~dtfft_core_c2c type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~pencil pencils type~transpose_plan transpose_plan type~dtfft_plan_t->type~transpose_plan plan type~create_args create_args type~create_args->type~backend_helper helper type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~transpose_plan->type~backend_helper helper type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int8), public :: aligned_dim Position of aligned dimension. For example: X pencil aligned_dim = 1, Z pencil aligned_dim = 3 integer(kind=int8), public :: rank Rank of buffer: 2 or 3 integer(kind=int32), public, allocatable :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), public, allocatable :: counts (:) Local counts of data, in elements logical, public :: is_even Is data evenly distributed across processes Type-Bound Procedures procedure, public, pass(self) :: create Creates pencil private  subroutine create (self, rank, aligned_dim, counts, comms, lstarts, lcounts, order) Creates pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil integer(kind=int8), intent(in) :: rank Rank of buffer integer(kind=int8), intent(in) :: aligned_dim Position of aligned dimension integer(kind=int32), intent(in) :: counts (:) Global counts type(MPI_Comm), intent(in) :: comms (:) Grid communicators integer(kind=int32), intent(in), optional :: lstarts (:) Local starts integer(kind=int32), intent(in), optional :: lcounts (:) Local counts integer(kind=int8), intent(in), optional :: order (:) Order of dimensions procedure, public, pass(self) :: destroy Destroys pencil private  subroutine destroy (self) Destroys pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil procedure, public, pass(self) :: make_public Creates public object that users can use to create own FFT backends private  function make_public (self) Creates public object that users can use to create own FFT backends Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: self Pencil Return Value type( dtfft_pencil_t )","tags":"","loc":"type/pencil.html"},{"title":"pencil_init – dtFFT ","text":"type, public :: pencil_init Class that describes information about data layout It is an extension of dtfft_pencil_t with additional fields Inherits type~~pencil_init~~InheritsGraph type~pencil_init pencil_init MPI_Comm MPI_Comm type~pencil_init->MPI_Comm comms Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(MPI_Comm), public, allocatable :: comms (:) 1D communicators for each dimension integer(kind=int32), public, allocatable :: starts (:) Local starts integer(kind=int32), public, allocatable :: counts (:) Local counts integer(kind=int32), public, allocatable :: dims (:) Global dimensions of entire region Type-Bound Procedures procedure, public, pass(self) :: create => create_pencil_init Creates and validates pencil passed by user to plan constructors private  function create_pencil_init (self, pencil, comm) result(error_code) Creates and validates pencil passed by user to plan constructors Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t type( dtfft_pencil_t ), intent(in) :: pencil Pencil passed by user to plan constructors type(MPI_Comm), intent(in) :: comm MPI Communicator passed to plan constructors Return Value integer(kind=int32) Error code procedure, public, pass(self) :: destroy => destroy_pencil_init Destroys pencil_init private  subroutine destroy_pencil_init (self) Destroys pencil_init Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t","tags":"","loc":"type/pencil_init.html"},{"title":"dtfft_plan_t – dtFFT ","text":"type, public, abstract :: dtfft_plan_t Abstract class for all dtFFT plans Inherits type~~dtfft_plan_t~~InheritsGraph type~dtfft_plan_t dtfft_plan_t MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~transpose_plan transpose_plan type~dtfft_plan_t->type~transpose_plan plan type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~transpose_plan->c_ptr aux type~transpose_plan->type~dtfft_platform_t platform type~transpose_plan->type~dtfft_stream_t stream type~backend_helper backend_helper type~transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~transpose_plan->type~dtfft_backend_t backend type~plan_t plan_t type~transpose_plan->type~plan_t plans type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~abstract_transpose_handle abstract_transpose_handle type~plan_t->type~abstract_transpose_handle p type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~dtfft_plan_t~~InheritedByGraph type~dtfft_plan_t dtfft_plan_t type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int8), private :: ndims Number of global dimensions integer(kind=int32), private, allocatable :: dims (:) Global dimensions integer(kind=int32), private, allocatable :: grid_dims (:) Grid decomposition dimensions type( dtfft_precision_t ), private :: precision Precision of transform logical, private :: is_created = .false. Plan creation flag logical, private :: is_transpose_plan = .false. Plan is transpose only logical, private :: is_aux_alloc = .false. Auxiliary buffer is allocated internally logical, private :: is_z_slab = .false. Using Z-slab optimization Only 3D plan. When .true., then data is distributed only Z direction and it creates a possibility for optimization: 2 dimensional FFT plan is created for both X and Y dimensions Single call to MPI_Alltoall is required to transpose data from X-align to Z-align For CUDA build this optimization means single CUDA kernel that tranposes data directly from X to Z logical, private :: is_y_slab = .false. Using Y-slab optimization Only 3D plan. When .true., then data is distributed only Y direction and it creates a possibility for optimization: 2 dimensional FFT plan is created for both Y and Z dimensions Transpose from Y-align to Z-align is skipped type( dtfft_effort_t ), private :: effort User defined type of effort integer(kind=int64), private :: storage_size Single element size in bytes type( dtfft_executor_t ), private :: executor FFT executor type type(MPI_Comm), private :: comm Grid communicator type(MPI_Comm), private, allocatable :: comms (:) Local 1d communicators type( transpose_plan ), private :: plan Transpose plan handle type( pencil ), private, allocatable :: pencils (:) Information about data aligment and datatypes type( dtfft_platform_t ), private :: platform Execution platform type( dtfft_stream_t ), private :: stream CUDA Stream associated with current plan type(c_ptr), private :: aux_ptr Auxiliary pointer type( fft_executor ), private, allocatable :: fft (:) Internal fft runners integer(kind=int32), private, allocatable :: fft_mapping (:) Memory and plan creation optimization.\nIn case same FFTs needs to be run in different dimensions\nonly single FFT plan needs to be created Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_start Starts an asynchronous transpose operation private  function transpose_start (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers private  function transpose_start_ptr (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_end Ends previously started transposition private  subroutine transpose_end (self, request, error_code) Ends previously started transposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_request_t ), intent(inout) :: request Handle obtained from transpose_start or transpose_start_ptr integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary buffer. Not optional. If not required, c_null_ptr must be passed.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_y_slab_enabled Returns logical value is Y-slab optimization is enabled private  function get_y_slab_enabled (self, error_code) Returns logical value is Y-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, layout, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: layout Required layout: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_grid_dims Returns grid decomposition dimensions private  subroutine get_grid_dims (self, grid_dims, error_code) Returns grid decomposition dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: grid_dims (:) Grid dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  function mem_alloc_ptr (self, alloc_bytes, error_code) result(ptr) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type(c_ptr) Allocated pointer generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d Allocates memory specific for this plan private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d Frees previously allocated memory specific for this plan private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_backend Returns selected backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 Returns CUDA stream associated with plan private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: get_stream_ptr Returns CUDA stream associated with plan private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: get_stream_int64 Returns CUDA stream associated with plan private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: execute_private Executes plan private  subroutine execute_private (self, in, out, execute_type, aux, inplace) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. logical, intent(in) :: inplace Inplace execution flag procedure, private, pass(self), non_overridable :: execute_2d Executes 2d plan private  subroutine execute_2d (self, in, out, execute_type, aux) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. procedure, private, pass(self), non_overridable :: execute_z_slab Executes Z slab plan private  subroutine execute_z_slab (self, in, out, execute_type, aux, inplace) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. logical, intent(in) :: inplace Inplace execution flag procedure, private, pass(self), non_overridable :: execute_generic Executes plan with specified auxiliary buffer private  subroutine execute_generic (self, in, out, execute_type, aux) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. procedure, private, pass(self), non_overridable :: transpose_private Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_private (self, in, out, transpose_type, exec_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. type( async_exec_t ), intent(in) :: exec_type Type of asynchronous execution. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: check_create_args Check arguments provided to create subroutines private  function check_create_args (self, dims, pencil, comm, precision, effort, executor, kinds) Check arguments provided by user and sets private variables Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm Optional MPI Communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) procedure, private, pass(self), non_overridable :: create_private Creates core private  function create_private (self, sngl_type, sngl_storage_size, dbl_type, dbl_storage_size, dims, pencil, comm, precision, effort, executor, kinds) Creates core Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(MPI_Datatype), intent(in) :: sngl_type MPI_Datatype for single precision plan integer(kind=int64), intent(in) :: sngl_storage_size Number of bytes needed to store single element (single precision) type(MPI_Datatype), intent(in) :: dbl_type MPI_Datatype for double precision plan integer(kind=int64), intent(in) :: dbl_storage_size Number of bytes needed to store single element (double precision) integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm User-defined communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) procedure, private, pass(self), non_overridable :: alloc_fft_plans Allocates fft_executor classes private  subroutine alloc_fft_plans (self, kinds) Allocates abstract_executor with required FFT class\nand populates fft_mapping with similar FFT ids Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform procedure, private, pass(self), non_overridable :: check_aux Checks if aux buffer was passed\nand if not will allocate one internally private  subroutine check_aux (self, aux) Checks if aux buffer was passed by user and if not will allocate one internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: aux Optional auxiliary buffer. procedure, private, pass(self), non_overridable :: mem_alloc_r32_1d Allocates memory for 1d real32 pointer private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r64_1d Allocates memory for 1d real64 pointer private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r32_2d Allocates memory for 2d real32 pointer private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r64_2d Allocates memory for 2d real64 pointer private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r32_3d Allocates memory for 2d real32 pointer private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_r64_3d Allocates memory for 2d real64 pointer private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c32_1d Allocates memory for 1d complex32 pointer private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c64_1d Allocates memory for 1d complex64 pointer private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c32_2d Allocates memory for 2d complex32 pointer private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c64_2d Allocates memory for 2d complex64 pointer private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c32_3d Allocates memory for 3d complex32 pointer private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_alloc_c64_3d Allocates memory for 3d complex64 pointer private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r32_1d Frees real32 1d pointer private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r64_1d Frees real64 1d pointer private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r32_2d Frees real32 2d pointer private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r64_2d Frees real64 2d pointer private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r32_3d Frees real32 3d pointer private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_r64_3d Frees real64 3d pointer private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c32_1d Frees complex32 1d pointer private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c64_1d Frees complex64 1d pointer private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c32_2d Frees complex32 2d pointer private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c64_2d Frees complex64 2d pointer private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c32_3d Frees complex32 3d pointer private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: mem_free_c64_3d Frees complex64 3d pointer private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user","tags":"","loc":"type/dtfft_plan_t.html"},{"title":"dtfft_plan_c2c_t – dtFFT ","text":"type, public, extends( dtfft_core_c2c ) :: dtfft_plan_c2c_t C2C Plan Inherits type~~dtfft_plan_c2c_t~~InheritsGraph type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_t dtfft_plan_t type~dtfft_core_c2c->type~dtfft_plan_t MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~transpose_plan transpose_plan type~dtfft_plan_t->type~transpose_plan plan type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~transpose_plan->c_ptr aux type~transpose_plan->type~dtfft_platform_t platform type~transpose_plan->type~dtfft_stream_t stream type~backend_helper backend_helper type~transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~transpose_plan->type~dtfft_backend_t backend type~plan_t plan_t type~transpose_plan->type~plan_t plans type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~abstract_transpose_handle abstract_transpose_handle type~plan_t->type~abstract_transpose_handle p type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_start Starts an asynchronous transpose operation private  function transpose_start (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers private  function transpose_start_ptr (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_end Ends previously started transposition private  subroutine transpose_end (self, request, error_code) Ends previously started transposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_request_t ), intent(inout) :: request Handle obtained from transpose_start or transpose_start_ptr integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary buffer. Not optional. If not required, c_null_ptr must be passed.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_y_slab_enabled Returns logical value is Y-slab optimization is enabled private  function get_y_slab_enabled (self, error_code) Returns logical value is Y-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, layout, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: layout Required layout: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_grid_dims Returns grid decomposition dimensions private  subroutine get_grid_dims (self, grid_dims, error_code) Returns grid decomposition dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: grid_dims (:) Grid dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  function mem_alloc_ptr (self, alloc_bytes, error_code) result(ptr) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type(c_ptr) Allocated pointer generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_backend Returns selected backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: create => create_c2c , create_c2c_pencil Creates C2C plan private  subroutine create_c2c (self, dims, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_c2c_pencil (self, pencil, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_c2c Creates C2C plan using global dimensions private  subroutine create_c2c (self, dims, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_c2c_pencil Creates C2C plan using Pencil of local data private  subroutine create_c2c_pencil (self, pencil, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_c2c_internal Private method that combines common logic for C2C plan creation private  function create_c2c_internal (self, dims, pencil, comm, precision, effort, executor) Private method that combines common logic for C2C plan creation Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32)","tags":"","loc":"type/dtfft_plan_c2c_t.html"},{"title":"dtfft_plan_r2c_t – dtFFT ","text":"type, public, extends( dtfft_core_c2c ) :: dtfft_plan_r2c_t R2C Plan Inherits type~~dtfft_plan_r2c_t~~InheritsGraph type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_r2c_t->type~dtfft_core_c2c type~pencil pencil type~dtfft_plan_r2c_t->type~pencil real_pencil type~dtfft_plan_t dtfft_plan_t type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_t->type~pencil pencils MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~transpose_plan transpose_plan type~dtfft_plan_t->type~transpose_plan plan type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~transpose_plan->c_ptr aux type~transpose_plan->type~dtfft_platform_t platform type~transpose_plan->type~dtfft_stream_t stream type~backend_helper backend_helper type~transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~transpose_plan->type~dtfft_backend_t backend type~plan_t plan_t type~transpose_plan->type~plan_t plans type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->type~pencil pencils type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~abstract_transpose_handle abstract_transpose_handle type~plan_t->type~abstract_transpose_handle p type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( pencil ), private :: real_pencil “Real” pencil decomposition info Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_start Starts an asynchronous transpose operation private  function transpose_start (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers private  function transpose_start_ptr (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_end Ends previously started transposition private  subroutine transpose_end (self, request, error_code) Ends previously started transposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_request_t ), intent(inout) :: request Handle obtained from transpose_start or transpose_start_ptr integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary buffer. Not optional. If not required, c_null_ptr must be passed.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_y_slab_enabled Returns logical value is Y-slab optimization is enabled private  function get_y_slab_enabled (self, error_code) Returns logical value is Y-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, layout, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: layout Required layout: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_grid_dims Returns grid decomposition dimensions private  subroutine get_grid_dims (self, grid_dims, error_code) Returns grid decomposition dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: grid_dims (:) Grid dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  function mem_alloc_ptr (self, alloc_bytes, error_code) result(ptr) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type(c_ptr) Allocated pointer generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_backend Returns selected backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: create => create_r2c , create_r2c_pencil Creates R2C plan private  subroutine create_r2c (self, dims, executor, comm, precision, effort, error_code) R2C Generic Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2c_pencil (self, pencil, executor, comm, precision, effort, error_code) R2C Plan Constructor with pencil Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2c Creates R2C plan using global dimensions private  subroutine create_r2c (self, dims, executor, comm, precision, effort, error_code) R2C Generic Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2c_pencil Creates R2C plan using Pencil of local data private  subroutine create_r2c_pencil (self, pencil, executor, comm, precision, effort, error_code) R2C Plan Constructor with pencil Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2c_internal Private method that combines common logic for R2C plan creation private  function create_r2c_internal (self, executor, dims, pencil, comm, precision, effort) Private method that combines common logic for R2C plan creation Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan Return Value integer(kind=int32)","tags":"","loc":"type/dtfft_plan_r2c_t.html"},{"title":"dtfft_plan_r2r_t – dtFFT ","text":"type, public, extends( dtfft_plan_t ) :: dtfft_plan_r2r_t R2R Plan Inherits type~~dtfft_plan_r2r_t~~InheritsGraph type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_r2r_t->type~dtfft_plan_t MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~transpose_plan transpose_plan type~dtfft_plan_t->type~transpose_plan plan type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~transpose_plan->c_ptr aux type~transpose_plan->type~dtfft_platform_t platform type~transpose_plan->type~dtfft_stream_t stream type~backend_helper backend_helper type~transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~transpose_plan->type~dtfft_backend_t backend type~plan_t plan_t type~transpose_plan->type~plan_t plans type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~abstract_transpose_handle abstract_transpose_handle type~plan_t->type~abstract_transpose_handle p type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_start Starts an asynchronous transpose operation private  function transpose_start (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers private  function transpose_start_ptr (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_end Ends previously started transposition private  subroutine transpose_end (self, request, error_code) Ends previously started transposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_request_t ), intent(inout) :: request Handle obtained from transpose_start or transpose_start_ptr integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary buffer. Not optional. If not required, c_null_ptr must be passed.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_y_slab_enabled Returns logical value is Y-slab optimization is enabled private  function get_y_slab_enabled (self, error_code) Returns logical value is Y-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, layout, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: layout Required layout: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_grid_dims Returns grid decomposition dimensions private  subroutine get_grid_dims (self, grid_dims, error_code) Returns grid decomposition dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: grid_dims (:) Grid dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  function mem_alloc_ptr (self, alloc_bytes, error_code) result(ptr) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type(c_ptr) Allocated pointer generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_backend Returns selected backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: create => create_r2r , create_r2r_pencil Creates R2R plan private  subroutine create_r2r (self, dims, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2r_pencil (self, pencil, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2r Creates R2R plan using global dimensions private  subroutine create_r2r (self, dims, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2r_pencil Creates R2R plan using Pencil of local data private  subroutine create_r2r_pencil (self, pencil, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, private, pass(self) :: create_r2r_internal Private method that combines common logic for R2R plan creation private  function create_r2r_internal (self, dims, pencil, kinds, comm, precision, effort, executor) Creates plan for R2R plans Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32)","tags":"","loc":"type/dtfft_plan_r2r_t.html"},{"title":"transpose_request – dtFFT ","text":"type, private :: transpose_request Handle for async transpose operation Inherits type~~transpose_request~~InheritsGraph type~transpose_request transpose_request c_ptr c_ptr type~transpose_request->c_ptr in, out type~dtfft_transpose_t dtfft_transpose_t type~transpose_request->type~dtfft_transpose_t transpose_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_transpose_t ), public :: transpose_type Type of transposition requested logical, public :: is_started = .false. Flag that indicates if transpose was started type(c_ptr), public :: in Input pointer type(c_ptr), public :: out Output pointer","tags":"","loc":"type/transpose_request.html"},{"title":"fft_executor – dtFFT ","text":"type, private :: fft_executor FFT handle Inherits type~~fft_executor~~InheritsGraph type~fft_executor fft_executor type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~fft_executor~~InheritedByGraph type~fft_executor fft_executor type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~fft_executor fft type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( abstract_executor ), public, allocatable :: fft Executor","tags":"","loc":"type/fft_executor.html"},{"title":"dtfft_core_c2c – dtFFT ","text":"type, private, abstract, extends( dtfft_plan_t ) :: dtfft_core_c2c Abstract C2C Plan Inherits type~~dtfft_core_c2c~~InheritsGraph type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_t dtfft_plan_t type~dtfft_core_c2c->type~dtfft_plan_t MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~transpose_plan transpose_plan type~dtfft_plan_t->type~transpose_plan plan type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~transpose_plan->c_ptr aux type~transpose_plan->type~dtfft_platform_t platform type~transpose_plan->type~dtfft_stream_t stream type~backend_helper backend_helper type~transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~transpose_plan->type~dtfft_backend_t backend type~plan_t plan_t type~transpose_plan->type~plan_t plans type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~abstract_transpose_handle abstract_transpose_handle type~plan_t->type~abstract_transpose_handle p type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~dtfft_core_c2c~~InheritedByGraph type~dtfft_core_c2c dtfft_core_c2c type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose Performs single transposition private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_ptr Performs single transposition using type(c_ptr) pointers instead of buffers private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: transpose_start Starts an asynchronous transpose operation private  function transpose_start (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers private  function transpose_start_ptr (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation procedure, public, pass(self), non_overridable :: transpose_end Ends previously started transposition private  subroutine transpose_end (self, request, error_code) Ends previously started transposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_request_t ), intent(inout) :: request Handle obtained from transpose_start or transpose_start_ptr integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute Executes plan private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: execute_ptr Executes plan using type(c_ptr) pointers instead of buffers private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary buffer. Not optional. If not required, c_null_ptr must be passed.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: destroy Destroys plan private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user procedure, public, pass(self), non_overridable :: get_local_sizes Returns local starts and counts in real and fourier spaces private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_alloc_size Wrapper around get_local_sizes to obtain number of elements only private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan procedure, public, pass(self), non_overridable :: get_z_slab_enabled Returns logical value is Z-slab optimization is enabled private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_y_slab_enabled Returns logical value is Y-slab optimization is enabled private  function get_y_slab_enabled (self, error_code) Returns logical value is Y-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical procedure, public, pass(self), non_overridable :: get_pencil Returns pencil decomposition private  function get_pencil (self, layout, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: layout Required layout: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) procedure, public, pass(self), non_overridable :: get_element_size Returns number of bytes required to store single element. private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_alloc_bytes Returns minimum number of bytes required to execute plan private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) procedure, public, pass(self), non_overridable :: get_executor Returns FFT Executor associated with plan private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) procedure, public, pass(self), non_overridable :: get_dims Returns global dimensions private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_grid_dims Returns grid decomposition dimensions private  subroutine get_grid_dims (self, grid_dims, error_code) Returns grid decomposition dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: grid_dims (:) Grid dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_precision Returns precision of plan private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) procedure, public, pass(self), non_overridable :: report Prints plan details private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_alloc_ptr Allocates memory for type(c_ptr) private  function mem_alloc_ptr (self, alloc_bytes, error_code) result(ptr) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type(c_ptr) Allocated pointer generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: mem_free_ptr Frees previously allocated memory for type(c_ptr) private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, public, pass(self), non_overridable :: get_backend Returns selected backend during autotuning private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) procedure, public, pass(self), non_overridable :: get_platform Returns plan execution platform private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) generic, public :: get_stream => get_stream_ptr , get_stream_int64 private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user procedure, private, pass(self), non_overridable :: create_c2c_core Creates plan for both C2C and R2C private  function create_c2c_core (self, dims, pencil, comm, precision, effort, executor) Creates plan for both C2C and R2C Arguments Type Intent Optional Attributes Name class( dtfft_core_c2c ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32)","tags":"","loc":"type/dtfft_core_c2c.html"},{"title":"vkfft_wrapper – dtFFT ","text":"type, public :: vkfft_wrapper VkFFT Wrapper Inherits type~~vkfft_wrapper~~InheritsGraph type~vkfft_wrapper vkfft_wrapper c_funptr c_funptr type~vkfft_wrapper->c_funptr vkfft_functions c_ptr c_ptr type~vkfft_wrapper->c_ptr lib_handle Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~vkfft_wrapper~~InheritedByGraph type~vkfft_wrapper vkfft_wrapper type~vkfft_executor vkfft_executor type~vkfft_executor->type~vkfft_wrapper wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial procedure( vkfft_create_interface ), public, pointer, nopass :: create Fortran Pointer to vkFFT create function procedure( vkfft_execute_interface ), public, pointer, nopass :: execute Fortran Pointer to vkFFT execute function procedure( vkfft_destroy_interface ), public, pointer, nopass :: destroy Fortran Pointer to vkFFT destroy function logical, private :: is_loaded = .false. Is VkFFT library loaded type(c_ptr), private :: lib_handle Handle to the loaded library type(c_funptr), private :: vkfft_functions (3) Array of VkFFT functions","tags":"","loc":"type/vkfft_wrapper.html"},{"title":"transpose_plan – dtFFT ","text":"type, public :: transpose_plan Transpose Plan class\nThis class is a container for transposition plans Inherits type~~transpose_plan~~InheritsGraph type~transpose_plan transpose_plan c_ptr c_ptr type~transpose_plan->c_ptr aux type~backend_helper backend_helper type~transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~transpose_plan->type~dtfft_backend_t backend type~dtfft_platform_t dtfft_platform_t type~transpose_plan->type~dtfft_platform_t platform type~dtfft_stream_t dtfft_stream_t type~transpose_plan->type~dtfft_stream_t stream type~plan_t plan_t type~transpose_plan->type~plan_t plans type~backend_helper->c_ptr nccl_register MPI_Comm MPI_Comm type~backend_helper->MPI_Comm comms type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~pencil pencil type~backend_helper->type~pencil pencils type~dtfft_stream_t->c_ptr stream type~abstract_transpose_handle abstract_transpose_handle type~plan_t->type~abstract_transpose_handle p type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~transpose_plan~~InheritedByGraph type~transpose_plan transpose_plan type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~transpose_plan plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), private :: backend Backend type( backend_helper ), private :: helper Backend helper logical, private :: is_z_slab Z-slab optimization flag (for 3D transforms) integer(kind=int64), private :: min_buffer_size Minimal buffer size for transposition type( dtfft_platform_t ), private :: platform Platform used for transposition type( dtfft_stream_t ), private :: stream CUDA stream type(c_ptr), private :: aux Auxiliary memory real(kind=real32), private, pointer :: paux (:) Pointer to auxiliary memory logical, private :: is_aux_alloc = .false. Is auxiliary memory allocated type( plan_t ), private, allocatable :: plans (:) Plans for each transposition Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates transpose plan private  function create (self, platform, dims, base_comm, effort, base_dtype, base_storage, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type( dtfft_platform_t ), intent(in) :: platform Platform to create plan for integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Pencil passed by user Return Value integer(kind=int32) Error code procedure, public, non_overridable, pass(self) :: execute Executes transposition private  subroutine execute (self, in, out, transpose_type, exec_type, error_code) Executes transposition Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming buffer type(c_ptr), intent(in) :: out Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to execute type( async_exec_t ), intent(in) :: exec_type Type of execution (sync/async) integer(kind=int32), intent(out), optional :: error_code Error code procedure, public, non_overridable, pass(self) :: execute_end Finishes asynchronous transposition private  subroutine execute_end (self, in, out, transpose_type, error_code) Finishes asynchronous transposition Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming buffer type(c_ptr), intent(in) :: out Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose integer(kind=int32), intent(out) :: error_code Error code procedure, public, non_overridable, pass(self) :: get_async_active Returns .true. if any of the plans is running asynchronously private  function get_async_active (self) Returns .true. if any of the plans is running asynchronously Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value logical procedure, public, non_overridable, pass(self) :: destroy Destroys transpose plan private  subroutine destroy (self) Destroys transposition plans Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class procedure, public, non_overridable, pass(self) :: get_aux_size Returns auxiliary buffer size private  function get_aux_size (self) result(aux_size) Returns maximum auxiliary memory size needed by transpose plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: get_backend Returns backend id private  function get_backend (self) Returns plan GPU backend Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value type( dtfft_backend_t ) procedure, public, non_overridable, pass(self) :: get_z_slab Returns .true. if Z-slab optimization is enabled private  function get_z_slab (self) Returns .true. if Z-slab optimization is enabled Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value logical procedure, public, non_overridable, pass(self) :: mem_alloc Allocates memory based on selected backend private  subroutine mem_alloc (self, comm, alloc_bytes, ptr, error_code) Allocates memory based on selected backend Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code procedure, public, non_overridable, pass(self) :: mem_free Frees memory allocated with mem_alloc private  subroutine mem_free (self, ptr, error_code) Frees memory allocated with mem_alloc Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code","tags":"","loc":"type/transpose_plan.html"},{"title":"plan_t – dtFFT ","text":"type, private :: plan_t This type is a container for allocatable transpose handles Inherits type~~plan_t~~InheritsGraph type~plan_t plan_t type~abstract_transpose_handle abstract_transpose_handle type~plan_t->type~abstract_transpose_handle p Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~plan_t~~InheritedByGraph type~plan_t plan_t type~transpose_plan transpose_plan type~transpose_plan->type~plan_t plans type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~transpose_plan plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( abstract_transpose_handle ), public, allocatable :: p Transpose handle","tags":"","loc":"type/plan_t.html"},{"title":"transpose_handle_generic – dtFFT ","text":"type, public, extends( abstract_transpose_handle ) :: transpose_handle_generic Generic Transpose Handle\nExecutes transposition in 3 steps: Transpose kernel execution Data exchange between processes Unpacking kernel execution Inherits type~~transpose_handle_generic~~InheritsGraph type~transpose_handle_generic transpose_handle_generic type~abstract_backend abstract_backend type~transpose_handle_generic->type~abstract_backend comm_handle type~abstract_kernel abstract_kernel type~transpose_handle_generic->type~abstract_kernel transpose_kernel, unpack_kernel type~abstract_transpose_handle abstract_transpose_handle type~transpose_handle_generic->type~abstract_transpose_handle type~abstract_backend->type~abstract_kernel unpack_kernel MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_platform_t dtfft_platform_t type~abstract_backend->type~dtfft_platform_t platform type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream type~kernel_type_t kernel_type_t type~abstract_kernel->type~kernel_type_t kernel_type c_ptr c_ptr type~cudaevent->c_ptr event type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, private :: has_exchange = .false. If current handle has exchanges between GPUs logical, private :: is_pipelined = .false. If underlying exchanges are pipelined logical, private :: is_async_supported = .false. If underlying backend support async execution(execute/execute_end) class( abstract_kernel ), private, allocatable :: transpose_kernel Kernel for data transposition class( abstract_kernel ), private, allocatable :: unpack_kernel Kernel for unpacking data class( abstract_backend ), private, allocatable :: comm_handle Communication handle Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates transpose handle private  subroutine create (self, send, recv, base_storage, kwargs) Creates transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract transpose handle type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil integer(kind=int64), intent(in) :: base_storage Base storage size type( create_args ), intent(inout) :: kwargs Additional arguments procedure, public, pass(self) :: create_private => create Creates Generic Transpose Handle private  subroutine create (self, comm, send, recv, transpose_type, base_storage, kwargs) Creates Generic Transpose Handle Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle type(MPI_Comm), intent(in) :: comm MPI Communicator type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Base storage type( create_args ), intent(in) :: kwargs Additional arguments procedure, public, pass(self) :: execute Executes transpose - exchange - unpack private  subroutine execute (self, in, out, kwargs, error_code) Executes transpose - exchange - unpack Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code procedure, public, pass(self) :: execute_end Finalizes async transpose private  subroutine execute_end (self, kwargs, error_code) Ends execution of transposition Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code procedure, public, pass(self) :: get_async_active Returns if async transpose is active private elemental function get_async_active (self) Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(in) :: self Generic Transpose Handle Return Value logical procedure, public, pass(self) :: destroy Destroys Generic Transpose Handle private  subroutine destroy (self) Destroys Generic Transpose Handle Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle procedure, public, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(in) :: self Generic Transpose Handle Return Value integer(kind=int64)","tags":"","loc":"type/transpose_handle_generic.html"},{"title":"data_handle – dtFFT ","text":"type, private :: data_handle Helper class used to obtain displacements and\ncounts needed to send to other processes Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: ls (:,:) Starts of my data that I should send or recv\nwhile communicating with other processes integer(kind=int32), public, allocatable :: ln (:,:) Counts of my data that I should send or recv\nwhile communicating with other processes integer(kind=int32), public, allocatable :: sizes (:,:) Counts of every rank in a comm integer(kind=int32), public, allocatable :: starts (:,:) Starts of every rank in a comm integer(kind=int32), public, allocatable :: displs (:) Local buffer displacement integer(kind=int32), public, allocatable :: counts (:) Number of elements to send or recv Type-Bound Procedures procedure, public, pass(self) :: create => create_data_handle Creates handle private  subroutine create_data_handle (self, info, comm, comm_size) Creates handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class type( pencil ), intent(in) :: info Pencil info type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int32), intent(in) :: comm_size Size of comm procedure, public, pass(self) :: destroy => destroy_data_handle Destroys handle private  subroutine destroy_data_handle (self) Destroys handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class","tags":"","loc":"type/data_handle.html"},{"title":"kernel_config – dtFFT ","text":"type, public :: kernel_config Configuration for the potential kernel Inherited by type~~kernel_config~~InheritedByGraph type~kernel_config kernel_config type~nvrtc_module nvrtc_module type~nvrtc_module->type~kernel_config configs type~nvrtc_module_cache nvrtc_module_cache type~nvrtc_module_cache->type~nvrtc_module cache Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: tile_size Tile size (number of columns) integer(kind=int32), public :: block_rows Block rows integer(kind=int32), public :: padding Padding added to the tile","tags":"","loc":"type/kernel_config.html"},{"title":"cufft_executor – dtFFT ","text":"type, public, extends( abstract_executor ) :: cufft_executor cuFFT FFT Executor Inherits type~~cufft_executor~~InheritsGraph type~cufft_executor cufft_executor type~abstract_executor abstract_executor type~cufft_executor->type~abstract_executor c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure, public :: create_private => create Creates FFT plan via cuFFT Interface private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via cuFFT Interface Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure, public :: execute_private => execute Executes cuFFT plan private  subroutine execute (self, a, b, sign) Executes cuFFT plan Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(in) :: self cuFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public :: destroy_private => destroy Destroys cuFFT plan private  subroutine destroy (self) Destroys cuFFT plan Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor procedure, public, nopass :: mem_alloc Dummy method. Raises error stop private  subroutine mem_alloc (alloc_bytes, ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure, public, nopass :: mem_free Dummy method. Raises error stop private  subroutine mem_free (ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"type/cufft_executor.html"},{"title":"nvrtc_module_cache – dtFFT ","text":"type, private :: nvrtc_module_cache Cache for nvrtc modules This type is used internally by the module and is not exposed to the user\nIt maintains a list of compiled nvrtc modules and provides methods to add new modules\nand retrieve existing ones The cache automatically grows as needed Inherits type~~nvrtc_module_cache~~InheritsGraph type~nvrtc_module_cache nvrtc_module_cache type~nvrtc_module nvrtc_module type~nvrtc_module_cache->type~nvrtc_module cache type~cumodule CUmodule type~nvrtc_module->type~cumodule cumod type~kernel_config kernel_config type~nvrtc_module->type~kernel_config configs type~kernel_type_t kernel_type_t type~nvrtc_module->type~kernel_type_t kernel_type type~nvrtcprogram nvrtcProgram type~nvrtc_module->type~nvrtcprogram prog c_ptr c_ptr type~cumodule->c_ptr ptr type~nvrtcprogram->c_ptr cptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, private :: is_created = .false. Flag that indicates if cache is created type( nvrtc_module ), private, allocatable :: cache (:) Array of cached modules integer(kind=int32), private :: size Number of entries in cache Type-Bound Procedures procedure, private, pass(self) :: create Creates cache private  subroutine create (self) Creates cache Arguments Type Intent Optional Attributes Name class( nvrtc_module_cache ), intent(inout) :: self Cache instance procedure, private, pass(self) :: add Adds new entry to cache private  subroutine add (self, m) Adds new entry to cache Arguments Type Intent Optional Attributes Name class( nvrtc_module_cache ), intent(inout) :: self Cache instance type( nvrtc_module ), intent(in) :: m Module to add","tags":"","loc":"type/nvrtc_module_cache.html"},{"title":"dtfft_config_t – dtFFT ","text":"type, public, bind(C) :: dtfft_config_t Type that can be used to set additional configuration parameters to dtFFT Inherits type~~dtfft_config_t~~InheritsGraph type~dtfft_config_t dtfft_config_t type~dtfft_backend_t dtfft_backend_t type~dtfft_config_t->type~dtfft_backend_t backend type~dtfft_platform_t dtfft_platform_t type~dtfft_config_t->type~dtfft_platform_t platform type~dtfft_stream_t dtfft_stream_t type~dtfft_config_t->type~dtfft_stream_t stream c_ptr c_ptr type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical(kind=c_bool), public :: enable_log Should dtFFT print additional information during plan creation or not. Default is false. logical(kind=c_bool), public :: enable_z_slab Should dtFFT use Z-slab optimization or not. Default is true. One should consider disabling Z-slab optimization in order to resolve DTFFT_ERROR_VKFFT_R2R_2D_PLAN error\nOR when underlying FFT implementation of 2D plan is too slow.\nIn all other cases it is considered that Z-slab is always faster, since it reduces number of data transpositions. logical(kind=c_bool), public :: enable_y_slab Should dtFFT use Y-slab optimization or not. Default is false. One should consider disabling Y-slab optimization in order to resolve DTFFT_ERROR_VKFFT_R2R_2D_PLAN error\nOR when underlying FFT implementation of 2D plan is too slow.\nIn all other cases it is considered that Y-slab is always faster, since it reduces number of data transpositions. integer(kind=c_int32_t), public :: n_measure_warmup_iters Number of warmup iterations to execute when effort level is higher or equal to DTFFT_MEASURE Default is 2. integer(kind=c_int32_t), public :: n_measure_iters Number of iterations to execute when effort level is higher or equal to DTFFT_MEASURE Default is 5.\nWhen dtFFT is built with CUDA support, this value also used to determine number\nof iterations when selecting block of threads for NVRTC transpose kernel type( dtfft_platform_t ), public :: platform Selects platform to execute plan. Default is DTFFT_PLATFORM_HOST This option is only defined with device support build.\nEven when dtFFT is build with device support it does not nessasary means that all plans must be related to device.\nThis enables single library installation to be compiled with both host, CUDA and HIP plans. type( dtfft_stream_t ), public :: stream Main CUDA stream that will be used in dtFFT. This parameter is a placeholder for user to set custom stream. Stream that is actually used by dtFFT plan is returned by plan%get_stream function. When user sets stream he is responsible of destroying it. Stream must not be destroyed before call to plan%destroy . type( dtfft_backend_t ), public :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . Default is DTFFT_BACKEND_NCCL if NCCL is enabled, otherwise DTFFT_BACKEND_MPI_P2P . logical(kind=c_bool), public :: enable_datatype_backend Should DTFFT_BACKEND_MPI_DATATYPE be enabled when effort is DTFFT_PATIENT or not. Default is true. This option works when platform is DTFFT_PLATFORM_HOST . logical(kind=c_bool), public :: enable_mpi_backends Should MPI Backends be enabled when effort is DTFFT_PATIENT or not. Default is false. The following applies only to CUDA builds.\nMPI Backends are disabled by default during autotuning process due to OpenMPI Bug https://github.com/open-mpi/ompi/issues/12849\nIt was noticed that during plan autotuning GPU memory not being freed completely.\nFor example:\n1024x1024x512 C2C, double precision, single GPU, using Z-slab optimization, with MPI backends enabled, plan autotuning will leak 8Gb GPU memory.\nWithout Z-slab optimization, running on 4 GPUs, will leak 24Gb on each of the GPUs. One of the workarounds is to disable MPI Backends by default, which is done here. Other is to pass “–mca btl_smcuda_use_cuda_ipc 0” to mpiexec ,\nbut it was noticed that disabling CUDA IPC seriously affects overall performance of MPI algorithms logical(kind=c_bool), public :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. Default is true. Pipelined backends require additional buffer that user has no control over. logical(kind=c_bool), public :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. Default is true. logical(kind=c_bool), public :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. Default is true. logical(kind=c_bool), public :: enable_kernel_optimization Should dtFFT try to optimize NVRTC kernel block size when effort is DTFFT_PATIENT or not. Default is true. This option is only defined when dtFFT is built with CUDA support. Enabling this option will make autotuning process longer, but may result in better performance for some problem sizes.\nIt is recommended to keep this option enabled. integer(kind=c_int32_t), public :: n_configs_to_test Number of top theoretical best performing blocks of threads to test for transposition kernels\nwhen effort is DTFFT_PATIENT or force_kernel_optimization set to true . Default is 5. This option is only defined when dtFFT is built with CUDA support. It is recommended to keep this value between 3 and 10.\nMaximum possible value is 25.\nSetting this value to zero or one will disable kernel optimization. logical(kind=c_bool), public :: force_kernel_optimization Whether to force kernel optimization when effort is not DTFFT_PATIENT . Default is false. This option is only defined when dtFFT is built with CUDA support. Enabling this option will make plan creation process longer, but may result in better performance for a long run.\nSince kernel optimization is performed without data transfers, the overall autotuning time increase should not be significant. Constructor public        interface dtfft_config_t Interface to create a new configuration private pure function config_constructor (enable_log, enable_z_slab, enable_y_slab, n_measure_warmup_iters, n_measure_iters, platform, stream, backend, enable_datatype_backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends, enable_kernel_optimization, n_configs_to_test, force_kernel_optimization) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_log Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_y_slab Should dtFFT use Y-slab optimization or not. integer(kind=int32), intent(in), optional :: n_measure_warmup_iters Number of warmup iterations for measurements integer(kind=int32), intent(in), optional :: n_measure_iters Number of measurement iterations type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_datatype_backend Should DTFFT_BACKEND_MPI_DATATYPE be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_kernel_optimization Should dtFFT try to optimize NVRTC kernel block size during autotune or not. integer(kind=int32), intent(in), optional :: n_configs_to_test Number of top theoretical best performing blocks of threads to test for transposition kernels when effort is DTFFT_PATIENT . logical, intent(in), optional :: force_kernel_optimization Whether to force kernel optimization when effort is not DTFFT_PATIENT . Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config","tags":"","loc":"type/dtfft_config_t.html"},{"title":"nvrtcProgram – dtFFT ","text":"type, public, bind(C) :: nvrtcProgram nvrtcProgram is the unit of compilation, and an opaque handle for a program. Inherits type~~nvrtcprogram~~InheritsGraph type~nvrtcprogram nvrtcProgram c_ptr c_ptr type~nvrtcprogram->c_ptr cptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~nvrtcprogram~~InheritedByGraph type~nvrtcprogram nvrtcProgram type~nvrtc_module nvrtc_module type~nvrtc_module->type~nvrtcprogram prog type~nvrtc_module_cache nvrtc_module_cache type~nvrtc_module_cache->type~nvrtc_module cache Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: cptr Actual pointer","tags":"","loc":"type/nvrtcprogram.html"},{"title":"dim3 – dtFFT ","text":"type, public, bind(C) :: dim3 Dimension specification type Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: x integer(kind=c_int), public :: y integer(kind=c_int), public :: z","tags":"","loc":"type/dim3.html"},{"title":"CUmodule – dtFFT ","text":"type, public, bind(C) :: CUmodule CUDA module Inherits type~~cumodule~~InheritsGraph type~cumodule CUmodule c_ptr c_ptr type~cumodule->c_ptr ptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~cumodule~~InheritedByGraph type~cumodule CUmodule type~nvrtc_module nvrtc_module type~nvrtc_module->type~cumodule cumod type~nvrtc_module_cache nvrtc_module_cache type~nvrtc_module_cache->type~nvrtc_module cache Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr Actual pointer","tags":"","loc":"type/cumodule.html"},{"title":"CUfunction – dtFFT ","text":"type, public, bind(C) :: CUfunction CUDA function Inherits type~~cufunction~~InheritsGraph type~cufunction CUfunction c_ptr c_ptr type~cufunction->c_ptr ptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~cufunction~~InheritedByGraph type~cufunction CUfunction type~kernel_device kernel_device type~kernel_device->type~cufunction cuda_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr Actual pointer","tags":"","loc":"type/cufunction.html"},{"title":"vkfft_executor – dtFFT ","text":"type, public, extends( abstract_executor ) :: vkfft_executor vkFFT FFT Executor Inherits type~~vkfft_executor~~InheritsGraph type~vkfft_executor vkfft_executor type~abstract_executor abstract_executor type~vkfft_executor->type~abstract_executor type~vkfft_wrapper vkfft_wrapper type~vkfft_executor->type~vkfft_wrapper wrapper c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward c_funptr c_funptr type~vkfft_wrapper->c_funptr vkfft_functions type~vkfft_wrapper->c_ptr lib_handle Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile type( vkfft_wrapper ), private, pointer :: wrapper => null() VkFFT Wrapper logical, private :: is_inverse_required Should be create separate inverse FFT Plan or not Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure, public, pass(self) :: create_private => create Creates FFT plan via vkFFT Interface private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via vkFFT Interface Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure, public, pass(self) :: execute_private => execute Executes vkFFT plan private  subroutine execute (self, a, b, sign) Executes vkFFT plan Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(in) :: self vkFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, pass(self) :: destroy_private => destroy Destroys vkFFT plan private  subroutine destroy (self) Destroys vkFFT plan Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor procedure, public, nopass :: mem_alloc Dummy method. Raises error stop private  subroutine mem_alloc (alloc_bytes, ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure, public, nopass :: mem_free Dummy method. Raises error stop private  subroutine mem_free (ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"type/vkfft_executor.html"},{"title":"plan_c – dtFFT ","text":"type, private :: plan_c C pointer to Fortran plan Inherits type~~plan_c~~InheritsGraph type~plan_c plan_c type~dtfft_plan_t dtfft_plan_t type~plan_c->type~dtfft_plan_t p MPI_Comm MPI_Comm type~dtfft_plan_t->MPI_Comm comm, comms c_ptr c_ptr type~dtfft_plan_t->c_ptr aux_ptr type~dtfft_effort_t dtfft_effort_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_platform_t dtfft_platform_t type~dtfft_plan_t->type~dtfft_platform_t platform type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_stream_t dtfft_stream_t type~dtfft_plan_t->type~dtfft_stream_t stream type~fft_executor fft_executor type~dtfft_plan_t->type~fft_executor fft type~pencil pencil type~dtfft_plan_t->type~pencil pencils type~transpose_plan transpose_plan type~dtfft_plan_t->type~transpose_plan plan type~dtfft_stream_t->c_ptr stream type~abstract_executor abstract_executor type~fft_executor->type~abstract_executor fft type~transpose_plan->c_ptr aux type~transpose_plan->type~dtfft_platform_t platform type~transpose_plan->type~dtfft_stream_t stream type~backend_helper backend_helper type~transpose_plan->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~transpose_plan->type~dtfft_backend_t backend type~plan_t plan_t type~transpose_plan->type~plan_t plans type~abstract_executor->c_ptr plan_forward, plan_backward type~backend_helper->MPI_Comm comms type~backend_helper->c_ptr nccl_register type~backend_helper->type~pencil pencils type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~abstract_transpose_handle abstract_transpose_handle type~plan_t->type~abstract_transpose_handle p type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( dtfft_plan_t ), public, allocatable :: p Actual Fortran plan","tags":"","loc":"type/plan_c.html"},{"title":"nvshmem_team_t – dtFFT ","text":"type, public, bind(C) :: nvshmem_team_t NVSHMEM team. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal representation of the NVSHMEM team.","tags":"","loc":"type/nvshmem_team_t.html"},{"title":"cufftReshapeHandle – dtFFT ","text":"type, public, bind(C) :: cufftReshapeHandle An opaque handle to a reshape operation. Inherits type~~cufftreshapehandle~~InheritsGraph type~cufftreshapehandle cufftReshapeHandle c_ptr c_ptr type~cufftreshapehandle->c_ptr cptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~cufftreshapehandle~~InheritedByGraph type~cufftreshapehandle cufftReshapeHandle type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~cufftreshapehandle plan Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: cptr","tags":"","loc":"type/cufftreshapehandle.html"},{"title":"backend_mpi – dtFFT ","text":"type, public, extends( abstract_backend ) :: backend_mpi MPI Backend Inherits type~~backend_mpi~~InheritsGraph type~backend_mpi backend_mpi MPI_Win MPI_Win type~backend_mpi->MPI_Win win type~abstract_backend abstract_backend type~backend_mpi->type~abstract_backend type~mpi_backend_helper mpi_backend_helper type~backend_mpi->type~mpi_backend_helper send, recv MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~abstract_kernel abstract_kernel type~abstract_backend->type~abstract_kernel unpack_kernel type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_platform_t dtfft_platform_t type~abstract_backend->type~dtfft_platform_t platform type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream MPI_Request MPI_Request type~mpi_backend_helper->MPI_Request requests type~kernel_type_t kernel_type_t type~abstract_kernel->type~kernel_type_t kernel_type c_ptr c_ptr type~cudaevent->c_ptr event type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type type( dtfft_platform_t ), public :: platform Platform to use logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer class( abstract_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data logical, private :: is_active If async transpose is active type( mpi_backend_helper ), private :: send MPI Helper for send data type( mpi_backend_helper ), private :: recv MPI Helper for recv data logical, private :: is_rma Using RMA backend type(MPI_Win), private :: win MPI Window for RMA backend logical, private :: is_request_created Request created flag. Used for persistent functions Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates Abstract Backend private  subroutine create (self, backend, helper, platform, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend type( dtfft_backend_t ), intent(in) :: backend Backend type type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_platform_t ), intent(in) :: platform Platform to use integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public, non_overridable, pass(self) :: execute Executes Backend private  subroutine execute (self, in, out, stream, aux, exec_type, error_code) Executes Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code procedure, public, non_overridable, pass(self) :: destroy Destroys Abstract Backend private  subroutine destroy (self) Destroys Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend procedure, public, non_overridable, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: set_unpack_kernel Sets unpack kernel for pipelined backend private  subroutine set_unpack_kernel (self, unpack_kernel) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend class( abstract_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data procedure, public :: create_private => create_mpi Creates MPI backend private  subroutine create_mpi (self, helper, base_storage) Creates MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend type( backend_helper ), intent(in) :: helper Backend helper (unused) integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) procedure, public :: execute_private => execute_mpi Executes MPI backend private  subroutine execute_mpi (self, in, out, stream, aux, exec_type, error_code) Executes MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code procedure, public :: destroy_private => destroy_mpi Destroys MPI backend private  subroutine destroy_mpi (self) Destroys MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend procedure, public :: execute_end => execute_end_mpi Finalizes async transpose private  subroutine execute_end_mpi (self, error_code) Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend integer(kind=int32), intent(out) :: error_code Error code procedure, public :: get_async_active Overrides abstract method and returns if async transpose is active private elemental function get_async_active (self) Returns if async transpose is active Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(in) :: self MPI Backend Return Value logical","tags":"","loc":"type/backend_mpi.html"},{"title":"mpi_backend_helper – dtFFT ","text":"type, private :: mpi_backend_helper MPI Helper Inherits type~~mpi_backend_helper~~InheritsGraph type~mpi_backend_helper mpi_backend_helper MPI_Request MPI_Request type~mpi_backend_helper->MPI_Request requests Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mpi_backend_helper~~InheritedByGraph type~mpi_backend_helper mpi_backend_helper type~backend_mpi backend_mpi type~backend_mpi->type~mpi_backend_helper send, recv Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=CNT_KIND), public, allocatable :: counts (:) Counts of data to send or recv integer(kind=ADDR_KIND), public, allocatable :: displs (:) Displacements of data to send or recv type(MPI_Request), public, allocatable :: requests (:) MPI Requests integer(kind=int32), public, allocatable :: process_map (:) Process map for pipelined communication integer(kind=int32), public :: n_requests Number of requests Type-Bound Procedures procedure, public, pass(self) :: create => create_helper Creates MPI helper private  subroutine create_helper (self, counts, displs, max_requests) Creates MPI helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper integer(kind=int64), intent(in) :: counts (:) Counts of data to send or recv integer(kind=int64), intent(in) :: displs (:) Displacements of data to send or recv integer(kind=int32), intent(in) :: max_requests Maximum number of requests required procedure, public, pass(self) :: destroy => destroy_helper Destroys MPI helper private  subroutine destroy_helper (self, is_request_created) Destroys MPI helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper logical, intent(in) :: is_request_created","tags":"","loc":"type/mpi_backend_helper.html"},{"title":"kernel_host – dtFFT ","text":"type, public, extends( abstract_kernel ) :: kernel_host Host kernel implementation Inherits type~~kernel_host~~InheritsGraph type~kernel_host kernel_host type~abstract_kernel abstract_kernel type~kernel_host->type~abstract_kernel type~kernel_type_t kernel_type_t type~abstract_kernel->type~kernel_type_t kernel_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: is_created = .false. Kernel is created flag. logical, public :: is_dummy = .false. If kernel should do anything or not. type( kernel_type_t ), public :: kernel_type Type of the kernel character(len=:), public, allocatable :: kernel_string integer(kind=int32), public, allocatable :: neighbor_data (:,:) Neighbor data for pipelined unpacking integer(kind=int32), public, allocatable :: dims (:) Local dimensions to process integer(kind=int64), public :: base_storage Type-Bound Procedures procedure, public, pass(self) :: create Creates kernel private  subroutine create (self, dims, effort, base_storage, kernel_type, neighbor_data, force_effort) Creates kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel integer(kind=int32), intent(in) :: dims (:) Local dimensions to process type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int32), intent(in), optional :: neighbor_data (:,:) Optional pointers for unpack kernels logical, intent(in), optional :: force_effort Should effort be forced or not procedure, public, pass(self) :: execute Executes kernel private  subroutine execute (self, in, out, stream, neighbor) Executes kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel real(kind=real32), intent(in) :: in (:) Source buffer, can be device or host pointer real(kind=real32), intent(inout) :: out (:) Target buffer, can be device or host pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, used only for device pointers integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking procedure, public, pass(self) :: destroy Destroys kernel private  subroutine destroy (self) Destroys kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel procedure, public :: create_private => create_host Creates kernel private  subroutine create_host (self, effort, base_storage, force_effort) Creates kernel Arguments Type Intent Optional Attributes Name class( kernel_host ), intent(inout) :: self Host kernel class type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in), optional :: force_effort Should effort be forced or not procedure, public :: execute_private => execute_host Executes kernel private  subroutine execute_host (self, in, out, stream, neighbor) Executes host kernel Arguments Type Intent Optional Attributes Name class( kernel_host ), intent(inout) :: self Host kernel class real(kind=real32), intent(in), target :: in (:) Source host-allocated buffer real(kind=real32), intent(inout), target :: out (:) Target host-allocated buffer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, unused here integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking procedure, public :: destroy_private => destroy_host Destroys kernel private  subroutine destroy_host (self) Destroys host kernel Arguments Type Intent Optional Attributes Name class( kernel_host ), intent(inout) :: self Host kernel class","tags":"","loc":"type/kernel_host.html"},{"title":"ncclUniqueId – dtFFT ","text":"type, public, bind(c) :: ncclUniqueId Components Type Visibility Attributes Name Initial character(len=c_char), public :: internal (128)","tags":"","loc":"type/nccluniqueid.html"},{"title":"ncclComm – dtFFT ","text":"type, public, bind(c) :: ncclComm Inherits type~~ncclcomm~~InheritsGraph type~ncclcomm ncclComm c_ptr c_ptr type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~ncclcomm~~InheritedByGraph type~ncclcomm ncclComm type~backend_helper backend_helper type~backend_helper->type~ncclcomm nccl_comm type~backend_nccl backend_nccl type~backend_nccl->type~ncclcomm nccl_comm type~create_args create_args type~create_args->type~backend_helper helper type~transpose_plan transpose_plan type~transpose_plan->type~backend_helper helper type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~transpose_plan plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: member","tags":"","loc":"type/ncclcomm.html"},{"title":"ncclDataType – dtFFT ","text":"type, public, bind(c) :: ncclDataType Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: member","tags":"","loc":"type/nccldatatype.html"},{"title":"backend_nccl – dtFFT ","text":"type, public, extends( abstract_backend ) :: backend_nccl NCCL backend Inherits type~~backend_nccl~~InheritsGraph type~backend_nccl backend_nccl type~abstract_backend abstract_backend type~backend_nccl->type~abstract_backend type~ncclcomm ncclComm type~backend_nccl->type~ncclcomm nccl_comm MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~abstract_kernel abstract_kernel type~abstract_backend->type~abstract_kernel unpack_kernel type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_platform_t dtfft_platform_t type~abstract_backend->type~dtfft_platform_t platform type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream c_ptr c_ptr type~ncclcomm->c_ptr member type~kernel_type_t kernel_type_t type~abstract_kernel->type~kernel_type_t kernel_type type~cudaevent->c_ptr event type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type type( dtfft_platform_t ), public :: platform Platform to use logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer class( abstract_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( ncclComm ), private :: nccl_comm NCCL Communicator Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates Abstract Backend private  subroutine create (self, backend, helper, platform, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend type( dtfft_backend_t ), intent(in) :: backend Backend type type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_platform_t ), intent(in) :: platform Platform to use integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public, non_overridable, pass(self) :: execute Executes Backend private  subroutine execute (self, in, out, stream, aux, exec_type, error_code) Executes Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code procedure, public, non_overridable, pass(self) :: destroy Destroys Abstract Backend private  subroutine destroy (self) Destroys Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend procedure, public, non_overridable, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: set_unpack_kernel Sets unpack kernel for pipelined backend private  subroutine set_unpack_kernel (self, unpack_kernel) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend class( abstract_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data procedure, public, pass(self) :: execute_end Ends execution of Backend private  subroutine execute_end (self, error_code) Ends execution of Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend integer(kind=int32), intent(out) :: error_code Error code procedure, public, pass(self) :: get_async_active Returns if async execution is active private elemental function get_async_active (self) Returns if async execution is active Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value logical procedure, public :: create_private => create_nccl Creates NCCL backend private  subroutine create_nccl (self, helper, base_storage) Creates NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) procedure, public :: execute_private => execute_nccl Executes NCCL backend private  subroutine execute_nccl (self, in, out, stream, aux, exec_type, error_code) Executes NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code procedure, public :: destroy_private => destroy_nccl Destroys NCCL backend private  subroutine destroy_nccl (self) Destroys NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend","tags":"","loc":"type/backend_nccl.html"},{"title":"nvtxDomainHandle – dtFFT ","text":"type, private, bind(C) :: nvtxDomainHandle NVTX domain handle. Inherits type~~nvtxdomainhandle~~InheritsGraph type~nvtxdomainhandle nvtxDomainHandle c_ptr c_ptr type~nvtxdomainhandle->c_ptr handle Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: handle Internal handle for the NVTX domain.","tags":"","loc":"type/nvtxdomainhandle.html"},{"title":"string – dtFFT ","text":"type, public :: string Class used to create array of strings Inherited by type~~string~~InheritedByGraph type~string string type~codegen_t codegen_t type~codegen_t->type~string Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: raw String Constructor public        interface string Creates string object private  function string_constructor (str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string ) Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_string private  subroutine destroy_string (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self","tags":"","loc":"type/string.html"},{"title":"kernel_device – dtFFT ","text":"type, public, extends( abstract_kernel ) :: kernel_device Device kernel class Inherits type~~kernel_device~~InheritsGraph type~kernel_device kernel_device type~abstract_kernel abstract_kernel type~kernel_device->type~abstract_kernel type~cufunction CUfunction type~kernel_device->type~cufunction cuda_kernel type~kernel_type_t kernel_type_t type~kernel_device->type~kernel_type_t internal_kernel_type type~abstract_kernel->type~kernel_type_t kernel_type c_ptr c_ptr type~cufunction->c_ptr ptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: is_created = .false. Kernel is created flag. logical, public :: is_dummy = .false. If kernel should do anything or not. type( kernel_type_t ), public :: kernel_type Type of the kernel character(len=:), public, allocatable :: kernel_string integer(kind=int32), public, allocatable :: neighbor_data (:,:) Neighbor data for pipelined unpacking integer(kind=int32), public, allocatable :: dims (:) Local dimensions to process type( kernel_type_t ), private :: internal_kernel_type Actual kernel type used for execution, can be different from kernel_type type( CUfunction ), private :: cuda_kernel Pointer to CUDA kernel. integer(kind=int32), private :: tile_size Tile size used for this kernel integer(kind=int32), private :: block_rows Number of rows in each block processed by each thread integer(kind=int64), private :: copy_bytes Number of bytes to copy for KERNEL_UNPACK_SIMPLE_COPY kernel Type-Bound Procedures procedure, public, pass(self) :: create Creates kernel private  subroutine create (self, dims, effort, base_storage, kernel_type, neighbor_data, force_effort) Creates kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel integer(kind=int32), intent(in) :: dims (:) Local dimensions to process type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int32), intent(in), optional :: neighbor_data (:,:) Optional pointers for unpack kernels logical, intent(in), optional :: force_effort Should effort be forced or not procedure, public, pass(self) :: execute Executes kernel private  subroutine execute (self, in, out, stream, neighbor) Executes kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel real(kind=real32), intent(in) :: in (:) Source buffer, can be device or host pointer real(kind=real32), intent(inout) :: out (:) Target buffer, can be device or host pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, used only for device pointers integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking procedure, public, pass(self) :: destroy Destroys kernel private  subroutine destroy (self) Destroys kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel procedure, public :: create_private => create Creates kernel private  subroutine create (self, effort, base_storage, force_effort) Creates kernel Arguments Type Intent Optional Attributes Name class( kernel_device ), intent(inout) :: self Device kernel class type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in), optional :: force_effort Should effort be forced or not procedure, public :: execute_private => execute Executes kernel private  subroutine execute (self, in, out, stream, neighbor) Executes kernel on stream Arguments Type Intent Optional Attributes Name class( kernel_device ), intent(inout) :: self Device kernel class real(kind=real32), intent(in), target :: in (:) Device pointer real(kind=real32), intent(inout), target :: out (:) Device pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking procedure, public :: destroy_private => destroy Destroys kernel private  subroutine destroy (self) Destroys kernel Arguments Type Intent Optional Attributes Name class( kernel_device ), intent(inout) :: self Device kernel class","tags":"","loc":"type/kernel_device.html"},{"title":"cudaEvent – dtFFT ","text":"type, public, bind(C) :: cudaEvent CUDA event types Inherits type~~cudaevent~~InheritsGraph type~cudaevent cudaEvent c_ptr c_ptr type~cudaevent->c_ptr event Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~cudaevent~~InheritedByGraph type~cudaevent cudaEvent type~abstract_backend abstract_backend type~abstract_backend->type~cudaevent execution_event, copy_event type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~transpose_handle_generic transpose_handle_generic type~transpose_handle_generic->type~abstract_backend comm_handle Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: event Handle","tags":"","loc":"type/cudaevent.html"},{"title":"device_props – dtFFT ","text":"type, public, bind(C) :: device_props GPU device properties obtained from cudaDeviceProp Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: sm_count Number of multiprocessors on device (cudaDeviceProp.multiProcessorCount) integer(kind=c_int), public :: max_threads_per_sm Maximum resident threads per multiprocessor (cudaDeviceProp.maxThreadsPerMultiProcessor) integer(kind=c_int), public :: max_blocks_per_sm Maximum number of resident blocks per multiprocessor (cudaDeviceProp.maxBlocksPerMultiProcessor) integer(kind=c_size_t), public :: shared_mem_per_sm Shared memory per multiprocessor (cudaDeviceProp.sharedMemPerMultiprocessor) integer(kind=c_int), public :: max_threads_per_block Maximum number of threads per block (cudaDeviceProp.maxThreadsPerBlock) integer(kind=c_size_t), public :: shared_mem_per_block Shared memory available per block in bytes (cudaDeviceProp.sharedMemPerBlock) integer(kind=c_int), public :: l2_cache_size Size of L2 cache in bytes (cudaDeviceProp.l2CacheSize) integer(kind=c_int), public :: compute_capability_major Major compute capability (cudaDeviceProp.major) integer(kind=c_int), public :: compute_capability_minor Minor compute capability (cudaDeviceProp.minor)","tags":"","loc":"type/device_props.html"},{"title":"abstract_executor – dtFFT ","text":"type, public, abstract :: abstract_executor The “most” abstract executor.\nAll FFT executors are extending this class. Inherits type~~abstract_executor~~InheritsGraph type~abstract_executor abstract_executor c_ptr c_ptr type~abstract_executor->c_ptr plan_forward, plan_backward Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~abstract_executor~~InheritedByGraph type~abstract_executor abstract_executor type~cufft_executor cufft_executor type~cufft_executor->type~abstract_executor type~fft_executor fft_executor type~fft_executor->type~abstract_executor fft type~fftw_executor fftw_executor type~fftw_executor->type~abstract_executor type~mkl_executor mkl_executor type~mkl_executor->type~abstract_executor type~vkfft_executor vkfft_executor type~vkfft_executor->type~abstract_executor type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~fft_executor fft type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile logical, private :: is_created = .false. Is plan created? Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates FFT plan private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) procedure, public, non_overridable, pass(self) :: execute Executes plan private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform procedure, public, non_overridable, pass(self) :: destroy Destroys plan private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor procedure( mem_alloc_interface ), public, deferred, nopass :: mem_alloc Allocates aligned memory subroutine mem_alloc_interface(alloc_bytes, ptr) Prototype Allocates aligned memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer procedure( mem_free_interface ), public, deferred, nopass :: mem_free Frees aligned memory subroutine mem_free_interface(ptr) Prototype Frees aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free procedure( create_interface ), public, deferred, pass(self) :: create_private Creates FFT plan subroutine create_interface(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Prototype Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform procedure( execute_interface ), public, deferred, pass(self) :: execute_private Executes plan subroutine execute_interface(self, a, b, sign) Prototype Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform procedure( destroy_interface ), public, deferred, pass(self) :: destroy_private Destroys plan subroutine destroy_interface(self) Prototype Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor","tags":"","loc":"type/abstract_executor.html"},{"title":"transpose_handle_datatype – dtFFT ","text":"type, public, extends( abstract_transpose_handle ) :: transpose_handle_datatype Tranpose backend that uses MPI_Ialltoall(w) with custom MPI datatypes Inherits type~~transpose_handle_datatype~~InheritsGraph type~transpose_handle_datatype transpose_handle_datatype MPI_Comm MPI_Comm type~transpose_handle_datatype->MPI_Comm comm MPI_Request MPI_Request type~transpose_handle_datatype->MPI_Request requests type~abstract_transpose_handle abstract_transpose_handle type~transpose_handle_datatype->type~abstract_transpose_handle type~handle_t handle_t type~transpose_handle_datatype->type~handle_t send, recv MPI_Datatype MPI_Datatype type~handle_t->MPI_Datatype dtypes Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(MPI_Comm), private :: comm 1d communicator logical, private :: is_even = .false. Is decomposition even logical, private :: is_active = .false. Is async transposition active type( handle_t ), private :: send Handle to send data type( handle_t ), private :: recv Handle to recieve data type(MPI_Request), private, allocatable :: requests (:) Requests for communication integer(kind=int32), private :: n_requests Actual number of requests, can be less than size(requests) logical, private :: is_request_created = .false. Is request created Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates transpose handle private  subroutine create (self, send, recv, base_storage, kwargs) Creates transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract transpose handle type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil integer(kind=int64), intent(in) :: base_storage Base storage size type( create_args ), intent(inout) :: kwargs Additional arguments procedure, public, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(in) :: self Abstract Transpose Handle Return Value integer(kind=int64) procedure, public, pass(self) :: create_private => create Initializes class private  subroutine create (self, comm, send, recv, transpose_type, base_storage, kwargs) Creates transpose_handle_datatype class Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle type(MPI_Comm), intent(in) :: comm MPI Communicator type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Base storage type( create_args ), intent(in) :: kwargs Additional arguments procedure, public, pass(self) :: execute Performs MPI_Ialltoall(w) private  subroutine execute (self, in, out, kwargs, error_code) Executes transposition Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Result of execution procedure, public, pass(self) :: execute_end Waits for MPI_Ialltoall(w) to complete private  subroutine execute_end (self, kwargs, error_code) Ends execution of transposition Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code procedure, public, pass(self) :: destroy Destroys class private  subroutine destroy (self) Destroys transpose_handle_datatype class Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle procedure, public, pass(self) :: get_async_active Returns .true. if async transposition is active private elemental function get_async_active (self) Returns if async transpose is active Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(in) :: self Transpose handle Return Value logical","tags":"","loc":"type/transpose_handle_datatype.html"},{"title":"handle_t – dtFFT ","text":"type, private :: handle_t Transposition handle class Inherits type~~handle_t~~InheritsGraph type~handle_t handle_t MPI_Datatype MPI_Datatype type~handle_t->MPI_Datatype dtypes Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~handle_t~~InheritedByGraph type~handle_t handle_t type~transpose_handle_datatype transpose_handle_datatype type~transpose_handle_datatype->type~handle_t send, recv Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(MPI_Datatype), public, allocatable :: dtypes (:) Datatypes buffer integer(kind=int32), public, allocatable :: counts (:) Number of datatypes (always equals 1) integer(kind=int32), public, allocatable :: displs (:) Displacements is bytes Type-Bound Procedures procedure, public, pass(self) :: create => create_handle Creates transposition handle private  subroutine create_handle (self, n) Creates transposition handle Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle integer(kind=int32), intent(in) :: n Number of datatypes to be created procedure, public, pass(self) :: destroy => destroy_handle Destroys transposition handle private  subroutine destroy_handle (self) Destroys transposition handle Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle","tags":"","loc":"type/handle_t.html"},{"title":"create_args – dtFFT ","text":"type, public :: create_args Arguments for creating transpose handle Inherits type~~create_args~~InheritsGraph type~create_args create_args MPI_Datatype MPI_Datatype type~create_args->MPI_Datatype base_type type~backend_helper backend_helper type~create_args->type~backend_helper helper type~dtfft_backend_t dtfft_backend_t type~create_args->type~dtfft_backend_t backend type~dtfft_effort_t dtfft_effort_t type~create_args->type~dtfft_effort_t effort type~dtfft_platform_t dtfft_platform_t type~create_args->type~dtfft_platform_t platform MPI_Comm MPI_Comm type~backend_helper->MPI_Comm comms c_ptr c_ptr type~backend_helper->c_ptr nccl_register type~dtfft_transpose_t dtfft_transpose_t type~backend_helper->type~dtfft_transpose_t tranpose_type type~ncclcomm ncclComm type~backend_helper->type~ncclcomm nccl_comm type~pencil pencil type~backend_helper->type~pencil pencils type~ncclcomm->c_ptr member Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_platform_t ), public :: platform Platform type type( backend_helper ), public :: helper Backend helper type( dtfft_effort_t ), public :: effort Effort level for generating transpose kernels type( dtfft_backend_t ), public :: backend Backend type logical, public :: force_effort Should effort be forced or not type(MPI_Datatype), public :: base_type Base MPI Datatype integer(kind=int8), public :: datatype_id Type of datatype to use integer(kind=int8), public :: comm_id ID of communicator to use","tags":"","loc":"type/create_args.html"},{"title":"execute_args – dtFFT ","text":"type, public :: execute_args Arguments for executing transpose handle Inherits type~~execute_args~~InheritsGraph type~execute_args execute_args type~async_exec_t async_exec_t type~execute_args->type~async_exec_t exec_type type~dtfft_stream_t dtfft_stream_t type~execute_args->type~dtfft_stream_t stream c_ptr c_ptr type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_stream_t ), public :: stream Stream to execute on type( async_exec_t ), public :: exec_type Async execution type real(kind=real32), public, pointer :: p1 (:) aux pointer for pipelined operations, in pointer for execute_end real(kind=real32), public, pointer :: p2 (:) out pointer for execute_end","tags":"","loc":"type/execute_args.html"},{"title":"abstract_transpose_handle – dtFFT ","text":"type, public, abstract :: abstract_transpose_handle Abstract transpose handle type Inherited by type~~abstract_transpose_handle~~InheritedByGraph type~abstract_transpose_handle abstract_transpose_handle type~plan_t plan_t type~plan_t->type~abstract_transpose_handle p type~transpose_handle_datatype transpose_handle_datatype type~transpose_handle_datatype->type~abstract_transpose_handle type~transpose_handle_generic transpose_handle_generic type~transpose_handle_generic->type~abstract_transpose_handle type~transpose_plan transpose_plan type~transpose_plan->type~plan_t plans type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~transpose_plan plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates transpose handle private  subroutine create (self, send, recv, base_storage, kwargs) Creates transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract transpose handle type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil integer(kind=int64), intent(in) :: base_storage Base storage size type( create_args ), intent(inout) :: kwargs Additional arguments procedure, public, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(in) :: self Abstract Transpose Handle Return Value integer(kind=int64) procedure( create_interface ), public, deferred :: create_private Creates transpose handle subroutine create_interface(self, comm, send, recv, transpose_type, base_storage, kwargs) Prototype Creates transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract transpose handle type(MPI_Comm), intent(in) :: comm MPI Communicator type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Base storage type( create_args ), intent(in) :: kwargs Additional arguments procedure( execute_interface ), public, deferred :: execute Executes transpose handle subroutine execute_interface(self, in, out, kwargs, error_code) Prototype Executes transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract Transpose Handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code procedure( execute_end_interface ), public, deferred :: execute_end Finishes async transpose subroutine execute_end_interface(self, kwargs, error_code) Prototype Finishes async transpose Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract Transpose Handle type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code procedure( destroy_interface ), public, deferred :: destroy Destroys transpose handle subroutine destroy_interface(self) Prototype Destroys transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract Transpose Handle procedure( get_async_active_interface ), public, deferred :: get_async_active Returns if async transpose is active elemental function get_async_active_interface(self) Prototype Returns if async transpose is active Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(in) :: self Abstract Transpose Handle Return Value logical","tags":"","loc":"type/abstract_transpose_handle.html"},{"title":"backend_cufftmp – dtFFT ","text":"type, public, extends( abstract_backend ) :: backend_cufftmp cuFFTMp GPU Backend Inherits type~~backend_cufftmp~~InheritsGraph type~backend_cufftmp backend_cufftmp type~abstract_backend abstract_backend type~backend_cufftmp->type~abstract_backend type~cufftreshapehandle cufftReshapeHandle type~backend_cufftmp->type~cufftreshapehandle plan MPI_Comm MPI_Comm type~abstract_backend->MPI_Comm comm type~abstract_kernel abstract_kernel type~abstract_backend->type~abstract_kernel unpack_kernel type~cudaevent cudaEvent type~abstract_backend->type~cudaevent execution_event, copy_event type~dtfft_backend_t dtfft_backend_t type~abstract_backend->type~dtfft_backend_t backend type~dtfft_platform_t dtfft_platform_t type~abstract_backend->type~dtfft_platform_t platform type~dtfft_stream_t dtfft_stream_t type~abstract_backend->type~dtfft_stream_t copy_stream c_ptr c_ptr type~cufftreshapehandle->c_ptr cptr type~kernel_type_t kernel_type_t type~abstract_kernel->type~kernel_type_t kernel_type type~cudaevent->c_ptr event type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type type( dtfft_platform_t ), public :: platform Platform to use logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer class( abstract_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( cufftReshapeHandle ), private :: plan Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create Creates Abstract Backend private  subroutine create (self, backend, helper, platform, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend type( dtfft_backend_t ), intent(in) :: backend Backend type type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_platform_t ), intent(in) :: platform Platform to use integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public, non_overridable, pass(self) :: execute Executes Backend private  subroutine execute (self, in, out, stream, aux, exec_type, error_code) Executes Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code procedure, public, non_overridable, pass(self) :: destroy Destroys Abstract Backend private  subroutine destroy (self) Destroys Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend procedure, public, non_overridable, pass(self) :: get_aux_size Returns number of bytes required by aux buffer private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value integer(kind=int64) procedure, public, non_overridable, pass(self) :: set_unpack_kernel Sets unpack kernel for pipelined backend private  subroutine set_unpack_kernel (self, unpack_kernel) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend class( abstract_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data procedure, public, pass(self) :: execute_end Ends execution of Backend private  subroutine execute_end (self, error_code) Ends execution of Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend integer(kind=int32), intent(out) :: error_code Error code procedure, public, pass(self) :: get_async_active Returns if async execution is active private elemental function get_async_active (self) Returns if async execution is active Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value logical procedure, public :: create_private => create private  subroutine create (self, helper, base_storage) Creates cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element procedure, public :: execute_private => execute private  subroutine execute (self, in, out, stream, aux, exec_type, error_code) Executes cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code procedure, public :: destroy_private => destroy private  subroutine destroy (self) Destroys cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend","tags":"","loc":"type/backend_cufftmp.html"},{"title":"Box3D – dtFFT ","text":"type, private :: Box3D cuFFTMp Box Components Type Visibility Attributes Name Initial integer(kind=c_long_long), public :: lower (3) Lower box boundaries integer(kind=c_long_long), public :: upper (3) Upper box boundaries integer(kind=c_long_long), public :: strides (3) Strides in memory","tags":"","loc":"type/box3d.html"},{"title":"dtfft_execute_t – dtFFT ","text":"type, public, bind(C) :: dtfft_execute_t Type that is used during call to execute method Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_execute_t.html"},{"title":"dtfft_transpose_t – dtFFT ","text":"type, public, bind(C) :: dtfft_transpose_t Type that is used during call to transpose method Inherited by type~~dtfft_transpose_t~~InheritedByGraph type~dtfft_transpose_t dtfft_transpose_t type~backend_helper backend_helper type~backend_helper->type~dtfft_transpose_t tranpose_type type~transpose_request transpose_request type~transpose_request->type~dtfft_transpose_t transpose_type type~create_args create_args type~create_args->type~backend_helper helper type~transpose_plan transpose_plan type~transpose_plan->type~backend_helper helper type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~transpose_plan plan type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_transpose_t.html"},{"title":"dtfft_executor_t – dtFFT ","text":"type, public, bind(C) :: dtfft_executor_t Type that specifies external FFT executor Inherited by type~~dtfft_executor_t~~InheritedByGraph type~dtfft_executor_t dtfft_executor_t type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_executor_t executor type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_executor_t.html"},{"title":"dtfft_effort_t – dtFFT ","text":"type, public, bind(C) :: dtfft_effort_t Type that specifies effort that dtFFT should use when creating plan Inherited by type~~dtfft_effort_t~~InheritedByGraph type~dtfft_effort_t dtfft_effort_t type~create_args create_args type~create_args->type~dtfft_effort_t effort type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_effort_t effort type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_effort_t.html"},{"title":"dtfft_precision_t – dtFFT ","text":"type, public, bind(C) :: dtfft_precision_t Type that specifies precision of dtFFT plan Inherited by type~~dtfft_precision_t~~InheritedByGraph type~dtfft_precision_t dtfft_precision_t type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_precision_t precision type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_precision_t.html"},{"title":"dtfft_r2r_kind_t – dtFFT ","text":"type, public, bind(C) :: dtfft_r2r_kind_t Type that specifies various kinds of R2R FFTs Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_r2r_kind_t.html"},{"title":"dtfft_backend_t – dtFFT ","text":"type, public, bind(C) :: dtfft_backend_t Type that specifies various backends present in dtFFT Inherited by type~~dtfft_backend_t~~InheritedByGraph type~dtfft_backend_t dtfft_backend_t type~abstract_backend abstract_backend type~abstract_backend->type~dtfft_backend_t backend type~create_args create_args type~create_args->type~dtfft_backend_t backend type~dtfft_config_t dtfft_config_t type~dtfft_config_t->type~dtfft_backend_t backend type~transpose_plan transpose_plan type~transpose_plan->type~dtfft_backend_t backend type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~transpose_plan plan type~transpose_handle_generic transpose_handle_generic type~transpose_handle_generic->type~abstract_backend comm_handle type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_backend_t.html"},{"title":"dtfft_stream_t – dtFFT ","text":"type, public, bind(C) :: dtfft_stream_t dtFFT stream representation. Inherits type~~dtfft_stream_t~~InheritsGraph type~dtfft_stream_t dtfft_stream_t c_ptr c_ptr type~dtfft_stream_t->c_ptr stream Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~dtfft_stream_t~~InheritedByGraph type~dtfft_stream_t dtfft_stream_t type~abstract_backend abstract_backend type~abstract_backend->type~dtfft_stream_t copy_stream type~dtfft_config_t dtfft_config_t type~dtfft_config_t->type~dtfft_stream_t stream type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_stream_t stream type~transpose_plan transpose_plan type~dtfft_plan_t->type~transpose_plan plan type~execute_args execute_args type~execute_args->type~dtfft_stream_t stream type~transpose_plan->type~dtfft_stream_t stream type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~transpose_handle_generic transpose_handle_generic type~transpose_handle_generic->type~abstract_backend comm_handle type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: stream Actual stream Constructor public        interface dtfft_stream_t Creates dtfft_stream_t from integer(cuda_stream_kind) private  function stream_from_int64 (cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream","tags":"","loc":"type/dtfft_stream_t.html"},{"title":"dtfft_platform_t – dtFFT ","text":"type, public, bind(C) :: dtfft_platform_t Type that specifies runtime platform, e.g. Host, CUDA, HIP Inherited by type~~dtfft_platform_t~~InheritedByGraph type~dtfft_platform_t dtfft_platform_t type~abstract_backend abstract_backend type~abstract_backend->type~dtfft_platform_t platform type~create_args create_args type~create_args->type~dtfft_platform_t platform type~dtfft_config_t dtfft_config_t type~dtfft_config_t->type~dtfft_platform_t platform type~dtfft_plan_t dtfft_plan_t type~dtfft_plan_t->type~dtfft_platform_t platform type~transpose_plan transpose_plan type~dtfft_plan_t->type~transpose_plan plan type~transpose_plan->type~dtfft_platform_t platform type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend type~dtfft_core_c2c dtfft_core_c2c type~dtfft_core_c2c->type~dtfft_plan_t type~dtfft_plan_r2r_t dtfft_plan_r2r_t type~dtfft_plan_r2r_t->type~dtfft_plan_t type~plan_c plan_c type~plan_c->type~dtfft_plan_t p type~transpose_handle_generic transpose_handle_generic type~transpose_handle_generic->type~abstract_backend comm_handle type~dtfft_plan_c2c_t dtfft_plan_c2c_t type~dtfft_plan_c2c_t->type~dtfft_core_c2c type~dtfft_plan_r2c_t dtfft_plan_r2c_t type~dtfft_plan_r2c_t->type~dtfft_core_c2c Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value","tags":"","loc":"type/dtfft_platform_t.html"},{"title":"dtfft_request_t – dtFFT ","text":"type, public, bind(C) :: dtfft_request_t Inherits type~~dtfft_request_t~~InheritsGraph type~dtfft_request_t dtfft_request_t c_ptr c_ptr type~dtfft_request_t->c_ptr val Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(c_ptr), public :: val = c_null_ptr","tags":"","loc":"type/dtfft_request_t.html"},{"title":"async_exec_t – dtFFT ","text":"type, public :: async_exec_t Inherited by type~~async_exec_t~~InheritedByGraph type~async_exec_t async_exec_t type~execute_args execute_args type~execute_args->type~async_exec_t exec_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: val","tags":"","loc":"type/async_exec_t.html"},{"title":"kernel_type_t – dtFFT ","text":"type, public :: kernel_type_t nvRTC Kernel type Inherited by type~~kernel_type_t~~InheritedByGraph type~kernel_type_t kernel_type_t type~abstract_kernel abstract_kernel type~abstract_kernel->type~kernel_type_t kernel_type type~kernel_device kernel_device type~kernel_device->type~kernel_type_t internal_kernel_type type~kernel_device->type~abstract_kernel type~nvrtc_module nvrtc_module type~nvrtc_module->type~kernel_type_t kernel_type type~abstract_backend abstract_backend type~abstract_backend->type~abstract_kernel unpack_kernel type~kernel_host kernel_host type~kernel_host->type~abstract_kernel type~nvrtc_module_cache nvrtc_module_cache type~nvrtc_module_cache->type~nvrtc_module cache type~transpose_handle_generic transpose_handle_generic type~transpose_handle_generic->type~abstract_kernel transpose_kernel, unpack_kernel type~transpose_handle_generic->type~abstract_backend comm_handle type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: val","tags":"","loc":"type/kernel_type_t.html"},{"title":"abstract_kernel – dtFFT ","text":"type, public, abstract :: abstract_kernel Abstract kernel type This kernel type is used in transpose_handle_generic type and\nis resposible for packing/unpacking/permute operations. Inherits type~~abstract_kernel~~InheritsGraph type~abstract_kernel abstract_kernel type~kernel_type_t kernel_type_t type~abstract_kernel->type~kernel_type_t kernel_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~abstract_kernel~~InheritedByGraph type~abstract_kernel abstract_kernel type~abstract_backend abstract_backend type~abstract_backend->type~abstract_kernel unpack_kernel type~kernel_device kernel_device type~kernel_device->type~abstract_kernel type~kernel_host kernel_host type~kernel_host->type~abstract_kernel type~transpose_handle_generic transpose_handle_generic type~transpose_handle_generic->type~abstract_kernel transpose_kernel, unpack_kernel type~transpose_handle_generic->type~abstract_backend comm_handle type~backend_cufftmp backend_cufftmp type~backend_cufftmp->type~abstract_backend type~backend_mpi backend_mpi type~backend_mpi->type~abstract_backend type~backend_nccl backend_nccl type~backend_nccl->type~abstract_backend Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: is_created = .false. Kernel is created flag. logical, public :: is_dummy = .false. If kernel should do anything or not. type( kernel_type_t ), public :: kernel_type Type of the kernel character(len=:), public, allocatable :: kernel_string integer(kind=int32), public, allocatable :: neighbor_data (:,:) Neighbor data for pipelined unpacking integer(kind=int32), public, allocatable :: dims (:) Local dimensions to process Type-Bound Procedures procedure, public, pass(self) :: create Creates kernel private  subroutine create (self, dims, effort, base_storage, kernel_type, neighbor_data, force_effort) Creates kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel integer(kind=int32), intent(in) :: dims (:) Local dimensions to process type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int32), intent(in), optional :: neighbor_data (:,:) Optional pointers for unpack kernels logical, intent(in), optional :: force_effort Should effort be forced or not procedure, public, pass(self) :: execute Executes kernel private  subroutine execute (self, in, out, stream, neighbor) Executes kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel real(kind=real32), intent(in) :: in (:) Source buffer, can be device or host pointer real(kind=real32), intent(inout) :: out (:) Target buffer, can be device or host pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, used only for device pointers integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking procedure, public, pass(self) :: destroy Destroys kernel private  subroutine destroy (self) Destroys kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel procedure( create_interface ), public, deferred :: create_private Creates underlying kernel subroutine create_interface(self, effort, base_storage, force_effort) Prototype Creates underlying kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in), optional :: force_effort Should effort be forced or not procedure( execute_interface ), public, deferred :: execute_private Executes underlying kernel subroutine execute_interface(self, in, out, stream, neighbor) Prototype Executes underlying kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel real(kind=real32), intent(in), target :: in (:) Source buffer, can be device or host pointer real(kind=real32), intent(inout), target :: out (:) Target buffer, can be device or host pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, used only for device pointers integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking procedure( destroy_interface ), public, deferred :: destroy_private Destroys underlying kernel subroutine destroy_interface(self) Prototype Destroys underlying kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel","tags":"","loc":"type/abstract_kernel.html"},{"title":"create_interface – dtFFT","text":"interface private  subroutine create_interface(self, helper, base_storage) Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element Description Creates overriding class","tags":"","loc":"interface/create_interface.html"},{"title":"execute_interface – dtFFT","text":"interface private  subroutine execute_interface(self, in, out, stream, aux, exec_type, error_code) Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code Description Executes Backend","tags":"","loc":"interface/execute_interface.html"},{"title":"destroy_interface – dtFFT","text":"interface private  subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend Description Destroys overriding class","tags":"","loc":"interface/destroy_interface.html"},{"title":"create_c2c_plan – dtFFT","text":"interface private  function create_c2c_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2C FFTW3 Plan","tags":"","loc":"interface/create_c2c_plan.html"},{"title":"create_r2c_plan – dtFFT","text":"interface private  function create_r2c_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2C FFTW3 Plan","tags":"","loc":"interface/create_r2c_plan.html"},{"title":"create_r2r_plan – dtFFT","text":"interface private  function create_r2r_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kinds, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kinds (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2R FFTW3 Plan","tags":"","loc":"interface/create_r2r_plan.html"},{"title":"apply_interface – dtFFT","text":"interface private  subroutine apply_interface(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes FFTW3 Plan","tags":"","loc":"interface/apply_interface.html"},{"title":"free_interface – dtFFT","text":"interface private  subroutine free_interface(plan) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Description Destroys FFTW3 Plan","tags":"","loc":"interface/free_interface.html"},{"title":"vkfft_create_interface – dtFFT","text":"interface private  subroutine vkfft_create_interface(rank, dims, double_precision, how_many, r2c, c2r, dct, dst, stream, app_handle) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), value :: rank Rank of fft: 1 or 2 integer(kind=c_int) :: dims (*) Dimensions of transform integer(kind=c_int), value :: double_precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=c_int), value :: how_many Number of transforms to create integer(kind=c_int8_t), value :: r2c Is R2C transform required integer(kind=c_int8_t), value :: c2r Is C2R transform required integer(kind=c_int8_t), value :: dct Is DCT transform required integer(kind=c_int8_t), value :: dst Is DST transform required type( dtfft_stream_t ), value :: stream CUDA stream type(c_ptr) :: app_handle vkFFT application handle Description Creates FFT plan via vkFFT Interface","tags":"","loc":"interface/vkfft_create_interface.html"},{"title":"vkfft_execute_interface – dtFFT","text":"interface private  subroutine vkfft_execute_interface(app_handle, in, out, sign) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: app_handle vkFFT application handle type(c_ptr), value :: in Input data type(c_ptr), value :: out Output data integer(kind=c_int8_t), value :: sign Sign of FFT Description Executes vkFFT plan","tags":"","loc":"interface/vkfft_execute_interface.html"},{"title":"vkfft_destroy_interface – dtFFT","text":"interface private  subroutine vkfft_destroy_interface(app_handle) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: app_handle vkFFT application handle Description Destroys vkFFT plan","tags":"","loc":"interface/vkfft_destroy_interface.html"},{"title":"nvrtcGetErrorString_interface – dtFFT","text":"interface private  function nvrtcGetErrorString_interface(error_code) result(string) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: error_code CUDA Runtime Compilation API result code. Return Value type(c_ptr) Pointer to C string Description Helper function that returns a string describing the given nvrtcResult code\nFor unrecognized enumeration values, it returns “NVRTC_ERROR unknown”","tags":"","loc":"interface/nvrtcgeterrorstring_interface.html"},{"title":"nvrtcCreateProgram_interface – dtFFT","text":"interface private  function nvrtcCreateProgram_interface(prog, src, name, numHeaders, headers, includeNames) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ) :: prog CUDA Runtime Compilation program. character(len=c_char) :: src (*) CUDA program source. character(len=c_char) :: name (*) CUDA program name. integer(kind=c_int), value :: numHeaders Number of headers used. Must be greater than or equal to 0. type(c_ptr), value :: headers Sources of the headers type(c_ptr), value :: includeNames Name of each header by which they can be included in the CUDA program source Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Creates an instance of nvrtcProgram with the given input parameters, \nand sets the output parameter prog with it.","tags":"","loc":"interface/nvrtccreateprogram_interface.html"},{"title":"nvrtcDestroyProgram_interface – dtFFT","text":"interface private  function nvrtcDestroyProgram_interface(prog) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ) :: prog CUDA Runtime Compilation program. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Destroys the given program.","tags":"","loc":"interface/nvrtcdestroyprogram_interface.html"},{"title":"nvrtcCompileProgram_interface – dtFFT","text":"interface private  function nvrtcCompileProgram_interface(prog, numOptions, options) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_int), value :: numOptions Number of compiler options passed. type(c_ptr) :: options (*) Compiler options in the form of C string array Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Compiles the given program.","tags":"","loc":"interface/nvrtccompileprogram_interface.html"},{"title":"nvrtcGetProgramLogSize_interface – dtFFT","text":"interface private  function nvrtcGetProgramLogSize_interface(prog, logSizeRet) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_size_t) :: logSizeRet Size of the compilation log. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Sets the value of logSizeRet with the size of the log generated by the previous compilation of prog .\nThe log is a null-terminated string.","tags":"","loc":"interface/nvrtcgetprogramlogsize_interface.html"},{"title":"nvrtcGetProgramLog_interface – dtFFT","text":"interface private  function nvrtcGetProgramLog_interface(prog, log) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. type(c_ptr), value :: log Compilation log. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Stores the log generated by the previous compilation of prog in the memory pointed by log","tags":"","loc":"interface/nvrtcgetprogramlog_interface.html"},{"title":"nvrtcGetCUBINSize_interface – dtFFT","text":"interface private  function nvrtcGetCUBINSize_interface(prog, cubinSizeRet) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_size_t) :: cubinSizeRet Size of the generated cubin. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Sets the value of cubinSizeRet with the size of the cubin generated by the previous compilation of prog .","tags":"","loc":"interface/nvrtcgetcubinsize_interface.html"},{"title":"nvrtcGetCUBIN_interface – dtFFT","text":"interface private  function nvrtcGetCUBIN_interface(prog, cubin) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. type(c_ptr), value :: cubin Compiled and assembled result. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Stores the cubin generated by the previous compilation of prog in the memory pointed by cubin .","tags":"","loc":"interface/nvrtcgetcubin_interface.html"},{"title":"nvrtcGetLoweredName_interface – dtFFT","text":"interface private  function nvrtcGetLoweredName_interface(prog, name_expression, lowered_name) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. character(len=c_char) :: name_expression (*) Name expression. type(c_ptr) :: lowered_name Mangled name. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Extracts the lowered (mangled) name for a global function or device/ constant variable, \nand updates *lowered_name to point to it.","tags":"","loc":"interface/nvrtcgetloweredname_interface.html"},{"title":"nvrtcAddNameExpression_interface – dtFFT","text":"interface private  function nvrtcAddNameExpression_interface(prog, name_expression) result(nvrtcResult) Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. character(len=c_char) :: name_expression (*) Name expression. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Description Notes the given name expression denoting the address of a global function or device/ constant variable.","tags":"","loc":"interface/nvrtcaddnameexpression_interface.html"},{"title":"cuModuleLoadData_interface – dtFFT","text":"interface private  function cuModuleLoadData_interface(mod, image) result(cuResult) Arguments Type Intent Optional Attributes Name type( CUmodule ) :: mod Returned module type(c_ptr), value :: image Module data to load Return Value integer(kind=c_int) Driver result code Description Load a module’s data with options. Takes a pointer image and loads the corresponding module module into the current context. \nThe image may be a cubin or fatbin as output by nvcc, or a NULL-terminated PTX, either as output by nvcc or hand-written.","tags":"","loc":"interface/cumoduleloaddata_interface.html"},{"title":"cuModuleUnload_interface – dtFFT","text":"interface private  function cuModuleUnload_interface(hmod) result(cuResult) Arguments Type Intent Optional Attributes Name type( CUmodule ), value :: hmod Module to unload Return Value integer(kind=c_int) Driver result code Description Unloads a module. Unloads a module hmod from the current context. \nAttempting to unload a module which was obtained from the Library Management API \nsuch as cuLibraryGetModule will return CUDA_ERROR_NOT_PERMITTED .","tags":"","loc":"interface/cumoduleunload_interface.html"},{"title":"cuModuleGetFunction_interface – dtFFT","text":"interface private  function cuModuleGetFunction_interface(hfunc, hmod, name) result(cuResult) Arguments Type Intent Optional Attributes Name type( CUfunction ) :: hfunc Returns a function handle. type( CUmodule ), value :: hmod Module to retrieve function from type(c_ptr), value :: name Name of function to retrieve Return Value integer(kind=c_int) Driver result code Description Returns a function handle. Returns in hfunc the handle of the function of name name located in module hmod.\nIf no function of that name exists, cuModuleGetFunction returns CUDA_ERROR_NOT_FOUND .","tags":"","loc":"interface/cumodulegetfunction_interface.html"},{"title":"cuLaunchKernel_interface – dtFFT","text":"interface private  function cuLaunchKernel_interface(func, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, stream, kernelParams, extra) result(cuResult) Arguments Type Intent Optional Attributes Name type( CUfunction ), value :: func CUDA function to launch integer(kind=c_int), value :: gridDimX Grid dimensions in X integer(kind=c_int), value :: gridDimY Grid dimensions in Y integer(kind=c_int), value :: gridDimZ Grid dimensions in Z integer(kind=c_int), value :: blockDimX Block dimensions in X integer(kind=c_int), value :: blockDimY Block dimensions in Y integer(kind=c_int), value :: blockDimZ Block dimensions in Z integer(kind=c_int), value :: sharedMemBytes Dynamic shared memory size type( dtfft_stream_t ), value :: stream Stream identifier type(c_ptr) :: kernelParams (*) Array of pointers to kernel parameters type(c_ptr) :: extra Dynamic shared-memory size per thread block in bytes Return Value integer(kind=c_int) Driver result code Description Launches a CUDA function CUfunction.","tags":"","loc":"interface/culaunchkernel_interface.html"},{"title":"create_interface – dtFFT","text":"interface private  subroutine create_interface(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Description Creates FFT plan","tags":"","loc":"interface/create_interface~2.html"},{"title":"execute_interface – dtFFT","text":"interface private  subroutine execute_interface(self, a, b, sign) Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform Description Executes plan","tags":"","loc":"interface/execute_interface~2.html"},{"title":"destroy_interface – dtFFT","text":"interface private  subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor Description Destroys plan","tags":"","loc":"interface/destroy_interface~2.html"},{"title":"mem_alloc_interface – dtFFT","text":"interface private  subroutine mem_alloc_interface(alloc_bytes, ptr) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer Description Allocates aligned memory","tags":"","loc":"interface/mem_alloc_interface.html"},{"title":"mem_free_interface – dtFFT","text":"interface private  subroutine mem_free_interface(ptr) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free Description Frees aligned memory","tags":"","loc":"interface/mem_free_interface.html"},{"title":"get_async_active_interface – dtFFT","text":"interface private elemental function get_async_active_interface(self) Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(in) :: self Abstract Transpose Handle Return Value logical Description Returns if async transpose is active","tags":"","loc":"interface/get_async_active_interface.html"},{"title":"create_interface – dtFFT","text":"interface private  subroutine create_interface(self, comm, send, recv, transpose_type, base_storage, kwargs) Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract transpose handle type(MPI_Comm), intent(in) :: comm MPI Communicator type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Base storage type( create_args ), intent(in) :: kwargs Additional arguments Description Creates transpose handle","tags":"","loc":"interface/create_interface~3.html"},{"title":"execute_interface – dtFFT","text":"interface private  subroutine execute_interface(self, in, out, kwargs, error_code) Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract Transpose Handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code Description Executes transpose handle","tags":"","loc":"interface/execute_interface~3.html"},{"title":"execute_end_interface – dtFFT","text":"interface private  subroutine execute_end_interface(self, kwargs, error_code) Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract Transpose Handle type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code Description Finishes async transpose","tags":"","loc":"interface/execute_end_interface.html"},{"title":"destroy_interface – dtFFT","text":"interface private  subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract Transpose Handle Description Destroys transpose handle","tags":"","loc":"interface/destroy_interface~3.html"},{"title":"create_interface – dtFFT","text":"interface private  subroutine create_interface(self, effort, base_storage, force_effort) Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in), optional :: force_effort Should effort be forced or not Description Creates underlying kernel","tags":"","loc":"interface/create_interface~4.html"},{"title":"execute_interface – dtFFT","text":"interface private  subroutine execute_interface(self, in, out, stream, neighbor) Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel real(kind=real32), intent(in), target :: in (:) Source buffer, can be device or host pointer real(kind=real32), intent(inout), target :: out (:) Target buffer, can be device or host pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, used only for device pointers integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking Description Executes underlying kernel","tags":"","loc":"interface/execute_interface~4.html"},{"title":"destroy_interface – dtFFT","text":"interface private  subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel Description Destroys underlying kernel","tags":"","loc":"interface/destroy_interface~4.html"},{"title":"get_async_active – dtFFT","text":"private elemental function get_async_active(self) Returns if async execution is active Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value logical Called by proc~~get_async_active~~CalledByGraph proc~get_async_active abstract_backend%get_async_active proc~get_async_active~3 transpose_handle_generic%get_async_active proc~get_async_active~3->proc~get_async_active Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_async_active.html"},{"title":"get_aux_size – dtFFT","text":"private pure function get_aux_size(self) Returns number of bytes required by aux buffer Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value integer(kind=int64) Called by proc~~get_aux_size~~CalledByGraph proc~get_aux_size abstract_backend%get_aux_size proc~get_aux_size~3 transpose_handle_generic%get_aux_size proc~get_aux_size~3->proc~get_aux_size Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_aux_size.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, backend, helper, platform, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Uses iso_fortran_env iso_c_binding proc~~create~~UsesGraph proc~create abstract_backend%create iso_c_binding iso_c_binding proc~create->iso_c_binding iso_fortran_env iso_fortran_env proc~create->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates Abstract Backend Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend type( dtfft_backend_t ), intent(in) :: backend Backend type type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_platform_t ), intent(in) :: platform Platform to use integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element Calls proc~~create~~CallsGraph proc~create abstract_backend%create create_private create_private proc~create->create_private fname fname proc~create->fname interface~cudaeventcreatewithflags cudaEventCreateWithFlags proc~create->interface~cudaeventcreatewithflags interface~cudastreamcreate cudaStreamCreate proc~create->interface~cudastreamcreate mpi_abort mpi_abort proc~create->mpi_abort mpi_comm_rank mpi_comm_rank proc~create->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create->mpi_comm_size proc~cudageterrorstring cudaGetErrorString proc~create->proc~cudageterrorstring proc~is_backend_mpi is_backend_mpi proc~create->proc~is_backend_mpi proc~is_backend_pipelined is_backend_pipelined proc~create->proc~is_backend_pipelined interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, stream, aux, exec_type, error_code) Uses iso_fortran_env iso_c_binding proc~~execute~~UsesGraph proc~execute abstract_backend%execute iso_c_binding iso_c_binding proc~execute->iso_c_binding iso_fortran_env iso_fortran_env proc~execute->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes Backend Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code Calls proc~~execute~~CallsGraph proc~execute abstract_backend%execute execute_private execute_private proc~execute->execute_private fname fname proc~execute->fname interface~cudaeventrecord cudaEventRecord proc~execute->interface~cudaeventrecord interface~cudamemcpyasync cudaMemcpyAsync proc~execute->interface~cudamemcpyasync interface~cudastreamsynchronize cudaStreamSynchronize proc~execute->interface~cudastreamsynchronize interface~cudastreamwaitevent cudaStreamWaitEvent proc~execute->interface~cudastreamwaitevent mpi_abort mpi_abort proc~execute->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~execute->proc~cudageterrorstring proc~execute_end abstract_backend%execute_end proc~execute->proc~execute_end proc~execute~13 abstract_kernel%execute proc~execute->proc~execute~13 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~execute~13->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~13->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~13->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute.html"},{"title":"execute_end – dtFFT","text":"private  subroutine execute_end(self, error_code) Ends execution of Backend Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend integer(kind=int32), intent(out) :: error_code Error code Called by proc~~execute_end~~CalledByGraph proc~execute_end abstract_backend%execute_end proc~execute abstract_backend%execute proc~execute->proc~execute_end proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute_end Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_end.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Uses iso_fortran_env iso_c_binding proc~~destroy~~UsesGraph proc~destroy abstract_backend%destroy iso_c_binding iso_c_binding proc~destroy->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys Abstract Backend Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend Calls proc~~destroy~~CallsGraph proc~destroy abstract_backend%destroy destroy_private destroy_private proc~destroy->destroy_private fname fname proc~destroy->fname interface~cudaeventdestroy cudaEventDestroy proc~destroy->interface~cudaeventdestroy interface~cudastreamdestroy cudaStreamDestroy proc~destroy->interface~cudastreamdestroy mpi_abort mpi_abort proc~destroy->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy->proc~cudageterrorstring interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy.html"},{"title":"set_unpack_kernel – dtFFT","text":"private  subroutine set_unpack_kernel(self, unpack_kernel) Sets unpack kernel for pipelined backend Type Bound abstract_backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend class( abstract_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data Called by proc~~set_unpack_kernel~~CalledByGraph proc~set_unpack_kernel abstract_backend%set_unpack_kernel proc~create~7 transpose_handle_generic%create proc~create~7->proc~set_unpack_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_unpack_kernel.html"},{"title":"create_helper – dtFFT","text":"private  subroutine create_helper(self, platform, base_comm, comms, is_nccl_needed, pencils) Uses iso_fortran_env iso_c_binding proc~~create_helper~~UsesGraph proc~create_helper backend_helper%create_helper iso_c_binding iso_c_binding proc~create_helper->iso_c_binding iso_fortran_env iso_fortran_env proc~create_helper->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates helper Type Bound backend_helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper type( dtfft_platform_t ), intent(in) :: platform Platform to use type(MPI_Comm), intent(in) :: base_comm MPI communicator type(MPI_Comm), intent(in) :: comms (:) 1D Communicators logical, intent(in) :: is_nccl_needed If nccl communicator will be needed type( pencil ), intent(in), target :: pencils (:) Pencils Calls proc~~create_helper~~CallsGraph proc~create_helper backend_helper%create_helper fname fname proc~create_helper->fname interface~get_env get_env proc~create_helper->interface~get_env interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid mpi_abort mpi_abort proc~create_helper->mpi_abort mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast mpi_comm_rank mpi_comm_rank proc~create_helper->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_helper->mpi_comm_size proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~ncclgeterrorstring ncclGetErrorString proc~create_helper->proc~ncclgeterrorstring proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_helper->fname proc~destroy_helper->mpi_abort proc~destroy_helper->proc~ncclgeterrorstring interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy proc~write_message write_message proc~destroy_helper->proc~write_message interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_helper~~CalledByGraph proc~create_helper backend_helper%create_helper proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_helper.html"},{"title":"destroy_helper – dtFFT","text":"private  subroutine destroy_helper(self) Uses iso_fortran_env iso_c_binding proc~~destroy_helper~~UsesGraph proc~destroy_helper backend_helper%destroy_helper iso_c_binding iso_c_binding proc~destroy_helper->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy_helper->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys helper Type Bound backend_helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper Calls proc~~destroy_helper~~CallsGraph proc~destroy_helper backend_helper%destroy_helper fname fname proc~destroy_helper->fname interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy mpi_abort mpi_abort proc~destroy_helper->mpi_abort proc~ncclgeterrorstring ncclGetErrorString proc~destroy_helper->proc~ncclgeterrorstring proc~write_message write_message proc~destroy_helper->proc~write_message interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_helper~~CalledByGraph proc~destroy_helper backend_helper%destroy_helper proc~create_helper backend_helper%create_helper proc~create_helper->proc~destroy_helper proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~destroy_helper proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~destroy_helper proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_helper.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via FFTW3 Interface Type Bound fftw_executor Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Calls proc~~create~2~~CallsGraph proc~create~2 fftw_executor%create constructor constructor proc~create~2->constructor constructor_inverse constructor_inverse proc~create~2->constructor_inverse inverse_kinds inverse_kinds proc~create~2->inverse_kinds knds knds proc~create~2->knds proc~get_inverse_kind get_inverse_kind proc~create~2->proc~get_inverse_kind proc~mem_alloc fftw_executor%mem_alloc proc~create~2->proc~mem_alloc proc~mem_free fftw_executor%mem_free proc~create~2->proc~mem_free fftw_malloc fftw_malloc proc~mem_alloc->fftw_malloc fftw_free fftw_free proc~mem_free->fftw_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~2.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, a, b, sign) Executes FFTW3 plan Type Bound fftw_executor Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(in) :: self FFTW FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform","tags":"","loc":"proc/execute~2.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys FFTW3 plan Type Bound fftw_executor Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor","tags":"","loc":"proc/destroy~2.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(alloc_bytes, ptr) Allocates FFTW3 memory Type Bound fftw_executor Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer Calls proc~~mem_alloc~~CallsGraph proc~mem_alloc fftw_executor%mem_alloc fftw_malloc fftw_malloc proc~mem_alloc->fftw_malloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mem_alloc~~CalledByGraph proc~mem_alloc fftw_executor%mem_alloc proc~create~2 fftw_executor%create proc~create~2->proc~mem_alloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(ptr) Frees FFTW3 aligned memory Type Bound fftw_executor Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free Calls proc~~mem_free~~CallsGraph proc~mem_free fftw_executor%mem_free fftw_free fftw_free proc~mem_free->fftw_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mem_free~~CalledByGraph proc~mem_free fftw_executor%mem_free proc~create~2 fftw_executor%create proc~create~2->proc~mem_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free.html"},{"title":"get – dtFFT","text":"private  function get(self, ndims, kernel_type, base_storage, tile_size, block_rows) result(fun) Uses iso_fortran_env iso_c_binding proc~~get~~UsesGraph proc~get nvrtc_module%get iso_c_binding iso_c_binding proc~get->iso_c_binding iso_fortran_env iso_fortran_env proc~get->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Returns kernel ready to be executed Type Bound nvrtc_module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions, used only for forward permutation type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter Return Value type( CUfunction ) Resulting kernel Calls proc~~get~~CallsGraph proc~get nvrtc_module%get fname fname proc~get->fname mpi_abort mpi_abort proc~get->mpi_abort none~check nvrtc_module%check proc~get->none~check proc~cudageterrorstring cudaGetErrorString proc~get->proc~cudageterrorstring proc~get_mangled_name get_mangled_name proc~get->proc~get_mangled_name proc~check_instance nvrtc_module%check_instance none~check->proc~check_instance proc~check_module nvrtc_module%check_module none~check->proc~check_module interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_mangled_name->fname proc~get_mangled_name->mpi_abort proc~get_name_expression get_name_expression proc~get_mangled_name->proc~get_name_expression proc~nvrtcgeterrorstring nvrtcGetErrorString proc~get_mangled_name->proc~nvrtcgeterrorstring proc~check_instance->none~check interface~to_str to_str proc~get_name_expression->interface~to_str proc~astring_f2c astring_f2c proc~get_name_expression->proc~astring_f2c proc~nvrtcgeterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get~~CalledByGraph proc~get nvrtc_module%get proc~get_kernel_instance get_kernel_instance proc~get_kernel_instance->proc~get proc~get_kernel get_kernel proc~get_kernel->proc~get_kernel_instance proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get.html"},{"title":"check_instance – dtFFT","text":"private  function check_instance(self, ndims, kernel_type, base_storage, tile_size, block_rows) Checks if kernel with given parameters is available in this module Type Bound nvrtc_module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter Return Value logical Calls proc~~check_instance~~CallsGraph proc~check_instance nvrtc_module%check_instance none~check nvrtc_module%check proc~check_instance->none~check none~check->proc~check_instance proc~check_module nvrtc_module%check_module none~check->proc~check_module Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_instance~~CalledByGraph proc~check_instance nvrtc_module%check_instance none~check nvrtc_module%check proc~check_instance->none~check none~check->proc~check_instance proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->none~check proc~get nvrtc_module%get proc~get->none~check proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->proc~get proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_instance.html"},{"title":"check_module – dtFFT","text":"private  function check_module(self, ndims, kernel_type, base_storage) Basic check that this module provides kernels of given type Type Bound nvrtc_module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value logical Called by proc~~check_module~~CalledByGraph proc~check_module nvrtc_module%check_module none~check nvrtc_module%check none~check->proc~check_module proc~check_instance nvrtc_module%check_instance none~check->proc~check_instance proc~check_instance->none~check proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->none~check proc~get nvrtc_module%get proc~get->none~check proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->proc~get proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_module.html"},{"title":"compile_program – dtFFT","text":"private  function compile_program(code, prog_name, configs, props) result(prog) Uses iso_fortran_env iso_c_binding proc~~compile_program~~UsesGraph proc~compile_program compile_program iso_c_binding iso_c_binding proc~compile_program->iso_c_binding iso_fortran_env iso_fortran_env proc~compile_program->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compiles nvRTC program with given configurations Arguments Type Intent Optional Attributes Name type( codegen_t ), intent(in) :: code CUDA code to compile character(len=*), intent(in) :: prog_name Basic kernel name type( kernel_config ), intent(in) :: configs (:) Kernel configurations that this module should be compiled for type( device_props ), intent(in) :: props GPU architecture properties Return Value type( nvrtcProgram ) Resulting nvRTC program Calls proc~~compile_program~~CallsGraph proc~compile_program compile_program fname fname proc~compile_program->fname interface~to_str to_str proc~compile_program->interface~to_str mpi_abort mpi_abort proc~compile_program->mpi_abort proc~astring_f2c astring_f2c proc~compile_program->proc~astring_f2c proc~destroy_strings destroy_strings proc~compile_program->proc~destroy_strings proc~mem_alloc_host mem_alloc_host proc~compile_program->proc~mem_alloc_host proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_program->proc~nvrtcgeterrorstring proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~string_c2f string_c2f proc~compile_program->proc~string_c2f proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~nvrtcgeterrorstring->proc~string_c2f proc~set_name_expression->fname proc~set_name_expression->mpi_abort proc~set_name_expression->proc~nvrtcgeterrorstring proc~get_name_expression get_name_expression proc~set_name_expression->proc~get_name_expression interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_name_expression->interface~to_str proc~get_name_expression->proc~astring_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compile_program~~CalledByGraph proc~compile_program compile_program proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compile_program.html"},{"title":"get_name_expression – dtFFT","text":"private  function get_name_expression(basic_name, tile_dim, block_rows, padding) result(expression) Generates name expression for given template parameters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basic_name Basic kernel name integer(kind=int32), intent(in) :: tile_dim Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter integer(kind=int32), intent(in) :: padding Padding to avoid shared memory bank conflicts, template parameter Return Value character(len=c_char), allocatable, (:) Resulting name expression Calls proc~~get_name_expression~~CallsGraph proc~get_name_expression get_name_expression interface~to_str to_str proc~get_name_expression->interface~to_str proc~astring_f2c astring_f2c proc~get_name_expression->proc~astring_f2c proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_name_expression~~CalledByGraph proc~get_name_expression get_name_expression proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~get_name_expression proc~set_name_expression set_name_expression proc~set_name_expression->proc~get_name_expression proc~compile_program compile_program proc~compile_program->proc~set_name_expression proc~get nvrtc_module%get proc~get->proc~get_mangled_name proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~get_kernel_instance get_kernel_instance proc~get_kernel_instance->proc~get proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~get_kernel get_kernel proc~get_kernel->proc~get_kernel_instance proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_name_expression.html"},{"title":"get_mangled_name – dtFFT","text":"private  function get_mangled_name(basic_name, prog, tile_dim, block_rows, padding) result(mangled) Uses iso_fortran_env iso_c_binding proc~~get_mangled_name~~UsesGraph proc~get_mangled_name get_mangled_name iso_c_binding iso_c_binding proc~get_mangled_name->iso_c_binding iso_fortran_env iso_fortran_env proc~get_mangled_name->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Gets mangled name for given template parameters from nvRTC program Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basic_name Basic kernel name type( nvrtcProgram ), intent(in) :: prog nvRTC program integer(kind=int32), intent(in) :: tile_dim Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter integer(kind=int32), intent(in) :: padding Padding to avoid shared memory bank conflicts, template parameter Return Value type(c_ptr) Mangled kernel name Calls proc~~get_mangled_name~~CallsGraph proc~get_mangled_name get_mangled_name fname fname proc~get_mangled_name->fname mpi_abort mpi_abort proc~get_mangled_name->mpi_abort proc~get_name_expression get_name_expression proc~get_mangled_name->proc~get_name_expression proc~nvrtcgeterrorstring nvrtcGetErrorString proc~get_mangled_name->proc~nvrtcgeterrorstring interface~to_str to_str proc~get_name_expression->interface~to_str proc~astring_f2c astring_f2c proc~get_name_expression->proc~astring_f2c proc~string_c2f string_c2f proc~nvrtcgeterrorstring->proc~string_c2f proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_mangled_name~~CalledByGraph proc~get_mangled_name get_mangled_name proc~get nvrtc_module%get proc~get->proc~get_mangled_name proc~get_kernel_instance get_kernel_instance proc~get_kernel_instance->proc~get proc~get_kernel get_kernel proc~get_kernel->proc~get_kernel_instance proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_mangled_name.html"},{"title":"get_code – dtFFT","text":"private  function get_code(kernel_name, ndims, base_storage, kernel_type) result(code) Generates code that will be used to locally tranpose data and prepares to send it to other processes Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int32), intent(in) :: ndims Number of dimensions integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to generate code for Return Value type( codegen_t ) Resulting code Calls proc~~get_code~~CallsGraph proc~get_code get_code proc~add_line codegen_t%add_line proc~get_code->proc~add_line proc~is_unpack_kernel is_unpack_kernel proc~get_code->proc~is_unpack_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_code~~CalledByGraph proc~get_code get_code proc~create~3 nvrtc_module%create proc~create~3->proc~get_code proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_code.html"},{"title":"add_line – dtFFT","text":"private  subroutine add_line(self, line) Adds new line to CUDA code Type Bound codegen_t Arguments Type Intent Optional Attributes Name class( codegen_t ), intent(inout) :: self Kernel code character(len=*), intent(in) :: line Line to add Called by proc~~add_line~~CalledByGraph proc~add_line codegen_t%add_line proc~get_code get_code proc~get_code->proc~add_line proc~create~3 nvrtc_module%create proc~create~3->proc~get_code proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/add_line.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, ndims, kernel_type, base_storage, configs, props) Uses iso_fortran_env iso_c_binding proc~~create~3~~UsesGraph proc~create~3 nvrtc_module%create iso_c_binding iso_c_binding proc~create~3->iso_c_binding iso_fortran_env iso_fortran_env proc~create~3->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates module with given parameters, compiles nvRTC program and loads it as CUDA module Type Bound nvrtc_module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(inout) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions, used only for forward permutation type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_config ), intent(in) :: configs (:) Kernel configurations that this module should be compiled for type( device_props ), intent(in) :: props GPU architecture properties Calls proc~~create~3~~CallsGraph proc~create~3 nvrtc_module%create fname fname proc~create~3->fname interface~mem_free_host mem_free_host proc~create~3->interface~mem_free_host mpi_abort mpi_abort proc~create~3->mpi_abort proc~compile_program compile_program proc~create~3->proc~compile_program proc~cudageterrorstring cudaGetErrorString proc~create~3->proc~cudageterrorstring proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~get_code get_code proc~create~3->proc~get_code proc~get_conf_log_enabled get_conf_log_enabled proc~create~3->proc~get_conf_log_enabled proc~mem_alloc_host mem_alloc_host proc~create~3->proc~mem_alloc_host proc~nvrtcgeterrorstring nvrtcGetErrorString proc~create~3->proc~nvrtcgeterrorstring proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create~3->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create~3->proc~push_nvtx_domain_range proc~write_message write_message proc~create~3->proc~write_message proc~compile_program->fname proc~compile_program->mpi_abort proc~compile_program->proc~mem_alloc_host proc~compile_program->proc~nvrtcgeterrorstring interface~to_str to_str proc~compile_program->interface~to_str proc~astring_f2c astring_f2c proc~compile_program->proc~astring_f2c proc~destroy_strings destroy_strings proc~compile_program->proc~destroy_strings proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~string_c2f string_c2f proc~compile_program->proc~string_c2f interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~cudageterrorstring->proc~string_c2f proc~destroy~3->fname proc~destroy~3->mpi_abort proc~destroy~3->proc~cudageterrorstring proc~destroy~3->proc~nvrtcgeterrorstring is_null_ptr is_null_ptr proc~destroy~3->is_null_ptr proc~add_line codegen_t%add_line proc~get_code->proc~add_line proc~is_unpack_kernel is_unpack_kernel proc~get_code->proc~is_unpack_kernel interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~nvrtcgeterrorstring->proc~string_c2f interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~set_name_expression->fname proc~set_name_expression->mpi_abort proc~set_name_expression->proc~nvrtcgeterrorstring proc~get_name_expression get_name_expression proc~set_name_expression->proc~get_name_expression interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_name_expression->interface~to_str proc~get_name_expression->proc~astring_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~3~~CalledByGraph proc~create~3 nvrtc_module%create proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~3.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Uses iso_fortran_env iso_c_binding proc~~destroy~3~~UsesGraph proc~destroy~3 nvrtc_module%destroy iso_c_binding iso_c_binding proc~destroy~3->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy~3->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys module and frees resources Type Bound nvrtc_module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(inout) :: self Calls proc~~destroy~3~~CallsGraph proc~destroy~3 nvrtc_module%destroy fname fname proc~destroy~3->fname is_null_ptr is_null_ptr proc~destroy~3->is_null_ptr mpi_abort mpi_abort proc~destroy~3->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy~3->proc~cudageterrorstring proc~nvrtcgeterrorstring nvrtcGetErrorString proc~destroy~3->proc~nvrtcgeterrorstring interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~nvrtcgeterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy~3~~CalledByGraph proc~destroy~3 nvrtc_module%destroy proc~create~3 nvrtc_module%create proc~create~3->proc~destroy~3 proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~3.html"},{"title":"set_name_expression – dtFFT","text":"private  subroutine set_name_expression(prog, basic_name, tile_dim, block_rows, padding) Uses iso_fortran_env iso_c_binding proc~~set_name_expression~~UsesGraph proc~set_name_expression set_name_expression iso_c_binding iso_c_binding proc~set_name_expression->iso_c_binding iso_fortran_env iso_fortran_env proc~set_name_expression->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Sets name expression for given template parameters to nvRTC program Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), intent(in) :: prog nvRTC program character(len=*), intent(in) :: basic_name Basic kernel name integer(kind=int32), intent(in) :: tile_dim Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter integer(kind=int32), intent(in) :: padding Padding to avoid shared memory bank conflicts, template parameter Calls proc~~set_name_expression~~CallsGraph proc~set_name_expression set_name_expression fname fname proc~set_name_expression->fname mpi_abort mpi_abort proc~set_name_expression->mpi_abort proc~get_name_expression get_name_expression proc~set_name_expression->proc~get_name_expression proc~nvrtcgeterrorstring nvrtcGetErrorString proc~set_name_expression->proc~nvrtcgeterrorstring interface~to_str to_str proc~get_name_expression->interface~to_str proc~astring_f2c astring_f2c proc~get_name_expression->proc~astring_f2c proc~string_c2f string_c2f proc~nvrtcgeterrorstring->proc~string_c2f proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_name_expression~~CalledByGraph proc~set_name_expression set_name_expression proc~compile_program compile_program proc~compile_program->proc~set_name_expression proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_name_expression.html"},{"title":"make_plan – dtFFT","text":"private  subroutine make_plan(fft_rank, fft_sizes, mkl_precision, forward_domain, how_many, idist, odist, plan) Creates general MKL plan Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=c_long), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: mkl_precision MKL Precision integer(kind=int32), intent(in) :: forward_domain C2C or R2C flag integer(kind=int32), intent(in) :: how_many Sets DFTI_NUMBER_OF_TRANSFORMS integer(kind=int32), intent(in) :: idist Sets DFTI_INPUT_DISTANCE integer(kind=int32), intent(in) :: odist Sets DFTI_OUTPUT_DISTANCE type(c_ptr), intent(inout) :: plan Resulting plan Calls proc~~make_plan~~CallsGraph proc~make_plan make_plan interface~mkl_dfti_commit_desc mkl_dfti_commit_desc proc~make_plan->interface~mkl_dfti_commit_desc interface~mkl_dfti_create_desc mkl_dfti_create_desc proc~make_plan->interface~mkl_dfti_create_desc interface~mkl_dfti_set_value mkl_dfti_set_value proc~make_plan->interface~mkl_dfti_set_value interface~to_str to_str proc~make_plan->interface~to_str mpi_abort mpi_abort proc~make_plan->mpi_abort proc~dftierrormessage DftiErrorMessage proc~make_plan->proc~dftierrormessage proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~make_plan~~CalledByGraph proc~make_plan make_plan proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/make_plan.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via MKL DFTI Interface Type Bound mkl_executor Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Calls proc~~create~4~~CallsGraph proc~create~4 mkl_executor%create proc~make_plan make_plan proc~create~4->proc~make_plan interface~mkl_dfti_commit_desc mkl_dfti_commit_desc proc~make_plan->interface~mkl_dfti_commit_desc interface~mkl_dfti_create_desc mkl_dfti_create_desc proc~make_plan->interface~mkl_dfti_create_desc interface~mkl_dfti_set_value mkl_dfti_set_value proc~make_plan->interface~mkl_dfti_set_value interface~to_str to_str proc~make_plan->interface~to_str mpi_abort mpi_abort proc~make_plan->mpi_abort proc~dftierrormessage DftiErrorMessage proc~make_plan->proc~dftierrormessage proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~4.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, a, b, sign) Executes MKL plan Type Bound mkl_executor Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(in) :: self MKL FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform Calls proc~~execute~3~~CallsGraph proc~execute~3 mkl_executor%execute interface~mkl_dfti_commit_desc mkl_dfti_commit_desc proc~execute~3->interface~mkl_dfti_commit_desc interface~mkl_dfti_execute mkl_dfti_execute proc~execute~3->interface~mkl_dfti_execute interface~mkl_dfti_set_value mkl_dfti_set_value proc~execute~3->interface~mkl_dfti_set_value interface~to_str to_str proc~execute~3->interface~to_str mpi_abort mpi_abort proc~execute~3->mpi_abort proc~dftierrormessage DftiErrorMessage proc~execute~3->proc~dftierrormessage proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~3.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys MKL plan Type Bound mkl_executor Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor Calls proc~~destroy~4~~CallsGraph proc~destroy~4 mkl_executor%destroy interface~mkl_dfti_free_desc mkl_dfti_free_desc proc~destroy~4->interface~mkl_dfti_free_desc interface~to_str to_str proc~destroy~4->interface~to_str mpi_abort mpi_abort proc~destroy~4->mpi_abort proc~dftierrormessage DftiErrorMessage proc~destroy~4->proc~dftierrormessage proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~4.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(alloc_bytes, ptr) Allocates MKL memory Type Bound mkl_executor Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer Calls proc~~mem_alloc~2~~CallsGraph proc~mem_alloc~2 mkl_executor%mem_alloc interface~mkl_dfti_mem_alloc mkl_dfti_mem_alloc proc~mem_alloc~2->interface~mkl_dfti_mem_alloc interface~to_str to_str proc~mem_alloc~2->interface~to_str mpi_abort mpi_abort proc~mem_alloc~2->mpi_abort proc~dftierrormessage DftiErrorMessage proc~mem_alloc~2->proc~dftierrormessage proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc~2.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(ptr) Frees MKL aligned memory Type Bound mkl_executor Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free Calls proc~~mem_free~2~~CallsGraph proc~mem_free~2 mkl_executor%mem_free interface~mkl_dfti_mem_free mkl_dfti_mem_free proc~mem_free~2->interface~mkl_dfti_mem_free interface~to_str to_str proc~mem_free~2->interface~to_str mpi_abort mpi_abort proc~mem_free~2->mpi_abort proc~dftierrormessage DftiErrorMessage proc~mem_free~2->proc~dftierrormessage proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free~2.html"},{"title":"get_transpose_type – dtFFT","text":"public pure function get_transpose_type(send, recv) result(transpose_type) Determines transpose ID based on pencils Arguments Type Intent Optional Attributes Name type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Receive pencil Return Value type( dtfft_transpose_t ) Transpose ID Called by proc~~get_transpose_type~~CalledByGraph proc~get_transpose_type get_transpose_type proc~create~14 abstract_transpose_handle%create proc~create~14->proc~get_transpose_type proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~create~14 proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->proc~autotune_transpose_id proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_transpose_type.html"},{"title":"check_if_even – dtFFT","text":"private  function check_if_even(count, comm) Checks if data is evenly distributed across processes Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: count Local count type(MPI_Comm), intent(in) :: comm Grid communicator Return Value logical Calls proc~~check_if_even~~CallsGraph proc~check_if_even check_if_even mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_if_even~~CalledByGraph proc~check_if_even check_if_even proc~create~5 pencil%create proc~create~5->proc~check_if_even proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create~5 proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create~5 proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create~6 transpose_plan%create proc~create~6->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_if_even.html"},{"title":"make_public – dtFFT","text":"private  function make_public(self) Creates public object that users can use to create own FFT backends Type Bound pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: self Pencil Return Value type( dtfft_pencil_t )","tags":"","loc":"proc/make_public.html"},{"title":"create_pencil_t – dtFFT","text":"private  function create_pencil_t(starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t ) Calls proc~~create_pencil_t~~CallsGraph proc~create_pencil_t create_pencil_t proc~destroy_pencil_t_private dtfft_pencil_t%destroy_pencil_t_private proc~create_pencil_t->proc~destroy_pencil_t_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_pencil_t~~CalledByGraph proc~create_pencil_t create_pencil_t interface~dtfft_pencil_t dtfft_pencil_t interface~dtfft_pencil_t->proc~create_pencil_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_pencil_t.html"},{"title":"create_pencil_init – dtFFT","text":"private  function create_pencil_init(self, pencil, comm) result(error_code) Creates and validates pencil passed by user to plan constructors Type Bound pencil_init Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t type( dtfft_pencil_t ), intent(in) :: pencil Pencil passed by user to plan constructors type(MPI_Comm), intent(in) :: comm MPI Communicator passed to plan constructors Return Value integer(kind=int32) Error code Calls proc~~create_pencil_init~~CallsGraph proc~create_pencil_init pencil_init%create_pencil_init mpi_allgather mpi_allgather proc~create_pencil_init->mpi_allgather mpi_allreduce mpi_allreduce proc~create_pencil_init->mpi_allreduce mpi_comm_rank mpi_comm_rank proc~create_pencil_init->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_pencil_init->mpi_comm_size proc~check_continuity check_continuity proc~create_pencil_init->proc~check_continuity proc~check_overlap check_overlap proc~create_pencil_init->proc~check_overlap proc~create_1d_comm create_1d_comm proc~create_pencil_init->proc~create_1d_comm proc~dtfft_get_error_string dtfft_get_error_string proc~create_pencil_init->proc~dtfft_get_error_string proc~write_message write_message proc~create_pencil_init->proc~write_message proc~create_1d_comm->mpi_comm_size proc~create_subcomm create_subcomm proc~create_1d_comm->proc~create_subcomm proc~get_varying_dim get_varying_dim proc~create_1d_comm->proc~get_varying_dim proc~sort_by_varying_dim sort_by_varying_dim proc~create_1d_comm->proc~sort_by_varying_dim proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized mpi_comm_create mpi_comm_create proc~create_subcomm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_subcomm->mpi_comm_group mpi_group_free mpi_group_free proc~create_subcomm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_subcomm->mpi_group_incl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_pencil_init.html"},{"title":"check_overlap – dtFFT","text":"private pure function check_overlap(lbounds1, sizes1, lbounds2, sizes2, ndims) Check if two pencols overlap in ndims-dimensional space Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lbounds1 (:) Lower bounds of first pencil integer(kind=int32), intent(in) :: sizes1 (:) Sizes of first pencil integer(kind=int32), intent(in) :: lbounds2 (:) Lower bounds of second pencil integer(kind=int32), intent(in) :: sizes2 (:) Sizes of second pencil integer(kind=int32), intent(in) :: ndims Number of dimensions Return Value logical Called by proc~~check_overlap~~CalledByGraph proc~check_overlap check_overlap proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~check_overlap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_overlap.html"},{"title":"check_continuity – dtFFT","text":"private  function check_continuity(all_lbounds, all_sizes, global_dims, comm_size) Check if the local pencils cover the global space without gaps Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: all_lbounds (:,:) Lower bounds of local pencils for each process integer(kind=int32), intent(in) :: all_sizes (:,:) Sizes of local pencils for each process integer(kind=int32), intent(in) :: global_dims (:) Global dimensions of the problem integer(kind=int32), intent(in) :: comm_size Number of processes in the communicator Return Value logical Called by proc~~check_continuity~~CalledByGraph proc~check_continuity check_continuity proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~check_continuity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_continuity.html"},{"title":"get_varying_dim – dtFFT","text":"private  function get_varying_dim(fixed_dims, total_dims) result(varying_dim) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: fixed_dims (:) integer(kind=int32), intent(in) :: total_dims Return Value integer(kind=int32) Called by proc~~get_varying_dim~~CalledByGraph proc~get_varying_dim get_varying_dim proc~create_1d_comm create_1d_comm proc~create_1d_comm->proc~get_varying_dim proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~create_1d_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_varying_dim.html"},{"title":"pencil_f2c – dtFFT","text":"public  subroutine pencil_f2c(pencil, c_pencil) Converts Fortran pencil to C pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_t ), intent(in) :: pencil Fortran pencil type( dtfft_pencil_c ), intent(out) :: c_pencil C pencil Called by proc~~pencil_f2c~~CalledByGraph proc~pencil_f2c pencil_f2c proc~dtfft_get_pencil_c dtfft_get_pencil_c proc~dtfft_get_pencil_c->proc~pencil_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/pencil_f2c.html"},{"title":"pencil_c2f – dtFFT","text":"public  subroutine pencil_c2f(c_pencil, pencil, error_code) Converts C pencil to Fortran pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: c_pencil C pencil type( dtfft_pencil_t ), intent(out) :: pencil Fortran pencil integer(kind=int32), intent(out) :: error_code Error code Called by proc~~pencil_c2f~~CalledByGraph proc~pencil_c2f pencil_c2f proc~dtfft_create_plan_c2c_pencil_c dtfft_create_plan_c2c_pencil_c proc~dtfft_create_plan_c2c_pencil_c->proc~pencil_c2f proc~dtfft_create_plan_r2r_pencil_c dtfft_create_plan_r2r_pencil_c proc~dtfft_create_plan_r2r_pencil_c->proc~pencil_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/pencil_c2f.html"},{"title":"get_local_sizes – dtFFT","text":"public  subroutine get_local_sizes(pencils, in_starts, in_counts, out_starts, out_counts, alloc_size, is_y_slab) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name type( pencil ), intent(in) :: pencils (:) Array of pencils integer(kind=int32), intent(out), optional :: in_starts (:) Start indexes in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements in real space integer(kind=int32), intent(out), optional :: out_starts (:) Start indexes in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan logical, intent(in), optional :: is_y_slab Is Y-slab optimization used Called by proc~~get_local_sizes~~CalledByGraph proc~get_local_sizes get_local_sizes proc~create~6 transpose_plan%create proc~create~6->proc~get_local_sizes proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~run_autotune_backend->proc~get_local_sizes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes~2 proc~autotune_grid_decomposition->proc~autotune_grid proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_local_sizes.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, rank, aligned_dim, counts, comms, lstarts, lcounts, order) Creates pencil Type Bound pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil integer(kind=int8), intent(in) :: rank Rank of buffer integer(kind=int8), intent(in) :: aligned_dim Position of aligned dimension integer(kind=int32), intent(in) :: counts (:) Global counts type(MPI_Comm), intent(in) :: comms (:) Grid communicators integer(kind=int32), intent(in), optional :: lstarts (:) Local starts integer(kind=int32), intent(in), optional :: lcounts (:) Local counts integer(kind=int8), intent(in), optional :: order (:) Order of dimensions Calls proc~~create~5~~CallsGraph proc~create~5 pencil%create proc~check_if_even check_if_even proc~create~5->proc~check_if_even proc~destroy~5 pencil%destroy proc~create~5->proc~destroy~5 proc~get_local_size get_local_size proc~create~5->proc~get_local_size mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~get_local_size->mpi_allgather mpi_comm_rank mpi_comm_rank proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_comm_size Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~5~~CalledByGraph proc~create~5 pencil%create proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create~5 proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create~5 proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create~6 transpose_plan%create proc~create~6->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~5.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys pencil Type Bound pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil Called by proc~~destroy~5~~CalledByGraph proc~destroy~5 pencil%destroy proc~autotune_grid autotune_grid proc~autotune_grid->proc~destroy~5 proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~create_private dtfft_plan_t%create_private proc~create_private->proc~destroy~5 proc~create~5 pencil%create proc~create~5->proc~destroy~5 proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_pencils_and_comm->proc~create~5 proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create~5 proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~6 transpose_plan%create proc~create~6->proc~autotune_grid_decomposition proc~create~6->proc~create_pencils_and_comm proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~5.html"},{"title":"get_local_size – dtFFT","text":"private  subroutine get_local_size(n_global, comm, start, count, start_to_keep, size_to_keep) Computes local portions of data based on global count and position inside grid communicator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_global Global number of points type(MPI_Comm), intent(in) :: comm Grid communicator integer(kind=int32), intent(out) :: start Local start integer(kind=int32), intent(out) :: count Local count integer(kind=int32), intent(in), optional :: start_to_keep Start to keep in case of user defined decomposition integer(kind=int32), intent(in), optional :: size_to_keep Size to keep in case of user defined decomposition Calls proc~~get_local_size~~CallsGraph proc~get_local_size get_local_size mpi_allgather mpi_allgather proc~get_local_size->mpi_allgather mpi_comm_rank mpi_comm_rank proc~get_local_size->mpi_comm_rank mpi_comm_size mpi_comm_size proc~get_local_size->mpi_comm_size Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_local_size~~CalledByGraph proc~get_local_size get_local_size proc~create~5 pencil%create proc~create~5->proc~get_local_size proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create~5 proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create~5 proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create~6 transpose_plan%create proc~create~6->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_local_size.html"},{"title":"destroy_pencil_t_private – dtFFT","text":"private  subroutine destroy_pencil_t_private(self) Destroys pencil Type Bound dtfft_pencil_t Arguments Type Intent Optional Attributes Name class( dtfft_pencil_t ), intent(inout) :: self Public pencil Called by proc~~destroy_pencil_t_private~~CalledByGraph proc~destroy_pencil_t_private dtfft_pencil_t%destroy_pencil_t_private proc~create_pencil_t create_pencil_t proc~create_pencil_t->proc~destroy_pencil_t_private proc~destroy_pencil_t destroy_pencil_t proc~destroy_pencil_t->proc~destroy_pencil_t_private interface~dtfft_pencil_t dtfft_pencil_t interface~dtfft_pencil_t->proc~create_pencil_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_pencil_t_private.html"},{"title":"destroy_pencil_t – dtFFT","text":"private  subroutine destroy_pencil_t(self) Destroys pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_t ), intent(inout) :: self Public pencil Calls proc~~destroy_pencil_t~~CallsGraph proc~destroy_pencil_t destroy_pencil_t proc~destroy_pencil_t_private dtfft_pencil_t%destroy_pencil_t_private proc~destroy_pencil_t->proc~destroy_pencil_t_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_pencil_t.html"},{"title":"destroy_pencil_init – dtFFT","text":"private  subroutine destroy_pencil_init(self) Destroys pencil_init Type Bound pencil_init Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t Calls proc~~destroy_pencil_init~~CallsGraph proc~destroy_pencil_init pencil_init%destroy_pencil_init mpi_comm_free mpi_comm_free proc~destroy_pencil_init->mpi_comm_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_pencil_init.html"},{"title":"sort_by_varying_dim – dtFFT","text":"private  subroutine sort_by_varying_dim(ranks, coords) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: ranks (:) integer(kind=int32), intent(in) :: coords (:) Called by proc~~sort_by_varying_dim~~CalledByGraph proc~sort_by_varying_dim sort_by_varying_dim proc~create_1d_comm create_1d_comm proc~create_1d_comm->proc~sort_by_varying_dim proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~create_1d_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/sort_by_varying_dim.html"},{"title":"create_1d_comm – dtFFT","text":"private  subroutine create_1d_comm(lbounds, all_lbounds, fixed_dims, comm, new_comm) Creates a new 1D communicator based on the fixed dimensions of the current pencil Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lbounds (:) Local starts of the current pencil integer(kind=int32), intent(in) :: all_lbounds (:,:) Local starts of all processes integer(kind=int32), intent(in) :: fixed_dims (:) Indices of fixed coordinates type(MPI_Comm), intent(in) :: comm Original MPI communicator type(MPI_Comm), intent(out) :: new_comm New 1D MPI communicator Calls proc~~create_1d_comm~~CallsGraph proc~create_1d_comm create_1d_comm mpi_comm_size mpi_comm_size proc~create_1d_comm->mpi_comm_size proc~create_subcomm create_subcomm proc~create_1d_comm->proc~create_subcomm proc~get_varying_dim get_varying_dim proc~create_1d_comm->proc~get_varying_dim proc~sort_by_varying_dim sort_by_varying_dim proc~create_1d_comm->proc~sort_by_varying_dim mpi_comm_create mpi_comm_create proc~create_subcomm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_subcomm->mpi_comm_group mpi_group_free mpi_group_free proc~create_subcomm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_subcomm->mpi_group_incl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_1d_comm~~CalledByGraph proc~create_1d_comm create_1d_comm proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~create_1d_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_1d_comm.html"},{"title":"dtfft_pencil_t – dtFFT","text":"public interface dtfft_pencil_t Type bound constuctor for dtfft_pencil_t Calls interface~~dtfft_pencil_t~~CallsGraph interface~dtfft_pencil_t dtfft_pencil_t proc~create_pencil_t create_pencil_t interface~dtfft_pencil_t->proc~create_pencil_t proc~destroy_pencil_t_private dtfft_pencil_t%destroy_pencil_t_private proc~create_pencil_t->proc~destroy_pencil_t_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t )","tags":"","loc":"interface/dtfft_pencil_t.html"},{"title":"transpose_start – dtFFT","text":"private  function transpose_start(self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation Note Buffers in and out cannot be the same Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation Calls proc~~transpose_start~~CallsGraph proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start->proc~transpose_start_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_start_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_start_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_start_ptr->proc~transpose_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~execute~5 transpose_plan%execute proc~transpose_private->proc~execute~5 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~5->proc~pop_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range execute execute proc~execute~5->execute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_start.html"},{"title":"transpose_start_ptr – dtFFT","text":"private  function transpose_start_ptr(self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers Note Buffers in and out cannot be the same Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation Calls proc~~transpose_start_ptr~~CallsGraph proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_start_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_start_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_start_ptr->proc~transpose_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~execute~5 transpose_plan%execute proc~transpose_private->proc~execute~5 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~5->proc~pop_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range execute execute proc~execute~5->execute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transpose_start_ptr~~CalledByGraph proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_start_ptr.html"},{"title":"get_z_slab_enabled – dtFFT","text":"private  function get_z_slab_enabled(self, error_code) Returns logical value is Z-slab optimization enabled internally Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical Calls proc~~get_z_slab_enabled~~CallsGraph proc~get_z_slab_enabled dtfft_plan_t%get_z_slab_enabled proc~dtfft_get_error_string dtfft_get_error_string proc~get_z_slab_enabled->proc~dtfft_get_error_string proc~write_message write_message proc~get_z_slab_enabled->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_z_slab_enabled~~CalledByGraph proc~get_z_slab_enabled dtfft_plan_t%get_z_slab_enabled proc~dtfft_get_z_slab_enabled_c dtfft_get_z_slab_enabled_c proc~dtfft_get_z_slab_enabled_c->proc~get_z_slab_enabled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_z_slab_enabled.html"},{"title":"get_y_slab_enabled – dtFFT","text":"private  function get_y_slab_enabled(self, error_code) Returns logical value is Y-slab optimization enabled internally Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical Calls proc~~get_y_slab_enabled~~CallsGraph proc~get_y_slab_enabled dtfft_plan_t%get_y_slab_enabled proc~dtfft_get_error_string dtfft_get_error_string proc~get_y_slab_enabled->proc~dtfft_get_error_string proc~write_message write_message proc~get_y_slab_enabled->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_y_slab_enabled~~CalledByGraph proc~get_y_slab_enabled dtfft_plan_t%get_y_slab_enabled proc~dtfft_get_y_slab_enabled_c dtfft_get_y_slab_enabled_c proc~dtfft_get_y_slab_enabled_c->proc~get_y_slab_enabled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_y_slab_enabled.html"},{"title":"get_pencil – dtFFT","text":"private  function get_pencil(self, layout, error_code) Returns pencil decomposition Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: layout Required layout: 0 for XYZ layout (real space, R2C only) 1 for XYZ layout 2 for YZX layout 3 for ZXY layout integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) Calls proc~~get_pencil~~CallsGraph proc~get_pencil dtfft_plan_t%get_pencil make_public make_public proc~get_pencil->make_public proc~dtfft_get_error_string dtfft_get_error_string proc~get_pencil->proc~dtfft_get_error_string proc~write_message write_message proc~get_pencil->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_pencil~~CalledByGraph proc~get_pencil dtfft_plan_t%get_pencil proc~dtfft_get_pencil_c dtfft_get_pencil_c proc~dtfft_get_pencil_c->proc~get_pencil Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_pencil.html"},{"title":"get_element_size – dtFFT","text":"private  function get_element_size(self, error_code) Returns number of bytes required to store single element. Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Calls proc~~get_element_size~~CallsGraph proc~get_element_size dtfft_plan_t%get_element_size proc~dtfft_get_error_string dtfft_get_error_string proc~get_element_size->proc~dtfft_get_error_string proc~write_message write_message proc~get_element_size->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_element_size~~CalledByGraph proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_element_size proc~dtfft_get_element_size_c dtfft_get_element_size_c proc~dtfft_get_element_size_c->proc~get_element_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_element_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_element_size.html"},{"title":"get_alloc_bytes – dtFFT","text":"private  function get_alloc_bytes(self, error_code) Returns minimum number of bytes required to execute plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Calls proc~~get_alloc_bytes~~CallsGraph proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~dtfft_get_error_string dtfft_get_error_string proc~get_alloc_bytes->proc~dtfft_get_error_string proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_bytes->proc~get_alloc_size proc~get_element_size dtfft_plan_t%get_element_size proc~get_alloc_bytes->proc~get_element_size proc~write_message write_message proc~get_alloc_bytes->proc~write_message proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes~2 proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_local_sizes~2->proc~write_message counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem starts starts proc~get_local_sizes~2->starts proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_alloc_bytes~~CalledByGraph proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_alloc_bytes.html"},{"title":"get_executor – dtFFT","text":"private  function get_executor(self, error_code) Returns FFT Executor associated with plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) Calls proc~~get_executor~~CallsGraph proc~get_executor dtfft_plan_t%get_executor proc~dtfft_get_error_string dtfft_get_error_string proc~get_executor->proc~dtfft_get_error_string proc~write_message write_message proc~get_executor->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_executor~~CalledByGraph proc~get_executor dtfft_plan_t%get_executor proc~dtfft_get_executor_c dtfft_get_executor_c proc~dtfft_get_executor_c->proc~get_executor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_executor.html"},{"title":"get_precision – dtFFT","text":"private  function get_precision(self, error_code) Returns precision of the plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) Calls proc~~get_precision~~CallsGraph proc~get_precision dtfft_plan_t%get_precision proc~dtfft_get_error_string dtfft_get_error_string proc~get_precision->proc~dtfft_get_error_string proc~write_message write_message proc~get_precision->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_precision~~CalledByGraph proc~get_precision dtfft_plan_t%get_precision proc~dtfft_get_precision_c dtfft_get_precision_c proc~dtfft_get_precision_c->proc~get_precision Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_precision.html"},{"title":"get_backend – dtFFT","text":"private  function get_backend(self, error_code) Returns selected GPU backend during autotuning Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) Calls proc~~get_backend~~CallsGraph proc~get_backend dtfft_plan_t%get_backend proc~dtfft_get_error_string dtfft_get_error_string proc~get_backend->proc~dtfft_get_error_string proc~get_backend~2 transpose_plan%get_backend proc~get_backend->proc~get_backend~2 proc~write_message write_message proc~get_backend->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_backend~~CalledByGraph proc~get_backend dtfft_plan_t%get_backend proc~dtfft_get_backend_c dtfft_get_backend_c proc~dtfft_get_backend_c->proc~get_backend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_backend.html"},{"title":"get_platform – dtFFT","text":"private  function get_platform(self, error_code) Returns execution platform of the plan (HOST or CUDA) Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) Calls proc~~get_platform~~CallsGraph proc~get_platform dtfft_plan_t%get_platform proc~dtfft_get_error_string dtfft_get_error_string proc~get_platform->proc~dtfft_get_error_string proc~write_message write_message proc~get_platform->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_platform~~CalledByGraph proc~get_platform dtfft_plan_t%get_platform proc~dtfft_get_platform_c dtfft_get_platform_c proc~dtfft_get_platform_c->proc~get_platform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_platform.html"},{"title":"check_device_pointers – dtFFT","text":"private  function check_device_pointers(in, out, backend, aux) result(error_code) Checks if device pointers are provided by user Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: in First pointer type(c_ptr), intent(in) :: out Second pointer type( dtfft_backend_t ), intent(in) :: backend Backend. Required to check for nvshmem pointer type(c_ptr), intent(in) :: aux Optional auxiliary pointer. Return Value integer(kind=int32) Calls proc~~check_device_pointers~~CallsGraph proc~check_device_pointers check_device_pointers interface~is_device_ptr is_device_ptr proc~check_device_pointers->interface~is_device_ptr is_null_ptr is_null_ptr proc~check_device_pointers->is_null_ptr proc~is_backend_nvshmem is_backend_nvshmem proc~check_device_pointers->proc~is_backend_nvshmem proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers->proc~is_nvshmem_ptr proc~is_nvshmem_ptr->is_null_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_device_pointers.html"},{"title":"get_alloc_size – dtFFT","text":"private  function get_alloc_size(self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan Calls proc~~get_alloc_size~~CallsGraph proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes~2 counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~dtfft_get_error_string dtfft_get_error_string proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem proc~write_message write_message proc~get_local_sizes~2->proc~write_message starts starts proc~get_local_sizes~2->starts proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_alloc_size~~CalledByGraph proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_alloc_size.html"},{"title":"create_private – dtFFT","text":"private  function create_private(self, sngl_type, sngl_storage_size, dbl_type, dbl_storage_size, dims, pencil, comm, precision, effort, executor, kinds) Uses iso_fortran_env iso_c_binding proc~~create_private~~UsesGraph proc~create_private dtfft_plan_t%create_private iso_c_binding iso_c_binding proc~create_private->iso_c_binding iso_fortran_env iso_fortran_env proc~create_private->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates core Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(MPI_Datatype), intent(in) :: sngl_type MPI_Datatype for single precision plan integer(kind=int64), intent(in) :: sngl_storage_size Number of bytes needed to store single element (single precision) type(MPI_Datatype), intent(in) :: dbl_type MPI_Datatype for double precision plan integer(kind=int64), intent(in) :: dbl_storage_size Number of bytes needed to store single element (double precision) integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm User-defined communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) Calls proc~~create_private~~CallsGraph proc~create_private dtfft_plan_t%create_private counts counts proc~create_private->counts create create proc~create_private->create fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort mpi_allgather mpi_allgather proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~destroy~5 pencil%destroy proc~create_private->proc~destroy~5 proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_private~~CalledByGraph proc~create_private dtfft_plan_t%create_private proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_private.html"},{"title":"check_create_args – dtFFT","text":"private  function check_create_args(self, dims, pencil, comm, precision, effort, executor, kinds) Check arguments provided by user and sets private variables Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm Optional MPI Communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) Calls proc~~check_create_args~~CallsGraph proc~check_create_args dtfft_plan_t%check_create_args mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment proc~get_correct_backend->proc~get_conf_platform backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_create_args~~CalledByGraph proc~check_create_args dtfft_plan_t%check_create_args proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_create_args.html"},{"title":"create_r2r_internal – dtFFT","text":"private  function create_r2r_internal(self, dims, pencil, kinds, comm, precision, effort, executor) Creates plan for R2R plans Type Bound dtfft_plan_r2r_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) Calls proc~~create_r2r_internal~~CallsGraph proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal create create proc~create_r2r_internal->create fft_mapping fft_mapping proc~create_r2r_internal->fft_mapping pencils pencils proc~create_r2r_internal->pencils proc~create_private dtfft_plan_t%create_private proc~create_r2r_internal->proc~create_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create_private->create counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort mpi_allgather mpi_allgather proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~destroy~5 pencil%destroy proc~create_private->proc~destroy~5 proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_r2r_internal~~CalledByGraph proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2r_internal.html"},{"title":"create_c2c_internal – dtFFT","text":"private  function create_c2c_internal(self, dims, pencil, comm, precision, effort, executor) Private method that combines common logic for C2C plan creation Type Bound dtfft_plan_c2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) Calls proc~~create_c2c_internal~~CallsGraph proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_internal->proc~create_c2c_core proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_c2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_c2c_internal->proc~push_nvtx_domain_range create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping pencils pencils proc~create_c2c_core->pencils proc~create_private dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private->create counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort mpi_allgather mpi_allgather proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~destroy~5 pencil%destroy proc~create_private->proc~destroy~5 proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_c2c_internal~~CalledByGraph proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_c2c_internal.html"},{"title":"create_c2c_core – dtFFT","text":"private  function create_c2c_core(self, dims, pencil, comm, precision, effort, executor) Creates plan for both C2C and R2C Type Bound dtfft_core_c2c Arguments Type Intent Optional Attributes Name class( dtfft_core_c2c ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) Calls proc~~create_c2c_core~~CallsGraph proc~create_c2c_core dtfft_core_c2c%create_c2c_core create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping pencils pencils proc~create_c2c_core->pencils proc~create_private dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private proc~create_private->create counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort mpi_allgather mpi_allgather proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~destroy~5 pencil%destroy proc~create_private->proc~destroy~5 proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_c2c_core~~CalledByGraph proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_c2c_core.html"},{"title":"create_r2c_internal – dtFFT","text":"private  function create_r2c_internal(self, executor, dims, pencil, comm, precision, effort) Private method that combines common logic for R2C plan creation Type Bound dtfft_plan_r2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan Return Value integer(kind=int32) Calls proc~~create_r2c_internal~~CallsGraph proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal pencils pencils proc~create_r2c_internal->pencils proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_r2c_internal->proc~create_c2c_core proc~create~5 pencil%create proc~create_r2c_internal->proc~create~5 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_c2c_core->pencils create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping proc~create_private dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private proc~check_if_even check_if_even proc~create~5->proc~check_if_even proc~destroy~5 pencil%destroy proc~create~5->proc~destroy~5 proc~get_local_size get_local_size proc~create~5->proc~get_local_size interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private->create proc~create_private->proc~destroy~5 counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free mpi_comm_rank mpi_comm_rank proc~create_private->mpi_comm_rank proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab proc~get_local_size->mpi_allgather proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_comm_size mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_r2c_internal~~CalledByGraph proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2c_internal.html"},{"title":"mem_alloc_ptr – dtFFT","text":"private  function mem_alloc_ptr(self, alloc_bytes, error_code) result(ptr) Allocates memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type(c_ptr) Allocated pointer Calls proc~~mem_alloc_ptr~~CallsGraph proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mem_alloc_ptr~~CalledByGraph proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~mem_alloc_ptr proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_ptr.html"},{"title":"transpose – dtFFT","text":"private  subroutine transpose(self, in, out, transpose_type, error_code) Performs single transposition Note Buffers in and out cannot be the same Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~transpose~~CallsGraph proc~transpose dtfft_plan_t%transpose proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose->proc~transpose_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~execute~5 transpose_plan%execute proc~transpose_private->proc~execute~5 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~5->proc~pop_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range execute execute proc~execute~5->execute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose.html"},{"title":"transpose_ptr – dtFFT","text":"private  subroutine transpose_ptr(self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Note Buffers in and out cannot be the same Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~transpose_ptr~~CallsGraph proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~execute~5 transpose_plan%execute proc~transpose_private->proc~execute~5 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~5->proc~pop_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range execute execute proc~execute~5->execute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transpose_ptr~~CalledByGraph proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_ptr.html"},{"title":"transpose_end – dtFFT","text":"private  subroutine transpose_end(self, request, error_code) Ends previously started transposition Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_request_t ), intent(inout) :: request Handle obtained from transpose_start or transpose_start_ptr integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~transpose_end~~CallsGraph proc~transpose_end dtfft_plan_t%transpose_end proc~execute_end~2 transpose_plan%execute_end proc~transpose_end->proc~execute_end~2 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_end->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_end->proc~push_nvtx_domain_range execute_end execute_end proc~execute_end~2->execute_end interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transpose_end~~CalledByGraph proc~transpose_end dtfft_plan_t%transpose_end proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_end.html"},{"title":"transpose_private – dtFFT","text":"private  subroutine transpose_private(self, in, out, transpose_type, exec_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Note Buffers in and out cannot be the same Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. type( async_exec_t ), intent(in) :: exec_type Type of asynchronous execution. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~transpose_private~~CallsGraph proc~transpose_private dtfft_plan_t%transpose_private proc~execute~5 transpose_plan%execute proc~transpose_private->proc~execute~5 execute execute proc~execute~5->execute proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~5->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transpose_private~~CalledByGraph proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~transpose_private proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_private.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, execute_type, aux, error_code) Executes plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~execute~4~~CallsGraph proc~execute~4 dtfft_plan_t%execute proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute~4->proc~execute_ptr is_null_ptr is_null_ptr proc~execute_ptr->is_null_ptr proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~is_same_ptr is_same_ptr proc~execute_ptr->proc~is_same_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute_ptr->proc~push_nvtx_domain_range proc~check_aux->is_null_ptr interface~to_str to_str proc~check_aux->interface~to_str mpi_abort mpi_abort proc~check_aux->mpi_abort proc~dtfft_get_error_string dtfft_get_error_string proc~check_aux->proc~dtfft_get_error_string proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~get_conf_log_enabled get_conf_log_enabled proc~check_aux->proc~get_conf_log_enabled proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~write_message write_message proc~check_aux->proc~write_message proc~execute_2d dtfft_plan_t%execute_2d proc~execute_private->proc~execute_2d proc~execute_generic dtfft_plan_t%execute_generic proc~execute_private->proc~execute_generic proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_private->proc~execute_z_slab interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~5 transpose_plan%execute proc~execute_2d->proc~execute~5 proc~execute_generic->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute_z_slab->proc~execute~5 proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes~2 interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~write_message proc~mem_alloc_ptr->is_null_ptr proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_ptr->proc~write_message mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~execute~5->proc~pop_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range execute execute proc~execute~5->execute proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_local_sizes~2->proc~write_message counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem starts starts proc~get_local_sizes~2->starts interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~4.html"},{"title":"execute_ptr – dtFFT","text":"private  subroutine execute_ptr(self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary buffer. Not optional. If not required, c_null_ptr must be passed.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~execute_ptr~~CallsGraph proc~execute_ptr dtfft_plan_t%execute_ptr is_null_ptr is_null_ptr proc~execute_ptr->is_null_ptr proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~is_same_ptr is_same_ptr proc~execute_ptr->proc~is_same_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute_ptr->proc~push_nvtx_domain_range proc~check_aux->is_null_ptr interface~to_str to_str proc~check_aux->interface~to_str mpi_abort mpi_abort proc~check_aux->mpi_abort proc~dtfft_get_error_string dtfft_get_error_string proc~check_aux->proc~dtfft_get_error_string proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~get_conf_log_enabled get_conf_log_enabled proc~check_aux->proc~get_conf_log_enabled proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~write_message write_message proc~check_aux->proc~write_message proc~execute_2d dtfft_plan_t%execute_2d proc~execute_private->proc~execute_2d proc~execute_generic dtfft_plan_t%execute_generic proc~execute_private->proc~execute_generic proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_private->proc~execute_z_slab interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~5 transpose_plan%execute proc~execute_2d->proc~execute~5 proc~execute_generic->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute_z_slab->proc~execute~5 proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes~2 interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~write_message proc~mem_alloc_ptr->is_null_ptr proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_ptr->proc~write_message mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~execute~5->proc~pop_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range execute execute proc~execute~5->execute proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_local_sizes~2->proc~write_message counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem starts starts proc~get_local_sizes~2->starts interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_ptr~~CalledByGraph proc~execute_ptr dtfft_plan_t%execute_ptr proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_ptr.html"},{"title":"execute_private – dtFFT","text":"private  subroutine execute_private(self, in, out, execute_type, aux, inplace) Executes plan with specified auxiliary buffer Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. logical, intent(in) :: inplace Inplace execution flag Calls proc~~execute_private~~CallsGraph proc~execute_private dtfft_plan_t%execute_private proc~execute_2d dtfft_plan_t%execute_2d proc~execute_private->proc~execute_2d proc~execute_generic dtfft_plan_t%execute_generic proc~execute_private->proc~execute_generic proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_private->proc~execute_z_slab proc~execute~5 transpose_plan%execute proc~execute_2d->proc~execute~5 proc~execute_generic->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute_z_slab->proc~execute~5 execute execute proc~execute~5->execute proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~5->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_private~~CalledByGraph proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~execute_private proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_private.html"},{"title":"execute_2d – dtFFT","text":"private  subroutine execute_2d(self, in, out, execute_type, aux) Executes plan with specified auxiliary buffer Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. Calls proc~~execute_2d~~CallsGraph proc~execute_2d dtfft_plan_t%execute_2d proc~execute~5 transpose_plan%execute proc~execute_2d->proc~execute~5 execute execute proc~execute~5->execute proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~5->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_2d~~CalledByGraph proc~execute_2d dtfft_plan_t%execute_2d proc~execute_private dtfft_plan_t%execute_private proc~execute_private->proc~execute_2d proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~execute_private proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_2d.html"},{"title":"execute_z_slab – dtFFT","text":"private  subroutine execute_z_slab(self, in, out, execute_type, aux, inplace) Executes plan with specified auxiliary buffer Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. logical, intent(in) :: inplace Inplace execution flag Calls proc~~execute_z_slab~~CallsGraph proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_generic dtfft_plan_t%execute_generic proc~execute_z_slab->proc~execute_generic proc~execute~5 transpose_plan%execute proc~execute_z_slab->proc~execute~5 proc~execute_generic->proc~execute~5 execute execute proc~execute~5->execute proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~5->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_z_slab~~CalledByGraph proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_private dtfft_plan_t%execute_private proc~execute_private->proc~execute_z_slab proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~execute_private proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_z_slab.html"},{"title":"execute_generic – dtFFT","text":"private  subroutine execute_generic(self, in, out, execute_type, aux) Executes plan with specified auxiliary buffer Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. Calls proc~~execute_generic~~CallsGraph proc~execute_generic dtfft_plan_t%execute_generic proc~execute~5 transpose_plan%execute proc~execute_generic->proc~execute~5 execute execute proc~execute~5->execute proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~5->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_generic~~CalledByGraph proc~execute_generic dtfft_plan_t%execute_generic proc~execute_private dtfft_plan_t%execute_private proc~execute_private->proc~execute_generic proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_private->proc~execute_z_slab proc~execute_z_slab->proc~execute_generic proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~execute_private proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_generic.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self, error_code) Destroys plan, frees all memory Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~destroy~6~~CallsGraph proc~destroy~6 dtfft_plan_t%destroy destroy destroy proc~destroy~6->destroy mpi_comm_free mpi_comm_free proc~destroy~6->mpi_comm_free mpi_finalized mpi_finalized proc~destroy~6->mpi_finalized proc~destroy_stream destroy_stream proc~destroy~6->proc~destroy_stream proc~dtfft_get_error_string dtfft_get_error_string proc~destroy~6->proc~dtfft_get_error_string proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~6->proc~mem_free_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~destroy~6->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~destroy~6->proc~push_nvtx_domain_range proc~write_message write_message proc~destroy~6->proc~write_message fname fname proc~destroy_stream->fname interface~cudastreamdestroy cudaStreamDestroy proc~destroy_stream->interface~cudastreamdestroy mpi_abort mpi_abort proc~destroy_stream->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy_stream->proc~cudageterrorstring proc~mem_free_ptr->proc~dtfft_get_error_string proc~mem_free_ptr->proc~write_message interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~write_message->mpi_finalized mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy~6~~CalledByGraph proc~destroy~6 dtfft_plan_t%destroy proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~6.html"},{"title":"get_dims – dtFFT","text":"private  subroutine get_dims(self, dims, error_code) Returns global dimensions Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~get_dims~~CallsGraph proc~get_dims dtfft_plan_t%get_dims proc~dtfft_get_error_string dtfft_get_error_string proc~get_dims->proc~dtfft_get_error_string proc~write_message write_message proc~get_dims->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_dims~~CalledByGraph proc~get_dims dtfft_plan_t%get_dims proc~dtfft_get_dims_c dtfft_get_dims_c proc~dtfft_get_dims_c->proc~get_dims Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_dims.html"},{"title":"get_grid_dims – dtFFT","text":"private  subroutine get_grid_dims(self, grid_dims, error_code) Returns grid decomposition dimensions Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: grid_dims (:) Grid dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~get_grid_dims~~CallsGraph proc~get_grid_dims dtfft_plan_t%get_grid_dims proc~dtfft_get_error_string dtfft_get_error_string proc~get_grid_dims->proc~dtfft_get_error_string proc~write_message write_message proc~get_grid_dims->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_grid_dims~~CalledByGraph proc~get_grid_dims dtfft_plan_t%get_grid_dims proc~dtfft_get_grid_dims_c dtfft_get_grid_dims_c proc~dtfft_get_grid_dims_c->proc~get_grid_dims Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_grid_dims.html"},{"title":"report – dtFFT","text":"private  subroutine report(self, error_code) Prints plan-related information to stdout Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~report~~CallsGraph proc~report dtfft_plan_t%report interface~to_str to_str proc~report->interface~to_str mpi_comm_size mpi_comm_size proc~report->mpi_comm_size proc~dtfft_get_backend_string dtfft_get_backend_string proc~report->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~report->proc~dtfft_get_error_string proc~dtfft_get_executor_string dtfft_get_executor_string proc~report->proc~dtfft_get_executor_string proc~dtfft_get_precision_string dtfft_get_precision_string proc~report->proc~dtfft_get_precision_string proc~get_backend~2 transpose_plan%get_backend proc~report->proc~get_backend~2 proc~write_message write_message proc~report->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~report~~CalledByGraph proc~report dtfft_plan_t%report proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/report.html"},{"title":"get_stream_ptr – dtFFT","text":"private  subroutine get_stream_ptr(self, stream, error_code) Returns CUDA stream associated with plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~get_stream_ptr~~CallsGraph proc~get_stream_ptr dtfft_plan_t%get_stream_ptr proc~dtfft_get_error_string dtfft_get_error_string proc~get_stream_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~get_stream_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_stream_ptr~~CalledByGraph proc~get_stream_ptr dtfft_plan_t%get_stream_ptr none~get_stream dtfft_plan_t%get_stream none~get_stream->proc~get_stream_ptr proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream->proc~get_stream_int64 proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream proc~get_stream_int64->none~get_stream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_stream_ptr.html"},{"title":"get_stream_int64 – dtFFT","text":"private  subroutine get_stream_int64(self, stream, error_code) Returns CUDA stream associated with plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~get_stream_int64~~CallsGraph proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream dtfft_plan_t%get_stream proc~get_stream_int64->none~get_stream proc~dtfft_get_cuda_stream dtfft_get_cuda_stream proc~get_stream_int64->proc~dtfft_get_cuda_stream none~get_stream->proc~get_stream_int64 proc~get_stream_ptr dtfft_plan_t%get_stream_ptr none~get_stream->proc~get_stream_ptr proc~dtfft_get_error_string dtfft_get_error_string proc~get_stream_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~get_stream_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_stream_int64~~CalledByGraph proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream dtfft_plan_t%get_stream proc~get_stream_int64->none~get_stream none~get_stream->proc~get_stream_int64 proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_stream_int64.html"},{"title":"get_local_sizes – dtFFT","text":"private  subroutine get_local_sizes(self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~get_local_sizes~2~~CallsGraph proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~dtfft_get_error_string dtfft_get_error_string proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem proc~write_message write_message proc~get_local_sizes~2->proc~write_message starts starts proc~get_local_sizes~2->starts proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_local_sizes~2~~CalledByGraph proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes~2 proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_local_sizes~2.html"},{"title":"alloc_fft_plans – dtFFT","text":"private  subroutine alloc_fft_plans(self, kinds) Allocates abstract_executor with required FFT class\nand populates fft_mapping with similar FFT ids Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Called by proc~~alloc_fft_plans~~CalledByGraph proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private dtfft_plan_t%create_private proc~create_private->proc~alloc_fft_plans proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/alloc_fft_plans.html"},{"title":"check_aux – dtFFT","text":"private  subroutine check_aux(self, aux) Uses iso_fortran_env proc~~check_aux~~UsesGraph proc~check_aux dtfft_plan_t%check_aux iso_fortran_env iso_fortran_env proc~check_aux->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Checks if aux buffer was passed by user and if not will allocate one internally Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: aux Optional auxiliary buffer. Calls proc~~check_aux~~CallsGraph proc~check_aux dtfft_plan_t%check_aux interface~to_str to_str proc~check_aux->interface~to_str is_null_ptr is_null_ptr proc~check_aux->is_null_ptr mpi_abort mpi_abort proc~check_aux->mpi_abort proc~dtfft_get_error_string dtfft_get_error_string proc~check_aux->proc~dtfft_get_error_string proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~get_conf_log_enabled get_conf_log_enabled proc~check_aux->proc~get_conf_log_enabled proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~write_message write_message proc~check_aux->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes~2 interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~write_message proc~mem_alloc_ptr->is_null_ptr proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_ptr->proc~write_message mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_local_sizes~2->proc~write_message counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem starts starts proc~get_local_sizes~2->starts interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_aux~~CalledByGraph proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_aux.html"},{"title":"create_r2r – dtFFT","text":"private  subroutine create_r2r(self, dims, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Type Bound dtfft_plan_r2r_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_r2r~~CallsGraph proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r->proc~create_r2r_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_r2r->proc~dtfft_get_error_string proc~write_message write_message proc~create_r2r->proc~write_message create create proc~create_r2r_internal->create fft_mapping fft_mapping proc~create_r2r_internal->fft_mapping pencils pencils proc~create_r2r_internal->pencils proc~create_private dtfft_plan_t%create_private proc~create_r2r_internal->proc~create_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2r_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~create_private->create proc~create_private->mpi_comm_rank counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort mpi_allgather mpi_allgather proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free mpi_comm_size mpi_comm_size proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~destroy~5 pencil%destroy proc~create_private->proc~destroy~5 proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform proc~init_environment->proc~write_message backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2r.html"},{"title":"create_r2r_pencil – dtFFT","text":"private  subroutine create_r2r_pencil(self, pencil, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Type Bound dtfft_plan_r2r_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_r2r_pencil~~CallsGraph proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_pencil->proc~create_r2r_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_r2r_pencil->proc~dtfft_get_error_string proc~write_message write_message proc~create_r2r_pencil->proc~write_message create create proc~create_r2r_internal->create fft_mapping fft_mapping proc~create_r2r_internal->fft_mapping pencils pencils proc~create_r2r_internal->pencils proc~create_private dtfft_plan_t%create_private proc~create_r2r_internal->proc~create_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2r_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~create_private->create proc~create_private->mpi_comm_rank counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort mpi_allgather mpi_allgather proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free mpi_comm_size mpi_comm_size proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~destroy~5 pencil%destroy proc~create_private->proc~destroy~5 proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform proc~init_environment->proc~write_message backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2r_pencil.html"},{"title":"create_c2c – dtFFT","text":"private  subroutine create_c2c(self, dims, comm, precision, effort, executor, error_code) C2C Plan Constructor Type Bound dtfft_plan_c2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_c2c~~CallsGraph proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c->proc~create_c2c_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_c2c->proc~dtfft_get_error_string proc~write_message write_message proc~create_c2c->proc~write_message proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_internal->proc~create_c2c_core proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_c2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_c2c_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping pencils pencils proc~create_c2c_core->pencils proc~create_private dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private->mpi_comm_rank proc~create_private->create counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort mpi_allgather mpi_allgather proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free mpi_comm_size mpi_comm_size proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~destroy~5 pencil%destroy proc~create_private->proc~destroy~5 proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform proc~init_environment->proc~write_message backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_c2c.html"},{"title":"create_c2c_pencil – dtFFT","text":"private  subroutine create_c2c_pencil(self, pencil, comm, precision, effort, executor, error_code) C2C Plan Constructor Type Bound dtfft_plan_c2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_c2c_pencil~~CallsGraph proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_pencil->proc~create_c2c_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_c2c_pencil->proc~dtfft_get_error_string proc~write_message write_message proc~create_c2c_pencil->proc~write_message proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_internal->proc~create_c2c_core proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_c2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_c2c_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping pencils pencils proc~create_c2c_core->pencils proc~create_private dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private->mpi_comm_rank proc~create_private->create counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort mpi_allgather mpi_allgather proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free mpi_comm_size mpi_comm_size proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~destroy~5 pencil%destroy proc~create_private->proc~destroy~5 proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform proc~init_environment->proc~write_message backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_c2c_pencil.html"},{"title":"create_r2c – dtFFT","text":"private  subroutine create_r2c(self, dims, executor, comm, precision, effort, error_code) R2C Generic Plan Constructor Type Bound dtfft_plan_r2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_r2c~~CallsGraph proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c->proc~create_r2c_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_r2c->proc~dtfft_get_error_string proc~write_message write_message proc~create_r2c->proc~write_message pencils pencils proc~create_r2c_internal->pencils proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_r2c_internal->proc~create_c2c_core proc~create~5 pencil%create proc~create_r2c_internal->proc~create~5 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2c_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~create_c2c_core->pencils create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping proc~create_private dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private proc~check_if_even check_if_even proc~create~5->proc~check_if_even proc~destroy~5 pencil%destroy proc~create~5->proc~destroy~5 proc~get_local_size get_local_size proc~create~5->proc~get_local_size interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private->mpi_comm_rank proc~create_private->create proc~create_private->proc~destroy~5 counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_allgather proc~get_local_size->mpi_comm_size mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform proc~init_environment->proc~write_message backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2c.html"},{"title":"create_r2c_pencil – dtFFT","text":"private  subroutine create_r2c_pencil(self, pencil, executor, comm, precision, effort, error_code) R2C Plan Constructor with pencil Type Bound dtfft_plan_r2c_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user Calls proc~~create_r2c_pencil~~CallsGraph proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_pencil->proc~create_r2c_internal proc~dtfft_get_error_string dtfft_get_error_string proc~create_r2c_pencil->proc~dtfft_get_error_string proc~write_message write_message proc~create_r2c_pencil->proc~write_message pencils pencils proc~create_r2c_internal->pencils proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_r2c_internal->proc~create_c2c_core proc~create~5 pencil%create proc~create_r2c_internal->proc~create~5 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create_r2c_internal->proc~push_nvtx_domain_range mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~create_c2c_core->pencils create create proc~create_c2c_core->create fft_mapping fft_mapping proc~create_c2c_core->fft_mapping proc~create_private dtfft_plan_t%create_private proc~create_c2c_core->proc~create_private proc~check_if_even check_if_even proc~create~5->proc~check_if_even proc~destroy~5 pencil%destroy proc~create~5->proc~destroy~5 proc~get_local_size get_local_size proc~create~5->proc~get_local_size interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_private->mpi_comm_rank proc~create_private->create proc~create_private->proc~destroy~5 counts counts proc~create_private->counts fixed_dims fixed_dims proc~create_private->fixed_dims fname fname proc~create_private->fname interface~cudagetdevice cudaGetDevice proc~create_private->interface~cudagetdevice interface~cudagetdevicecount cudaGetDeviceCount proc~create_private->interface~cudagetdevicecount local_devices local_devices proc~create_private->local_devices mpi_abort mpi_abort proc~create_private->mpi_abort proc~create_private->mpi_allgather mpi_comm_free mpi_comm_free proc~create_private->mpi_comm_free proc~create_private->mpi_comm_size mpi_comm_split_type mpi_comm_split_type proc~create_private->mpi_comm_split_type proc~alloc_fft_plans dtfft_plan_t%alloc_fft_plans proc~create_private->proc~alloc_fft_plans proc~check_create_args dtfft_plan_t%check_create_args proc~create_private->proc~check_create_args proc~count_unique count_unique proc~create_private->proc~count_unique proc~cudageterrorstring cudaGetErrorString proc~create_private->proc~cudageterrorstring proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private->proc~get_conf_y_slab_enabled proc~get_z_slab transpose_plan%get_z_slab proc~create_private->proc~get_z_slab proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_allgather proc~get_local_size->mpi_comm_size mpi_topo_test mpi_topo_test proc~check_create_args->mpi_topo_test proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~get_conf_platform get_conf_platform proc~check_create_args->proc~get_conf_platform proc~init_internal init_internal proc~check_create_args->proc~init_internal proc~is_backend_nccl is_backend_nccl proc~check_create_args->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~check_create_args->proc~is_backend_nvshmem proc~is_cuda_executor is_cuda_executor proc~check_create_args->proc~is_cuda_executor proc~is_host_executor is_host_executor proc~check_create_args->proc~is_host_executor proc~is_valid_comm_type is_valid_comm_type proc~check_create_args->proc~is_valid_comm_type proc~is_valid_dimension is_valid_dimension proc~check_create_args->proc~is_valid_dimension proc~is_valid_effort is_valid_effort proc~check_create_args->proc~is_valid_effort proc~is_valid_executor is_valid_executor proc~check_create_args->proc~is_valid_executor proc~is_valid_precision is_valid_precision proc~check_create_args->proc~is_valid_precision proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args->proc~is_valid_r2r_kind interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_correct_backend->proc~get_conf_platform proc~init_environment->proc~write_message backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_r2c_pencil.html"},{"title":"mem_free_ptr – dtFFT","text":"private  subroutine mem_free_ptr(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_ptr~~CallsGraph proc~mem_free_ptr dtfft_plan_t%mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mem_free_ptr~~CalledByGraph proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~mem_free_ptr proc~dtfft_mem_free_c dtfft_mem_free_c proc~dtfft_mem_free_c->proc~mem_free_ptr proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_c32_1d->proc~mem_free_ptr proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_c32_2d->proc~mem_free_ptr proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_c32_3d->proc~mem_free_ptr proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_c64_1d->proc~mem_free_ptr proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_c64_2d->proc~mem_free_ptr proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_c64_3d->proc~mem_free_ptr proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_r32_1d->proc~mem_free_ptr proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_r32_2d->proc~mem_free_ptr proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_r32_3d->proc~mem_free_ptr proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_r64_1d->proc~mem_free_ptr proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_r64_2d->proc~mem_free_ptr proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_r64_3d->proc~mem_free_ptr proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_ptr.html"},{"title":"mem_alloc_r32_1d – dtFFT","text":"private  subroutine mem_alloc_r32_1d(self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r32_1d~~CallsGraph proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r32_1d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r32_1d.html"},{"title":"mem_alloc_r32_2d – dtFFT","text":"private  subroutine mem_alloc_r32_2d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r32_2d~~CallsGraph proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r32_2d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r32_2d.html"},{"title":"mem_alloc_r32_3d – dtFFT","text":"private  subroutine mem_alloc_r32_3d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r32_3d~~CallsGraph proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r32_3d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r32_3d.html"},{"title":"mem_free_r32_1d – dtFFT","text":"private  subroutine mem_free_r32_1d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r32_1d~~CallsGraph proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r32_1d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r32_1d.html"},{"title":"mem_free_r32_2d – dtFFT","text":"private  subroutine mem_free_r32_2d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r32_2d~~CallsGraph proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r32_2d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r32_2d.html"},{"title":"mem_free_r32_3d – dtFFT","text":"private  subroutine mem_free_r32_3d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r32_3d~~CallsGraph proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r32_3d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r32_3d.html"},{"title":"mem_alloc_r64_1d – dtFFT","text":"private  subroutine mem_alloc_r64_1d(self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r64_1d~~CallsGraph proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r64_1d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r64_1d.html"},{"title":"mem_alloc_r64_2d – dtFFT","text":"private  subroutine mem_alloc_r64_2d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r64_2d~~CallsGraph proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r64_2d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r64_2d.html"},{"title":"mem_alloc_r64_3d – dtFFT","text":"private  subroutine mem_alloc_r64_3d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_r64_3d~~CallsGraph proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_r64_3d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_r64_3d.html"},{"title":"mem_free_r64_1d – dtFFT","text":"private  subroutine mem_free_r64_1d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r64_1d~~CallsGraph proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r64_1d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r64_1d.html"},{"title":"mem_free_r64_2d – dtFFT","text":"private  subroutine mem_free_r64_2d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r64_2d~~CallsGraph proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r64_2d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r64_2d.html"},{"title":"mem_free_r64_3d – dtFFT","text":"private  subroutine mem_free_r64_3d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_r64_3d~~CallsGraph proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_r64_3d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_r64_3d.html"},{"title":"mem_alloc_c32_1d – dtFFT","text":"private  subroutine mem_alloc_c32_1d(self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c32_1d~~CallsGraph proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c32_1d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c32_1d.html"},{"title":"mem_alloc_c32_2d – dtFFT","text":"private  subroutine mem_alloc_c32_2d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c32_2d~~CallsGraph proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c32_2d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c32_2d.html"},{"title":"mem_alloc_c32_3d – dtFFT","text":"private  subroutine mem_alloc_c32_3d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c32_3d~~CallsGraph proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c32_3d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c32_3d.html"},{"title":"mem_free_c32_1d – dtFFT","text":"private  subroutine mem_free_c32_1d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c32_1d~~CallsGraph proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c32_1d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c32_1d.html"},{"title":"mem_free_c32_2d – dtFFT","text":"private  subroutine mem_free_c32_2d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c32_2d~~CallsGraph proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c32_2d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c32_2d.html"},{"title":"mem_free_c32_3d – dtFFT","text":"private  subroutine mem_free_c32_3d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c32_3d~~CallsGraph proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c32_3d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c32_3d.html"},{"title":"mem_alloc_c64_1d – dtFFT","text":"private  subroutine mem_alloc_c64_1d(self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c64_1d~~CallsGraph proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c64_1d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c64_1d.html"},{"title":"mem_alloc_c64_2d – dtFFT","text":"private  subroutine mem_alloc_c64_2d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c64_2d~~CallsGraph proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c64_2d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c64_2d.html"},{"title":"mem_alloc_c64_3d – dtFFT","text":"private  subroutine mem_alloc_c64_3d(self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_alloc_c64_3d~~CallsGraph proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_c64_3d->proc~mem_alloc_ptr is_null_ptr is_null_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_c64_3d.html"},{"title":"mem_free_c64_1d – dtFFT","text":"private  subroutine mem_free_c64_1d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c64_1d~~CallsGraph proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c64_1d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c64_1d.html"},{"title":"mem_free_c64_2d – dtFFT","text":"private  subroutine mem_free_c64_2d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c64_2d~~CallsGraph proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c64_2d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c64_2d.html"},{"title":"mem_free_c64_3d – dtFFT","text":"private  subroutine mem_free_c64_3d(self, ptr, error_code) Frees previously allocated memory specific for this plan Type Bound dtfft_plan_t Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Calls proc~~mem_free_c64_3d~~CallsGraph proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_c64_3d->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free_c64_3d.html"},{"title":"load_vkfft – dtFFT","text":"public  function load_vkfft(platform) Loads VkFFT library based on the platform Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to load VkFFT library for Return Value integer(kind=int32) Calls proc~~load_vkfft~~CallsGraph proc~load_vkfft load_vkfft proc~load load proc~load_vkfft->proc~load proc~destroy_strings destroy_strings proc~load->proc~destroy_strings proc~dynamic_load dynamic_load proc~load->proc~dynamic_load proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_vkfft~~CalledByGraph proc~load_vkfft load_vkfft proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_vkfft.html"},{"title":"load – dtFFT","text":"private  function load(wrapper, suffix) result(error_code) Loads VkFFT library Arguments Type Intent Optional Attributes Name class( vkfft_wrapper ), intent(inout) :: wrapper VkFFT Wrapper character(len=*), intent(in) :: suffix Suffix for the library name Return Value integer(kind=int32) Error code Calls proc~~load~~CallsGraph proc~load load proc~destroy_strings destroy_strings proc~load->proc~destroy_strings proc~dynamic_load dynamic_load proc~load->proc~dynamic_load proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load~~CalledByGraph proc~load load proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load.html"},{"title":"create – dtFFT","text":"private  function create(self, platform, dims, base_comm, effort, base_dtype, base_storage, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plan Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type( dtfft_platform_t ), intent(in) :: platform Platform to create plan for integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Pencil passed by user Return Value integer(kind=int32) Error code Calls proc~~create~6~~CallsGraph proc~create~6 transpose_plan%create interface~to_str to_str proc~create~6->interface~to_str mpi_cart_get mpi_cart_get proc~create~6->mpi_cart_get mpi_cartdim_get mpi_cartdim_get proc~create~6->mpi_cartdim_get mpi_comm_size mpi_comm_size proc~create~6->mpi_comm_size mpi_dims_create mpi_dims_create proc~create~6->mpi_dims_create mpi_topo_test mpi_topo_test proc~create~6->mpi_topo_test mpi_wtime mpi_wtime proc~create~6->mpi_wtime proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~allocate_plans allocate_plans proc~create~6->proc~allocate_plans proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create_helper backend_helper%create_helper proc~create~6->proc~create_helper proc~create_pencils_and_comm create_pencils_and_comm proc~create~6->proc~create_pencils_and_comm proc~dtfft_get_backend_string dtfft_get_backend_string proc~create~6->proc~dtfft_get_backend_string proc~get_conf_backend get_conf_backend proc~create~6->proc~get_conf_backend proc~get_conf_datatype_enabled get_conf_datatype_enabled proc~create~6->proc~get_conf_datatype_enabled proc~get_conf_log_enabled get_conf_log_enabled proc~create~6->proc~get_conf_log_enabled proc~get_conf_mpi_enabled get_conf_mpi_enabled proc~create~6->proc~get_conf_mpi_enabled proc~get_conf_nccl_enabled get_conf_nccl_enabled proc~create~6->proc~get_conf_nccl_enabled proc~get_conf_nvshmem_enabled get_conf_nvshmem_enabled proc~create~6->proc~get_conf_nvshmem_enabled proc~get_conf_stream get_conf_stream proc~create~6->proc~get_conf_stream proc~get_conf_z_slab_enabled get_conf_z_slab_enabled proc~create~6->proc~get_conf_z_slab_enabled proc~get_datatype_from_env get_datatype_from_env proc~create~6->proc~get_datatype_from_env proc~get_local_sizes get_local_sizes proc~create~6->proc~get_local_sizes proc~is_backend_nccl is_backend_nccl proc~create~6->proc~is_backend_nccl proc~load_cuda load_cuda proc~create~6->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create~6->proc~load_nvrtc proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~write_message write_message proc~create~6->proc~write_message temp_coords temp_coords proc~create~6->temp_coords temp_dims temp_dims proc~create~6->temp_dims temp_periods temp_periods proc~create~6->temp_periods proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string mpi_abort mpi_abort proc~alloc_and_set_aux->mpi_abort mpi_allreduce mpi_allreduce proc~alloc_and_set_aux->mpi_allreduce proc~alloc_mem alloc_mem proc~alloc_and_set_aux->proc~alloc_mem proc~dtfft_get_error_string dtfft_get_error_string proc~alloc_and_set_aux->proc~dtfft_get_error_string proc~get_aux_size_generic get_aux_size_generic proc~alloc_and_set_aux->proc~get_aux_size_generic proc~autotune_grid_decomposition->mpi_comm_size proc~autotune_grid autotune_grid proc~autotune_grid_decomposition->proc~autotune_grid proc~create_helper->mpi_comm_size fname fname proc~create_helper->fname interface~get_env get_env proc~create_helper->interface~get_env interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid proc~create_helper->mpi_abort mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast mpi_comm_rank mpi_comm_rank proc~create_helper->mpi_comm_rank proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~ncclgeterrorstring ncclGetErrorString proc~create_helper->proc~ncclgeterrorstring lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~5 pencil%create proc~create_pencils_and_comm->proc~create~5 proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend interface~get_conf_internal get_conf_internal proc~get_conf_datatype_enabled->interface~get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_mpi_enabled->interface~get_conf_internal proc~get_conf_nccl_enabled->interface~get_conf_internal proc~get_conf_nvshmem_enabled->interface~get_conf_internal proc~get_conf_stream->fname interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate proc~get_conf_stream->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~get_conf_stream->proc~cudageterrorstring proc~get_conf_z_slab_enabled->interface~get_conf_internal proc~get_datatype_from_env->interface~get_env proc~destroy_strings destroy_strings proc~load_cuda->proc~destroy_strings proc~dynamic_load dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~destroy_strings proc~load_nvrtc->proc~dynamic_load proc~run_autotune_backend->mpi_comm_size proc~run_autotune_backend->mpi_wtime proc~run_autotune_backend->proc~alloc_and_set_aux proc~run_autotune_backend->proc~allocate_plans proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~dtfft_get_backend_string proc~run_autotune_backend->proc~get_conf_datatype_enabled proc~run_autotune_backend->proc~get_conf_log_enabled proc~run_autotune_backend->proc~get_conf_mpi_enabled proc~run_autotune_backend->proc~get_conf_nvshmem_enabled proc~run_autotune_backend->proc~get_local_sizes proc~run_autotune_backend->proc~is_backend_nccl proc~run_autotune_backend->proc~write_message execute execute proc~run_autotune_backend->execute proc~run_autotune_backend->fname interface~cudaeventcreate cudaEventCreate proc~run_autotune_backend->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~run_autotune_backend->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~run_autotune_backend->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~run_autotune_backend->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~run_autotune_backend->interface~cudaeventsynchronize interface~cudastreamsynchronize cudaStreamSynchronize proc~run_autotune_backend->interface~cudastreamsynchronize proc~run_autotune_backend->mpi_abort mpi_barrier mpi_barrier proc~run_autotune_backend->mpi_barrier proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~cudageterrorstring proc~run_autotune_backend->proc~destroy_helper proc~destroy_plans destroy_plans proc~run_autotune_backend->proc~destroy_plans proc~run_autotune_backend->proc~dtfft_get_error_string proc~free_mem free_mem proc~run_autotune_backend->proc~free_mem proc~get_conf_measure_iters get_conf_measure_iters proc~run_autotune_backend->proc~get_conf_measure_iters proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~run_autotune_backend->proc~get_conf_measure_warmup_iters proc~get_conf_pipelined_enabled get_conf_pipelined_enabled proc~run_autotune_backend->proc~get_conf_pipelined_enabled proc~is_backend_mpi is_backend_mpi proc~run_autotune_backend->proc~is_backend_mpi proc~is_backend_nvshmem is_backend_nvshmem proc~run_autotune_backend->proc~is_backend_nvshmem proc~is_backend_pipelined is_backend_pipelined proc~run_autotune_backend->proc~is_backend_pipelined proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~report_timings report_timings proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~alloc_mem->interface~to_str proc~alloc_mem->proc~dtfft_get_backend_string proc~alloc_mem->proc~get_conf_log_enabled proc~alloc_mem->proc~is_backend_nccl proc~alloc_mem->proc~write_message proc~alloc_mem->fname proc~alloc_mem->mpi_abort proc~alloc_mem->mpi_allreduce proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~is_backend_nvshmem proc~alloc_mem->proc~ncclgeterrorstring interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr proc~mem_alloc_host mem_alloc_host proc~alloc_mem->proc~mem_alloc_host temp temp proc~alloc_mem->temp proc~autotune_grid->interface~to_str proc~autotune_grid->proc~create_pencils_and_comm proc~autotune_grid->proc~get_conf_log_enabled proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid->proc~write_message proc~autotune_grid->proc~pop_nvtx_domain_range proc~autotune_grid->proc~push_nvtx_domain_range mpi_comm_free mpi_comm_free proc~autotune_grid->mpi_comm_free proc~destroy~5 pencil%destroy proc~autotune_grid->proc~destroy~5 proc~create_cart_comm->interface~to_str mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~create_cart_comm->mpi_comm_free proc~create_subcomm_include_all create_subcomm_include_all proc~create_cart_comm->proc~create_subcomm_include_all proc~check_if_even check_if_even proc~create~5->proc~check_if_even proc~create~5->proc~destroy~5 proc~get_local_size get_local_size proc~create~5->proc~get_local_size interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy_helper->proc~write_message proc~destroy_helper->fname proc~destroy_helper->mpi_abort proc~destroy_helper->proc~ncclgeterrorstring interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy destroy destroy proc~destroy_plans->destroy proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library proc~free_mem->interface~to_str proc~free_mem->proc~get_conf_log_enabled proc~free_mem->proc~is_backend_nccl proc~free_mem->proc~write_message proc~free_mem->fname proc~free_mem->mpi_abort proc~free_mem->proc~is_backend_nvshmem proc~free_mem->proc~ncclgeterrorstring interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~mem_free_host mem_free_host proc~free_mem->interface~mem_free_host interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree nvshmem_free nvshmem_free proc~free_mem->nvshmem_free proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_pipelined_enabled->interface~get_conf_internal proc~get_conf_platform get_conf_platform proc~get_correct_backend->proc~get_conf_platform interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~ncclgeterrorstring->proc~string_c2f interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~report_timings->interface~to_str proc~report_timings->mpi_comm_size proc~report_timings->proc~get_conf_log_enabled proc~report_timings->proc~write_message proc~report_timings->mpi_allreduce proc~run_autotune_datatypes->interface~to_str proc~run_autotune_datatypes->proc~get_conf_log_enabled proc~run_autotune_datatypes->proc~write_message proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~get_plan_execution_time get_plan_execution_time proc~autotune_transpose_id->proc~get_plan_execution_time proc~check_if_even->mpi_comm_size proc~check_if_even->mpi_allgather proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create_subcomm_include_all->mpi_comm_size proc~create_subcomm create_subcomm proc~create_subcomm_include_all->proc~create_subcomm proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string proc~get_local_size->mpi_comm_size proc~get_local_size->mpi_allgather proc~get_local_size->mpi_comm_rank proc~load_library->interface~is_null_ptr proc~load_library->proc~astring_f2c interface~dlopen dlopen proc~load_library->interface~dlopen proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr proc~load_symbol->proc~astring_f2c interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~dl_error interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~string_c2f->interface~is_null_ptr interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error mpi_comm_create mpi_comm_create proc~create_subcomm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_subcomm->mpi_comm_group mpi_group_free mpi_group_free proc~create_subcomm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_subcomm->mpi_group_incl proc~dl_error->proc~write_message proc~dl_error->proc~string_c2f interface~dlerror dlerror proc~dl_error->interface~dlerror proc~get_plan_execution_time->interface~to_str proc~get_plan_execution_time->mpi_wtime proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_plan_execution_time->proc~write_message proc~get_plan_execution_time->mpi_barrier proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~report_timings proc~create~14 abstract_transpose_handle%create proc~get_plan_execution_time->proc~create~14 proc~destroy~13 transpose_handle_datatype%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_datatype%execute proc~get_plan_execution_time->proc~execute~11 create_private create_private proc~create~14->create_private proc~get_transpose_type get_transpose_type proc~create~14->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle proc~execute~11->mpi_comm_size mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_startall mpi_startall proc~execute~11->mpi_startall proc~execute_end~4 transpose_handle_datatype%execute_end proc~execute~11->proc~execute_end~4 mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free mpi_waitall mpi_waitall proc~execute_end~4->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~6.html"},{"title":"get_async_active – dtFFT","text":"private  function get_async_active(self) Returns .true. if any of the plans is running asynchronously Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value logical Calls proc~~get_async_active~2~~CallsGraph proc~get_async_active~2 transpose_plan%get_async_active get_async_active get_async_active proc~get_async_active~2->get_async_active Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_async_active~2.html"},{"title":"get_z_slab – dtFFT","text":"private  function get_z_slab(self) Returns .true. if Z-slab optimization is enabled Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value logical Called by proc~~get_z_slab~~CalledByGraph proc~get_z_slab transpose_plan%get_z_slab proc~create_private dtfft_plan_t%create_private proc~create_private->proc~get_z_slab proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_z_slab.html"},{"title":"autotune_transpose_id – dtFFT","text":"private  function autotune_transpose_id(helper, from, to, base_dtype, base_storage, transpose_name_id, a, b, forward_id, backward_id) result(elapsed_time) Creates forward and backward transpose plans for backend DTFFT_BACKEND_MPI_DATATYPE based on source and target data distributions and,\nexecutes them DTFFT_MEASURE_ITERS times ( 4 * DTFFT_MEASURE_ITERS iterations total ) + 4 * DTFFT_MEASURE_WARMUP_ITERS warmup iterations Returns elapsed time for best plans selected Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer integer(kind=int8), intent(out) :: forward_id Best forward plan ID integer(kind=int8), intent(out) :: backward_id Best backward plan ID Return Value real(kind=real32) Elapsed time for best plans selected Calls proc~~autotune_transpose_id~~CallsGraph proc~autotune_transpose_id autotune_transpose_id proc~get_plan_execution_time get_plan_execution_time proc~autotune_transpose_id->proc~get_plan_execution_time interface~to_str to_str proc~get_plan_execution_time->interface~to_str mpi_barrier mpi_barrier proc~get_plan_execution_time->mpi_barrier mpi_wtime mpi_wtime proc~get_plan_execution_time->mpi_wtime proc~create~14 abstract_transpose_handle%create proc~get_plan_execution_time->proc~create~14 proc~destroy~13 transpose_handle_datatype%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_datatype%execute proc~get_plan_execution_time->proc~execute~11 proc~get_conf_log_enabled get_conf_log_enabled proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_conf_measure_iters get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~write_message write_message proc~get_plan_execution_time->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string create_private create_private proc~create~14->create_private proc~get_transpose_type get_transpose_type proc~create~14->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_comm_size mpi_comm_size proc~execute~11->mpi_comm_size mpi_startall mpi_startall proc~execute~11->mpi_startall proc~execute_end~4 transpose_handle_datatype%execute_end proc~execute~11->proc~execute_end~4 interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~report_timings->interface~to_str proc~report_timings->proc~get_conf_log_enabled proc~report_timings->proc~write_message mpi_allreduce mpi_allreduce proc~report_timings->mpi_allreduce proc~report_timings->mpi_comm_size mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free mpi_waitall mpi_waitall proc~execute_end~4->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~autotune_transpose_id~~CalledByGraph proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->proc~autotune_transpose_id proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autotune_transpose_id.html"},{"title":"get_plan_execution_time – dtFFT","text":"private  function get_plan_execution_time(helper, from, to, base_dtype, base_storage, datatype_id, transpose_name_id, a, b) result(elapsed_time) Creates transpose plan for backend DTFFT_BACKEND_MPI_DATATYPE and executes it DTFFT_MEASURE_WARMUP_ITERS + DTFFT_MEASURE_ITERS times Returns elapsed time Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: datatype_id ID of transpose (1 or 2) integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer Return Value real(kind=real32) Execution time [ms] Calls proc~~get_plan_execution_time~~CallsGraph proc~get_plan_execution_time get_plan_execution_time interface~to_str to_str proc~get_plan_execution_time->interface~to_str mpi_barrier mpi_barrier proc~get_plan_execution_time->mpi_barrier mpi_wtime mpi_wtime proc~get_plan_execution_time->mpi_wtime proc~create~14 abstract_transpose_handle%create proc~get_plan_execution_time->proc~create~14 proc~destroy~13 transpose_handle_datatype%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_datatype%execute proc~get_plan_execution_time->proc~execute~11 proc~get_conf_log_enabled get_conf_log_enabled proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_conf_measure_iters get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~write_message write_message proc~get_plan_execution_time->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string create_private create_private proc~create~14->create_private proc~get_transpose_type get_transpose_type proc~create~14->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_comm_size mpi_comm_size proc~execute~11->mpi_comm_size mpi_startall mpi_startall proc~execute~11->mpi_startall proc~execute_end~4 transpose_handle_datatype%execute_end proc~execute~11->proc~execute_end~4 interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~report_timings->interface~to_str proc~report_timings->proc~get_conf_log_enabled proc~report_timings->proc~write_message mpi_allreduce mpi_allreduce proc~report_timings->mpi_allreduce proc~report_timings->mpi_comm_size mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free mpi_waitall mpi_waitall proc~execute_end~4->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_plan_execution_time~~CalledByGraph proc~get_plan_execution_time get_plan_execution_time proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->proc~autotune_transpose_id proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_plan_execution_time.html"},{"title":"report_timings – dtFFT","text":"private  function report_timings(comm, elapsed_time, n_iters, space_count) result(max_time) Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm real(kind=real32), intent(in) :: elapsed_time integer(kind=int32), intent(in) :: n_iters integer(kind=int32), intent(in), optional :: space_count Return Value real(kind=real32) Calls proc~~report_timings~~CallsGraph proc~report_timings report_timings interface~to_str to_str proc~report_timings->interface~to_str mpi_allreduce mpi_allreduce proc~report_timings->mpi_allreduce mpi_comm_size mpi_comm_size proc~report_timings->mpi_comm_size proc~get_conf_log_enabled get_conf_log_enabled proc~report_timings->proc~get_conf_log_enabled proc~write_message write_message proc~report_timings->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~report_timings~~CalledByGraph proc~report_timings report_timings proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~report_timings proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~run_autotune_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/report_timings.html"},{"title":"get_aux_size – dtFFT","text":"private  function get_aux_size(self) result(aux_size) Returns maximum auxiliary memory size needed by transpose plan Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value integer(kind=int64) Calls proc~~get_aux_size~2~~CallsGraph proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_aux_size~2~~CalledByGraph proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_local_sizes~2->proc~get_aux_size~2 proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes~2 proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_aux_size~2.html"},{"title":"get_aux_size_generic – dtFFT","text":"private  function get_aux_size_generic(plans) result(aux_size) Returns maximum auxiliary memory size needed by plans Arguments Type Intent Optional Attributes Name type( plan_t ), intent(in) :: plans (:) Transpose plans Return Value integer(kind=int64) Maximum auxiliary memory size needed Calls proc~~get_aux_size_generic~~CallsGraph proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_aux_size_generic~~CalledByGraph proc~get_aux_size_generic get_aux_size_generic proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~get_aux_size_generic proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_aux_size~2->proc~get_aux_size_generic proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_local_sizes~2->proc~get_aux_size~2 proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes~2 proc~autotune_grid_decomposition->proc~autotune_grid proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_aux_size_generic.html"},{"title":"get_backend – dtFFT","text":"private  function get_backend(self) Returns plan GPU backend Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value type( dtfft_backend_t ) Called by proc~~get_backend~2~~CalledByGraph proc~get_backend~2 transpose_plan%get_backend proc~get_backend dtfft_plan_t%get_backend proc~get_backend->proc~get_backend~2 proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_local_sizes~2->proc~get_backend~2 proc~report dtfft_plan_t%report proc~report->proc~get_backend~2 proc~dtfft_get_backend_c dtfft_get_backend_c proc~dtfft_get_backend_c->proc~get_backend proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes~2 proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_backend~2.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, transpose_type, exec_type, error_code) Executes transposition Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming buffer type(c_ptr), intent(in) :: out Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to execute type( async_exec_t ), intent(in) :: exec_type Type of execution (sync/async) integer(kind=int32), intent(out), optional :: error_code Error code Calls proc~~execute~5~~CallsGraph proc~execute~5 transpose_plan%execute execute execute proc~execute~5->execute proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~5->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute~5~~CalledByGraph proc~execute~5 transpose_plan%execute proc~execute_2d dtfft_plan_t%execute_2d proc~execute_2d->proc~execute~5 proc~execute_generic dtfft_plan_t%execute_generic proc~execute_generic->proc~execute~5 proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_z_slab->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_private->proc~execute~5 proc~execute_private dtfft_plan_t%execute_private proc~execute_private->proc~execute_2d proc~execute_private->proc~execute_generic proc~execute_private->proc~execute_z_slab proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~transpose_private proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~execute_private proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~5.html"},{"title":"execute_end – dtFFT","text":"private  subroutine execute_end(self, in, out, transpose_type, error_code) Finishes asynchronous transposition Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming buffer type(c_ptr), intent(in) :: out Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose integer(kind=int32), intent(out) :: error_code Error code Calls proc~~execute_end~2~~CallsGraph proc~execute_end~2 transpose_plan%execute_end execute_end execute_end proc~execute_end~2->execute_end Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_end~2~~CalledByGraph proc~execute_end~2 transpose_plan%execute_end proc~transpose_end dtfft_plan_t%transpose_end proc~transpose_end->proc~execute_end~2 proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_end~2.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys transposition plans Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class Calls proc~~destroy~7~~CallsGraph proc~destroy~7 transpose_plan%destroy proc~destroy_helper backend_helper%destroy_helper proc~destroy~7->proc~destroy_helper proc~destroy_plans destroy_plans proc~destroy~7->proc~destroy_plans proc~mem_free~3 transpose_plan%mem_free proc~destroy~7->proc~mem_free~3 fname fname proc~destroy_helper->fname interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy mpi_abort mpi_abort proc~destroy_helper->mpi_abort proc~ncclgeterrorstring ncclGetErrorString proc~destroy_helper->proc~ncclgeterrorstring proc~write_message write_message proc~destroy_helper->proc~write_message destroy destroy proc~destroy_plans->destroy proc~free_mem free_mem proc~mem_free~3->proc~free_mem proc~free_mem->fname proc~free_mem->mpi_abort proc~free_mem->proc~ncclgeterrorstring proc~free_mem->proc~write_message interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~mem_free_host mem_free_host proc~free_mem->interface~mem_free_host interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~to_str to_str proc~free_mem->interface~to_str nvshmem_free nvshmem_free proc~free_mem->nvshmem_free proc~get_conf_log_enabled get_conf_log_enabled proc~free_mem->proc~get_conf_log_enabled proc~is_backend_nccl is_backend_nccl proc~free_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~free_mem->proc~is_backend_nvshmem proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~7.html"},{"title":"allocate_plans – dtFFT","text":"private  subroutine allocate_plans(plans, backend) Allocates array of plans Arguments Type Intent Optional Attributes Name type( plan_t ), intent(inout) :: plans (:) Plans to allocate type( dtfft_backend_t ), intent(in) :: backend Backend to use Called by proc~~allocate_plans~~CalledByGraph proc~allocate_plans allocate_plans proc~create~6 transpose_plan%create proc~create~6->proc~allocate_plans proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~allocate_plans proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/allocate_plans.html"},{"title":"destroy_plans – dtFFT","text":"private  subroutine destroy_plans(plans) Destroys array of plans Arguments Type Intent Optional Attributes Name type( plan_t ), intent(inout) :: plans (:) Plans to destroy Calls proc~~destroy_plans~~CallsGraph proc~destroy_plans destroy_plans destroy destroy proc~destroy_plans->destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_plans~~CalledByGraph proc~destroy_plans destroy_plans proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~destroy_plans proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~destroy_plans proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_plans.html"},{"title":"autotune_grid_decomposition – dtFFT","text":"private  subroutine autotune_grid_decomposition(platform, dims, transposed_dims, base_comm, effort, base_dtype, base_storage, stream, best_forward_ids, best_backward_ids, best_decomposition, backend, min_execution_time, best_backend) Runs through all possible grid decompositions and selects the best one based on the lowest average execution time Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to use integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm 3D comm type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use integer(kind=int8), intent(inout) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(inout) :: best_backward_ids (:) Best Datatype ids for backward plan integer(kind=int32), intent(out) :: best_decomposition (:) Best decomposition found type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: min_execution_time Elapsed time for best plan selected type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected Calls proc~~autotune_grid_decomposition~~CallsGraph proc~autotune_grid_decomposition autotune_grid_decomposition mpi_comm_size mpi_comm_size proc~autotune_grid_decomposition->mpi_comm_size proc~autotune_grid autotune_grid proc~autotune_grid_decomposition->proc~autotune_grid interface~to_str to_str proc~autotune_grid->interface~to_str mpi_comm_free mpi_comm_free proc~autotune_grid->mpi_comm_free proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~destroy~5 pencil%destroy proc~autotune_grid->proc~destroy~5 proc~get_conf_log_enabled get_conf_log_enabled proc~autotune_grid->proc~get_conf_log_enabled proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~autotune_grid->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~write_message write_message proc~autotune_grid->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~5 pencil%create proc~create_pencils_and_comm->proc~create~5 interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~run_autotune_backend->mpi_comm_size proc~run_autotune_backend->proc~get_conf_log_enabled proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~write_message execute execute proc~run_autotune_backend->execute fname fname proc~run_autotune_backend->fname interface~cudaeventcreate cudaEventCreate proc~run_autotune_backend->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~run_autotune_backend->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~run_autotune_backend->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~run_autotune_backend->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~run_autotune_backend->interface~cudaeventsynchronize interface~cudastreamsynchronize cudaStreamSynchronize proc~run_autotune_backend->interface~cudastreamsynchronize mpi_abort mpi_abort proc~run_autotune_backend->mpi_abort mpi_barrier mpi_barrier proc~run_autotune_backend->mpi_barrier mpi_wtime mpi_wtime proc~run_autotune_backend->mpi_wtime proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_mem alloc_mem proc~run_autotune_backend->proc~alloc_mem proc~allocate_plans allocate_plans proc~run_autotune_backend->proc~allocate_plans proc~create_helper backend_helper%create_helper proc~run_autotune_backend->proc~create_helper proc~cudageterrorstring cudaGetErrorString proc~run_autotune_backend->proc~cudageterrorstring proc~destroy_helper backend_helper%destroy_helper proc~run_autotune_backend->proc~destroy_helper proc~destroy_plans destroy_plans proc~run_autotune_backend->proc~destroy_plans proc~dtfft_get_backend_string dtfft_get_backend_string proc~run_autotune_backend->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~run_autotune_backend->proc~dtfft_get_error_string proc~free_mem free_mem proc~run_autotune_backend->proc~free_mem proc~get_conf_datatype_enabled get_conf_datatype_enabled proc~run_autotune_backend->proc~get_conf_datatype_enabled proc~get_conf_measure_iters get_conf_measure_iters proc~run_autotune_backend->proc~get_conf_measure_iters proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~run_autotune_backend->proc~get_conf_measure_warmup_iters proc~get_conf_mpi_enabled get_conf_mpi_enabled proc~run_autotune_backend->proc~get_conf_mpi_enabled proc~get_conf_nvshmem_enabled get_conf_nvshmem_enabled proc~run_autotune_backend->proc~get_conf_nvshmem_enabled proc~get_conf_pipelined_enabled get_conf_pipelined_enabled proc~run_autotune_backend->proc~get_conf_pipelined_enabled proc~get_local_sizes get_local_sizes proc~run_autotune_backend->proc~get_local_sizes proc~is_backend_mpi is_backend_mpi proc~run_autotune_backend->proc~is_backend_mpi proc~is_backend_nccl is_backend_nccl proc~run_autotune_backend->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~run_autotune_backend->proc~is_backend_nvshmem proc~is_backend_pipelined is_backend_pipelined proc~run_autotune_backend->proc~is_backend_pipelined proc~report_timings report_timings proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~alloc_and_set_aux->mpi_abort proc~alloc_and_set_aux->proc~alloc_mem proc~alloc_and_set_aux->proc~dtfft_get_error_string mpi_allreduce mpi_allreduce proc~alloc_and_set_aux->mpi_allreduce proc~get_aux_size_generic get_aux_size_generic proc~alloc_and_set_aux->proc~get_aux_size_generic proc~alloc_mem->interface~to_str proc~alloc_mem->proc~get_conf_log_enabled proc~alloc_mem->proc~write_message proc~alloc_mem->fname proc~alloc_mem->mpi_abort proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~dtfft_get_backend_string proc~alloc_mem->proc~is_backend_nccl proc~alloc_mem->proc~is_backend_nvshmem interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr proc~alloc_mem->mpi_allreduce proc~mem_alloc_host mem_alloc_host proc~alloc_mem->proc~mem_alloc_host proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring temp temp proc~alloc_mem->temp proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_cart_comm->interface~to_str proc~create_cart_comm->mpi_comm_free mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~create_subcomm_include_all create_subcomm_include_all proc~create_cart_comm->proc~create_subcomm_include_all proc~create_helper->mpi_comm_size proc~create_helper->fname proc~create_helper->mpi_abort proc~create_helper->mpi_comm_rank proc~create_helper->proc~destroy_helper interface~get_env get_env proc~create_helper->interface~get_env interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast proc~create_helper->proc~ncclgeterrorstring proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create~5->proc~destroy~5 proc~check_if_even check_if_even proc~create~5->proc~check_if_even proc~get_local_size get_local_size proc~create~5->proc~get_local_size interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy_helper->proc~write_message proc~destroy_helper->fname proc~destroy_helper->mpi_abort interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy proc~destroy_helper->proc~ncclgeterrorstring destroy destroy proc~destroy_plans->destroy proc~free_mem->interface~to_str proc~free_mem->proc~get_conf_log_enabled proc~free_mem->proc~write_message proc~free_mem->fname proc~free_mem->mpi_abort proc~free_mem->proc~is_backend_nccl proc~free_mem->proc~is_backend_nvshmem interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~mem_free_host mem_free_host proc~free_mem->interface~mem_free_host interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree nvshmem_free nvshmem_free proc~free_mem->nvshmem_free proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~free_mem->proc~ncclgeterrorstring proc~get_conf_datatype_enabled->interface~get_conf_internal proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_mpi_enabled->interface~get_conf_internal proc~get_conf_nvshmem_enabled->interface~get_conf_internal proc~get_conf_pipelined_enabled->interface~get_conf_internal proc~report_timings->mpi_comm_size proc~report_timings->interface~to_str proc~report_timings->proc~get_conf_log_enabled proc~report_timings->proc~write_message proc~report_timings->mpi_allreduce proc~run_autotune_datatypes->interface~to_str proc~run_autotune_datatypes->proc~get_conf_log_enabled proc~run_autotune_datatypes->proc~write_message proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_plan_execution_time get_plan_execution_time proc~autotune_transpose_id->proc~get_plan_execution_time proc~check_if_even->mpi_comm_size proc~check_if_even->mpi_allgather proc~create_subcomm_include_all->mpi_comm_size proc~create_subcomm create_subcomm proc~create_subcomm_include_all->proc~create_subcomm proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 proc~get_local_size->mpi_comm_size proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_allgather interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~ncclgeterrorstring->proc~string_c2f interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr mpi_comm_create mpi_comm_create proc~create_subcomm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_subcomm->mpi_comm_group mpi_group_free mpi_group_free proc~create_subcomm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_subcomm->mpi_group_incl proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string proc~get_plan_execution_time->interface~to_str proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~write_message proc~get_plan_execution_time->mpi_barrier proc~get_plan_execution_time->mpi_wtime proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~get_plan_execution_time->proc~report_timings proc~create~14 abstract_transpose_handle%create proc~get_plan_execution_time->proc~create~14 proc~destroy~13 transpose_handle_datatype%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_datatype%execute proc~get_plan_execution_time->proc~execute~11 create_private create_private proc~create~14->create_private proc~get_transpose_type get_transpose_type proc~create~14->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle proc~execute~11->mpi_comm_size mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_startall mpi_startall proc~execute~11->mpi_startall proc~execute_end~4 transpose_handle_datatype%execute_end proc~execute~11->proc~execute_end~4 mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free mpi_waitall mpi_waitall proc~execute_end~4->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~autotune_grid_decomposition~~CalledByGraph proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6 transpose_plan%create proc~create~6->proc~autotune_grid_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autotune_grid_decomposition.html"},{"title":"autotune_grid – dtFFT","text":"private  subroutine autotune_grid(platform, dims, transposed_dims, base_comm, effort, base_dtype, comm_dims, base_storage, stream, is_z_slab, best_forward_ids, best_backward_ids, backend, best_time, best_backend) Creates cartesian grid and runs various backends on it. Returns best backend and execution time Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to create plan for integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm Basic communicator to create 3d grid from type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int32), intent(in) :: comm_dims (:) Number of processors in each dimension integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use logical, intent(in) :: is_z_slab Is Z-slab optimization enabled integer(kind=int8), intent(inout) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(inout) :: best_backward_ids (:) Best Datatype ids for backward plan type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: best_time Elapsed time for best plan selected type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected for the grid Calls proc~~autotune_grid~~CallsGraph proc~autotune_grid autotune_grid interface~to_str to_str proc~autotune_grid->interface~to_str mpi_comm_free mpi_comm_free proc~autotune_grid->mpi_comm_free proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~destroy~5 pencil%destroy proc~autotune_grid->proc~destroy~5 proc~get_conf_log_enabled get_conf_log_enabled proc~autotune_grid->proc~get_conf_log_enabled proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~autotune_grid->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~write_message write_message proc~autotune_grid->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~5 pencil%create proc~create_pencils_and_comm->proc~create~5 interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~run_autotune_backend->proc~get_conf_log_enabled proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~write_message execute execute proc~run_autotune_backend->execute fname fname proc~run_autotune_backend->fname interface~cudaeventcreate cudaEventCreate proc~run_autotune_backend->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~run_autotune_backend->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~run_autotune_backend->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~run_autotune_backend->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~run_autotune_backend->interface~cudaeventsynchronize interface~cudastreamsynchronize cudaStreamSynchronize proc~run_autotune_backend->interface~cudastreamsynchronize mpi_abort mpi_abort proc~run_autotune_backend->mpi_abort mpi_barrier mpi_barrier proc~run_autotune_backend->mpi_barrier mpi_comm_size mpi_comm_size proc~run_autotune_backend->mpi_comm_size mpi_wtime mpi_wtime proc~run_autotune_backend->mpi_wtime proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_mem alloc_mem proc~run_autotune_backend->proc~alloc_mem proc~allocate_plans allocate_plans proc~run_autotune_backend->proc~allocate_plans proc~create_helper backend_helper%create_helper proc~run_autotune_backend->proc~create_helper proc~cudageterrorstring cudaGetErrorString proc~run_autotune_backend->proc~cudageterrorstring proc~destroy_helper backend_helper%destroy_helper proc~run_autotune_backend->proc~destroy_helper proc~destroy_plans destroy_plans proc~run_autotune_backend->proc~destroy_plans proc~dtfft_get_backend_string dtfft_get_backend_string proc~run_autotune_backend->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~run_autotune_backend->proc~dtfft_get_error_string proc~free_mem free_mem proc~run_autotune_backend->proc~free_mem proc~get_conf_datatype_enabled get_conf_datatype_enabled proc~run_autotune_backend->proc~get_conf_datatype_enabled proc~get_conf_measure_iters get_conf_measure_iters proc~run_autotune_backend->proc~get_conf_measure_iters proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~run_autotune_backend->proc~get_conf_measure_warmup_iters proc~get_conf_mpi_enabled get_conf_mpi_enabled proc~run_autotune_backend->proc~get_conf_mpi_enabled proc~get_conf_nvshmem_enabled get_conf_nvshmem_enabled proc~run_autotune_backend->proc~get_conf_nvshmem_enabled proc~get_conf_pipelined_enabled get_conf_pipelined_enabled proc~run_autotune_backend->proc~get_conf_pipelined_enabled proc~get_local_sizes get_local_sizes proc~run_autotune_backend->proc~get_local_sizes proc~is_backend_mpi is_backend_mpi proc~run_autotune_backend->proc~is_backend_mpi proc~is_backend_nccl is_backend_nccl proc~run_autotune_backend->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~run_autotune_backend->proc~is_backend_nvshmem proc~is_backend_pipelined is_backend_pipelined proc~run_autotune_backend->proc~is_backend_pipelined proc~report_timings report_timings proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~alloc_and_set_aux->mpi_abort proc~alloc_and_set_aux->proc~alloc_mem proc~alloc_and_set_aux->proc~dtfft_get_error_string mpi_allreduce mpi_allreduce proc~alloc_and_set_aux->mpi_allreduce proc~get_aux_size_generic get_aux_size_generic proc~alloc_and_set_aux->proc~get_aux_size_generic proc~alloc_mem->interface~to_str proc~alloc_mem->proc~get_conf_log_enabled proc~alloc_mem->proc~write_message proc~alloc_mem->fname proc~alloc_mem->mpi_abort proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~dtfft_get_backend_string proc~alloc_mem->proc~is_backend_nccl proc~alloc_mem->proc~is_backend_nvshmem interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr proc~alloc_mem->mpi_allreduce proc~mem_alloc_host mem_alloc_host proc~alloc_mem->proc~mem_alloc_host proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring temp temp proc~alloc_mem->temp proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_cart_comm->interface~to_str proc~create_cart_comm->mpi_comm_free mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup proc~create_subcomm_include_all create_subcomm_include_all proc~create_cart_comm->proc~create_subcomm_include_all proc~create_helper->fname proc~create_helper->mpi_abort proc~create_helper->mpi_comm_rank proc~create_helper->mpi_comm_size proc~create_helper->proc~destroy_helper interface~get_env get_env proc~create_helper->interface~get_env interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast proc~create_helper->proc~ncclgeterrorstring proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create~5->proc~destroy~5 proc~check_if_even check_if_even proc~create~5->proc~check_if_even proc~get_local_size get_local_size proc~create~5->proc~get_local_size interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy_helper->proc~write_message proc~destroy_helper->fname proc~destroy_helper->mpi_abort interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy proc~destroy_helper->proc~ncclgeterrorstring destroy destroy proc~destroy_plans->destroy proc~free_mem->interface~to_str proc~free_mem->proc~get_conf_log_enabled proc~free_mem->proc~write_message proc~free_mem->fname proc~free_mem->mpi_abort proc~free_mem->proc~is_backend_nccl proc~free_mem->proc~is_backend_nvshmem interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~mem_free_host mem_free_host proc~free_mem->interface~mem_free_host interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree nvshmem_free nvshmem_free proc~free_mem->nvshmem_free proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~free_mem->proc~ncclgeterrorstring proc~get_conf_datatype_enabled->interface~get_conf_internal proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_mpi_enabled->interface~get_conf_internal proc~get_conf_nvshmem_enabled->interface~get_conf_internal proc~get_conf_pipelined_enabled->interface~get_conf_internal proc~report_timings->interface~to_str proc~report_timings->proc~get_conf_log_enabled proc~report_timings->proc~write_message proc~report_timings->mpi_comm_size proc~report_timings->mpi_allreduce proc~run_autotune_datatypes->interface~to_str proc~run_autotune_datatypes->proc~get_conf_log_enabled proc~run_autotune_datatypes->proc~write_message proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~get_plan_execution_time get_plan_execution_time proc~autotune_transpose_id->proc~get_plan_execution_time proc~check_if_even->mpi_comm_size proc~check_if_even->mpi_allgather proc~create_subcomm_include_all->mpi_comm_size proc~create_subcomm create_subcomm proc~create_subcomm_include_all->proc~create_subcomm proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_comm_size proc~get_local_size->mpi_allgather interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~ncclgeterrorstring->proc~string_c2f interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr mpi_comm_create mpi_comm_create proc~create_subcomm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_subcomm->mpi_comm_group mpi_group_free mpi_group_free proc~create_subcomm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_subcomm->mpi_group_incl proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string proc~get_plan_execution_time->interface~to_str proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~write_message proc~get_plan_execution_time->mpi_barrier proc~get_plan_execution_time->mpi_wtime proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~get_plan_execution_time->proc~report_timings proc~create~14 abstract_transpose_handle%create proc~get_plan_execution_time->proc~create~14 proc~destroy~13 transpose_handle_datatype%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_datatype%execute proc~get_plan_execution_time->proc~execute~11 create_private create_private proc~create~14->create_private proc~get_transpose_type get_transpose_type proc~create~14->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle proc~execute~11->mpi_comm_size mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_startall mpi_startall proc~execute~11->mpi_startall proc~execute_end~4 transpose_handle_datatype%execute_end proc~execute~11->proc~execute_end~4 mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free mpi_waitall mpi_waitall proc~execute_end~4->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~autotune_grid~~CalledByGraph proc~autotune_grid autotune_grid proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~create~6 transpose_plan%create proc~create~6->proc~autotune_grid_decomposition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autotune_grid.html"},{"title":"run_autotune_backend – dtFFT","text":"private  subroutine run_autotune_backend(platform, comms, cart_comm, effort, base_dtype, pencils, base_storage, stream, is_z_slab, best_forward_ids, best_backward_ids, backend, best_time, best_backend) Uses iso_fortran_env iso_c_binding proc~~run_autotune_backend~~UsesGraph proc~run_autotune_backend run_autotune_backend iso_c_binding iso_c_binding proc~run_autotune_backend->iso_c_binding iso_fortran_env iso_fortran_env proc~run_autotune_backend->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Runs autotune for all backends\nSymmetric heap can be allocated after nvshmem_init, which is done during plan creation Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to create plan for type(MPI_Comm), intent(in) :: comms (:) 1D comms type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( dtfft_effort_t ), intent(in) :: effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype type( pencil ), intent(in) :: pencils (:) Source meta integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use logical, intent(in) :: is_z_slab Is Z-slab optimization enabled integer(kind=int8), intent(inout) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(inout) :: best_backward_ids (:) Best Datatype ids for backward plan type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: best_time Elapsed time for best backend type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected Calls proc~~run_autotune_backend~~CallsGraph proc~run_autotune_backend run_autotune_backend execute execute proc~run_autotune_backend->execute fname fname proc~run_autotune_backend->fname interface~cudaeventcreate cudaEventCreate proc~run_autotune_backend->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~run_autotune_backend->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~run_autotune_backend->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~run_autotune_backend->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~run_autotune_backend->interface~cudaeventsynchronize interface~cudastreamsynchronize cudaStreamSynchronize proc~run_autotune_backend->interface~cudastreamsynchronize mpi_abort mpi_abort proc~run_autotune_backend->mpi_abort mpi_barrier mpi_barrier proc~run_autotune_backend->mpi_barrier mpi_comm_size mpi_comm_size proc~run_autotune_backend->mpi_comm_size mpi_wtime mpi_wtime proc~run_autotune_backend->mpi_wtime proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_mem alloc_mem proc~run_autotune_backend->proc~alloc_mem proc~allocate_plans allocate_plans proc~run_autotune_backend->proc~allocate_plans proc~create_helper backend_helper%create_helper proc~run_autotune_backend->proc~create_helper proc~cudageterrorstring cudaGetErrorString proc~run_autotune_backend->proc~cudageterrorstring proc~destroy_helper backend_helper%destroy_helper proc~run_autotune_backend->proc~destroy_helper proc~destroy_plans destroy_plans proc~run_autotune_backend->proc~destroy_plans proc~dtfft_get_backend_string dtfft_get_backend_string proc~run_autotune_backend->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~run_autotune_backend->proc~dtfft_get_error_string proc~free_mem free_mem proc~run_autotune_backend->proc~free_mem proc~get_conf_datatype_enabled get_conf_datatype_enabled proc~run_autotune_backend->proc~get_conf_datatype_enabled proc~get_conf_log_enabled get_conf_log_enabled proc~run_autotune_backend->proc~get_conf_log_enabled proc~get_conf_measure_iters get_conf_measure_iters proc~run_autotune_backend->proc~get_conf_measure_iters proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~run_autotune_backend->proc~get_conf_measure_warmup_iters proc~get_conf_mpi_enabled get_conf_mpi_enabled proc~run_autotune_backend->proc~get_conf_mpi_enabled proc~get_conf_nvshmem_enabled get_conf_nvshmem_enabled proc~run_autotune_backend->proc~get_conf_nvshmem_enabled proc~get_conf_pipelined_enabled get_conf_pipelined_enabled proc~run_autotune_backend->proc~get_conf_pipelined_enabled proc~get_local_sizes get_local_sizes proc~run_autotune_backend->proc~get_local_sizes proc~is_backend_mpi is_backend_mpi proc~run_autotune_backend->proc~is_backend_mpi proc~is_backend_nccl is_backend_nccl proc~run_autotune_backend->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~run_autotune_backend->proc~is_backend_nvshmem proc~is_backend_pipelined is_backend_pipelined proc~run_autotune_backend->proc~is_backend_pipelined proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~report_timings report_timings proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~write_message write_message proc~run_autotune_backend->proc~write_message proc~alloc_and_set_aux->mpi_abort proc~alloc_and_set_aux->proc~alloc_mem proc~alloc_and_set_aux->proc~dtfft_get_error_string mpi_allreduce mpi_allreduce proc~alloc_and_set_aux->mpi_allreduce proc~get_aux_size_generic get_aux_size_generic proc~alloc_and_set_aux->proc~get_aux_size_generic proc~alloc_mem->fname proc~alloc_mem->mpi_abort proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~dtfft_get_backend_string proc~alloc_mem->proc~get_conf_log_enabled proc~alloc_mem->proc~is_backend_nccl proc~alloc_mem->proc~is_backend_nvshmem proc~alloc_mem->proc~write_message interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc interface~to_str to_str proc~alloc_mem->interface~to_str is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr proc~alloc_mem->mpi_allreduce proc~mem_alloc_host mem_alloc_host proc~alloc_mem->proc~mem_alloc_host proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring temp temp proc~alloc_mem->temp proc~create_helper->fname proc~create_helper->mpi_abort proc~create_helper->mpi_comm_size proc~create_helper->proc~destroy_helper interface~get_env get_env proc~create_helper->interface~get_env interface~ncclcomminitrank ncclCommInitRank proc~create_helper->interface~ncclcomminitrank interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper->interface~ncclgetuniqueid mpi_allgather mpi_allgather proc~create_helper->mpi_allgather mpi_bcast mpi_bcast proc~create_helper->mpi_bcast mpi_comm_rank mpi_comm_rank proc~create_helper->mpi_comm_rank proc~create_helper->proc~ncclgeterrorstring interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy_helper->fname proc~destroy_helper->mpi_abort proc~destroy_helper->proc~write_message interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper->interface~ncclcommdestroy proc~destroy_helper->proc~ncclgeterrorstring destroy destroy proc~destroy_plans->destroy proc~free_mem->fname proc~free_mem->mpi_abort proc~free_mem->proc~get_conf_log_enabled proc~free_mem->proc~is_backend_nccl proc~free_mem->proc~is_backend_nvshmem proc~free_mem->proc~write_message interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~mem_free_host mem_free_host proc~free_mem->interface~mem_free_host interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree proc~free_mem->interface~to_str nvshmem_free nvshmem_free proc~free_mem->nvshmem_free proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~free_mem->proc~ncclgeterrorstring interface~get_conf_internal get_conf_internal proc~get_conf_datatype_enabled->interface~get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_mpi_enabled->interface~get_conf_internal proc~get_conf_nvshmem_enabled->interface~get_conf_internal proc~get_conf_pipelined_enabled->interface~get_conf_internal interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~report_timings->mpi_comm_size proc~report_timings->proc~get_conf_log_enabled proc~report_timings->proc~write_message proc~report_timings->interface~to_str proc~report_timings->mpi_allreduce proc~run_autotune_datatypes->proc~get_conf_log_enabled proc~run_autotune_datatypes->proc~write_message proc~run_autotune_datatypes->interface~to_str proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~get_plan_execution_time get_plan_execution_time proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~ncclgeterrorstring->proc~string_c2f interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->proc~write_message proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string proc~get_plan_execution_time->mpi_barrier proc~get_plan_execution_time->mpi_wtime proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~get_plan_execution_time->proc~report_timings proc~get_plan_execution_time->proc~write_message proc~get_plan_execution_time->interface~to_str proc~create~14 abstract_transpose_handle%create proc~get_plan_execution_time->proc~create~14 proc~destroy~13 transpose_handle_datatype%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_datatype%execute proc~get_plan_execution_time->proc~execute~11 create_private create_private proc~create~14->create_private proc~get_transpose_type get_transpose_type proc~create~14->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle proc~execute~11->mpi_comm_size mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_startall mpi_startall proc~execute~11->mpi_startall proc~execute_end~4 transpose_handle_datatype%execute_end proc~execute~11->proc~execute_end~4 mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free mpi_waitall mpi_waitall proc~execute_end~4->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_autotune_backend~~CalledByGraph proc~run_autotune_backend run_autotune_backend proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/run_autotune_backend.html"},{"title":"run_autotune_datatypes – dtFFT","text":"private  subroutine run_autotune_datatypes(helper, base_dtype, pencils, base_storage, is_z_slab, best_forward_ids, best_backward_ids, a, b, elapsed_time) Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype type( pencil ), intent(in) :: pencils (:) Source meta integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_z_slab Is Z-slab optimization enabled integer(kind=int8), intent(out) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(out) :: best_backward_ids (:) Best Datatype ids for backward plan real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer real(kind=real32), intent(out) :: elapsed_time Elapsed time for best plans selected in [ms] Calls proc~~run_autotune_datatypes~~CallsGraph proc~run_autotune_datatypes run_autotune_datatypes interface~to_str to_str proc~run_autotune_datatypes->interface~to_str proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~get_conf_log_enabled get_conf_log_enabled proc~run_autotune_datatypes->proc~get_conf_log_enabled proc~write_message write_message proc~run_autotune_datatypes->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~get_plan_execution_time get_plan_execution_time proc~autotune_transpose_id->proc~get_plan_execution_time interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~get_plan_execution_time->interface~to_str proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_plan_execution_time->proc~write_message mpi_barrier mpi_barrier proc~get_plan_execution_time->mpi_barrier mpi_wtime mpi_wtime proc~get_plan_execution_time->mpi_wtime proc~create~14 abstract_transpose_handle%create proc~get_plan_execution_time->proc~create~14 proc~destroy~13 transpose_handle_datatype%destroy proc~get_plan_execution_time->proc~destroy~13 proc~execute~11 transpose_handle_datatype%execute proc~get_plan_execution_time->proc~execute~11 proc~get_conf_measure_iters get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings create_private create_private proc~create~14->create_private proc~get_transpose_type get_transpose_type proc~create~14->proc~get_transpose_type mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_comm_size mpi_comm_size proc~execute~11->mpi_comm_size mpi_startall mpi_startall proc~execute~11->mpi_startall proc~execute_end~4 transpose_handle_datatype%execute_end proc~execute~11->proc~execute_end~4 proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~report_timings->interface~to_str proc~report_timings->proc~get_conf_log_enabled proc~report_timings->proc~write_message mpi_allreduce mpi_allreduce proc~report_timings->mpi_allreduce proc~report_timings->mpi_comm_size proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free mpi_waitall mpi_waitall proc~execute_end~4->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_autotune_datatypes~~CalledByGraph proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/run_autotune_datatypes.html"},{"title":"alloc_and_set_aux – dtFFT","text":"private  subroutine alloc_and_set_aux(platform, helper, backend, cart_comm, aux, paux, plans, is_aux_alloc) Uses iso_fortran_env proc~~alloc_and_set_aux~~UsesGraph proc~alloc_and_set_aux alloc_and_set_aux iso_fortran_env iso_fortran_env proc~alloc_and_set_aux->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Allocates auxiliary memory according to the backend and sets it to the plans Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(MPI_Comm), intent(in) :: cart_comm Cartesian communicator type(c_ptr), intent(inout) :: aux Allocatable auxiliary memory real(kind=real32), intent(inout), pointer :: paux (:) Pointer to auxiliary memory type( plan_t ), intent(in) :: plans (:) logical :: is_aux_alloc Is auxiliary memory allocated Calls proc~~alloc_and_set_aux~~CallsGraph proc~alloc_and_set_aux alloc_and_set_aux mpi_abort mpi_abort proc~alloc_and_set_aux->mpi_abort mpi_allreduce mpi_allreduce proc~alloc_and_set_aux->mpi_allreduce proc~alloc_mem alloc_mem proc~alloc_and_set_aux->proc~alloc_mem proc~dtfft_get_error_string dtfft_get_error_string proc~alloc_and_set_aux->proc~dtfft_get_error_string proc~get_aux_size_generic get_aux_size_generic proc~alloc_and_set_aux->proc~get_aux_size_generic proc~alloc_mem->mpi_abort proc~alloc_mem->mpi_allreduce fname fname proc~alloc_mem->fname interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc interface~to_str to_str proc~alloc_mem->interface~to_str is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr proc~cudageterrorstring cudaGetErrorString proc~alloc_mem->proc~cudageterrorstring proc~dtfft_get_backend_string dtfft_get_backend_string proc~alloc_mem->proc~dtfft_get_backend_string proc~get_conf_log_enabled get_conf_log_enabled proc~alloc_mem->proc~get_conf_log_enabled proc~is_backend_nccl is_backend_nccl proc~alloc_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~alloc_mem->proc~is_backend_nvshmem proc~mem_alloc_host mem_alloc_host proc~alloc_mem->proc~mem_alloc_host proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring proc~write_message write_message proc~alloc_mem->proc~write_message temp temp proc~alloc_mem->temp proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_and_set_aux~~CalledByGraph proc~alloc_and_set_aux alloc_and_set_aux proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/alloc_and_set_aux.html"},{"title":"create_pencils_and_comm – dtFFT","text":"private  subroutine create_pencils_and_comm(transposed_dims, old_comm, comm_dims, comm, local_comms, pencils, ipencil) Creates cartesian communicator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: transposed_dims (:,:) Global counts in transposed coordinates type(MPI_Comm), intent(in) :: old_comm Communicator to create cartesian from integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type(MPI_Comm), intent(out) :: comm Cartesian communicator type(MPI_Comm), intent(out) :: local_comms (:) 1d communicators in cartesian communicator type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Pencil passed by user Calls proc~~create_pencils_and_comm~~CallsGraph proc~create_pencils_and_comm create_pencils_and_comm lcounts lcounts proc~create_pencils_and_comm->lcounts lstarts lstarts proc~create_pencils_and_comm->lstarts proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~create~5 pencil%create proc~create_pencils_and_comm->proc~create~5 interface~to_str to_str proc~create_cart_comm->interface~to_str mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup mpi_comm_free mpi_comm_free proc~create_cart_comm->mpi_comm_free proc~create_subcomm_include_all create_subcomm_include_all proc~create_cart_comm->proc~create_subcomm_include_all proc~check_if_even check_if_even proc~create~5->proc~check_if_even proc~destroy~5 pencil%destroy proc~create~5->proc~destroy~5 proc~get_local_size get_local_size proc~create~5->proc~get_local_size proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string mpi_allgather mpi_allgather proc~check_if_even->mpi_allgather mpi_comm_size mpi_comm_size proc~check_if_even->mpi_comm_size proc~create_subcomm_include_all->mpi_comm_size proc~create_subcomm create_subcomm proc~create_subcomm_include_all->proc~create_subcomm proc~get_local_size->mpi_allgather mpi_comm_rank mpi_comm_rank proc~get_local_size->mpi_comm_rank proc~get_local_size->mpi_comm_size mpi_comm_create mpi_comm_create proc~create_subcomm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_subcomm->mpi_comm_group mpi_group_free mpi_group_free proc~create_subcomm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_subcomm->mpi_group_incl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_pencils_and_comm~~CalledByGraph proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~create~6 transpose_plan%create proc~create~6->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_pencils_and_comm.html"},{"title":"create_cart_comm – dtFFT","text":"private  subroutine create_cart_comm(old_comm, comm_dims, comm, local_comms, ipencil) Creates cartesian communicator Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: old_comm Communicator to create cartesian from integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type(MPI_Comm), intent(out) :: comm Cartesian communicator type(MPI_Comm), intent(out) :: local_comms (:) 1d communicators in cartesian communicator type( pencil_init ), intent(in), optional :: ipencil Pencil passed by user Calls proc~~create_cart_comm~~CallsGraph proc~create_cart_comm create_cart_comm interface~to_str to_str proc~create_cart_comm->interface~to_str mpi_cart_create mpi_cart_create proc~create_cart_comm->mpi_cart_create mpi_cart_sub mpi_cart_sub proc~create_cart_comm->mpi_cart_sub mpi_comm_dup mpi_comm_dup proc~create_cart_comm->mpi_comm_dup mpi_comm_free mpi_comm_free proc~create_cart_comm->mpi_comm_free proc~create_subcomm_include_all create_subcomm_include_all proc~create_cart_comm->proc~create_subcomm_include_all proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string mpi_comm_size mpi_comm_size proc~create_subcomm_include_all->mpi_comm_size proc~create_subcomm create_subcomm proc~create_subcomm_include_all->proc~create_subcomm mpi_comm_create mpi_comm_create proc~create_subcomm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_subcomm->mpi_comm_group mpi_group_free mpi_group_free proc~create_subcomm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_subcomm->mpi_group_incl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_cart_comm~~CalledByGraph proc~create_cart_comm create_cart_comm proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~create~6 transpose_plan%create proc~create~6->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_cart_comm.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(self, comm, alloc_bytes, ptr, error_code) Allocates memory based on selected backend Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code Calls proc~~mem_alloc~3~~CallsGraph proc~mem_alloc~3 transpose_plan%mem_alloc proc~alloc_mem alloc_mem proc~mem_alloc~3->proc~alloc_mem fname fname proc~alloc_mem->fname interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc interface~to_str to_str proc~alloc_mem->interface~to_str is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr mpi_abort mpi_abort proc~alloc_mem->mpi_abort mpi_allreduce mpi_allreduce proc~alloc_mem->mpi_allreduce proc~cudageterrorstring cudaGetErrorString proc~alloc_mem->proc~cudageterrorstring proc~dtfft_get_backend_string dtfft_get_backend_string proc~alloc_mem->proc~dtfft_get_backend_string proc~get_conf_log_enabled get_conf_log_enabled proc~alloc_mem->proc~get_conf_log_enabled proc~is_backend_nccl is_backend_nccl proc~alloc_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~alloc_mem->proc~is_backend_nvshmem proc~mem_alloc_host mem_alloc_host proc~alloc_mem->proc~mem_alloc_host proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring proc~write_message write_message proc~alloc_mem->proc~write_message temp temp proc~alloc_mem->temp proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc~3.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(self, ptr, error_code) Frees memory allocated with mem_alloc Type Bound transpose_plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code Calls proc~~mem_free~3~~CallsGraph proc~mem_free~3 transpose_plan%mem_free proc~free_mem free_mem proc~mem_free~3->proc~free_mem fname fname proc~free_mem->fname interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~mem_free_host mem_free_host proc~free_mem->interface~mem_free_host interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~to_str to_str proc~free_mem->interface~to_str mpi_abort mpi_abort proc~free_mem->mpi_abort nvshmem_free nvshmem_free proc~free_mem->nvshmem_free proc~get_conf_log_enabled get_conf_log_enabled proc~free_mem->proc~get_conf_log_enabled proc~is_backend_nccl is_backend_nccl proc~free_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~free_mem->proc~is_backend_nvshmem proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~ncclgeterrorstring ncclGetErrorString proc~free_mem->proc~ncclgeterrorstring proc~write_message write_message proc~free_mem->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mem_free~3~~CalledByGraph proc~mem_free~3 transpose_plan%mem_free proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_free~3.html"},{"title":"alloc_mem – dtFFT","text":"private  subroutine alloc_mem(platform, helper, backend, comm, alloc_bytes, ptr, error_code) Uses iso_fortran_env iso_c_binding proc~~alloc_mem~~UsesGraph proc~alloc_mem alloc_mem iso_c_binding iso_c_binding proc~alloc_mem->iso_c_binding iso_fortran_env iso_fortran_env proc~alloc_mem->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Allocates memory based on backend Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code Calls proc~~alloc_mem~~CallsGraph proc~alloc_mem alloc_mem fname fname proc~alloc_mem->fname interface~cudamalloc cudaMalloc proc~alloc_mem->interface~cudamalloc interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem->interface~cudamemgetinfo interface~ncclcommregister ncclCommRegister proc~alloc_mem->interface~ncclcommregister interface~ncclmemalloc ncclMemAlloc proc~alloc_mem->interface~ncclmemalloc interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem->interface~nvshmem_malloc interface~to_str to_str proc~alloc_mem->interface~to_str is_null_ptr is_null_ptr proc~alloc_mem->is_null_ptr mpi_abort mpi_abort proc~alloc_mem->mpi_abort mpi_allreduce mpi_allreduce proc~alloc_mem->mpi_allreduce proc~cudageterrorstring cudaGetErrorString proc~alloc_mem->proc~cudageterrorstring proc~dtfft_get_backend_string dtfft_get_backend_string proc~alloc_mem->proc~dtfft_get_backend_string proc~get_conf_log_enabled get_conf_log_enabled proc~alloc_mem->proc~get_conf_log_enabled proc~is_backend_nccl is_backend_nccl proc~alloc_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~alloc_mem->proc~is_backend_nvshmem proc~mem_alloc_host mem_alloc_host proc~alloc_mem->proc~mem_alloc_host proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem->proc~ncclgeterrorstring proc~write_message write_message proc~alloc_mem->proc~write_message temp temp proc~alloc_mem->temp proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_mem~~CalledByGraph proc~alloc_mem alloc_mem proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/alloc_mem.html"},{"title":"free_mem – dtFFT","text":"private  subroutine free_mem(platform, helper, backend, ptr, error_code) Uses iso_fortran_env iso_c_binding proc~~free_mem~~UsesGraph proc~free_mem free_mem iso_c_binding iso_c_binding proc~free_mem->iso_c_binding iso_fortran_env iso_fortran_env proc~free_mem->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Frees memory based on backend Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code Calls proc~~free_mem~~CallsGraph proc~free_mem free_mem fname fname proc~free_mem->fname interface~cudafree cudaFree proc~free_mem->interface~cudafree interface~mem_free_host mem_free_host proc~free_mem->interface~mem_free_host interface~ncclcommderegister ncclCommDeregister proc~free_mem->interface~ncclcommderegister interface~ncclmemfree ncclMemFree proc~free_mem->interface~ncclmemfree interface~to_str to_str proc~free_mem->interface~to_str mpi_abort mpi_abort proc~free_mem->mpi_abort nvshmem_free nvshmem_free proc~free_mem->nvshmem_free proc~get_conf_log_enabled get_conf_log_enabled proc~free_mem->proc~get_conf_log_enabled proc~is_backend_nccl is_backend_nccl proc~free_mem->proc~is_backend_nccl proc~is_backend_nvshmem is_backend_nvshmem proc~free_mem->proc~is_backend_nvshmem proc~is_same_ptr is_same_ptr proc~free_mem->proc~is_same_ptr proc~ncclgeterrorstring ncclGetErrorString proc~free_mem->proc~ncclgeterrorstring proc~write_message write_message proc~free_mem->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~free_mem~~CalledByGraph proc~free_mem free_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/free_mem.html"},{"title":"get_async_active – dtFFT","text":"private elemental function get_async_active(self) Type Bound transpose_handle_generic Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(in) :: self Generic Transpose Handle Return Value logical Calls proc~~get_async_active~3~~CallsGraph proc~get_async_active~3 transpose_handle_generic%get_async_active proc~get_async_active abstract_backend%get_async_active proc~get_async_active~3->proc~get_async_active Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_async_active~3.html"},{"title":"get_aux_size – dtFFT","text":"private pure function get_aux_size(self) Returns number of bytes required by aux buffer Type Bound transpose_handle_generic Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(in) :: self Generic Transpose Handle Return Value integer(kind=int64) Calls proc~~get_aux_size~3~~CallsGraph proc~get_aux_size~3 transpose_handle_generic%get_aux_size proc~get_aux_size abstract_backend%get_aux_size proc~get_aux_size~3->proc~get_aux_size Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_aux_size~3.html"},{"title":"create_data_handle – dtFFT","text":"private  subroutine create_data_handle(self, info, comm, comm_size) Creates handle Type Bound data_handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class type( pencil ), intent(in) :: info Pencil info type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int32), intent(in) :: comm_size Size of comm Calls proc~~create_data_handle~~CallsGraph proc~create_data_handle data_handle%create_data_handle mpi_allgather mpi_allgather proc~create_data_handle->mpi_allgather Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_data_handle.html"},{"title":"destroy_data_handle – dtFFT","text":"private  subroutine destroy_data_handle(self) Destroys handle Type Bound data_handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class","tags":"","loc":"proc/destroy_data_handle.html"},{"title":"check_if_overflow – dtFFT","text":"private  subroutine check_if_overflow(sizes) Checks if product of sizes fits into integer(int32) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: sizes (:) Sizes to check Called by proc~~check_if_overflow~~CalledByGraph proc~check_if_overflow check_if_overflow proc~create~7 transpose_handle_generic%create proc~create~7->proc~check_if_overflow Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/check_if_overflow.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, comm, send, recv, transpose_type, base_storage, kwargs) Creates Generic Transpose Handle Type Bound transpose_handle_generic Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle type(MPI_Comm), intent(in) :: comm MPI Communicator type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Base storage type( create_args ), intent(in) :: kwargs Additional arguments Calls proc~~create~7~~CallsGraph proc~create~7 transpose_handle_generic%create mpi_comm_rank mpi_comm_rank proc~create~7->mpi_comm_rank mpi_comm_size mpi_comm_size proc~create~7->mpi_comm_size mpi_irecv mpi_irecv proc~create~7->mpi_irecv mpi_isend mpi_isend proc~create~7->mpi_isend mpi_wait mpi_wait proc~create~7->mpi_wait proc~check_if_overflow check_if_overflow proc~create~7->proc~check_if_overflow proc~create~16 abstract_kernel%create proc~create~7->proc~create~16 proc~destroy~8 transpose_handle_generic%destroy proc~create~7->proc~destroy~8 proc~is_backend_cufftmp is_backend_cufftmp proc~create~7->proc~is_backend_cufftmp proc~is_backend_mpi is_backend_mpi proc~create~7->proc~is_backend_mpi proc~is_backend_nccl is_backend_nccl proc~create~7->proc~is_backend_nccl proc~is_backend_pipelined is_backend_pipelined proc~create~7->proc~is_backend_pipelined proc~set_unpack_kernel abstract_backend%set_unpack_kernel proc~create~7->proc~set_unpack_kernel create_private create_private proc~create~16->create_private proc~destroy~15 abstract_kernel%destroy proc~create~16->proc~destroy~15 proc~get_kernel_string get_kernel_string proc~create~16->proc~get_kernel_string proc~destroy~8->proc~destroy~15 destroy_private destroy_private proc~destroy~15->destroy_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~7.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, kwargs, error_code) Executes transpose - exchange - unpack Type Bound transpose_handle_generic Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code Calls proc~~execute~6~~CallsGraph proc~execute~6 transpose_handle_generic%execute proc~execute~13 abstract_kernel%execute proc~execute~6->proc~execute~13 execute_private execute_private proc~execute~13->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~13->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~13->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~6.html"},{"title":"execute_end – dtFFT","text":"private  subroutine execute_end(self, kwargs, error_code) Ends execution of transposition Type Bound transpose_handle_generic Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code Calls proc~~execute_end~3~~CallsGraph proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end abstract_backend%execute_end proc~execute_end~3->proc~execute_end proc~execute~13 abstract_kernel%execute proc~execute_end~3->proc~execute~13 execute_private execute_private proc~execute~13->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~13->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~13->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_end~3.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys Generic Transpose Handle Type Bound transpose_handle_generic Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle Calls proc~~destroy~8~~CallsGraph proc~destroy~8 transpose_handle_generic%destroy proc~destroy~15 abstract_kernel%destroy proc~destroy~8->proc~destroy~15 destroy_private destroy_private proc~destroy~15->destroy_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy~8~~CalledByGraph proc~destroy~8 transpose_handle_generic%destroy proc~create~7 transpose_handle_generic%create proc~create~7->proc~destroy~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~8.html"},{"title":"get_ampere_architecture – dtFFT","text":"public  function get_ampere_architecture() result(props) Ampere architecture (Compute Capability 8.0) Arguments None Return Value type( device_props ) Ampere architecture properties","tags":"","loc":"proc/get_ampere_architecture.html"},{"title":"get_volta_architecture – dtFFT","text":"public  function get_volta_architecture() result(props) Volta architecture (Compute Capability 7.0) Arguments None Return Value type( device_props ) Volta architecture properties","tags":"","loc":"proc/get_volta_architecture.html"},{"title":"count_bank_conflicts – dtFFT","text":"public pure function count_bank_conflicts(tile_size, block_rows, base_storage, padding) result(total_conflicts) Counts bank conflicts for a given tile size, padding, element size, and block rows. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: tile_size Size of the tile integer(kind=int32), intent(in) :: block_rows Number of rows in the block integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: padding Padding added to the tile Return Value integer(kind=int32) Total number of bank conflicts Called by proc~~count_bank_conflicts~~CalledByGraph proc~count_bank_conflicts count_bank_conflicts proc~estimate_bank_conflict_ratio estimate_bank_conflict_ratio proc~estimate_bank_conflict_ratio->proc~count_bank_conflicts proc~estimate_optimal_padding estimate_optimal_padding proc~estimate_optimal_padding->proc~count_bank_conflicts proc~evaluate_analytical_performance evaluate_analytical_performance proc~evaluate_analytical_performance->proc~count_bank_conflicts proc~evaluate_analytical_performance->proc~estimate_bank_conflict_ratio proc~generate_candidates generate_candidates proc~generate_candidates->proc~estimate_optimal_padding proc~get_kernel get_kernel proc~get_kernel->proc~evaluate_analytical_performance proc~get_kernel->proc~generate_candidates proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/count_bank_conflicts.html"},{"title":"evaluate_analytical_performance – dtFFT","text":"public  function evaluate_analytical_performance(dims, tile_dim, other_dim, kernel_type, config, props, base_storage, neighbor_data) result(score) This function evaluates the performance of a kernel configuration\nbased on various architectural and problem-specific parameters. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Problem dimensions integer(kind=int32), intent(in) :: tile_dim Tile dimension integer(kind=int32), intent(in) :: other_dim Other dimension (not tiled) type( kernel_type_t ), intent(in) :: kernel_type Type of kernel_type to evaluate type( kernel_config ), intent(in) :: config Kernel configuration type( device_props ), intent(in) :: props GPU architecture properties integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in), optional :: neighbor_data (:) Neighboring data dimensions for pipelined kernels Return Value real(kind=real32) Performance score Calls proc~~evaluate_analytical_performance~~CallsGraph proc~evaluate_analytical_performance evaluate_analytical_performance proc~count_bank_conflicts count_bank_conflicts proc~evaluate_analytical_performance->proc~count_bank_conflicts proc~estimate_bank_conflict_ratio estimate_bank_conflict_ratio proc~evaluate_analytical_performance->proc~estimate_bank_conflict_ratio proc~estimate_coalescing estimate_coalescing proc~evaluate_analytical_performance->proc~estimate_coalescing proc~estimate_occupancy estimate_occupancy proc~evaluate_analytical_performance->proc~estimate_occupancy proc~estimate_bank_conflict_ratio->proc~count_bank_conflicts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~evaluate_analytical_performance~~CalledByGraph proc~evaluate_analytical_performance evaluate_analytical_performance proc~get_kernel get_kernel proc~get_kernel->proc~evaluate_analytical_performance proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/evaluate_analytical_performance.html"},{"title":"estimate_optimal_padding – dtFFT","text":"private pure function estimate_optimal_padding(tile_size, block_rows, base_storage) result(padding) Estimates the optimal padding for a given tile size and element size Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: tile_size Size of the tile integer(kind=int32), intent(in) :: block_rows Number of rows in the block integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value integer(kind=int32) Optimal padding to reduce bank conflicts Calls proc~~estimate_optimal_padding~~CallsGraph proc~estimate_optimal_padding estimate_optimal_padding proc~count_bank_conflicts count_bank_conflicts proc~estimate_optimal_padding->proc~count_bank_conflicts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~estimate_optimal_padding~~CalledByGraph proc~estimate_optimal_padding estimate_optimal_padding proc~generate_candidates generate_candidates proc~generate_candidates->proc~estimate_optimal_padding proc~get_kernel get_kernel proc~get_kernel->proc~generate_candidates proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/estimate_optimal_padding.html"},{"title":"estimate_bank_conflict_ratio – dtFFT","text":"private pure function estimate_bank_conflict_ratio(config, base_storage) result(ratio) Estimates the bank conflict ratio for a given kernel configuration Arguments Type Intent Optional Attributes Name type( kernel_config ), intent(in) :: config Kernel configuration integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value real(kind=real32) Bank conflict estimation Calls proc~~estimate_bank_conflict_ratio~~CallsGraph proc~estimate_bank_conflict_ratio estimate_bank_conflict_ratio proc~count_bank_conflicts count_bank_conflicts proc~estimate_bank_conflict_ratio->proc~count_bank_conflicts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~estimate_bank_conflict_ratio~~CalledByGraph proc~estimate_bank_conflict_ratio estimate_bank_conflict_ratio proc~evaluate_analytical_performance evaluate_analytical_performance proc~evaluate_analytical_performance->proc~estimate_bank_conflict_ratio proc~get_kernel get_kernel proc~get_kernel->proc~evaluate_analytical_performance proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/estimate_bank_conflict_ratio.html"},{"title":"estimate_occupancy – dtFFT","text":"private pure function estimate_occupancy(config, props, base_storage) result(occupancy) Calculates theoretical occupancy for a given kernel configuration Arguments Type Intent Optional Attributes Name type( kernel_config ), intent(in) :: config Kernel configuration type( device_props ), intent(in) :: props GPU architecture properties integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value real(kind=real32) Estimated occupancy Called by proc~~estimate_occupancy~~CalledByGraph proc~estimate_occupancy estimate_occupancy proc~evaluate_analytical_performance evaluate_analytical_performance proc~evaluate_analytical_performance->proc~estimate_occupancy proc~get_kernel get_kernel proc~get_kernel->proc~evaluate_analytical_performance proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/estimate_occupancy.html"},{"title":"estimate_memory_pressure – dtFFT","text":"private  function estimate_memory_pressure(dims, tile_dim, other_dim, base_storage, props) result(pressure) Analytical estimation of memory pressure based on GPU architecture Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Size of the problem integer(kind=int32), intent(in) :: tile_dim Tile dimension integer(kind=int32), intent(in) :: other_dim Other dimension (not tiled) integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( device_props ), intent(in) :: props GPU architecture properties Return Value real(kind=real32) Pressure metric Called by proc~~estimate_memory_pressure~~CalledByGraph proc~estimate_memory_pressure estimate_memory_pressure proc~generate_candidates generate_candidates proc~generate_candidates->proc~estimate_memory_pressure proc~get_kernel get_kernel proc~get_kernel->proc~generate_candidates proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/estimate_memory_pressure.html"},{"title":"estimate_coalescing – dtFFT","text":"private  function estimate_coalescing(dims, tile_dim, other_dim, kernel_type, config, base_storage, neighbor_data) result(score) Estimate memory coalescing efficiency for a given kernel configuration and transpose type Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Local dimensions of the input data integer(kind=int32), intent(in) :: tile_dim Tile dimension integer(kind=int32), intent(in) :: other_dim Other dimension (not tiled) type( kernel_type_t ), intent(in) :: kernel_type Type of kernel type( kernel_config ), intent(in) :: config Kernel configuration integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in), optional :: neighbor_data (:) Neighboring data dimensions for pipelined kernels Return Value real(kind=real32) Coalescing score Called by proc~~estimate_coalescing~~CalledByGraph proc~estimate_coalescing estimate_coalescing proc~evaluate_analytical_performance evaluate_analytical_performance proc~evaluate_analytical_performance->proc~estimate_coalescing proc~get_kernel get_kernel proc~get_kernel->proc~evaluate_analytical_performance proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/estimate_coalescing.html"},{"title":"generate_candidates – dtFFT","text":"public  subroutine generate_candidates(dims, tile_dim, other_dim, base_storage, props, candidates, num_candidates) Generate kernel configuration candidates for given problem Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Local dimensions of the input data, always 3D integer(kind=int32), intent(in) :: tile_dim Tile dimension integer(kind=int32), intent(in) :: other_dim Other dimension (not tiled) integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( device_props ), intent(in) :: props GPU architecture properties type( kernel_config ), intent(out) :: candidates (:) Generated kernel configurations integer(kind=int32), intent(out) :: num_candidates Number of generated candidates Calls proc~~generate_candidates~~CallsGraph proc~generate_candidates generate_candidates proc~estimate_memory_pressure estimate_memory_pressure proc~generate_candidates->proc~estimate_memory_pressure proc~estimate_optimal_padding estimate_optimal_padding proc~generate_candidates->proc~estimate_optimal_padding proc~find_valid_combination find_valid_combination proc~generate_candidates->proc~find_valid_combination proc~count_bank_conflicts count_bank_conflicts proc~estimate_optimal_padding->proc~count_bank_conflicts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_candidates~~CalledByGraph proc~generate_candidates generate_candidates proc~get_kernel get_kernel proc~get_kernel->proc~generate_candidates proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_candidates.html"},{"title":"sort_candidates_by_score – dtFFT","text":"public  subroutine sort_candidates_by_score(scores, num_candidates, sorted_indices) Sorting candidates by their performance scores Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scores (:) Performance scores of candidates generated by evaluate_analytical_performance integer(kind=int32), intent(in) :: num_candidates Number of candidates integer(kind=int32), intent(out) :: sorted_indices (:) Sorted indices of candidates Called by proc~~sort_candidates_by_score~~CalledByGraph proc~sort_candidates_by_score sort_candidates_by_score proc~get_kernel get_kernel proc~get_kernel->proc~sort_candidates_by_score proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/sort_candidates_by_score.html"},{"title":"find_valid_combination – dtFFT","text":"private  subroutine find_valid_combination(base_tile, base_rows) This subroutine optimizes the tile size and number of rows for narrow matrices\nby adjusting them to be compatible with the warp size. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: base_tile < Tile size integer(kind=int32), intent(inout) :: base_rows < Number of rows Called by proc~~find_valid_combination~~CalledByGraph proc~find_valid_combination find_valid_combination proc~generate_candidates generate_candidates proc~generate_candidates->proc~find_valid_combination proc~get_kernel get_kernel proc~get_kernel->proc~generate_candidates proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/find_valid_combination.html"},{"title":"dtfft_get_error_string – dtFFT","text":"public pure function dtfft_get_error_string(error_code) result(error_string) Gets the string description of an error code Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: error_code Error code Return Value character(len=:), allocatable Error string Called by proc~~dtfft_get_error_string~~CalledByGraph proc~dtfft_get_error_string dtfft_get_error_string proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~dtfft_get_error_string proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~dtfft_get_error_string proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~dtfft_get_error_string proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~dtfft_get_error_string proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~dtfft_get_error_string proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~dtfft_get_error_string proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~dtfft_get_error_string proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~dtfft_get_error_string proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~dtfft_get_error_string proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~dtfft_get_error_string proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~6->proc~mem_free_ptr proc~dtfft_get_error_string_c dtfft_get_error_string_c proc~dtfft_get_error_string_c->proc~dtfft_get_error_string proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~dtfft_get_error_string proc~get_alloc_bytes->proc~get_element_size proc~get_alloc_bytes->proc~get_alloc_size proc~get_backend dtfft_plan_t%get_backend proc~get_backend->proc~dtfft_get_error_string proc~get_dims dtfft_plan_t%get_dims proc~get_dims->proc~dtfft_get_error_string proc~get_element_size->proc~dtfft_get_error_string proc~get_executor dtfft_plan_t%get_executor proc~get_executor->proc~dtfft_get_error_string proc~get_grid_dims dtfft_plan_t%get_grid_dims proc~get_grid_dims->proc~dtfft_get_error_string proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_pencil dtfft_plan_t%get_pencil proc~get_pencil->proc~dtfft_get_error_string proc~get_platform dtfft_plan_t%get_platform proc~get_platform->proc~dtfft_get_error_string proc~get_precision dtfft_plan_t%get_precision proc~get_precision->proc~dtfft_get_error_string proc~get_stream_ptr dtfft_plan_t%get_stream_ptr proc~get_stream_ptr->proc~dtfft_get_error_string proc~get_y_slab_enabled dtfft_plan_t%get_y_slab_enabled proc~get_y_slab_enabled->proc~dtfft_get_error_string proc~get_z_slab_enabled dtfft_plan_t%get_z_slab_enabled proc~get_z_slab_enabled->proc~dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~report dtfft_plan_t%report proc~report->proc~dtfft_get_error_string proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~dtfft_get_error_string proc~run_autotune_backend->proc~alloc_and_set_aux none~get_stream dtfft_plan_t%get_stream none~get_stream->proc~get_stream_ptr proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream->proc~get_stream_int64 proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~dtfft_get_backend_c dtfft_get_backend_c proc~dtfft_get_backend_c->proc~get_backend proc~dtfft_get_dims_c dtfft_get_dims_c proc~dtfft_get_dims_c->proc~get_dims proc~dtfft_get_element_size_c dtfft_get_element_size_c proc~dtfft_get_element_size_c->proc~get_element_size proc~dtfft_get_executor_c dtfft_get_executor_c proc~dtfft_get_executor_c->proc~get_executor proc~dtfft_get_grid_dims_c dtfft_get_grid_dims_c proc~dtfft_get_grid_dims_c->proc~get_grid_dims proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 proc~dtfft_get_pencil_c dtfft_get_pencil_c proc~dtfft_get_pencil_c->proc~get_pencil proc~dtfft_get_platform_c dtfft_get_platform_c proc~dtfft_get_platform_c->proc~get_platform proc~dtfft_get_precision_c dtfft_get_precision_c proc~dtfft_get_precision_c->proc~get_precision proc~dtfft_get_y_slab_enabled_c dtfft_get_y_slab_enabled_c proc~dtfft_get_y_slab_enabled_c->proc~get_y_slab_enabled proc~dtfft_get_z_slab_enabled_c dtfft_get_z_slab_enabled_c proc~dtfft_get_z_slab_enabled_c->proc~get_z_slab_enabled proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~dtfft_mem_free_c dtfft_mem_free_c proc~dtfft_mem_free_c->proc~mem_free_ptr proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_alloc_size->proc~get_local_sizes~2 proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_c32_1d->proc~mem_free_ptr proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_c32_2d->proc~mem_free_ptr proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_c32_3d->proc~mem_free_ptr proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_c64_1d->proc~mem_free_ptr proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_c64_2d->proc~mem_free_ptr proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_c64_3d->proc~mem_free_ptr proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_r32_1d->proc~mem_free_ptr proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_r32_2d->proc~mem_free_ptr proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_r32_3d->proc~mem_free_ptr proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_r64_1d->proc~mem_free_ptr proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_r64_2d->proc~mem_free_ptr proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_r64_3d->proc~mem_free_ptr proc~autotune_grid_decomposition->proc~autotune_grid proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~get_stream_int64->none~get_stream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_error_string.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Uses iso_fortran_env iso_c_binding proc~~create~8~~UsesGraph proc~create~8 cufft_executor%create iso_c_binding iso_c_binding proc~create~8->iso_c_binding iso_fortran_env iso_fortran_env proc~create~8->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates FFT plan via cuFFT Interface Type Bound cufft_executor Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Calls proc~~create~8~~CallsGraph proc~create~8 cufft_executor%create fname fname proc~create~8->fname interface~cufftplanmany cufftPlanMany proc~create~8->interface~cufftplanmany interface~cufftsetstream cufftSetStream proc~create~8->interface~cufftsetstream mpi_abort mpi_abort proc~create~8->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~create~8->proc~cufftgeterrorstring proc~get_conf_stream get_conf_stream proc~create~8->proc~get_conf_stream proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate proc~cudageterrorstring cudaGetErrorString proc~get_conf_stream->proc~cudageterrorstring interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~8.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, a, b, sign) Uses iso_fortran_env iso_c_binding proc~~execute~7~~UsesGraph proc~execute~7 cufft_executor%execute iso_c_binding iso_c_binding proc~execute~7->iso_c_binding iso_fortran_env iso_fortran_env proc~execute~7->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes cuFFT plan Type Bound cufft_executor Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(in) :: self cuFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform Calls proc~~execute~7~~CallsGraph proc~execute~7 cufft_executor%execute fname fname proc~execute~7->fname interface~cufftxtexec cufftXtExec proc~execute~7->interface~cufftxtexec mpi_abort mpi_abort proc~execute~7->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~execute~7->proc~cufftgeterrorstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~7.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Uses iso_fortran_env iso_c_binding proc~~destroy~9~~UsesGraph proc~destroy~9 cufft_executor%destroy iso_c_binding iso_c_binding proc~destroy~9->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy~9->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys cuFFT plan Type Bound cufft_executor Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor Calls proc~~destroy~9~~CallsGraph proc~destroy~9 cufft_executor%destroy fname fname proc~destroy~9->fname interface~cufftdestroy cufftDestroy proc~destroy~9->interface~cufftdestroy mpi_abort mpi_abort proc~destroy~9->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~destroy~9->proc~cufftgeterrorstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~9.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(alloc_bytes, ptr) Dummy method. Raises error stop Type Bound cufft_executor Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer","tags":"","loc":"proc/mem_alloc~4.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(ptr) Dummy method. Raises error stop Type Bound cufft_executor Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"proc/mem_free~4.html"},{"title":"get_kernel_instance – dtFFT","text":"public  function get_kernel_instance(ndims, kernel_type, base_storage, tile_size, block_rows) result(fun) Retrieves a kernel instance from the cache\nIf the instance is not found, an error is raised Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ndims Number of dimensions (2 or 3) type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Tile size (number of columns) integer(kind=int32), intent(in) :: block_rows Block rows Return Value type( CUfunction ) Retrieved kernel instance Calls proc~~get_kernel_instance~~CallsGraph proc~get_kernel_instance get_kernel_instance interface~to_str to_str proc~get_kernel_instance->interface~to_str is_null_ptr is_null_ptr proc~get_kernel_instance->is_null_ptr proc~get nvrtc_module%get proc~get_kernel_instance->proc~get proc~get_conf_log_enabled get_conf_log_enabled proc~get_kernel_instance->proc~get_conf_log_enabled proc~get_kernel_string get_kernel_string proc~get_kernel_instance->proc~get_kernel_string proc~write_message write_message proc~get_kernel_instance->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string fname fname proc~get->fname mpi_abort mpi_abort proc~get->mpi_abort none~check nvrtc_module%check proc~get->none~check proc~cudageterrorstring cudaGetErrorString proc~get->proc~cudageterrorstring proc~get_mangled_name get_mangled_name proc~get->proc~get_mangled_name interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~check_instance nvrtc_module%check_instance none~check->proc~check_instance proc~check_module nvrtc_module%check_module none~check->proc~check_module interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~get_mangled_name->fname proc~get_mangled_name->mpi_abort proc~get_name_expression get_name_expression proc~get_mangled_name->proc~get_name_expression proc~nvrtcgeterrorstring nvrtcGetErrorString proc~get_mangled_name->proc~nvrtcgeterrorstring proc~check_instance->none~check proc~get_name_expression->interface~to_str proc~astring_f2c astring_f2c proc~get_name_expression->proc~astring_f2c proc~nvrtcgeterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_kernel_instance~~CalledByGraph proc~get_kernel_instance get_kernel_instance proc~get_kernel get_kernel proc~get_kernel->proc~get_kernel_instance proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_kernel_instance.html"},{"title":"create_nvrtc_module – dtFFT","text":"public  subroutine create_nvrtc_module(ndims, kernel_type, base_storage, configs, props) Creates and adds a new nvrtc module to the cache if it does not already exist Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ndims Number of dimensions (2 or 3) type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_config ), intent(in) :: configs (:) Array of kernel configurations to build type( device_props ), intent(in) :: props GPU architecture properties Calls proc~~create_nvrtc_module~~CallsGraph proc~create_nvrtc_module create_nvrtc_module interface~to_str to_str proc~create_nvrtc_module->interface~to_str none~check nvrtc_module%check proc~create_nvrtc_module->none~check proc~add nvrtc_module_cache%add proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~get_conf_log_enabled get_conf_log_enabled proc~create_nvrtc_module->proc~get_conf_log_enabled proc~get_kernel_string get_kernel_string proc~create_nvrtc_module->proc~get_kernel_string proc~write_message write_message proc~create_nvrtc_module->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~check_instance nvrtc_module%check_instance none~check->proc~check_instance proc~check_module nvrtc_module%check_module none~check->proc~check_module proc~add->interface~to_str proc~add->proc~get_conf_log_enabled proc~add->proc~write_message proc~create~9 nvrtc_module_cache%create proc~add->proc~create~9 proc~create~3->proc~get_conf_log_enabled proc~create~3->proc~write_message fname fname proc~create~3->fname interface~mem_free_host mem_free_host proc~create~3->interface~mem_free_host mpi_abort mpi_abort proc~create~3->mpi_abort proc~compile_program compile_program proc~create~3->proc~compile_program proc~cudageterrorstring cudaGetErrorString proc~create~3->proc~cudageterrorstring proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~get_code get_code proc~create~3->proc~get_code proc~mem_alloc_host mem_alloc_host proc~create~3->proc~mem_alloc_host proc~nvrtcgeterrorstring nvrtcGetErrorString proc~create~3->proc~nvrtcgeterrorstring proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create~3->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create~3->proc~push_nvtx_domain_range interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~check_instance->none~check proc~compile_program->interface~to_str proc~compile_program->fname proc~compile_program->mpi_abort proc~compile_program->proc~mem_alloc_host proc~compile_program->proc~nvrtcgeterrorstring proc~astring_f2c astring_f2c proc~compile_program->proc~astring_f2c proc~destroy_strings destroy_strings proc~compile_program->proc~destroy_strings proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~string_c2f string_c2f proc~compile_program->proc~string_c2f interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~cudageterrorstring->proc~string_c2f proc~destroy~3->fname proc~destroy~3->mpi_abort proc~destroy~3->proc~cudageterrorstring proc~destroy~3->proc~nvrtcgeterrorstring is_null_ptr is_null_ptr proc~destroy~3->is_null_ptr proc~add_line codegen_t%add_line proc~get_code->proc~add_line proc~is_unpack_kernel is_unpack_kernel proc~get_code->proc~is_unpack_kernel interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~nvrtcgeterrorstring->proc~string_c2f interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~set_name_expression->fname proc~set_name_expression->mpi_abort proc~set_name_expression->proc~nvrtcgeterrorstring proc~get_name_expression get_name_expression proc~set_name_expression->proc~get_name_expression interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~get_name_expression->interface~to_str proc~get_name_expression->proc~astring_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_nvrtc_module~~CalledByGraph proc~create_nvrtc_module create_nvrtc_module proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_nvrtc_module.html"},{"title":"create – dtFFT","text":"private  subroutine create(self) Creates cache Type Bound nvrtc_module_cache Arguments Type Intent Optional Attributes Name class( nvrtc_module_cache ), intent(inout) :: self Cache instance Called by proc~~create~9~~CalledByGraph proc~create~9 nvrtc_module_cache%create proc~add nvrtc_module_cache%add proc~add->proc~create~9 proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~add proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~9.html"},{"title":"add – dtFFT","text":"private  subroutine add(self, m) Adds new entry to cache Type Bound nvrtc_module_cache Arguments Type Intent Optional Attributes Name class( nvrtc_module_cache ), intent(inout) :: self Cache instance type( nvrtc_module ), intent(in) :: m Module to add Calls proc~~add~~CallsGraph proc~add nvrtc_module_cache%add interface~to_str to_str proc~add->interface~to_str proc~create~9 nvrtc_module_cache%create proc~add->proc~create~9 proc~get_conf_log_enabled get_conf_log_enabled proc~add->proc~get_conf_log_enabled proc~write_message write_message proc~add->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add~~CalledByGraph proc~add nvrtc_module_cache%add proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~add proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/add.html"},{"title":"init_internal – dtFFT","text":"public  function init_internal() Checks if MPI is initialized and loads environment variables Arguments None Return Value integer(kind=int32) Calls proc~~init_internal~~CallsGraph proc~init_internal init_internal mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_internal~~CalledByGraph proc~init_internal init_internal proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/init_internal.html"},{"title":"get_conf_log_enabled – dtFFT","text":"public elemental function get_conf_log_enabled() result(bool) Whether logging is enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_log_enabled~~CallsGraph proc~get_conf_log_enabled get_conf_log_enabled interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_log_enabled~~CalledByGraph proc~get_conf_log_enabled get_conf_log_enabled proc~add nvrtc_module_cache%add proc~add->proc~get_conf_log_enabled proc~alloc_mem alloc_mem proc~alloc_mem->proc~get_conf_log_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~get_conf_log_enabled proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_conf_log_enabled proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~get_conf_log_enabled proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create~3->proc~get_conf_log_enabled proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_log_enabled proc~create~6->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~free_mem free_mem proc~free_mem->proc~get_conf_log_enabled proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_log_enabled proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->proc~get_conf_log_enabled proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~get_conf_log_enabled proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~report_timings->proc~get_conf_log_enabled proc~run_autotune_backend->proc~get_conf_log_enabled proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~run_autotune_datatypes->proc~get_conf_log_enabled proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_log_enabled.html"},{"title":"get_conf_z_slab_enabled – dtFFT","text":"public elemental function get_conf_z_slab_enabled() result(bool) Whether Z-slab optimization is enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_z_slab_enabled~~CallsGraph proc~get_conf_z_slab_enabled get_conf_z_slab_enabled interface~get_conf_internal get_conf_internal proc~get_conf_z_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_z_slab_enabled~~CalledByGraph proc~get_conf_z_slab_enabled get_conf_z_slab_enabled proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_z_slab_enabled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_z_slab_enabled.html"},{"title":"get_conf_y_slab_enabled – dtFFT","text":"public elemental function get_conf_y_slab_enabled() result(bool) Whether Y-slab optimization is enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_y_slab_enabled~~CallsGraph proc~get_conf_y_slab_enabled get_conf_y_slab_enabled interface~get_conf_internal get_conf_internal proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_y_slab_enabled~~CalledByGraph proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~create_private dtfft_plan_t%create_private proc~create_private->proc~get_conf_y_slab_enabled proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_y_slab_enabled.html"},{"title":"get_conf_measure_warmup_iters – dtFFT","text":"public elemental function get_conf_measure_warmup_iters() result(iters) Returns the number of warmup iterations Arguments None Return Value integer(kind=int32) Result Calls proc~~get_conf_measure_warmup_iters~~CallsGraph proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters interface~get_conf_internal get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_measure_warmup_iters~~CalledByGraph proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_measure_warmup_iters proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~get_conf_measure_warmup_iters proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~run_autotune_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_measure_warmup_iters.html"},{"title":"get_conf_measure_iters – dtFFT","text":"public elemental function get_conf_measure_iters() result(iters) Returns the number of measurement iterations Arguments None Return Value integer(kind=int32) Result Calls proc~~get_conf_measure_iters~~CallsGraph proc~get_conf_measure_iters get_conf_measure_iters interface~get_conf_internal get_conf_internal proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_measure_iters~~CalledByGraph proc~get_conf_measure_iters get_conf_measure_iters proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_measure_iters proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~get_conf_measure_iters proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~get_conf_measure_iters proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~run_autotune_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_measure_iters.html"},{"title":"get_conf_platform – dtFFT","text":"public elemental function get_conf_platform() Returns platform set by the user or default one Arguments None Return Value type( dtfft_platform_t ) Called by proc~~get_conf_platform~~CalledByGraph proc~get_conf_platform get_conf_platform proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~get_conf_platform proc~get_conf_backend get_conf_backend proc~check_create_args->proc~get_conf_backend proc~create~10 vkfft_executor%create proc~create~10->proc~get_conf_platform proc~get_correct_backend get_correct_backend proc~get_correct_backend->proc~get_conf_platform proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~get_correct_backend proc~get_conf_backend->proc~get_correct_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_backend proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_platform.html"},{"title":"get_conf_stream – dtFFT","text":"public  function get_conf_stream() result(stream) Uses iso_fortran_env iso_c_binding proc~~get_conf_stream~~UsesGraph proc~get_conf_stream get_conf_stream iso_c_binding iso_c_binding proc~get_conf_stream->iso_c_binding iso_fortran_env iso_fortran_env proc~get_conf_stream->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Returns either the custom provided by user or creates a new one Arguments None Return Value type( dtfft_stream_t ) Calls proc~~get_conf_stream~~CallsGraph proc~get_conf_stream get_conf_stream fname fname proc~get_conf_stream->fname interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate mpi_abort mpi_abort proc~get_conf_stream->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~get_conf_stream->proc~cudageterrorstring interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_stream~~CalledByGraph proc~get_conf_stream get_conf_stream proc~create_private dtfft_plan_t%create_private proc~create_private->proc~get_conf_stream proc~create~10 vkfft_executor%create proc~create~10->proc~get_conf_stream proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_stream proc~create~8 cufft_executor%create proc~create~8->proc~get_conf_stream proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_stream proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_stream.html"},{"title":"get_conf_backend – dtFFT","text":"public elemental function get_conf_backend() Returns backend set by the user or default one Arguments None Return Value type( dtfft_backend_t ) Calls proc~~get_conf_backend~~CallsGraph proc~get_conf_backend get_conf_backend proc~get_correct_backend get_correct_backend proc~get_conf_backend->proc~get_correct_backend proc~get_conf_platform get_conf_platform proc~get_correct_backend->proc~get_conf_platform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_backend~~CalledByGraph proc~get_conf_backend get_conf_backend proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~get_conf_backend proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_backend proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_backend.html"},{"title":"get_conf_datatype_enabled – dtFFT","text":"public elemental function get_conf_datatype_enabled() result(bool) Whether MPI Datatype backend is enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_datatype_enabled~~CallsGraph proc~get_conf_datatype_enabled get_conf_datatype_enabled interface~get_conf_internal get_conf_internal proc~get_conf_datatype_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_datatype_enabled~~CalledByGraph proc~get_conf_datatype_enabled get_conf_datatype_enabled proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_datatype_enabled proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~get_conf_datatype_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_datatype_enabled.html"},{"title":"get_conf_pipelined_enabled – dtFFT","text":"public elemental function get_conf_pipelined_enabled() result(bool) Whether pipelined backends are enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_pipelined_enabled~~CallsGraph proc~get_conf_pipelined_enabled get_conf_pipelined_enabled interface~get_conf_internal get_conf_internal proc~get_conf_pipelined_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_pipelined_enabled~~CalledByGraph proc~get_conf_pipelined_enabled get_conf_pipelined_enabled proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~get_conf_pipelined_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_pipelined_enabled.html"},{"title":"get_conf_mpi_enabled – dtFFT","text":"public elemental function get_conf_mpi_enabled() result(bool) Whether MPI backends are enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_mpi_enabled~~CallsGraph proc~get_conf_mpi_enabled get_conf_mpi_enabled interface~get_conf_internal get_conf_internal proc~get_conf_mpi_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_mpi_enabled~~CalledByGraph proc~get_conf_mpi_enabled get_conf_mpi_enabled proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_mpi_enabled proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~get_conf_mpi_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_mpi_enabled.html"},{"title":"get_conf_nccl_enabled – dtFFT","text":"public elemental function get_conf_nccl_enabled() result(bool) Whether NCCL backends are enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_nccl_enabled~~CallsGraph proc~get_conf_nccl_enabled get_conf_nccl_enabled interface~get_conf_internal get_conf_internal proc~get_conf_nccl_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_nccl_enabled~~CalledByGraph proc~get_conf_nccl_enabled get_conf_nccl_enabled proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_nccl_enabled Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_nccl_enabled.html"},{"title":"get_conf_nvshmem_enabled – dtFFT","text":"public elemental function get_conf_nvshmem_enabled() result(bool) Whether nvshmem backends are enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_nvshmem_enabled~~CallsGraph proc~get_conf_nvshmem_enabled get_conf_nvshmem_enabled interface~get_conf_internal get_conf_internal proc~get_conf_nvshmem_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_nvshmem_enabled~~CalledByGraph proc~get_conf_nvshmem_enabled get_conf_nvshmem_enabled proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_nvshmem_enabled proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~get_conf_nvshmem_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_nvshmem_enabled.html"},{"title":"get_conf_kernel_optimization_enabled – dtFFT","text":"public elemental function get_conf_kernel_optimization_enabled() result(bool) Whether kernel optimization is enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_kernel_optimization_enabled~~CallsGraph proc~get_conf_kernel_optimization_enabled get_conf_kernel_optimization_enabled interface~get_conf_internal get_conf_internal proc~get_conf_kernel_optimization_enabled->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_kernel_optimization_enabled~~CalledByGraph proc~get_conf_kernel_optimization_enabled get_conf_kernel_optimization_enabled proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_kernel_optimization_enabled proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_kernel_optimization_enabled.html"},{"title":"get_conf_configs_to_test – dtFFT","text":"public pure function get_conf_configs_to_test() result(n) Returns the number of configurations to test Arguments None Return Value integer(kind=int32) Result Calls proc~~get_conf_configs_to_test~~CallsGraph proc~get_conf_configs_to_test get_conf_configs_to_test interface~get_conf_internal get_conf_internal proc~get_conf_configs_to_test->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_configs_to_test~~CalledByGraph proc~get_conf_configs_to_test get_conf_configs_to_test proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_configs_to_test proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_configs_to_test.html"},{"title":"get_conf_forced_kernel_optimization – dtFFT","text":"public elemental function get_conf_forced_kernel_optimization() result(bool) Whether forced kernel optimization is enabled or not Arguments None Return Value logical Result flag Calls proc~~get_conf_forced_kernel_optimization~~CallsGraph proc~get_conf_forced_kernel_optimization get_conf_forced_kernel_optimization interface~get_conf_internal get_conf_internal proc~get_conf_forced_kernel_optimization->interface~get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_conf_forced_kernel_optimization~~CalledByGraph proc~get_conf_forced_kernel_optimization get_conf_forced_kernel_optimization proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_forced_kernel_optimization proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_forced_kernel_optimization.html"},{"title":"get_datatype_from_env – dtFFT","text":"public  function get_datatype_from_env(name) result(env) Obtains datatype id from environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value integer(kind=int8) Calls proc~~get_datatype_from_env~~CallsGraph proc~get_datatype_from_env get_datatype_from_env interface~get_env get_env proc~get_datatype_from_env->interface~get_env proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_datatype_from_env~~CalledByGraph proc~get_datatype_from_env get_datatype_from_env proc~create~6 transpose_plan%create proc~create~6->proc~get_datatype_from_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_datatype_from_env.html"},{"title":"config_constructor – dtFFT","text":"private pure function config_constructor(enable_log, enable_z_slab, enable_y_slab, n_measure_warmup_iters, n_measure_iters, platform, stream, backend, enable_datatype_backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends, enable_kernel_optimization, n_configs_to_test, force_kernel_optimization) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_log Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_y_slab Should dtFFT use Y-slab optimization or not. integer(kind=int32), intent(in), optional :: n_measure_warmup_iters Number of warmup iterations for measurements integer(kind=int32), intent(in), optional :: n_measure_iters Number of measurement iterations type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_datatype_backend Should DTFFT_BACKEND_MPI_DATATYPE be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_kernel_optimization Should dtFFT try to optimize NVRTC kernel block size during autotune or not. integer(kind=int32), intent(in), optional :: n_configs_to_test Number of top theoretical best performing blocks of threads to test for transposition kernels when effort is DTFFT_PATIENT . logical, intent(in), optional :: force_kernel_optimization Whether to force kernel optimization when effort is not DTFFT_PATIENT . Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config Called by proc~~config_constructor~~CalledByGraph proc~config_constructor config_constructor interface~dtfft_config_t dtfft_config_t interface~dtfft_config_t->proc~config_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/config_constructor.html"},{"title":"get_correct_backend – dtFFT","text":"private elemental function get_correct_backend(back) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: back Return Value type( dtfft_backend_t ) Calls proc~~get_correct_backend~~CallsGraph proc~get_correct_backend get_correct_backend proc~get_conf_platform get_conf_platform proc~get_correct_backend->proc~get_conf_platform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_correct_backend~~CalledByGraph proc~get_correct_backend get_correct_backend proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~get_correct_backend proc~get_conf_backend get_conf_backend proc~get_conf_backend->proc~get_correct_backend proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~get_conf_backend proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_backend proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_correct_backend.html"},{"title":"get_conf_internal_logical – dtFFT","text":"private elemental function get_conf_internal_logical(from_conf, from_env) Returns value from configuration unless environment variable is set Arguments Type Intent Optional Attributes Name logical, intent(in) :: from_conf Value from configuration integer(kind=int32), intent(in) :: from_env Value from environment variable Return Value logical Called by proc~~get_conf_internal_logical~~CalledByGraph proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal get_conf_internal interface~get_conf_internal->proc~get_conf_internal_logical proc~get_conf_configs_to_test get_conf_configs_to_test proc~get_conf_configs_to_test->interface~get_conf_internal proc~get_conf_datatype_enabled get_conf_datatype_enabled proc~get_conf_datatype_enabled->interface~get_conf_internal proc~get_conf_forced_kernel_optimization get_conf_forced_kernel_optimization proc~get_conf_forced_kernel_optimization->interface~get_conf_internal proc~get_conf_kernel_optimization_enabled get_conf_kernel_optimization_enabled proc~get_conf_kernel_optimization_enabled->interface~get_conf_internal proc~get_conf_log_enabled get_conf_log_enabled proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_measure_iters get_conf_measure_iters proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_mpi_enabled get_conf_mpi_enabled proc~get_conf_mpi_enabled->interface~get_conf_internal proc~get_conf_nccl_enabled get_conf_nccl_enabled proc~get_conf_nccl_enabled->interface~get_conf_internal proc~get_conf_nvshmem_enabled get_conf_nvshmem_enabled proc~get_conf_nvshmem_enabled->interface~get_conf_internal proc~get_conf_pipelined_enabled get_conf_pipelined_enabled proc~get_conf_pipelined_enabled->interface~get_conf_internal proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_z_slab_enabled get_conf_z_slab_enabled proc~get_conf_z_slab_enabled->interface~get_conf_internal proc~add nvrtc_module_cache%add proc~add->proc~get_conf_log_enabled proc~alloc_mem alloc_mem proc~alloc_mem->proc~get_conf_log_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~get_conf_log_enabled proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_conf_log_enabled proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~get_conf_log_enabled proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create_private dtfft_plan_t%create_private proc~create_private->proc~get_conf_y_slab_enabled proc~create~3->proc~get_conf_log_enabled proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_datatype_enabled proc~create~6->proc~get_conf_log_enabled proc~create~6->proc~get_conf_mpi_enabled proc~create~6->proc~get_conf_nccl_enabled proc~create~6->proc~get_conf_nvshmem_enabled proc~create~6->proc~get_conf_z_slab_enabled proc~create~6->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~free_mem free_mem proc~free_mem->proc~get_conf_log_enabled proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_configs_to_test proc~get_kernel->proc~get_conf_forced_kernel_optimization proc~get_kernel->proc~get_conf_kernel_optimization_enabled proc~get_kernel->proc~get_conf_log_enabled proc~get_kernel->proc~get_conf_measure_iters proc~get_kernel->proc~get_conf_measure_warmup_iters proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->proc~get_conf_log_enabled proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~report_timings->proc~get_conf_log_enabled proc~run_autotune_backend->proc~get_conf_datatype_enabled proc~run_autotune_backend->proc~get_conf_log_enabled proc~run_autotune_backend->proc~get_conf_measure_iters proc~run_autotune_backend->proc~get_conf_measure_warmup_iters proc~run_autotune_backend->proc~get_conf_mpi_enabled proc~run_autotune_backend->proc~get_conf_nvshmem_enabled proc~run_autotune_backend->proc~get_conf_pipelined_enabled proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~run_autotune_datatypes->proc~get_conf_log_enabled proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_internal_logical.html"},{"title":"get_conf_internal_int32 – dtFFT","text":"private elemental function get_conf_internal_int32(from_conf, from_env) Returns value from configuration unless environment variable is set Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: from_conf Value from configuration integer(kind=int32), intent(in) :: from_env Value from environment variable Return Value integer(kind=int32) Called by proc~~get_conf_internal_int32~~CalledByGraph proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal get_conf_internal interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_configs_to_test get_conf_configs_to_test proc~get_conf_configs_to_test->interface~get_conf_internal proc~get_conf_datatype_enabled get_conf_datatype_enabled proc~get_conf_datatype_enabled->interface~get_conf_internal proc~get_conf_forced_kernel_optimization get_conf_forced_kernel_optimization proc~get_conf_forced_kernel_optimization->interface~get_conf_internal proc~get_conf_kernel_optimization_enabled get_conf_kernel_optimization_enabled proc~get_conf_kernel_optimization_enabled->interface~get_conf_internal proc~get_conf_log_enabled get_conf_log_enabled proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_measure_iters get_conf_measure_iters proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_mpi_enabled get_conf_mpi_enabled proc~get_conf_mpi_enabled->interface~get_conf_internal proc~get_conf_nccl_enabled get_conf_nccl_enabled proc~get_conf_nccl_enabled->interface~get_conf_internal proc~get_conf_nvshmem_enabled get_conf_nvshmem_enabled proc~get_conf_nvshmem_enabled->interface~get_conf_internal proc~get_conf_pipelined_enabled get_conf_pipelined_enabled proc~get_conf_pipelined_enabled->interface~get_conf_internal proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_z_slab_enabled get_conf_z_slab_enabled proc~get_conf_z_slab_enabled->interface~get_conf_internal proc~add nvrtc_module_cache%add proc~add->proc~get_conf_log_enabled proc~alloc_mem alloc_mem proc~alloc_mem->proc~get_conf_log_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~get_conf_log_enabled proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_conf_log_enabled proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~get_conf_log_enabled proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create_private dtfft_plan_t%create_private proc~create_private->proc~get_conf_y_slab_enabled proc~create~3->proc~get_conf_log_enabled proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_datatype_enabled proc~create~6->proc~get_conf_log_enabled proc~create~6->proc~get_conf_mpi_enabled proc~create~6->proc~get_conf_nccl_enabled proc~create~6->proc~get_conf_nvshmem_enabled proc~create~6->proc~get_conf_z_slab_enabled proc~create~6->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~free_mem free_mem proc~free_mem->proc~get_conf_log_enabled proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_configs_to_test proc~get_kernel->proc~get_conf_forced_kernel_optimization proc~get_kernel->proc~get_conf_kernel_optimization_enabled proc~get_kernel->proc~get_conf_log_enabled proc~get_kernel->proc~get_conf_measure_iters proc~get_kernel->proc~get_conf_measure_warmup_iters proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->proc~get_conf_log_enabled proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~report_timings->proc~get_conf_log_enabled proc~run_autotune_backend->proc~get_conf_datatype_enabled proc~run_autotune_backend->proc~get_conf_log_enabled proc~run_autotune_backend->proc~get_conf_measure_iters proc~run_autotune_backend->proc~get_conf_measure_warmup_iters proc~run_autotune_backend->proc~get_conf_mpi_enabled proc~run_autotune_backend->proc~get_conf_nvshmem_enabled proc~run_autotune_backend->proc~get_conf_pipelined_enabled proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~run_autotune_datatypes->proc~get_conf_log_enabled proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_conf_internal_int32.html"},{"title":"get_env_base – dtFFT","text":"private  function get_env_base(name) result(env) Base function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value type( string ) Calls proc~~get_env_base~~CallsGraph proc~get_env_base get_env_base proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_env_base~~CalledByGraph proc~get_env_base get_env_base interface~get_env get_env interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~init_environment init_environment proc~init_environment->interface~get_env proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~get_datatype_from_env proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~init_internal init_internal proc~init_internal->proc~init_environment proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~autotune_grid_decomposition->proc~autotune_grid proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_base.html"},{"title":"get_env_string – dtFFT","text":"private  function get_env_string(name, default, valid_values) result(env) Obtains string environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix character(len=*), intent(in) :: default Name of environment variable without prefix type( string ), intent(in) :: valid_values (:) List of valid variable values Return Value type( string ) Calls proc~~get_env_string~~CallsGraph proc~get_env_string get_env_string interface~get_env get_env proc~get_env_string->interface~get_env proc~destroy_string string%destroy_string proc~get_env_string->proc~destroy_string proc~write_message write_message proc~get_env_string->proc~write_message interface~get_env->proc~get_env_string proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_env_string~~CalledByGraph proc~get_env_string get_env_string interface~get_env get_env proc~get_env_string->interface~get_env interface~get_env->proc~get_env_string proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~init_environment init_environment proc~init_environment->interface~get_env proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~get_datatype_from_env proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~init_internal init_internal proc~init_internal->proc~init_environment proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~autotune_grid_decomposition->proc~autotune_grid proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_string.html"},{"title":"get_env_int32 – dtFFT","text":"private  function get_env_int32(name, default, valid_values, min_valid_value) result(env) Base Integer function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int32), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in), optional :: valid_values (:) List of valid values integer(kind=int32), intent(in), optional :: min_valid_value Mininum valid value. Usually 0 or 1 Return Value integer(kind=int32) Calls proc~~get_env_int32~~CallsGraph proc~get_env_int32 get_env_int32 interface~get_env get_env proc~get_env_int32->interface~get_env proc~write_message write_message proc~get_env_int32->proc~write_message interface~get_env->proc~get_env_int32 proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_env_int32~~CalledByGraph proc~get_env_int32 get_env_int32 interface~get_env get_env proc~get_env_int32->interface~get_env interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~init_environment init_environment proc~init_environment->interface~get_env proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~get_datatype_from_env proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~init_internal init_internal proc~init_internal->proc~init_environment proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~autotune_grid_decomposition->proc~autotune_grid proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_int32.html"},{"title":"get_env_int8 – dtFFT","text":"private  function get_env_int8(name, default, valid_values) result(env) Obtains int8 environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int8), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in) :: valid_values (:) List of valid values Return Value integer(kind=int8) Calls proc~~get_env_int8~~CallsGraph proc~get_env_int8 get_env_int8 interface~get_env get_env proc~get_env_int8->interface~get_env interface~get_env->proc~get_env_int8 proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_env_int8~~CalledByGraph proc~get_env_int8 get_env_int8 interface~get_env get_env proc~get_env_int8->interface~get_env interface~get_env->proc~get_env_int8 proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~init_environment init_environment proc~init_environment->interface~get_env proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~get_datatype_from_env proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~init_internal init_internal proc~init_internal->proc~init_environment proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~autotune_grid_decomposition->proc~autotune_grid proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_int8.html"},{"title":"get_env_logical – dtFFT","text":"private  function get_env_logical(name, default) result(env) Obtains logical environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix logical, intent(in) :: default Default value in case env is not set or it has wrong value Return Value logical Calls proc~~get_env_logical~~CallsGraph proc~get_env_logical get_env_logical interface~get_env get_env proc~get_env_logical->interface~get_env interface~get_env->proc~get_env_logical proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_env_logical~~CalledByGraph proc~get_env_logical get_env_logical interface~get_env get_env proc~get_env_logical->interface~get_env interface~get_env->proc~get_env_logical proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_string->interface~get_env proc~init_environment init_environment proc~init_environment->interface~get_env proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~get_datatype_from_env proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~init_internal init_internal proc~init_internal->proc~init_environment proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~autotune_grid_decomposition->proc~autotune_grid proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_env_logical.html"},{"title":"dtfft_create_config – dtFFT","text":"public pure subroutine dtfft_create_config(config) bind(C, name=\"dtfft_create_config_c\") Creates a new configuration and sets default values. C interface Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(out) :: config Configuration to create","tags":"","loc":"proc/dtfft_create_config.html"},{"title":"dtfft_set_config – dtFFT","text":"public  subroutine dtfft_set_config(config, error_code) Sets configuration parameters Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(in) :: config Configuration to set integer(kind=int32), intent(out), optional :: error_code Error code Calls proc~~dtfft_set_config~~CallsGraph proc~dtfft_set_config dtfft_set_config interface~cudastreamquery cudaStreamQuery proc~dtfft_set_config->interface~cudastreamquery is_null_ptr is_null_ptr proc~dtfft_set_config->is_null_ptr proc~get_correct_backend get_correct_backend proc~dtfft_set_config->proc~get_correct_backend proc~init_internal init_internal proc~dtfft_set_config->proc~init_internal proc~is_valid_backend is_valid_backend proc~dtfft_set_config->proc~is_valid_backend proc~is_valid_platform is_valid_platform proc~dtfft_set_config->proc~is_valid_platform proc~get_conf_platform get_conf_platform proc~get_correct_backend->proc~get_conf_platform mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment proc~init_environment->proc~is_valid_backend backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dtfft_set_config~~CalledByGraph proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_set_config.html"},{"title":"destroy_stream – dtFFT","text":"public  subroutine destroy_stream() Uses iso_fortran_env iso_c_binding proc~~destroy_stream~~UsesGraph proc~destroy_stream destroy_stream iso_c_binding iso_c_binding proc~destroy_stream->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy_stream->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroy the default stream if it was created Arguments None Calls proc~~destroy_stream~~CallsGraph proc~destroy_stream destroy_stream fname fname proc~destroy_stream->fname interface~cudastreamdestroy cudaStreamDestroy proc~destroy_stream->interface~cudastreamdestroy mpi_abort mpi_abort proc~destroy_stream->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy_stream->proc~cudageterrorstring interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_stream~~CalledByGraph proc~destroy_stream destroy_stream proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~destroy_stream proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_stream.html"},{"title":"init_environment – dtFFT","text":"private  subroutine init_environment() Arguments None Calls proc~~init_environment~~CallsGraph proc~init_environment init_environment backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~is_valid_backend is_valid_backend proc~init_environment->proc~is_valid_backend proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_environment~~CalledByGraph proc~init_environment init_environment proc~init_internal init_internal proc~init_internal->proc~init_environment proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/init_environment.html"},{"title":"dtfft_config_t – dtFFT","text":"public interface dtfft_config_t Interface to create a new configuration Calls interface~~dtfft_config_t~~CallsGraph interface~dtfft_config_t dtfft_config_t proc~config_constructor config_constructor interface~dtfft_config_t->proc~config_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function config_constructor (enable_log, enable_z_slab, enable_y_slab, n_measure_warmup_iters, n_measure_iters, platform, stream, backend, enable_datatype_backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends, enable_kernel_optimization, n_configs_to_test, force_kernel_optimization) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_log Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_y_slab Should dtFFT use Y-slab optimization or not. integer(kind=int32), intent(in), optional :: n_measure_warmup_iters Number of warmup iterations for measurements integer(kind=int32), intent(in), optional :: n_measure_iters Number of measurement iterations type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_datatype_backend Should DTFFT_BACKEND_MPI_DATATYPE be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_kernel_optimization Should dtFFT try to optimize NVRTC kernel block size during autotune or not. integer(kind=int32), intent(in), optional :: n_configs_to_test Number of top theoretical best performing blocks of threads to test for transposition kernels when effort is DTFFT_PATIENT . logical, intent(in), optional :: force_kernel_optimization Whether to force kernel optimization when effort is not DTFFT_PATIENT . Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config","tags":"","loc":"interface/dtfft_config_t.html"},{"title":"get_env – dtFFT","text":"public interface get_env Obtains environment variable Calls interface~~get_env~~CallsGraph interface~get_env get_env proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~write_message write_message proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~destroy_string proc~get_env_string->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~get_env~~CalledByGraph interface~get_env get_env proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~get_datatype_from_env get_datatype_from_env proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~init_environment init_environment proc~init_environment->interface~get_env proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~get_datatype_from_env proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~init_internal init_internal proc~init_internal->proc~init_environment proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~autotune_grid_decomposition->proc~autotune_grid proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function get_env_base (name) result(env) Base function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value type( string ) private  function get_env_string (name, default, valid_values) result(env) Obtains string environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix character(len=*), intent(in) :: default Name of environment variable without prefix type( string ), intent(in) :: valid_values (:) List of valid variable values Return Value type( string ) private  function get_env_int32 (name, default, valid_values, min_valid_value) result(env) Base Integer function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int32), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in), optional :: valid_values (:) List of valid values integer(kind=int32), intent(in), optional :: min_valid_value Mininum valid value. Usually 0 or 1 Return Value integer(kind=int32) private  function get_env_int8 (name, default, valid_values) result(env) Obtains int8 environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int8), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in) :: valid_values (:) List of valid values Return Value integer(kind=int8) private  function get_env_logical (name, default) result(env) Obtains logical environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix logical, intent(in) :: default Default value in case env is not set or it has wrong value Return Value logical","tags":"","loc":"interface/get_env.html"},{"title":"get_conf_internal – dtFFT","text":"private interface get_conf_internal Returns value from configuration unless environment variable is set Calls interface~~get_conf_internal~~CallsGraph interface~get_conf_internal get_conf_internal proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~get_conf_internal~~CalledByGraph interface~get_conf_internal get_conf_internal proc~get_conf_configs_to_test get_conf_configs_to_test proc~get_conf_configs_to_test->interface~get_conf_internal proc~get_conf_datatype_enabled get_conf_datatype_enabled proc~get_conf_datatype_enabled->interface~get_conf_internal proc~get_conf_forced_kernel_optimization get_conf_forced_kernel_optimization proc~get_conf_forced_kernel_optimization->interface~get_conf_internal proc~get_conf_kernel_optimization_enabled get_conf_kernel_optimization_enabled proc~get_conf_kernel_optimization_enabled->interface~get_conf_internal proc~get_conf_log_enabled get_conf_log_enabled proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_measure_iters get_conf_measure_iters proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_mpi_enabled get_conf_mpi_enabled proc~get_conf_mpi_enabled->interface~get_conf_internal proc~get_conf_nccl_enabled get_conf_nccl_enabled proc~get_conf_nccl_enabled->interface~get_conf_internal proc~get_conf_nvshmem_enabled get_conf_nvshmem_enabled proc~get_conf_nvshmem_enabled->interface~get_conf_internal proc~get_conf_pipelined_enabled get_conf_pipelined_enabled proc~get_conf_pipelined_enabled->interface~get_conf_internal proc~get_conf_y_slab_enabled get_conf_y_slab_enabled proc~get_conf_y_slab_enabled->interface~get_conf_internal proc~get_conf_z_slab_enabled get_conf_z_slab_enabled proc~get_conf_z_slab_enabled->interface~get_conf_internal proc~add nvrtc_module_cache%add proc~add->proc~get_conf_log_enabled proc~alloc_mem alloc_mem proc~alloc_mem->proc~get_conf_log_enabled proc~autotune_grid autotune_grid proc~autotune_grid->proc~get_conf_log_enabled proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_conf_log_enabled proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~get_conf_log_enabled proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create_private dtfft_plan_t%create_private proc~create_private->proc~get_conf_y_slab_enabled proc~create~3->proc~get_conf_log_enabled proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_datatype_enabled proc~create~6->proc~get_conf_log_enabled proc~create~6->proc~get_conf_mpi_enabled proc~create~6->proc~get_conf_nccl_enabled proc~create~6->proc~get_conf_nvshmem_enabled proc~create~6->proc~get_conf_z_slab_enabled proc~create~6->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~free_mem free_mem proc~free_mem->proc~get_conf_log_enabled proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_configs_to_test proc~get_kernel->proc~get_conf_forced_kernel_optimization proc~get_kernel->proc~get_conf_kernel_optimization_enabled proc~get_kernel->proc~get_conf_log_enabled proc~get_kernel->proc~get_conf_measure_iters proc~get_kernel->proc~get_conf_measure_warmup_iters proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->proc~get_conf_log_enabled proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~get_conf_log_enabled proc~get_plan_execution_time->proc~get_conf_measure_iters proc~get_plan_execution_time->proc~get_conf_measure_warmup_iters proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~report_timings->proc~get_conf_log_enabled proc~run_autotune_backend->proc~get_conf_datatype_enabled proc~run_autotune_backend->proc~get_conf_log_enabled proc~run_autotune_backend->proc~get_conf_measure_iters proc~run_autotune_backend->proc~get_conf_measure_warmup_iters proc~run_autotune_backend->proc~get_conf_mpi_enabled proc~run_autotune_backend->proc~get_conf_nvshmem_enabled proc~run_autotune_backend->proc~get_conf_pipelined_enabled proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~run_autotune_datatypes->proc~get_conf_log_enabled proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function get_conf_internal_logical (from_conf, from_env) Returns value from configuration unless environment variable is set Arguments Type Intent Optional Attributes Name logical, intent(in) :: from_conf Value from configuration integer(kind=int32), intent(in) :: from_env Value from environment variable Return Value logical private elemental function get_conf_internal_int32 (from_conf, from_env) Returns value from configuration unless environment variable is set Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: from_conf Value from configuration integer(kind=int32), intent(in) :: from_env Value from environment variable Return Value integer(kind=int32)","tags":"","loc":"interface/get_conf_internal.html"},{"title":"nvrtcGetErrorString – dtFFT","text":"public  function nvrtcGetErrorString(error_code) result(string) Helper function that returns a string describing the given nvrtcResult code\nFor unrecognized enumeration values, it returns “NVRTC_ERROR unknown” Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: error_code CUDA Runtime Compilation API result code. Return Value character(len=:), allocatable Result string Calls proc~~nvrtcgeterrorstring~~CallsGraph proc~nvrtcgeterrorstring nvrtcGetErrorString proc~string_c2f string_c2f proc~nvrtcgeterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nvrtcgeterrorstring~~CalledByGraph proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_program compile_program proc~compile_program->proc~nvrtcgeterrorstring proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~create~3 nvrtc_module%create proc~create~3->proc~nvrtcgeterrorstring proc~create~3->proc~compile_program proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~destroy~3->proc~nvrtcgeterrorstring proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~nvrtcgeterrorstring proc~set_name_expression->proc~nvrtcgeterrorstring proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~get nvrtc_module%get proc~get->proc~get_mangled_name proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->proc~get proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nvrtcgeterrorstring.html"},{"title":"load_nvrtc – dtFFT","text":"public  function load_nvrtc() result(error_code) Dynamically loads nvRTC library and its functions Arguments None Return Value integer(kind=int32) Error code Calls proc~~load_nvrtc~~CallsGraph proc~load_nvrtc load_nvrtc proc~destroy_strings destroy_strings proc~load_nvrtc->proc~destroy_strings proc~dynamic_load dynamic_load proc~load_nvrtc->proc~dynamic_load proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_nvrtc~~CalledByGraph proc~load_nvrtc load_nvrtc proc~create~6 transpose_plan%create proc~create~6->proc~load_nvrtc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_nvrtc.html"},{"title":"load_cuda – dtFFT","text":"public  function load_cuda() result(error_code) Loads the CUDA Driver library and needed symbols Arguments None Return Value integer(kind=int32) Error code Calls proc~~load_cuda~~CallsGraph proc~load_cuda load_cuda proc~destroy_strings destroy_strings proc~load_cuda->proc~destroy_strings proc~dynamic_load dynamic_load proc~load_cuda->proc~dynamic_load proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_cuda~~CalledByGraph proc~load_cuda load_cuda proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_cuda.html"},{"title":"cuLaunchKernel – dtFFT","text":"public  function cuLaunchKernel(func, in, out, blocks, threads, stream, nargs, args) result(cuResult) Launches a CUDA kernel Arguments Type Intent Optional Attributes Name type( CUfunction ), intent(in) :: func Function CUfunction or Kernel CUkernel to launch type(c_ptr), intent(in), target :: in Input pointer type(c_ptr), intent(in), target :: out Output pointer type( dim3 ), intent(in) :: blocks Grid in blocks type( dim3 ), intent(in) :: threads Thread block type( dtfft_stream_t ), intent(in) :: stream Stream identifier integer(kind=int32), intent(in) :: nargs integer(kind=int32), intent(in), target :: args (MAX_KERNEL_ARGS) Input parameters of kernel func Return Value integer(kind=c_int) Driver result code Called by proc~~culaunchkernel~~CalledByGraph proc~culaunchkernel cuLaunchKernel proc~execute~9 kernel_device%execute proc~execute~9->proc~culaunchkernel proc~get_kernel get_kernel proc~get_kernel->proc~culaunchkernel proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/culaunchkernel.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via vkFFT Interface Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Calls proc~~create~10~~CallsGraph proc~create~10 vkfft_executor%create proc~get_conf_platform get_conf_platform proc~create~10->proc~get_conf_platform proc~get_conf_stream get_conf_stream proc~create~10->proc~get_conf_stream proc~load_vkfft load_vkfft proc~create~10->proc~load_vkfft fname fname proc~get_conf_stream->fname interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate mpi_abort mpi_abort proc~get_conf_stream->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~get_conf_stream->proc~cudageterrorstring proc~load load proc~load_vkfft->proc~load interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~destroy_strings destroy_strings proc~load->proc~destroy_strings proc~dynamic_load dynamic_load proc~load->proc~dynamic_load proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~dl_error->proc~string_c2f interface~dlerror dlerror proc~dl_error->interface~dlerror proc~write_message write_message proc~dl_error->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~10.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, a, b, sign) Executes vkFFT plan Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(in) :: self vkFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform","tags":"","loc":"proc/execute~8.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys vkFFT plan Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor","tags":"","loc":"proc/destroy~10.html"},{"title":"mem_alloc – dtFFT","text":"private  subroutine mem_alloc(alloc_bytes, ptr) Dummy method. Raises error stop Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer","tags":"","loc":"proc/mem_alloc~5.html"},{"title":"mem_free – dtFFT","text":"private  subroutine mem_free(ptr) Dummy method. Raises error stop Type Bound vkfft_executor Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"proc/mem_free~5.html"},{"title":"get_comm – dtFFT","text":"private pure function get_comm(c_comm) Converts C communicator to Fortran communicator Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: c_comm C communicator Return Value type(mpi_comm) Called by proc~~get_comm~~CalledByGraph proc~get_comm get_comm proc~dtfft_create_plan_c2c_c dtfft_create_plan_c2c_c proc~dtfft_create_plan_c2c_c->proc~get_comm proc~dtfft_create_plan_c2c_pencil_c dtfft_create_plan_c2c_pencil_c proc~dtfft_create_plan_c2c_pencil_c->proc~get_comm proc~dtfft_create_plan_r2r_c dtfft_create_plan_r2r_c proc~dtfft_create_plan_r2r_c->proc~get_comm proc~dtfft_create_plan_r2r_pencil_c dtfft_create_plan_r2r_pencil_c proc~dtfft_create_plan_r2r_pencil_c->proc~get_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_comm.html"},{"title":"dtfft_create_plan_r2r_c – dtFFT","text":"private  function dtfft_create_plan_r2r_c(ndims, dims, kinds, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates R2R dtFFT Plan, allocates all structures and prepares FFT, C interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: ndims Rank of transform. Can be 2 or 3. type(c_ptr), intent(in), value :: dims Global sizes of transform type(c_ptr), intent(in), value :: kinds FFT R2R kinds integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_create_plan_r2r_c~~CallsGraph proc~dtfft_create_plan_r2r_c dtfft_create_plan_r2r_c create create proc~dtfft_create_plan_r2r_c->create is_null_ptr is_null_ptr proc~dtfft_create_plan_r2r_c->is_null_ptr proc~get_comm get_comm proc~dtfft_create_plan_r2r_c->proc~get_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_create_plan_r2r_c.html"},{"title":"dtfft_create_plan_r2r_pencil_c – dtFFT","text":"private  function dtfft_create_plan_r2r_pencil_c(pencil, kinds, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates R2R dtFFT Plan from Pencil, allocates all structures and prepares FFT, C interface Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: pencil C pointer to Fortran pencil type(c_ptr), intent(in), value :: kinds FFT R2R kinds integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_create_plan_r2r_pencil_c~~CallsGraph proc~dtfft_create_plan_r2r_pencil_c dtfft_create_plan_r2r_pencil_c create create proc~dtfft_create_plan_r2r_pencil_c->create is_null_ptr is_null_ptr proc~dtfft_create_plan_r2r_pencil_c->is_null_ptr proc~get_comm get_comm proc~dtfft_create_plan_r2r_pencil_c->proc~get_comm proc~pencil_c2f pencil_c2f proc~dtfft_create_plan_r2r_pencil_c->proc~pencil_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_create_plan_r2r_pencil_c.html"},{"title":"dtfft_create_plan_c2c_c – dtFFT","text":"private  function dtfft_create_plan_c2c_c(ndims, dims, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates C2C dtFFT Plan, allocates all structures and prepares FFT, C interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: ndims Rank of transform. Can be 2 or 3. type(c_ptr), intent(in), value :: dims Global sizes of transform integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_create_plan_c2c_c~~CallsGraph proc~dtfft_create_plan_c2c_c dtfft_create_plan_c2c_c create create proc~dtfft_create_plan_c2c_c->create proc~get_comm get_comm proc~dtfft_create_plan_c2c_c->proc~get_comm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_create_plan_c2c_c.html"},{"title":"dtfft_create_plan_c2c_pencil_c – dtFFT","text":"private  function dtfft_create_plan_c2c_pencil_c(pencil, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates C2C dtFFT plan from Pencil, allocates all structures and prepares FFT, C interface Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: pencil C pointer to Fortran pencil integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_create_plan_c2c_pencil_c~~CallsGraph proc~dtfft_create_plan_c2c_pencil_c dtfft_create_plan_c2c_pencil_c create create proc~dtfft_create_plan_c2c_pencil_c->create proc~get_comm get_comm proc~dtfft_create_plan_c2c_pencil_c->proc~get_comm proc~pencil_c2f pencil_c2f proc~dtfft_create_plan_c2c_pencil_c->proc~pencil_c2f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_create_plan_c2c_pencil_c.html"},{"title":"dtfft_get_z_slab_enabled_c – dtFFT","text":"private  function dtfft_get_z_slab_enabled_c(plan_ptr, is_z_slab_enabled) result(error_code) bind(C) Checks if dtFFT Plan is using Z-slab optimization Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan logical(kind=c_bool), intent(out) :: is_z_slab_enabled Is plan internally using Z-slab optimization Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_z_slab_enabled_c~~CallsGraph proc~dtfft_get_z_slab_enabled_c dtfft_get_z_slab_enabled_c is_null_ptr is_null_ptr proc~dtfft_get_z_slab_enabled_c->is_null_ptr proc~get_z_slab_enabled dtfft_plan_t%get_z_slab_enabled proc~dtfft_get_z_slab_enabled_c->proc~get_z_slab_enabled proc~dtfft_get_error_string dtfft_get_error_string proc~get_z_slab_enabled->proc~dtfft_get_error_string proc~write_message write_message proc~get_z_slab_enabled->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_z_slab_enabled_c.html"},{"title":"dtfft_get_y_slab_enabled_c – dtFFT","text":"private  function dtfft_get_y_slab_enabled_c(plan_ptr, is_y_slab_enabled) result(error_code) bind(C) Checks if dtFFT Plan is using Y-slab optimization Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan logical(kind=c_bool), intent(out) :: is_y_slab_enabled Is plan internally using Y-slab optimization Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_y_slab_enabled_c~~CallsGraph proc~dtfft_get_y_slab_enabled_c dtfft_get_y_slab_enabled_c is_null_ptr is_null_ptr proc~dtfft_get_y_slab_enabled_c->is_null_ptr proc~get_y_slab_enabled dtfft_plan_t%get_y_slab_enabled proc~dtfft_get_y_slab_enabled_c->proc~get_y_slab_enabled proc~dtfft_get_error_string dtfft_get_error_string proc~get_y_slab_enabled->proc~dtfft_get_error_string proc~write_message write_message proc~get_y_slab_enabled->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_y_slab_enabled_c.html"},{"title":"dtfft_execute_c – dtFFT","text":"private  function dtfft_execute_c(plan_ptr, in, out, execute_type, aux) result(error_code) bind(C) Executes dtFFT Plan, C interface. aux can be NULL. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_execute_t ), intent(in) :: execute_type Type of execution type(c_ptr), intent(in), value :: aux Aux buffer, can be NULL Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_execute_c~~CallsGraph proc~dtfft_execute_c dtfft_execute_c is_null_ptr is_null_ptr proc~dtfft_execute_c->is_null_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~dtfft_execute_c->proc~execute_ptr proc~execute_ptr->is_null_ptr proc~check_aux dtfft_plan_t%check_aux proc~execute_ptr->proc~check_aux proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~is_same_ptr is_same_ptr proc~execute_ptr->proc~is_same_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute_ptr->proc~push_nvtx_domain_range proc~check_aux->is_null_ptr interface~to_str to_str proc~check_aux->interface~to_str mpi_abort mpi_abort proc~check_aux->mpi_abort proc~dtfft_get_error_string dtfft_get_error_string proc~check_aux->proc~dtfft_get_error_string proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~get_conf_log_enabled get_conf_log_enabled proc~check_aux->proc~get_conf_log_enabled proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~write_message write_message proc~check_aux->proc~write_message proc~execute_2d dtfft_plan_t%execute_2d proc~execute_private->proc~execute_2d proc~execute_generic dtfft_plan_t%execute_generic proc~execute_private->proc~execute_generic proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_private->proc~execute_z_slab interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~5 transpose_plan%execute proc~execute_2d->proc~execute~5 proc~execute_generic->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute_z_slab->proc~execute~5 proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes~2 interface~get_conf_internal get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~write_message proc~mem_alloc_ptr->is_null_ptr proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_ptr->proc~write_message mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~execute~5->proc~pop_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range execute execute proc~execute~5->execute proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_local_sizes~2->proc~write_message counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem starts starts proc~get_local_sizes~2->starts interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_execute_c.html"},{"title":"dtfft_transpose_c – dtFFT","text":"private  function dtfft_transpose_c(plan_ptr, in, out, transpose_type) result(error_code) bind(C) Executes single transposition, C interface. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_transpose_c~~CallsGraph proc~dtfft_transpose_c dtfft_transpose_c is_null_ptr is_null_ptr proc~dtfft_transpose_c->is_null_ptr proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~dtfft_transpose_c->proc~transpose_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~execute~5 transpose_plan%execute proc~transpose_private->proc~execute~5 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~5->proc~pop_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range execute execute proc~execute~5->execute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_transpose_c.html"},{"title":"dtfft_transpose_start_c – dtFFT","text":"private  function dtfft_transpose_start_c(plan_ptr, in, out, transpose_type, request) result(error_code) bind(C) Starts asynchronous transposition, returns transpose handle, C interface. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. type( dtfft_request_t ), intent(out) :: request Async transpose handle Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_transpose_start_c~~CallsGraph proc~dtfft_transpose_start_c dtfft_transpose_start_c is_null_ptr is_null_ptr proc~dtfft_transpose_start_c->is_null_ptr proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_start_ptr->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_start_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_start_ptr->proc~transpose_private interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~execute~5 transpose_plan%execute proc~transpose_private->proc~execute~5 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~execute~5->proc~pop_nvtx_domain_range proc~execute~5->proc~push_nvtx_domain_range execute execute proc~execute~5->execute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_transpose_start_c.html"},{"title":"dtfft_transpose_end_c – dtFFT","text":"private  function dtfft_transpose_end_c(plan_ptr, request) result(error_code) bind(C) Finishes asynchronous transposition, C interface. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type( dtfft_request_t ), intent(inout) :: request Async transpose handle Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_transpose_end_c~~CallsGraph proc~dtfft_transpose_end_c dtfft_transpose_end_c is_null_ptr is_null_ptr proc~dtfft_transpose_end_c->is_null_ptr proc~transpose_end dtfft_plan_t%transpose_end proc~dtfft_transpose_end_c->proc~transpose_end proc~execute_end~2 transpose_plan%execute_end proc~transpose_end->proc~execute_end~2 proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~transpose_end->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~transpose_end->proc~push_nvtx_domain_range execute_end execute_end proc~execute_end~2->execute_end interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_transpose_end_c.html"},{"title":"dtfft_destroy_c – dtFFT","text":"private  function dtfft_destroy_c(plan_ptr) result(error_code) bind(C) Destroys dtFFT Plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_destroy_c~~CallsGraph proc~dtfft_destroy_c dtfft_destroy_c is_null_ptr is_null_ptr proc~dtfft_destroy_c->is_null_ptr proc~destroy~6 dtfft_plan_t%destroy proc~dtfft_destroy_c->proc~destroy~6 destroy destroy proc~destroy~6->destroy mpi_comm_free mpi_comm_free proc~destroy~6->mpi_comm_free mpi_finalized mpi_finalized proc~destroy~6->mpi_finalized proc~destroy_stream destroy_stream proc~destroy~6->proc~destroy_stream proc~dtfft_get_error_string dtfft_get_error_string proc~destroy~6->proc~dtfft_get_error_string proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~6->proc~mem_free_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~destroy~6->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~destroy~6->proc~push_nvtx_domain_range proc~write_message write_message proc~destroy~6->proc~write_message fname fname proc~destroy_stream->fname interface~cudastreamdestroy cudaStreamDestroy proc~destroy_stream->interface~cudastreamdestroy mpi_abort mpi_abort proc~destroy_stream->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~destroy_stream->proc~cudageterrorstring proc~mem_free_ptr->proc~dtfft_get_error_string proc~mem_free_ptr->proc~write_message interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~write_message->mpi_finalized mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_destroy_c.html"},{"title":"dtfft_get_local_sizes_c – dtFFT","text":"private  function dtfft_get_local_sizes_c(plan_ptr, in_starts, in_counts, out_starts, out_counts, alloc_size) result(error_code) bind(C) Returns local sizes, counts in real and Fourier spaces and number of elements to be allocated for in and out buffers,\nC interface. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int32_t), intent(out), optional :: in_starts (3) Starts of local portion of data in ‘real’ space integer(kind=c_int32_t), intent(out), optional :: in_counts (3) Counts of local portion of data in ‘real’ space integer(kind=c_int32_t), intent(out), optional :: out_starts (3) Starts of local portion of data in ‘fourier’ space integer(kind=c_int32_t), intent(out), optional :: out_counts (3) Counts of local portion of data in ‘fourier’ space integer(kind=c_size_t), intent(out), optional :: alloc_size Minimum data needs to be allocated Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_local_sizes_c~~CallsGraph proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c is_null_ptr is_null_ptr proc~dtfft_get_local_sizes_c->is_null_ptr proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~dtfft_get_error_string dtfft_get_error_string proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem proc~write_message write_message proc~get_local_sizes~2->proc~write_message starts starts proc~get_local_sizes~2->starts proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_local_sizes_c.html"},{"title":"dtfft_get_alloc_size_c – dtFFT","text":"private  function dtfft_get_alloc_size_c(plan_ptr, alloc_size) result(error_code) bind(C) Returns minimum number of bytes to be allocated for in and out buffers, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: alloc_size Minimum data needs to be allocated Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_alloc_size_c~~CallsGraph proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c is_null_ptr is_null_ptr proc~dtfft_get_alloc_size_c->is_null_ptr proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes~2 counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~dtfft_get_error_string dtfft_get_error_string proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem proc~write_message write_message proc~get_local_sizes~2->proc~write_message starts starts proc~get_local_sizes~2->starts proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_alloc_size_c.html"},{"title":"dtfft_get_pencil_c – dtFFT","text":"private  function dtfft_get_pencil_c(plan_ptr, dim, pencil) result(error_code) bind(C) Returns pencil decomposition info, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int32_t), intent(in) :: dim Dimension requested type( dtfft_pencil_c ) :: pencil Pencil pointer Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_pencil_c~~CallsGraph proc~dtfft_get_pencil_c dtfft_get_pencil_c is_null_ptr is_null_ptr proc~dtfft_get_pencil_c->is_null_ptr proc~get_pencil dtfft_plan_t%get_pencil proc~dtfft_get_pencil_c->proc~get_pencil proc~pencil_f2c pencil_f2c proc~dtfft_get_pencil_c->proc~pencil_f2c make_public make_public proc~get_pencil->make_public proc~dtfft_get_error_string dtfft_get_error_string proc~get_pencil->proc~dtfft_get_error_string proc~write_message write_message proc~get_pencil->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_pencil_c.html"},{"title":"dtfft_get_element_size_c – dtFFT","text":"private  function dtfft_get_element_size_c(plan_ptr, element_size) result(error_code) bind(C) Returns size of element in bytes, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: element_size Size of element in bytes Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_element_size_c~~CallsGraph proc~dtfft_get_element_size_c dtfft_get_element_size_c is_null_ptr is_null_ptr proc~dtfft_get_element_size_c->is_null_ptr proc~get_element_size dtfft_plan_t%get_element_size proc~dtfft_get_element_size_c->proc~get_element_size proc~dtfft_get_error_string dtfft_get_error_string proc~get_element_size->proc~dtfft_get_error_string proc~write_message write_message proc~get_element_size->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_element_size_c.html"},{"title":"dtfft_get_alloc_bytes_c – dtFFT","text":"private  function dtfft_get_alloc_bytes_c(plan_ptr, alloc_bytes) result(error_code) bind(C) Returns minimum number of bytes required to execute plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: alloc_bytes Number of bytes required Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_alloc_bytes_c~~CallsGraph proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c is_null_ptr is_null_ptr proc~dtfft_get_alloc_bytes_c->is_null_ptr proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~dtfft_get_error_string dtfft_get_error_string proc~get_alloc_bytes->proc~dtfft_get_error_string proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_bytes->proc~get_alloc_size proc~get_element_size dtfft_plan_t%get_element_size proc~get_alloc_bytes->proc~get_element_size proc~write_message write_message proc~get_alloc_bytes->proc~write_message proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_alloc_size->proc~get_local_sizes~2 proc~get_element_size->proc~dtfft_get_error_string proc~get_element_size->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_local_sizes~2->proc~dtfft_get_error_string proc~get_local_sizes~2->proc~write_message counts counts proc~get_local_sizes~2->counts mpi_allreduce mpi_allreduce proc~get_local_sizes~2->mpi_allreduce proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_local_sizes~2->proc~get_aux_size~2 proc~get_backend~2 transpose_plan%get_backend proc~get_local_sizes~2->proc~get_backend~2 proc~get_local_sizes get_local_sizes proc~get_local_sizes~2->proc~get_local_sizes proc~is_backend_nvshmem is_backend_nvshmem proc~get_local_sizes~2->proc~is_backend_nvshmem starts starts proc~get_local_sizes~2->starts proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size~2->proc~get_aux_size_generic proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic->proc~get_aux_size~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_alloc_bytes_c.html"},{"title":"dtfft_get_executor_c – dtFFT","text":"private  function dtfft_get_executor_c(plan_ptr, executor) result(error_code) bind(C) Returns executor type used in plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_executor_t ), intent(out) :: executor The enumerated type dtfft_executor_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_executor_c~~CallsGraph proc~dtfft_get_executor_c dtfft_get_executor_c is_null_ptr is_null_ptr proc~dtfft_get_executor_c->is_null_ptr proc~get_executor dtfft_plan_t%get_executor proc~dtfft_get_executor_c->proc~get_executor proc~dtfft_get_error_string dtfft_get_error_string proc~get_executor->proc~dtfft_get_error_string proc~write_message write_message proc~get_executor->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_executor_c.html"},{"title":"dtfft_get_precision_c – dtFFT","text":"private  function dtfft_get_precision_c(plan_ptr, precision) result(error_code) bind(C) Returns precision used in plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_precision_t ), intent(out) :: precision The enumerated type dtfft_precision_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_precision_c~~CallsGraph proc~dtfft_get_precision_c dtfft_get_precision_c is_null_ptr is_null_ptr proc~dtfft_get_precision_c->is_null_ptr proc~get_precision dtfft_plan_t%get_precision proc~dtfft_get_precision_c->proc~get_precision proc~dtfft_get_error_string dtfft_get_error_string proc~get_precision->proc~dtfft_get_error_string proc~write_message write_message proc~get_precision->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_precision_c.html"},{"title":"dtfft_get_dims_c – dtFFT","text":"private  function dtfft_get_dims_c(plan_ptr, ndims, dims) result(error_code) bind(C) Returns dimensions of plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int8_t), intent(out) :: ndims Number of dimensions type(c_ptr), intent(out) :: dims Array of dimensions Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_dims_c~~CallsGraph proc~dtfft_get_dims_c dtfft_get_dims_c is_null_ptr is_null_ptr proc~dtfft_get_dims_c->is_null_ptr proc~get_dims dtfft_plan_t%get_dims proc~dtfft_get_dims_c->proc~get_dims proc~dtfft_get_error_string dtfft_get_error_string proc~get_dims->proc~dtfft_get_error_string proc~write_message write_message proc~get_dims->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_dims_c.html"},{"title":"dtfft_get_grid_dims_c – dtFFT","text":"private  function dtfft_get_grid_dims_c(plan_ptr, ndims, grid_dims) result(error_code) bind(C) Returns grid decomposition dimensions of plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int8_t), intent(out) :: ndims Number of dimensions type(c_ptr), intent(out) :: grid_dims Array of dimensions Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_grid_dims_c~~CallsGraph proc~dtfft_get_grid_dims_c dtfft_get_grid_dims_c is_null_ptr is_null_ptr proc~dtfft_get_grid_dims_c->is_null_ptr proc~get_grid_dims dtfft_plan_t%get_grid_dims proc~dtfft_get_grid_dims_c->proc~get_grid_dims proc~dtfft_get_error_string dtfft_get_error_string proc~get_grid_dims->proc~dtfft_get_error_string proc~write_message write_message proc~get_grid_dims->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_grid_dims_c.html"},{"title":"dtfft_set_config_c – dtFFT","text":"private  function dtfft_set_config_c(config) result(error_code) bind(C) Sets dtFFT configuration, C interface Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(in) :: config Configuration to set Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_set_config_c~~CallsGraph proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config_c->proc~dtfft_set_config interface~cudastreamquery cudaStreamQuery proc~dtfft_set_config->interface~cudastreamquery is_null_ptr is_null_ptr proc~dtfft_set_config->is_null_ptr proc~get_correct_backend get_correct_backend proc~dtfft_set_config->proc~get_correct_backend proc~init_internal init_internal proc~dtfft_set_config->proc~init_internal proc~is_valid_backend is_valid_backend proc~dtfft_set_config->proc~is_valid_backend proc~is_valid_platform is_valid_platform proc~dtfft_set_config->proc~is_valid_platform proc~get_conf_platform get_conf_platform proc~get_correct_backend->proc~get_conf_platform mpi_initialized mpi_initialized proc~init_internal->mpi_initialized proc~init_environment init_environment proc~init_internal->proc~init_environment proc~init_environment->proc~is_valid_backend backends backends proc~init_environment->backends destroy destroy proc~init_environment->destroy interface~get_env get_env proc~init_environment->interface~get_env platforms platforms proc~init_environment->platforms proc~destroy_strings destroy_strings proc~init_environment->proc~destroy_strings proc~write_message write_message proc~init_environment->proc~write_message proc~get_env_base get_env_base interface~get_env->proc~get_env_base proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~get_env_string get_env_string interface~get_env->proc~get_env_string proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_env_base->proc~destroy_string proc~get_env_int32->interface~get_env proc~get_env_int32->proc~write_message proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_env_string->interface~get_env proc~get_env_string->proc~write_message proc~get_env_string->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_set_config_c.html"},{"title":"dtfft_report_c – dtFFT","text":"private  function dtfft_report_c(plan_ptr) result(error_code) bind(C) Reports dtFFT Plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_report_c~~CallsGraph proc~dtfft_report_c dtfft_report_c is_null_ptr is_null_ptr proc~dtfft_report_c->is_null_ptr proc~report dtfft_plan_t%report proc~dtfft_report_c->proc~report interface~to_str to_str proc~report->interface~to_str mpi_comm_size mpi_comm_size proc~report->mpi_comm_size proc~dtfft_get_backend_string dtfft_get_backend_string proc~report->proc~dtfft_get_backend_string proc~dtfft_get_error_string dtfft_get_error_string proc~report->proc~dtfft_get_error_string proc~dtfft_get_executor_string dtfft_get_executor_string proc~report->proc~dtfft_get_executor_string proc~dtfft_get_precision_string dtfft_get_precision_string proc~report->proc~dtfft_get_precision_string proc~get_backend~2 transpose_plan%get_backend proc~report->proc~get_backend~2 proc~write_message write_message proc~report->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_report_c.html"},{"title":"dtfft_mem_alloc_c – dtFFT","text":"private  function dtfft_mem_alloc_c(plan_ptr, alloc_bytes, ptr) result(error_code) bind(C) Allocates memory for dtFFT Plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), value :: alloc_bytes Number of bytes to allocate type(c_ptr) :: ptr Allocated pointer Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_mem_alloc_c~~CallsGraph proc~dtfft_mem_alloc_c dtfft_mem_alloc_c is_null_ptr is_null_ptr proc~dtfft_mem_alloc_c->is_null_ptr proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~mem_alloc_ptr->is_null_ptr mem_alloc mem_alloc proc~mem_alloc_ptr->mem_alloc proc~dtfft_get_error_string dtfft_get_error_string proc~mem_alloc_ptr->proc~dtfft_get_error_string proc~mem_alloc_host mem_alloc_host proc~mem_alloc_ptr->proc~mem_alloc_host proc~write_message write_message proc~mem_alloc_ptr->proc~write_message interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_mem_alloc_c.html"},{"title":"dtfft_mem_free_c – dtFFT","text":"private  function dtfft_mem_free_c(plan_ptr, ptr) result(error_code) bind(C) Frees memory for dtFFT Plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type(c_ptr), value :: ptr Pointer to deallocate Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_mem_free_c~~CallsGraph proc~dtfft_mem_free_c dtfft_mem_free_c is_null_ptr is_null_ptr proc~dtfft_mem_free_c->is_null_ptr proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~dtfft_mem_free_c->proc~mem_free_ptr interface~mem_free_host mem_free_host proc~mem_free_ptr->interface~mem_free_host mem_free mem_free proc~mem_free_ptr->mem_free proc~dtfft_get_error_string dtfft_get_error_string proc~mem_free_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~mem_free_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_mem_free_c.html"},{"title":"dtfft_get_backend_c – dtFFT","text":"private  function dtfft_get_backend_c(plan_ptr, backend) result(error_code) bind(C) Returns selected dtfft_backend_t during autotuning Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_backend_t ), intent(out) :: backend The enumerated type dtfft_backend_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_backend_c~~CallsGraph proc~dtfft_get_backend_c dtfft_get_backend_c is_null_ptr is_null_ptr proc~dtfft_get_backend_c->is_null_ptr proc~get_backend dtfft_plan_t%get_backend proc~dtfft_get_backend_c->proc~get_backend proc~dtfft_get_error_string dtfft_get_error_string proc~get_backend->proc~dtfft_get_error_string proc~get_backend~2 transpose_plan%get_backend proc~get_backend->proc~get_backend~2 proc~write_message write_message proc~get_backend->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_backend_c.html"},{"title":"dtfft_get_stream_c – dtFFT","text":"private  function dtfft_get_stream_c(plan_ptr, stream) result(error_code) bind(C) Returns Stream associated with plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_stream_t ), intent(out) :: stream CUDA stream Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_stream_c~~CallsGraph proc~dtfft_get_stream_c dtfft_get_stream_c is_null_ptr is_null_ptr proc~dtfft_get_stream_c->is_null_ptr none~get_stream dtfft_plan_t%get_stream proc~dtfft_get_stream_c->none~get_stream proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream->proc~get_stream_int64 proc~get_stream_ptr dtfft_plan_t%get_stream_ptr none~get_stream->proc~get_stream_ptr proc~get_stream_int64->none~get_stream proc~dtfft_get_cuda_stream dtfft_get_cuda_stream proc~get_stream_int64->proc~dtfft_get_cuda_stream proc~dtfft_get_error_string dtfft_get_error_string proc~get_stream_ptr->proc~dtfft_get_error_string proc~write_message write_message proc~get_stream_ptr->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_stream_c.html"},{"title":"dtfft_get_platform_c – dtFFT","text":"private  function dtfft_get_platform_c(plan_ptr, platform) result(error_code) bind(C) Returns selected dtfft_platform_t during autotuning Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_platform_t ), intent(out) :: platform The enumerated type dtfft_platform_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Calls proc~~dtfft_get_platform_c~~CallsGraph proc~dtfft_get_platform_c dtfft_get_platform_c is_null_ptr is_null_ptr proc~dtfft_get_platform_c->is_null_ptr proc~get_platform dtfft_plan_t%get_platform proc~dtfft_get_platform_c->proc~get_platform proc~dtfft_get_error_string dtfft_get_error_string proc~get_platform->proc~dtfft_get_error_string proc~write_message write_message proc~get_platform->proc~write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_platform_c.html"},{"title":"dtfft_get_error_string_c – dtFFT","text":"private  subroutine dtfft_get_error_string_c(error_code, error_string, error_string_size) bind(C) Returns an explaination of error_code that could have been previously returned by one of dtFFT API calls,\nC interface Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: error_code The enumerated type dtfft_error_t\ndefines API call result codes. character(len=c_char), intent(out) :: error_string (*) Explanation of error integer(kind=c_size_t), intent(out) :: error_string_size Size of error_string Calls proc~~dtfft_get_error_string_c~~CallsGraph proc~dtfft_get_error_string_c dtfft_get_error_string_c proc~dtfft_get_error_string dtfft_get_error_string proc~dtfft_get_error_string_c->proc~dtfft_get_error_string proc~string_f2c string_f2c proc~dtfft_get_error_string_c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_error_string_c.html"},{"title":"dtfft_get_precision_string_c – dtFFT","text":"private  subroutine dtfft_get_precision_string_c(precision, precision_string, precision_string_size) bind(C) Returns string representation of dtfft_precision_t , C interface Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: precision The enumerated type dtfft_precision_t character(len=c_char), intent(out) :: precision_string (*) Resulting string integer(kind=c_size_t), intent(out) :: precision_string_size Size of string Calls proc~~dtfft_get_precision_string_c~~CallsGraph proc~dtfft_get_precision_string_c dtfft_get_precision_string_c proc~dtfft_get_precision_string dtfft_get_precision_string proc~dtfft_get_precision_string_c->proc~dtfft_get_precision_string proc~string_f2c string_f2c proc~dtfft_get_precision_string_c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_precision_string_c.html"},{"title":"dtfft_get_executor_string_c – dtFFT","text":"private  subroutine dtfft_get_executor_string_c(executor, executor_string, executor_string_size) bind(C) Returns string representation of dtfft_executor_t , C interface Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: executor The enumerated type dtfft_executor_t character(len=c_char), intent(out) :: executor_string (*) Resulting string integer(kind=c_size_t), intent(out) :: executor_string_size Size of string Calls proc~~dtfft_get_executor_string_c~~CallsGraph proc~dtfft_get_executor_string_c dtfft_get_executor_string_c proc~dtfft_get_executor_string dtfft_get_executor_string proc~dtfft_get_executor_string_c->proc~dtfft_get_executor_string proc~string_f2c string_f2c proc~dtfft_get_executor_string_c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_executor_string_c.html"},{"title":"dtfft_get_backend_string_c – dtFFT","text":"private  subroutine dtfft_get_backend_string_c(backend, backend_string, backend_string_size) bind(C) Returns string representation of dtfft_backend_t Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: backend The enumerated type dtfft_backend_t character(len=c_char), intent(out) :: backend_string (*) Resulting string integer(kind=c_size_t), intent(out) :: backend_string_size Size of string Calls proc~~dtfft_get_backend_string_c~~CallsGraph proc~dtfft_get_backend_string_c dtfft_get_backend_string_c proc~dtfft_get_backend_string dtfft_get_backend_string proc~dtfft_get_backend_string_c->proc~dtfft_get_backend_string proc~string_f2c string_f2c proc~dtfft_get_backend_string_c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_backend_string_c.html"},{"title":"is_nvshmem_ptr – dtFFT","text":"public  function is_nvshmem_ptr(ptr) result(bool) Checks if pointer is a symmetric nvshmem allocated pointer Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr Device pointer Return Value logical Result Calls proc~~is_nvshmem_ptr~~CallsGraph proc~is_nvshmem_ptr is_nvshmem_ptr interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr->interface~nvshmem_my_pe interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr is_null_ptr is_null_ptr proc~is_nvshmem_ptr->is_null_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_nvshmem_ptr~~CalledByGraph proc~is_nvshmem_ptr is_nvshmem_ptr proc~check_device_pointers check_device_pointers proc~check_device_pointers->proc~is_nvshmem_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_nvshmem_ptr.html"},{"title":"nvshmem_malloc – dtFFT","text":"interface Called by interface~~nvshmem_malloc~~CalledByGraph interface~nvshmem_malloc nvshmem_malloc proc~alloc_mem alloc_mem proc~alloc_mem->interface~nvshmem_malloc proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function nvshmem_malloc(size) result(ptr) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: size Size of the allocation in bytes. Return Value type(c_ptr) Pointer to the allocated memory. Description Allocates symmetric memory in the NVSHMEM heap.","tags":"","loc":"interface/nvshmem_malloc.html"},{"title":"nvshmem_free – dtFFT","text":"public interface nvshmem_free Subroutines private  subroutine nvshmem_free(ptr) bind(C) Frees symmetric memory allocated by nvshmem_malloc. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to the memory to free.","tags":"","loc":"interface/nvshmem_free.html"},{"title":"nvshmemx_sync_all_on_stream – dtFFT","text":"interface public  subroutine nvshmemx_sync_all_on_stream(stream) bind(C) Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), intent(in), value :: stream CUDA stream for synchronization. Description Synchronizes all PEs (Processing Elements) on the specified stream.","tags":"","loc":"interface/nvshmemx_sync_all_on_stream.html"},{"title":"nvshmemx_float_alltoall_on_stream – dtFFT","text":"interface public  function nvshmemx_float_alltoall_on_stream(team, dest, source, nelems, stream) result(ierr) bind(C) Arguments Type Intent Optional Attributes Name type( nvshmem_team_t ), intent(in), value :: team NVSHMEM team. type(c_ptr), value :: dest Destination buffer. type(c_ptr), value :: source Source buffer. integer(kind=c_size_t), intent(in), value :: nelems Number of elements to exchange. type( dtfft_stream_t ), intent(in), value :: stream CUDA stream for the operation. Return Value integer(kind=c_int) Completion status. Description Performs an all-to-all exchange of floating-point data on the specified stream.","tags":"","loc":"interface/nvshmemx_float_alltoall_on_stream.html"},{"title":"nvshmem_ptr – dtFFT","text":"interface Called by interface~~nvshmem_ptr~~CalledByGraph interface~nvshmem_ptr nvshmem_ptr proc~is_nvshmem_ptr is_nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_ptr proc~check_device_pointers check_device_pointers proc~check_device_pointers->proc~is_nvshmem_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function nvshmem_ptr(ptr, pe) result(pe_ptr) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Local pointer to the symmetric memory. integer(kind=c_int), value :: pe PE (Processing Element) number. Return Value type(c_ptr) Pointer to the symmetric memory on the specified PE. Description Returns a pointer to a symmetric memory location on a specified PE.","tags":"","loc":"interface/nvshmem_ptr.html"},{"title":"nvshmem_my_pe – dtFFT","text":"interface Called by interface~~nvshmem_my_pe~~CalledByGraph interface~nvshmem_my_pe nvshmem_my_pe proc~is_nvshmem_ptr is_nvshmem_ptr proc~is_nvshmem_ptr->interface~nvshmem_my_pe proc~check_device_pointers check_device_pointers proc~check_device_pointers->proc~is_nvshmem_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function nvshmem_my_pe() result(pe) bind(C) Arguments None Return Value integer(kind=c_int) PE number of the calling thread. Description Returns the PE (Processing Element) number of the calling thread.","tags":"","loc":"interface/nvshmem_my_pe.html"},{"title":"nvshmemx_init_status – dtFFT","text":"interface private  function nvshmemx_init_status() result(status) bind(C) Arguments None Return Value integer(kind=c_int) Completion status.","tags":"","loc":"interface/nvshmemx_init_status.html"},{"title":"init_nvshmem – dtFFT","text":"interface private  subroutine init_nvshmem(comm) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: comm MPI communicator (C handle)","tags":"","loc":"interface/init_nvshmem.html"},{"title":"nvshmem_finalize_ – dtFFT","text":"interface private  subroutine nvshmem_finalize_() bind(C, name=\"nvshmemi_finalize\") Arguments None Description Finalizes the NVSHMEM library.","tags":"","loc":"interface/nvshmem_finalize_.html"},{"title":"cufftGetErrorString – dtFFT","text":"public  function cufftGetErrorString(error_code) result(string) Returns a string representation of the cuFFT error code. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: error_code cuFFT error code Return Value character(len=:), allocatable String representation of the cuFFT error code Called by proc~~cufftgeterrorstring~~CalledByGraph proc~cufftgeterrorstring cufftGetErrorString proc~create~15 backend_cufftmp%create proc~create~15->proc~cufftgeterrorstring proc~create~8 cufft_executor%create proc~create~8->proc~cufftgeterrorstring proc~destroy~14 backend_cufftmp%destroy proc~destroy~14->proc~cufftgeterrorstring proc~destroy~9 cufft_executor%destroy proc~destroy~9->proc~cufftgeterrorstring proc~execute~12 backend_cufftmp%execute proc~execute~12->proc~cufftgeterrorstring proc~execute~7 cufft_executor%execute proc~execute~7->proc~cufftgeterrorstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cufftgeterrorstring.html"},{"title":"cufftPlanMany – dtFFT","text":"interface Creates a FFT plan configuration of dimension rank, with sizes specified in the array n. Called by interface~~cufftplanmany~~CalledByGraph interface~cufftplanmany cufftPlanMany proc~create~8 cufft_executor%create proc~create~8->interface~cufftplanmany Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftPlanMany(plan, rank, n, inembed, istride, idist, onembed, ostride, odist, ffttype, batch) result(cufftResult) bind(C, name=\"cufftPlanMany\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: plan Pointer to an uninitialized cufftHandle object. integer(kind=c_int), value :: rank Dimensionality of the transform (1, 2, or 3). integer(kind=c_int) :: n (*) Array of size rank, describing the size of each dimension,\nn[0] being the size of the outermost\nand n[rank-1] innermost (contiguous) dimension of a transform. integer(kind=c_int) :: inembed (*) Pointer of size rank that indicates the storage dimensions of the input data in memory.\nIf set to NULL, all other advanced data layout parameters are ignored. integer(kind=c_int), value :: istride Indicates the distance between two successive input elements in the least\nsignificant (i.e., innermost) dimension. integer(kind=c_int), value :: idist Indicates the distance between the first element of two consecutive signals\nin a batch of the input data. integer(kind=c_int) :: onembed (*) Pointer of size rank that indicates the storage dimensions of the output data in memory.\nIf set to NULL, all other advanced data layout parameters are ignored. integer(kind=c_int), value :: ostride Indicates the distance between two successive output elements in the output array\nin the least significant (i.e., innermost) dimension. integer(kind=c_int), value :: odist Indicates the distance between the first element of two consecutive signals\nin a batch of the output data. integer(kind=c_int), value :: ffttype The transform data type (e.g., CUFFT_R2C for single precision real to complex). integer(kind=c_int), value :: batch Batch size for this transform. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftplanmany.html"},{"title":"cufftXtExec – dtFFT","text":"interface Executes any cuFFT transform regardless of precision and type.\nIn case of complex-to-real and real-to-complex transforms, the direction parameter is ignored. Called by interface~~cufftxtexec~~CalledByGraph interface~cufftxtexec cufftXtExec proc~execute~7 cufft_executor%execute proc~execute~7->interface~cufftxtexec Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftXtExec(plan, input, output, direction) result(cufftResult) bind(C, name=\"cufftXtExec\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan cufftHandle returned by cufftCreate. type(c_ptr), value :: input Pointer to the input data (in GPU memory) to transform. type(c_ptr), value :: output Pointer to the output data (in GPU memory). integer(kind=c_int), value :: direction The transform direction: CUFFT_FORWARD or CUFFT_INVERSE.\nIgnored for complex-to-real and real-to-complex transforms. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftxtexec.html"},{"title":"cufftDestroy – dtFFT","text":"interface Frees all GPU resources associated with a cuFFT plan and destroys the internal plan data structure. Called by interface~~cufftdestroy~~CalledByGraph interface~cufftdestroy cufftDestroy proc~destroy~9 cufft_executor%destroy proc~destroy~9->interface~cufftdestroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftDestroy(plan) result(cufftResult) bind(C, name=\"cufftDestroy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Object of the plan to be destroyed. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftdestroy.html"},{"title":"cufftSetStream – dtFFT","text":"interface Associates a CUDA stream with a cuFFT plan. Called by interface~~cufftsetstream~~CalledByGraph interface~cufftsetstream cufftSetStream proc~create~8 cufft_executor%create proc~create~8->interface~cufftsetstream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftSetStream(plan, stream) result(cufftResult) bind(C, name=\"cufftSetStream\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Object to associate with the stream. type( dtfft_stream_t ), value :: stream A valid CUDA stream. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftsetstream.html"},{"title":"cufftMpCreateReshape – dtFFT","text":"interface Initializes a reshape handle for future use. This function is not collective. Called by interface~~cufftmpcreatereshape~~CalledByGraph interface~cufftmpcreatereshape cufftMpCreateReshape proc~create~15 backend_cufftmp%create proc~create~15->interface~cufftmpcreatereshape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpCreateReshape(reshapeHandle) result(cufftResult) bind(C, name=\"cufftMpCreateReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ) :: reshapeHandle The reshape handle. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpcreatereshape.html"},{"title":"cufftMpAttachReshapeComm – dtFFT","text":"interface Attaches a communication handle to a reshape. This function is not collective. Called by interface~~cufftmpattachreshapecomm~~CalledByGraph interface~cufftmpattachreshapecomm cufftMpAttachReshapeComm proc~create~15 backend_cufftmp%create proc~create~15->interface~cufftmpattachreshapecomm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpAttachReshapeComm(reshapeHandle, commType, comm) result(cufftResult) bind(C, name=\"cufftMpAttachReshapeComm\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_int), value :: commType An enum describing the communication type of the handle. type(c_ptr) :: comm If commType is CUFFT_COMM_MPI, this should be a pointer to an MPI communicator.\nThe pointer should remain valid until destruction of the handle.\nOtherwise, this should be NULL. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpattachreshapecomm.html"},{"title":"cufftMpGetReshapeSize – dtFFT","text":"interface Returns the amount (in bytes) of workspace required to execute the handle. Called by interface~~cufftmpgetreshapesize~~CalledByGraph interface~cufftmpgetreshapesize cufftMpGetReshapeSize proc~create~15 backend_cufftmp%create proc~create~15->interface~cufftmpgetreshapesize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpGetReshapeSize(reshapeHandle, workSize) result(cufftResult) bind(C, name=\"cufftMpGetReshapeSize\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_size_t) :: workSize The size, in bytes, of the workspace required during reshape execution. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpgetreshapesize.html"},{"title":"cufftMpMakeReshape – dtFFT","text":"interface Creates a reshape intended to re-distribute a global array of 3D data. Called by interface~~cufftmpmakereshape~~CalledByGraph interface~cufftmpmakereshape cufftMpMakeReshape proc~create~15 backend_cufftmp%create proc~create~15->interface~cufftmpmakereshape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpMakeReshape(reshapeHandle, elementSize, rank, lower_input, upper_input, lower_output, upper_output, strides_input, strides_output) result(cufftResult) bind(C, name=\"cufftMpMakeReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_long_long), value :: elementSize The size of the individual elements, in bytes. Allowed values are 4, 8, and 16. integer(kind=c_int), value :: rank The length of the lower_input, upper_input, lower_output, upper_output, strides_input, and strides_output arrays. rank should be 3. integer(kind=c_long_long) :: lower_input (*) An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer(kind=c_long_long) :: upper_input (*) An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer(kind=c_long_long) :: lower_output (*) An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer(kind=c_long_long) :: upper_output (*) An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer(kind=c_long_long) :: strides_input (*) An array of length rank, representing the local data layout of the input descriptor in memory. All entries must be decreasing and positive. integer(kind=c_long_long) :: strides_output (*) An array of length rank, representing the local data layout of the output descriptor in memory. All entries must be decreasing and positive. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpmakereshape.html"},{"title":"cufftMpExecReshapeAsync – dtFFT","text":"interface Executes the reshape, redistributing data_in into data_out using the workspace in workspace. Called by interface~~cufftmpexecreshapeasync~~CalledByGraph interface~cufftmpexecreshapeasync cufftMpExecReshapeAsync proc~execute~12 backend_cufftmp%execute proc~execute~12->interface~cufftmpexecreshapeasync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpExecReshapeAsync(reshapeHandle, dataOut, dataIn, workSpace, stream) result(cufftResult) bind(C, name=\"cufftMpExecReshapeAsync\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. type(c_ptr), value :: dataOut A symmetric-heap pointer to the output data. This memory should be NVSHMEM allocated and identical on all processes. type(c_ptr), value :: dataIn A symmetric-heap pointer to the input data. This memory should be NVSHMEM allocated and identical on all processes. type(c_ptr), value :: workSpace A symmetric-heap pointer to the workspace data. This memory should be NVSHMEM allocated and identical on all processes. type( dtfft_stream_t ), value :: stream The CUDA stream in which to run the reshape operation. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpexecreshapeasync.html"},{"title":"cufftMpDestroyReshape – dtFFT","text":"interface Destroys a reshape and all its associated data. Called by interface~~cufftmpdestroyreshape~~CalledByGraph interface~cufftmpdestroyreshape cufftMpDestroyReshape proc~destroy~14 backend_cufftmp%destroy proc~destroy~14->interface~cufftmpdestroyreshape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftMpDestroyReshape(reshapeHandle) result(cufftResult) bind(C, name=\"cufftMpDestroyReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes.","tags":"","loc":"interface/cufftmpdestroyreshape.html"},{"title":"get_async_active – dtFFT","text":"private elemental function get_async_active(self) Returns if async transpose is active Type Bound backend_mpi Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(in) :: self MPI Backend Return Value logical","tags":"","loc":"proc/get_async_active~4.html"},{"title":"create_helper – dtFFT","text":"private  subroutine create_helper(self, counts, displs, max_requests) Creates MPI helper Type Bound mpi_backend_helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper integer(kind=int64), intent(in) :: counts (:) Counts of data to send or recv integer(kind=int64), intent(in) :: displs (:) Displacements of data to send or recv integer(kind=int32), intent(in) :: max_requests Maximum number of requests required Called by proc~~create_helper~2~~CalledByGraph proc~create_helper~2 mpi_backend_helper%create_helper proc~create_mpi backend_mpi%create_mpi proc~create_mpi->proc~create_helper~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_helper~2.html"},{"title":"destroy_helper – dtFFT","text":"private  subroutine destroy_helper(self, is_request_created) Destroys MPI helper Type Bound mpi_backend_helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper logical, intent(in) :: is_request_created Calls proc~~destroy_helper~2~~CallsGraph proc~destroy_helper~2 mpi_backend_helper%destroy_helper mpi_request_free mpi_request_free proc~destroy_helper~2->mpi_request_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_helper~2~~CalledByGraph proc~destroy_helper~2 mpi_backend_helper%destroy_helper proc~destroy_mpi backend_mpi%destroy_mpi proc~destroy_mpi->proc~destroy_helper~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_helper~2.html"},{"title":"create_mpi – dtFFT","text":"private  subroutine create_mpi(self, helper, base_storage) Creates MPI backend Type Bound backend_mpi Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend type( backend_helper ), intent(in) :: helper Backend helper (unused) integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) Calls proc~~create_mpi~~CallsGraph proc~create_mpi backend_mpi%create_mpi proc~create_helper~2 mpi_backend_helper%create_helper proc~create_mpi->proc~create_helper~2 proc~is_backend_mpi is_backend_mpi proc~create_mpi->proc~is_backend_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_mpi.html"},{"title":"destroy_mpi – dtFFT","text":"private  subroutine destroy_mpi(self) Destroys MPI backend Type Bound backend_mpi Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend Calls proc~~destroy_mpi~~CallsGraph proc~destroy_mpi backend_mpi%destroy_mpi proc~destroy_helper~2 mpi_backend_helper%destroy_helper proc~destroy_mpi->proc~destroy_helper~2 mpi_request_free mpi_request_free proc~destroy_helper~2->mpi_request_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_mpi.html"},{"title":"execute_mpi – dtFFT","text":"private  subroutine execute_mpi(self, in, out, stream, aux, exec_type, error_code) Uses iso_fortran_env iso_c_binding proc~~execute_mpi~~UsesGraph proc~execute_mpi backend_mpi%execute_mpi iso_c_binding iso_c_binding proc~execute_mpi->iso_c_binding iso_fortran_env iso_fortran_env proc~execute_mpi->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes MPI backend Type Bound backend_mpi Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code Calls proc~~execute_mpi~~CallsGraph proc~execute_mpi backend_mpi%execute_mpi fname fname proc~execute_mpi->fname interface~cudastreamsynchronize cudaStreamSynchronize proc~execute_mpi->interface~cudastreamsynchronize mpi_abort mpi_abort proc~execute_mpi->mpi_abort mpi_waitall mpi_waitall proc~execute_mpi->mpi_waitall mpi_waitsome mpi_waitsome proc~execute_mpi->mpi_waitsome mpi_win_fence mpi_win_fence proc~execute_mpi->mpi_win_fence proc~cudageterrorstring cudaGetErrorString proc~execute_mpi->proc~cudageterrorstring proc~execute~13 abstract_kernel%execute proc~execute_mpi->proc~execute~13 proc~run_mpi_a2a run_mpi_a2a proc~execute_mpi->proc~run_mpi_a2a proc~run_mpi_p2p run_mpi_p2p proc~execute_mpi->proc~run_mpi_p2p interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f execute_private execute_private proc~execute~13->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~13->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~13->proc~push_nvtx_domain_range mpi_alltoallv_init mpi_alltoallv_init proc~run_mpi_a2a->mpi_alltoallv_init mpi_start mpi_start proc~run_mpi_a2a->mpi_start mpi_comm_size mpi_comm_size proc~run_mpi_p2p->mpi_comm_size mpi_recv_init mpi_recv_init proc~run_mpi_p2p->mpi_recv_init mpi_send_init mpi_send_init proc~run_mpi_p2p->mpi_send_init mpi_startall mpi_startall proc~run_mpi_p2p->mpi_startall interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_mpi.html"},{"title":"execute_end_mpi – dtFFT","text":"private  subroutine execute_end_mpi(self, error_code) Type Bound backend_mpi Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend integer(kind=int32), intent(out) :: error_code Error code Calls proc~~execute_end_mpi~~CallsGraph proc~execute_end_mpi backend_mpi%execute_end_mpi mpi_waitall mpi_waitall proc~execute_end_mpi->mpi_waitall mpi_win_fence mpi_win_fence proc~execute_end_mpi->mpi_win_fence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_end_mpi.html"},{"title":"run_mpi_p2p – dtFFT","text":"private  subroutine run_mpi_p2p(comm, send, recv, in, out, is_request_created) Executes MPI point-to-point communication Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI communicator type( mpi_backend_helper ), intent(inout) :: send MPI Helper for send data type( mpi_backend_helper ), intent(inout) :: recv MPI Helper for recv data real(kind=real32), intent(in) :: in (:) Data to be sent real(kind=real32), intent(inout) :: out (:) Data to be received logical, intent(inout) :: is_request_created Calls proc~~run_mpi_p2p~~CallsGraph proc~run_mpi_p2p run_mpi_p2p mpi_comm_size mpi_comm_size proc~run_mpi_p2p->mpi_comm_size mpi_recv_init mpi_recv_init proc~run_mpi_p2p->mpi_recv_init mpi_send_init mpi_send_init proc~run_mpi_p2p->mpi_send_init mpi_startall mpi_startall proc~run_mpi_p2p->mpi_startall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_mpi_p2p~~CalledByGraph proc~run_mpi_p2p run_mpi_p2p proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~run_mpi_p2p Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/run_mpi_p2p.html"},{"title":"run_mpi_a2a – dtFFT","text":"private  subroutine run_mpi_a2a(comm, send, recv, in, out, is_request_created) Executes MPI all-to-all communication Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI communicator type( mpi_backend_helper ), intent(inout) :: send MPI Helper for send data type( mpi_backend_helper ), intent(inout) :: recv MPI Helper for recv data real(kind=real32), intent(in) :: in (:) Data to be sent real(kind=real32), intent(inout) :: out (:) Data to be received logical, intent(inout) :: is_request_created Calls proc~~run_mpi_a2a~~CallsGraph proc~run_mpi_a2a run_mpi_a2a mpi_alltoallv_init mpi_alltoallv_init proc~run_mpi_a2a->mpi_alltoallv_init mpi_start mpi_start proc~run_mpi_a2a->mpi_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_mpi_a2a~~CalledByGraph proc~run_mpi_a2a run_mpi_a2a proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~run_mpi_a2a Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/run_mpi_a2a.html"},{"title":"create_host – dtFFT","text":"private  subroutine create_host(self, effort, base_storage, force_effort) Creates kernel Type Bound kernel_host Arguments Type Intent Optional Attributes Name class( kernel_host ), intent(inout) :: self Host kernel class type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in), optional :: force_effort Should effort be forced or not","tags":"","loc":"proc/create_host.html"},{"title":"execute_host – dtFFT","text":"private  subroutine execute_host(self, in, out, stream, neighbor) Executes host kernel Type Bound kernel_host Arguments Type Intent Optional Attributes Name class( kernel_host ), intent(inout) :: self Host kernel class real(kind=real32), intent(in), target :: in (:) Source host-allocated buffer real(kind=real32), intent(inout), target :: out (:) Target host-allocated buffer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, unused here integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking Calls proc~~execute_host~~CallsGraph proc~execute_host kernel_host%execute_host inbuf inbuf proc~execute_host->inbuf outbuf outbuf proc~execute_host->outbuf proc~permute_backward_end_f128 permute_backward_end_f128 proc~execute_host->proc~permute_backward_end_f128 proc~permute_backward_end_f32 permute_backward_end_f32 proc~execute_host->proc~permute_backward_end_f32 proc~permute_backward_end_f64 permute_backward_end_f64 proc~execute_host->proc~permute_backward_end_f64 proc~permute_backward_end_pipelined_f128 permute_backward_end_pipelined_f128 proc~execute_host->proc~permute_backward_end_pipelined_f128 proc~permute_backward_end_pipelined_f32 permute_backward_end_pipelined_f32 proc~execute_host->proc~permute_backward_end_pipelined_f32 proc~permute_backward_end_pipelined_f64 permute_backward_end_pipelined_f64 proc~execute_host->proc~permute_backward_end_pipelined_f64 proc~permute_backward_f128 permute_backward_f128 proc~execute_host->proc~permute_backward_f128 proc~permute_backward_f32 permute_backward_f32 proc~execute_host->proc~permute_backward_f32 proc~permute_backward_f64 permute_backward_f64 proc~execute_host->proc~permute_backward_f64 proc~permute_backward_start_f128 permute_backward_start_f128 proc~execute_host->proc~permute_backward_start_f128 proc~permute_backward_start_f32 permute_backward_start_f32 proc~execute_host->proc~permute_backward_start_f32 proc~permute_backward_start_f64 permute_backward_start_f64 proc~execute_host->proc~permute_backward_start_f64 proc~permute_forward_f128 permute_forward_f128 proc~execute_host->proc~permute_forward_f128 proc~permute_forward_f32 permute_forward_f32 proc~execute_host->proc~permute_forward_f32 proc~permute_forward_f64 permute_forward_f64 proc~execute_host->proc~permute_forward_f64 proc~unpack_f128 unpack_f128 proc~execute_host->proc~unpack_f128 proc~unpack_f32 unpack_f32 proc~execute_host->proc~unpack_f32 proc~unpack_f64 unpack_f64 proc~execute_host->proc~unpack_f64 proc~unpack_pipelined_f128 unpack_pipelined_f128 proc~execute_host->proc~unpack_pipelined_f128 proc~unpack_pipelined_f32 unpack_pipelined_f32 proc~execute_host->proc~unpack_pipelined_f32 proc~unpack_pipelined_f64 unpack_pipelined_f64 proc~execute_host->proc~unpack_pipelined_f64 proc~permute_backward_end_f128->proc~permute_backward_end_pipelined_f128 proc~permute_backward_end_f32->proc~permute_backward_end_pipelined_f32 proc~permute_backward_end_f64->proc~permute_backward_end_pipelined_f64 proc~unpack_f128->proc~unpack_pipelined_f128 proc~unpack_f32->proc~unpack_pipelined_f32 proc~unpack_f64->proc~unpack_pipelined_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_host.html"},{"title":"destroy_host – dtFFT","text":"private  subroutine destroy_host(self) Destroys host kernel Type Bound kernel_host Arguments Type Intent Optional Attributes Name class( kernel_host ), intent(inout) :: self Host kernel class","tags":"","loc":"proc/destroy_host.html"},{"title":"permute_forward_f128 – dtFFT","text":"private  subroutine permute_forward_f128(in, out, dims) Forward permutation of a 2D and 3D arrays Forward permutation is defined as: out(x,y,z) = in(z,x,y) for 3D arrays out(x,y)   = in(y,x)   for 2D arrays Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array Called by proc~~permute_forward_f128~~CalledByGraph proc~permute_forward_f128 permute_forward_f128 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_forward_f128 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_forward_f128.html"},{"title":"permute_backward_f128 – dtFFT","text":"private  subroutine permute_backward_f128(in, out, dims) Backward permutation of a 2D and 3D arrays Backward permutation is defined as: out(x,y,z) = in(y,z,x) for 3D arrays Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array Called by proc~~permute_backward_f128~~CalledByGraph proc~permute_backward_f128 permute_backward_f128 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_f128 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_f128.html"},{"title":"permute_backward_start_f128 – dtFFT","text":"private  subroutine permute_backward_start_f128(in, out, dims) Backward permutation start of a 3D array Backward permutation start is defined as: out(x,y,z) = in(z,y,x) for 3D arrays Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array Called by proc~~permute_backward_start_f128~~CalledByGraph proc~permute_backward_start_f128 permute_backward_start_f128 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_start_f128 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_start_f128.html"},{"title":"permute_backward_end_pipelined_f128 – dtFFT","text":"private  subroutine permute_backward_end_pipelined_f128(in, out, dims, neighbor_data) Backward permutation end of a 3D array for a single neighbor Backward permutation end is defined as: out(x,y,z) = in(x,z,y) for 3D arrays Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data Called by proc~~permute_backward_end_pipelined_f128~~CalledByGraph proc~permute_backward_end_pipelined_f128 permute_backward_end_pipelined_f128 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_end_pipelined_f128 proc~permute_backward_end_f128 permute_backward_end_f128 proc~execute_host->proc~permute_backward_end_f128 proc~permute_backward_end_f128->proc~permute_backward_end_pipelined_f128 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_end_pipelined_f128.html"},{"title":"permute_backward_end_f128 – dtFFT","text":"private  subroutine permute_backward_end_f128(in, out, dims, neighbor_data) Backward permutation end of a 3D array for all neighbors Backward permutation end is defined as: out(z,x,y) = in(z,y,x) for 3D arrays Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data Calls proc~~permute_backward_end_f128~~CallsGraph proc~permute_backward_end_f128 permute_backward_end_f128 proc~permute_backward_end_pipelined_f128 permute_backward_end_pipelined_f128 proc~permute_backward_end_f128->proc~permute_backward_end_pipelined_f128 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~permute_backward_end_f128~~CalledByGraph proc~permute_backward_end_f128 permute_backward_end_f128 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_end_f128 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_end_f128.html"},{"title":"unpack_pipelined_f128 – dtFFT","text":"private  subroutine unpack_pipelined_f128(in, out, dims, neighbor_data) Unpacks part of contiguous buffer recieved from a single rank. For 3D arrays: out(x + in_displacement, y, z) = in(out_displacement + z * nxx * nyy + y * nxx + x) where out buffer x,y,z are full slab indices, while in buffer x,y,z are indices that were sent from neighbor rank. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data Called by proc~~unpack_pipelined_f128~~CalledByGraph proc~unpack_pipelined_f128 unpack_pipelined_f128 proc~execute_host kernel_host%execute_host proc~execute_host->proc~unpack_pipelined_f128 proc~unpack_f128 unpack_f128 proc~execute_host->proc~unpack_f128 proc~unpack_f128->proc~unpack_pipelined_f128 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unpack_pipelined_f128.html"},{"title":"unpack_f128 – dtFFT","text":"private  subroutine unpack_f128(in, out, dims, neighbor_data) Unpacks pack of contiguous buffer recieved from all ranks. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data Calls proc~~unpack_f128~~CallsGraph proc~unpack_f128 unpack_f128 proc~unpack_pipelined_f128 unpack_pipelined_f128 proc~unpack_f128->proc~unpack_pipelined_f128 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unpack_f128~~CalledByGraph proc~unpack_f128 unpack_f128 proc~execute_host kernel_host%execute_host proc~execute_host->proc~unpack_f128 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unpack_f128.html"},{"title":"permute_forward_f64 – dtFFT","text":"private  subroutine permute_forward_f64(in, out, dims) Forward permutation of a 2D and 3D arrays Forward permutation is defined as: out(x,y,z) = in(z,x,y) for 3D arrays out(x,y)   = in(y,x)   for 2D arrays Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array Called by proc~~permute_forward_f64~~CalledByGraph proc~permute_forward_f64 permute_forward_f64 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_forward_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_forward_f64.html"},{"title":"permute_backward_f64 – dtFFT","text":"private  subroutine permute_backward_f64(in, out, dims) Backward permutation of a 2D and 3D arrays Backward permutation is defined as: out(x,y,z) = in(y,z,x) for 3D arrays Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array Called by proc~~permute_backward_f64~~CalledByGraph proc~permute_backward_f64 permute_backward_f64 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_f64.html"},{"title":"permute_backward_start_f64 – dtFFT","text":"private  subroutine permute_backward_start_f64(in, out, dims) Backward permutation start of a 3D array Backward permutation start is defined as: out(x,y,z) = in(z,y,x) for 3D arrays Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array Called by proc~~permute_backward_start_f64~~CalledByGraph proc~permute_backward_start_f64 permute_backward_start_f64 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_start_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_start_f64.html"},{"title":"permute_backward_end_pipelined_f64 – dtFFT","text":"private  subroutine permute_backward_end_pipelined_f64(in, out, dims, neighbor_data) Backward permutation end of a 3D array for a single neighbor Backward permutation end is defined as: out(x,y,z) = in(x,z,y) for 3D arrays Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data Called by proc~~permute_backward_end_pipelined_f64~~CalledByGraph proc~permute_backward_end_pipelined_f64 permute_backward_end_pipelined_f64 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_end_pipelined_f64 proc~permute_backward_end_f64 permute_backward_end_f64 proc~execute_host->proc~permute_backward_end_f64 proc~permute_backward_end_f64->proc~permute_backward_end_pipelined_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_end_pipelined_f64.html"},{"title":"permute_backward_end_f64 – dtFFT","text":"private  subroutine permute_backward_end_f64(in, out, dims, neighbor_data) Backward permutation end of a 3D array for all neighbors Backward permutation end is defined as: out(z,x,y) = in(z,y,x) for 3D arrays Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data Calls proc~~permute_backward_end_f64~~CallsGraph proc~permute_backward_end_f64 permute_backward_end_f64 proc~permute_backward_end_pipelined_f64 permute_backward_end_pipelined_f64 proc~permute_backward_end_f64->proc~permute_backward_end_pipelined_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~permute_backward_end_f64~~CalledByGraph proc~permute_backward_end_f64 permute_backward_end_f64 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_end_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_end_f64.html"},{"title":"unpack_pipelined_f64 – dtFFT","text":"private  subroutine unpack_pipelined_f64(in, out, dims, neighbor_data) Unpacks part of contiguous buffer recieved from a single rank. For 3D arrays: out(x + in_displacement, y, z) = in(out_displacement + z * nxx * nyy + y * nxx + x) where out buffer x,y,z are full slab indices, while in buffer x,y,z are indices that were sent from neighbor rank. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data Called by proc~~unpack_pipelined_f64~~CalledByGraph proc~unpack_pipelined_f64 unpack_pipelined_f64 proc~execute_host kernel_host%execute_host proc~execute_host->proc~unpack_pipelined_f64 proc~unpack_f64 unpack_f64 proc~execute_host->proc~unpack_f64 proc~unpack_f64->proc~unpack_pipelined_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unpack_pipelined_f64.html"},{"title":"unpack_f64 – dtFFT","text":"private  subroutine unpack_f64(in, out, dims, neighbor_data) Unpacks pack of contiguous buffer recieved from all ranks. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data Calls proc~~unpack_f64~~CallsGraph proc~unpack_f64 unpack_f64 proc~unpack_pipelined_f64 unpack_pipelined_f64 proc~unpack_f64->proc~unpack_pipelined_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unpack_f64~~CalledByGraph proc~unpack_f64 unpack_f64 proc~execute_host kernel_host%execute_host proc~execute_host->proc~unpack_f64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unpack_f64.html"},{"title":"permute_forward_f32 – dtFFT","text":"private  subroutine permute_forward_f32(in, out, dims) Forward permutation of a 2D and 3D arrays Forward permutation is defined as: out(x,y,z) = in(z,x,y) for 3D arrays out(x,y)   = in(y,x)   for 2D arrays Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array Called by proc~~permute_forward_f32~~CalledByGraph proc~permute_forward_f32 permute_forward_f32 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_forward_f32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_forward_f32.html"},{"title":"permute_backward_f32 – dtFFT","text":"private  subroutine permute_backward_f32(in, out, dims) Backward permutation of a 2D and 3D arrays Backward permutation is defined as: out(x,y,z) = in(y,z,x) for 3D arrays Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array Called by proc~~permute_backward_f32~~CalledByGraph proc~permute_backward_f32 permute_backward_f32 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_f32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_f32.html"},{"title":"permute_backward_start_f32 – dtFFT","text":"private  subroutine permute_backward_start_f32(in, out, dims) Backward permutation start of a 3D array Backward permutation start is defined as: out(x,y,z) = in(z,y,x) for 3D arrays Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array Called by proc~~permute_backward_start_f32~~CalledByGraph proc~permute_backward_start_f32 permute_backward_start_f32 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_start_f32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_start_f32.html"},{"title":"permute_backward_end_pipelined_f32 – dtFFT","text":"private  subroutine permute_backward_end_pipelined_f32(in, out, dims, neighbor_data) Backward permutation end of a 3D array for a single neighbor Backward permutation end is defined as: out(x,y,z) = in(x,z,y) for 3D arrays Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data Called by proc~~permute_backward_end_pipelined_f32~~CalledByGraph proc~permute_backward_end_pipelined_f32 permute_backward_end_pipelined_f32 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_end_pipelined_f32 proc~permute_backward_end_f32 permute_backward_end_f32 proc~execute_host->proc~permute_backward_end_f32 proc~permute_backward_end_f32->proc~permute_backward_end_pipelined_f32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_end_pipelined_f32.html"},{"title":"permute_backward_end_f32 – dtFFT","text":"private  subroutine permute_backward_end_f32(in, out, dims, neighbor_data) Backward permutation end of a 3D array for all neighbors Backward permutation end is defined as: out(z,x,y) = in(z,y,x) for 3D arrays Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data Calls proc~~permute_backward_end_f32~~CallsGraph proc~permute_backward_end_f32 permute_backward_end_f32 proc~permute_backward_end_pipelined_f32 permute_backward_end_pipelined_f32 proc~permute_backward_end_f32->proc~permute_backward_end_pipelined_f32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~permute_backward_end_f32~~CalledByGraph proc~permute_backward_end_f32 permute_backward_end_f32 proc~execute_host kernel_host%execute_host proc~execute_host->proc~permute_backward_end_f32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/permute_backward_end_f32.html"},{"title":"unpack_pipelined_f32 – dtFFT","text":"private  subroutine unpack_pipelined_f32(in, out, dims, neighbor_data) Unpacks part of contiguous buffer recieved from a single rank. For 3D arrays: out(x + in_displacement, y, z) = in(out_displacement + z * nxx * nyy + y * nxx + x) where out buffer x,y,z are full slab indices, while in buffer x,y,z are indices that were sent from neighbor rank. Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data Called by proc~~unpack_pipelined_f32~~CalledByGraph proc~unpack_pipelined_f32 unpack_pipelined_f32 proc~execute_host kernel_host%execute_host proc~execute_host->proc~unpack_pipelined_f32 proc~unpack_f32 unpack_f32 proc~execute_host->proc~unpack_f32 proc~unpack_f32->proc~unpack_pipelined_f32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unpack_pipelined_f32.html"},{"title":"unpack_f32 – dtFFT","text":"private  subroutine unpack_f32(in, out, dims, neighbor_data) Unpacks pack of contiguous buffer recieved from all ranks. Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data Calls proc~~unpack_f32~~CallsGraph proc~unpack_f32 unpack_f32 proc~unpack_pipelined_f32 unpack_pipelined_f32 proc~unpack_f32->proc~unpack_pipelined_f32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unpack_f32~~CalledByGraph proc~unpack_f32 unpack_f32 proc~execute_host kernel_host%execute_host proc~execute_host->proc~unpack_f32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unpack_f32.html"},{"title":"ncclGetErrorString – dtFFT","text":"public  function ncclGetErrorString(ncclResult_t) result(string) Generates an error message. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ncclResult_t Completion status of a function. Return Value character(len=:), allocatable Error message Calls proc~~ncclgeterrorstring~~CallsGraph proc~ncclgeterrorstring ncclGetErrorString interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ncclgeterrorstring~~CalledByGraph proc~ncclgeterrorstring ncclGetErrorString proc~alloc_mem alloc_mem proc~alloc_mem->proc~ncclgeterrorstring proc~create_helper backend_helper%create_helper proc~create_helper->proc~ncclgeterrorstring proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~destroy_helper->proc~ncclgeterrorstring proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~ncclgeterrorstring proc~free_mem free_mem proc~free_mem->proc~ncclgeterrorstring proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~destroy_helper proc~mem_free~3 transpose_plan%mem_free proc~destroy~7->proc~mem_free~3 proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~destroy_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ncclgeterrorstring.html"},{"title":"ncclGetUniqueId – dtFFT","text":"interface Generates an Id to be used in ncclCommInitRank. \nncclGetUniqueId should be called once when creating a communicator and the Id should be \ndistributed to all ranks in the communicator before calling ncclCommInitRank. \nuniqueId should point to a ncclUniqueId object allocated by the user. Called by interface~~ncclgetuniqueid~~CalledByGraph interface~ncclgetuniqueid ncclGetUniqueId proc~create_helper backend_helper%create_helper proc~create_helper->interface~ncclgetuniqueid proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclGetUniqueId(uniqueId) result(ncclResult_t) bind(C, name=\"ncclGetUniqueId\") Arguments Type Intent Optional Attributes Name type( ncclUniqueId ), intent(out) :: uniqueId Unique ID Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclgetuniqueid.html"},{"title":"ncclMemAlloc – dtFFT","text":"interface Allocate a GPU buffer with size.\nAllocated buffer head address will be returned by ptr, and the actual allocated size can be larger \nthan requested because of the buffer granularity requirements from all types of NCCL optimizations. Called by interface~~ncclmemalloc~~CalledByGraph interface~ncclmemalloc ncclMemAlloc proc~alloc_mem alloc_mem proc~alloc_mem->interface~ncclmemalloc proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclMemAlloc(ptr, alloc_bytes) result(ncclResult_t) bind(C, name=\"ncclMemAlloc\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: ptr Buffer address integer(kind=c_size_t), intent(in), value :: alloc_bytes Number of bytes to allocate Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclmemalloc.html"},{"title":"ncclMemFree – dtFFT","text":"interface Free memory allocated by ncclMemAlloc(). Called by interface~~ncclmemfree~~CalledByGraph interface~ncclmemfree ncclMemFree proc~free_mem free_mem proc~free_mem->interface~ncclmemfree proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclMemFree(ptr) result(ncclResult_t) bind(C, name=\"ncclMemFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: ptr Buffer address Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclmemfree.html"},{"title":"ncclCommInitRank – dtFFT","text":"interface Creates a new communicator (multi thread/process version). rank must be between 0 and nranks-1 and unique within a communicator clique.\nEach rank is associated to a CUDA device, which has to be set before calling ncclCommInitRank. ncclCommInitRank implicitly synchronizes with other ranks, hence it must be called by different\nthreads/processes or used within ncclGroupStart/ncclGroupEnd. Called by interface~~ncclcomminitrank~~CalledByGraph interface~ncclcomminitrank ncclCommInitRank proc~create_helper backend_helper%create_helper proc~create_helper->interface~ncclcomminitrank proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclCommInitRank(comm, nranks, uniqueId, rank) result(ncclResult_t) bind(C, name=\"ncclCommInitRank\") Arguments Type Intent Optional Attributes Name type( ncclComm ) :: comm Communicator integer(kind=c_int), value :: nranks Number of ranks in communicator type( ncclUniqueId ), value :: uniqueId Unique ID integer(kind=c_int), value :: rank Calling rank Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclcomminitrank.html"},{"title":"ncclSend – dtFFT","text":"interface Send data from sendbuff to rank peer. Rank peer needs to call ncclRecv with the same datatype and the same count as this rank. This operation is blocking for the GPU.\nIf multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, \nthey must be fused within a ncclGroupStart()/ ncclGroupEnd() section. Called by interface~~ncclsend~~CalledByGraph interface~ncclsend ncclSend proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~ncclsend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclSend(sendbuff, count, datatype, peer, comm, stream) result(ncclResult_t) bind(c, name='ncclSend') Arguments Type Intent Optional Attributes Name real(kind=c_float) :: sendbuff Buffer to send data from integer(kind=c_size_t), value :: count Number of elements to send type( ncclDataType ), value :: datatype Datatype to send integer(kind=c_int), value :: peer Target GPU type( ncclComm ), value :: comm Communicator type( dtfft_stream_t ), value :: stream CUDA Stream Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclsend.html"},{"title":"ncclRecv – dtFFT","text":"interface Receive data from rank peer into recvbuff. Rank peer needs to call ncclSend with the same datatype and the same count as this rank. This operation is blocking for the GPU.\nIf multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, \nthey must be fused within a ncclGroupStart()/ ncclGroupEnd() section. Called by interface~~ncclrecv~~CalledByGraph interface~ncclrecv ncclRecv proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~ncclrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclRecv(recvbuff, count, datatype, peer, comm, stream) result(ncclResult_t) bind(c, name='ncclRecv') Arguments Type Intent Optional Attributes Name real(kind=c_float) :: recvbuff Buffer to recv data into integer(kind=c_size_t), value :: count Number of elements to recv type( ncclDataType ), value :: datatype Datatype to recv integer(kind=c_int), value :: peer Source GPU type( ncclComm ), value :: comm Communicator type( dtfft_stream_t ), value :: stream CUDA Stream Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclrecv.html"},{"title":"ncclGroupStart – dtFFT","text":"interface Start a group call. All subsequent calls to NCCL until ncclGroupEnd will not block due to inter-CPU synchronization. Called by interface~~ncclgroupstart~~CalledByGraph interface~ncclgroupstart ncclGroupStart proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~ncclgroupstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclGroupStart() result(ncclResult_t) bind(C, name=\"ncclGroupStart\") Arguments None Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclgroupstart.html"},{"title":"ncclGroupEnd – dtFFT","text":"interface End a group call. Returns when all operations since ncclGroupStart have been processed.\nThis means the communication primitives have been enqueued to the provided streams, \nbut are not necessarily complete. Called by interface~~ncclgroupend~~CalledByGraph interface~ncclgroupend ncclGroupEnd proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->interface~ncclgroupend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclGroupEnd() result(ncclResult_t) bind(C, name=\"ncclGroupEnd\") Arguments None Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclgroupend.html"},{"title":"ncclCommDestroy – dtFFT","text":"interface Destroy a communicator object comm. Called by interface~~ncclcommdestroy~~CalledByGraph interface~ncclcommdestroy ncclCommDestroy proc~destroy_helper backend_helper%destroy_helper proc~destroy_helper->interface~ncclcommdestroy proc~create_helper backend_helper%create_helper proc~create_helper->proc~destroy_helper proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~destroy_helper proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~destroy_helper proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclCommDestroy(comm) result(ncclResult_t) bind(C, name=\"ncclCommDestroy\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclcommdestroy.html"},{"title":"ncclCommRegister – dtFFT","text":"interface Register a buffer for collective communication. Called by interface~~ncclcommregister~~CalledByGraph interface~ncclcommregister ncclCommRegister proc~alloc_mem alloc_mem proc~alloc_mem->interface~ncclcommregister proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclCommRegister(comm, buff, size, handle) result(ncclResult_t) bind(C, name=\"ncclCommRegister\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator type(c_ptr), value :: buff Buffer to register integer(kind=c_size_t), value :: size Size of the buffer in bytes type(c_ptr) :: handle Handle to the registered buffer Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclcommregister.html"},{"title":"ncclCommDeregister – dtFFT","text":"interface Deregister a buffer for collective communication. Called by interface~~ncclcommderegister~~CalledByGraph interface~ncclcommderegister ncclCommDeregister proc~free_mem free_mem proc~free_mem->interface~ncclcommderegister proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function ncclCommDeregister(comm, handle) result(ncclResult_t) bind(C, name=\"ncclCommDeregister\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator type(c_ptr), value :: handle Handle to the registered buffer Return Value integer(kind=c_int32_t) Completion status","tags":"","loc":"interface/ncclcommderegister.html"},{"title":"ncclGetErrorString_c – dtFFT","text":"interface Returns a human-readable string corresponding to the passed error code. Called by interface~~ncclgeterrorstring_c~~CalledByGraph interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring ncclGetErrorString proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~alloc_mem alloc_mem proc~alloc_mem->proc~ncclgeterrorstring proc~create_helper backend_helper%create_helper proc~create_helper->proc~ncclgeterrorstring proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~destroy_helper->proc~ncclgeterrorstring proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~ncclgeterrorstring proc~free_mem free_mem proc~free_mem->proc~ncclgeterrorstring proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~destroy_helper proc~mem_free~3 transpose_plan%mem_free proc~destroy~7->proc~mem_free~3 proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~destroy_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function ncclGetErrorString_c(ncclResult_t) result(message) bind(C, name=\"ncclGetErrorString\") Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in), value :: ncclResult_t Completion status of a NCCL function. Return Value type(c_ptr) Pointer to message","tags":"","loc":"interface/ncclgeterrorstring_c.html"},{"title":"create_nccl – dtFFT","text":"private  subroutine create_nccl(self, helper, base_storage) Creates NCCL backend Type Bound backend_nccl Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) Calls proc~~create_nccl~~CallsGraph proc~create_nccl backend_nccl%create_nccl proc~is_backend_nccl is_backend_nccl proc~create_nccl->proc~is_backend_nccl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_nccl.html"},{"title":"execute_nccl – dtFFT","text":"private  subroutine execute_nccl(self, in, out, stream, aux, exec_type, error_code) Uses iso_fortran_env iso_c_binding proc~~execute_nccl~~UsesGraph proc~execute_nccl backend_nccl%execute_nccl iso_c_binding iso_c_binding proc~execute_nccl->iso_c_binding iso_fortran_env iso_fortran_env proc~execute_nccl->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes NCCL backend Type Bound backend_nccl Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code Calls proc~~execute_nccl~~CallsGraph proc~execute_nccl backend_nccl%execute_nccl fname fname proc~execute_nccl->fname interface~ncclgroupend ncclGroupEnd proc~execute_nccl->interface~ncclgroupend interface~ncclgroupstart ncclGroupStart proc~execute_nccl->interface~ncclgroupstart interface~ncclrecv ncclRecv proc~execute_nccl->interface~ncclrecv interface~ncclsend ncclSend proc~execute_nccl->interface~ncclsend mpi_abort mpi_abort proc~execute_nccl->mpi_abort proc~execute~13 abstract_kernel%execute proc~execute_nccl->proc~execute~13 proc~ncclgeterrorstring ncclGetErrorString proc~execute_nccl->proc~ncclgeterrorstring execute_private execute_private proc~execute~13->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~13->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~13->proc~push_nvtx_domain_range interface~ncclgeterrorstring_c ncclGetErrorString_c proc~ncclgeterrorstring->interface~ncclgeterrorstring_c proc~string_c2f string_c2f proc~ncclgeterrorstring->proc~string_c2f interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_nccl.html"},{"title":"destroy_nccl – dtFFT","text":"private  subroutine destroy_nccl(self) Destroys NCCL backend Type Bound backend_nccl Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend","tags":"","loc":"proc/destroy_nccl.html"},{"title":"push_nvtx_domain_range – dtFFT","text":"public  subroutine push_nvtx_domain_range(message, color) Pushes a range to the NVTX domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to push integer(kind=c_int), intent(in) :: color Color of the range Calls proc~~push_nvtx_domain_range~~CallsGraph proc~push_nvtx_domain_range push_nvtx_domain_range interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~push_nvtx_domain_range~~CalledByGraph proc~push_nvtx_domain_range push_nvtx_domain_range proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create~12 abstract_executor%create proc~create~12->proc~push_nvtx_domain_range proc~create~3 nvrtc_module%create proc~create~3->proc~push_nvtx_domain_range proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~execute~10 abstract_executor%execute proc~execute~10->proc~push_nvtx_domain_range proc~execute~13 abstract_kernel%execute proc~execute~13->proc~push_nvtx_domain_range proc~execute~5 transpose_plan%execute proc~execute~5->proc~push_nvtx_domain_range proc~get_kernel get_kernel proc~get_kernel->proc~push_nvtx_domain_range proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~transpose_end dtfft_plan_t%transpose_end proc~transpose_end->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~push_nvtx_domain_range proc~transpose_start_ptr->proc~transpose_private proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_nvrtc_module->proc~create~3 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~create~6->proc~autotune_grid_decomposition proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~execute abstract_backend%execute proc~execute->proc~execute~13 proc~execute_2d dtfft_plan_t%execute_2d proc~execute_2d->proc~execute~5 proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute~13 proc~execute_generic dtfft_plan_t%execute_generic proc~execute_generic->proc~execute~5 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~13 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~13 proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_z_slab->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~execute~6 transpose_handle_generic%execute proc~execute~6->proc~execute~13 proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_private->proc~execute~5 proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr proc~execute_private->proc~execute_2d proc~execute_private->proc~execute_generic proc~execute_private->proc~execute_z_slab proc~run_autotune_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/push_nvtx_domain_range.html"},{"title":"pop_nvtx_domain_range – dtFFT","text":"public  subroutine pop_nvtx_domain_range() Pops a range from the NVTX domain Arguments None Calls proc~~pop_nvtx_domain_range~~CallsGraph proc~pop_nvtx_domain_range pop_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pop_nvtx_domain_range~~CalledByGraph proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~autotune_grid autotune_grid proc~autotune_grid->proc~pop_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~pop_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~create~12 abstract_executor%create proc~create~12->proc~pop_nvtx_domain_range proc~create~3 nvrtc_module%create proc~create~3->proc~pop_nvtx_domain_range proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~pop_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~pop_nvtx_domain_range proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~execute~10 abstract_executor%execute proc~execute~10->proc~pop_nvtx_domain_range proc~execute~13 abstract_kernel%execute proc~execute~13->proc~pop_nvtx_domain_range proc~execute~5 transpose_plan%execute proc~execute~5->proc~pop_nvtx_domain_range proc~get_kernel get_kernel proc~get_kernel->proc~pop_nvtx_domain_range proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~transpose_end dtfft_plan_t%transpose_end proc~transpose_end->proc~pop_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~pop_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~pop_nvtx_domain_range proc~transpose_start_ptr->proc~transpose_private proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_nvrtc_module->proc~create~3 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~create~6->proc~autotune_grid_decomposition proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~execute abstract_backend%execute proc~execute->proc~execute~13 proc~execute_2d dtfft_plan_t%execute_2d proc~execute_2d->proc~execute~5 proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute~13 proc~execute_generic dtfft_plan_t%execute_generic proc~execute_generic->proc~execute~5 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~13 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~13 proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_z_slab->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~execute~6 transpose_handle_generic%execute proc~execute~6->proc~execute~13 proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_private->proc~execute~5 proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr proc~execute_private->proc~execute_2d proc~execute_private->proc~execute_generic proc~execute_private->proc~execute_z_slab proc~run_autotune_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/pop_nvtx_domain_range.html"},{"title":"create_nvtx_domain – dtFFT","text":"private  subroutine create_nvtx_domain() Creates a new NVTX domain Arguments None Calls proc~~create_nvtx_domain~~CallsGraph proc~create_nvtx_domain create_nvtx_domain interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~astring_f2c astring_f2c proc~create_nvtx_domain->proc~astring_f2c proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_nvtx_domain~~CalledByGraph proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range push_nvtx_domain_range proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create~12 abstract_executor%create proc~create~12->proc~push_nvtx_domain_range proc~create~3 nvrtc_module%create proc~create~3->proc~push_nvtx_domain_range proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~execute~10 abstract_executor%execute proc~execute~10->proc~push_nvtx_domain_range proc~execute~13 abstract_kernel%execute proc~execute~13->proc~push_nvtx_domain_range proc~execute~5 transpose_plan%execute proc~execute~5->proc~push_nvtx_domain_range proc~get_kernel get_kernel proc~get_kernel->proc~push_nvtx_domain_range proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~transpose_end dtfft_plan_t%transpose_end proc~transpose_end->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~push_nvtx_domain_range proc~transpose_start_ptr->proc~transpose_private proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_nvrtc_module->proc~create~3 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~create~6->proc~autotune_grid_decomposition proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~execute abstract_backend%execute proc~execute->proc~execute~13 proc~execute_2d dtfft_plan_t%execute_2d proc~execute_2d->proc~execute~5 proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute~13 proc~execute_generic dtfft_plan_t%execute_generic proc~execute_generic->proc~execute~5 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~13 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~13 proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_z_slab->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~execute~6 transpose_handle_generic%execute proc~execute~6->proc~execute~13 proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_private->proc~execute~5 proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr proc~execute_private->proc~execute_2d proc~execute_private->proc~execute_generic proc~execute_private->proc~execute_z_slab proc~run_autotune_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_nvtx_domain.html"},{"title":"nvtxDomainCreate_c – dtFFT","text":"interface Called by interface~~nvtxdomaincreate_c~~CalledByGraph interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain create_nvtx_domain proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~push_nvtx_domain_range push_nvtx_domain_range proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create~12 abstract_executor%create proc~create~12->proc~push_nvtx_domain_range proc~create~3 nvrtc_module%create proc~create~3->proc~push_nvtx_domain_range proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~execute~10 abstract_executor%execute proc~execute~10->proc~push_nvtx_domain_range proc~execute~13 abstract_kernel%execute proc~execute~13->proc~push_nvtx_domain_range proc~execute~5 transpose_plan%execute proc~execute~5->proc~push_nvtx_domain_range proc~get_kernel get_kernel proc~get_kernel->proc~push_nvtx_domain_range proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~transpose_end dtfft_plan_t%transpose_end proc~transpose_end->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~push_nvtx_domain_range proc~transpose_start_ptr->proc~transpose_private proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_nvrtc_module->proc~create~3 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~create~6->proc~autotune_grid_decomposition proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~execute abstract_backend%execute proc~execute->proc~execute~13 proc~execute_2d dtfft_plan_t%execute_2d proc~execute_2d->proc~execute~5 proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute~13 proc~execute_generic dtfft_plan_t%execute_generic proc~execute_generic->proc~execute~5 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~13 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~13 proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_z_slab->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~execute~6 transpose_handle_generic%execute proc~execute~6->proc~execute~13 proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_private->proc~execute~5 proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr proc~execute_private->proc~execute_2d proc~execute_private->proc~execute_generic proc~execute_private->proc~execute_z_slab proc~run_autotune_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine nvtxDomainCreate_c(name, domain) bind(C, name=\"nvtxDomainCreate_c\") Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: name (*) Name of the NVTX domain. type( nvtxDomainHandle ) :: domain Handle to the created NVTX domain. Description Creates an NVTX domain with the specified name.","tags":"","loc":"interface/nvtxdomaincreate_c.html"},{"title":"nvtxDomainRangePushEx_c – dtFFT","text":"interface Called by interface~~nvtxdomainrangepushex_c~~CalledByGraph interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range push_nvtx_domain_range proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create~12 abstract_executor%create proc~create~12->proc~push_nvtx_domain_range proc~create~3 nvrtc_module%create proc~create~3->proc~push_nvtx_domain_range proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~push_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~execute~10 abstract_executor%execute proc~execute~10->proc~push_nvtx_domain_range proc~execute~13 abstract_kernel%execute proc~execute~13->proc~push_nvtx_domain_range proc~execute~5 transpose_plan%execute proc~execute~5->proc~push_nvtx_domain_range proc~get_kernel get_kernel proc~get_kernel->proc~push_nvtx_domain_range proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~transpose_end dtfft_plan_t%transpose_end proc~transpose_end->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~push_nvtx_domain_range proc~transpose_start_ptr->proc~transpose_private proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_nvrtc_module->proc~create~3 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~create~6->proc~autotune_grid_decomposition proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~execute abstract_backend%execute proc~execute->proc~execute~13 proc~execute_2d dtfft_plan_t%execute_2d proc~execute_2d->proc~execute~5 proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute~13 proc~execute_generic dtfft_plan_t%execute_generic proc~execute_generic->proc~execute~5 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~13 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~13 proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_z_slab->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~execute~6 transpose_handle_generic%execute proc~execute~6->proc~execute~13 proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_private->proc~execute~5 proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr proc~execute_private->proc~execute_2d proc~execute_private->proc~execute_generic proc~execute_private->proc~execute_z_slab proc~run_autotune_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine nvtxDomainRangePushEx_c(domain, message, color) bind(C, name=\"nvtxDomainRangePushEx_c\") Arguments Type Intent Optional Attributes Name type( nvtxDomainHandle ), value :: domain NVTX domain handle. character(len=c_char), intent(in) :: message (*) Custom message for the range. integer(kind=c_int), intent(in), value :: color Color for the range. Description Pushes a range with a custom message and color onto the specified NVTX domain.","tags":"","loc":"interface/nvtxdomainrangepushex_c.html"},{"title":"nvtxDomainRangePop_c – dtFFT","text":"interface Called by interface~~nvtxdomainrangepop_c~~CalledByGraph interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c proc~autotune_grid autotune_grid proc~autotune_grid->proc~pop_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~pop_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~pop_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~pop_nvtx_domain_range proc~create~12 abstract_executor%create proc~create~12->proc~pop_nvtx_domain_range proc~create~3 nvrtc_module%create proc~create~3->proc~pop_nvtx_domain_range proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~pop_nvtx_domain_range proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~pop_nvtx_domain_range proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~execute~10 abstract_executor%execute proc~execute~10->proc~pop_nvtx_domain_range proc~execute~13 abstract_kernel%execute proc~execute~13->proc~pop_nvtx_domain_range proc~execute~5 transpose_plan%execute proc~execute~5->proc~pop_nvtx_domain_range proc~get_kernel get_kernel proc~get_kernel->proc~pop_nvtx_domain_range proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~pop_nvtx_domain_range proc~run_autotune_backend->proc~pop_nvtx_domain_range proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~transpose_end dtfft_plan_t%transpose_end proc~transpose_end->proc~pop_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~pop_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~pop_nvtx_domain_range proc~transpose_start_ptr->proc~transpose_private proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_nvrtc_module->proc~create~3 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~create~6->proc~autotune_grid_decomposition proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~execute abstract_backend%execute proc~execute->proc~execute~13 proc~execute_2d dtfft_plan_t%execute_2d proc~execute_2d->proc~execute~5 proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute~13 proc~execute_generic dtfft_plan_t%execute_generic proc~execute_generic->proc~execute~5 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~13 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~13 proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_z_slab->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~execute~6 transpose_handle_generic%execute proc~execute~6->proc~execute~13 proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_private->proc~execute~5 proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr proc~execute_private->proc~execute_2d proc~execute_private->proc~execute_generic proc~execute_private->proc~execute_z_slab proc~run_autotune_datatypes->proc~autotune_transpose_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine nvtxDomainRangePop_c(domain) bind(C, name=\"nvtxDomainRangePop_c\") Arguments Type Intent Optional Attributes Name type( nvtxDomainHandle ), value :: domain NVTX domain handle. Description Pops a range from the specified NVTX domain.","tags":"","loc":"interface/nvtxdomainrangepop_c.html"},{"title":"dynamic_load – dtFFT","text":"public  function dynamic_load(name, symbol_names, handle, symbols) result(error_code) Dynamically loads library and its symbols Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of library to load type( string ), intent(in) :: symbol_names (:) Names of functions to load type(c_ptr), intent(out) :: handle Loaded handle type(c_funptr), intent(out) :: symbols (:) Function pointers Return Value integer(kind=int32) Error code Calls proc~~dynamic_load~~CallsGraph proc~dynamic_load dynamic_load interface~is_null_ptr is_null_ptr proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~load_library->interface~is_null_ptr interface~dlopen dlopen proc~load_library->interface~dlopen proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr interface~dlsym dlsym proc~load_symbol->interface~dlsym proc~load_symbol->proc~astring_f2c proc~load_symbol->proc~dl_error interface~dlclose dlclose proc~unload_library->interface~dlclose proc~unload_library->proc~dl_error proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dynamic_load~~CalledByGraph proc~dynamic_load dynamic_load proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dynamic_load.html"},{"title":"get_inverse_kind – dtFFT","text":"public elemental function get_inverse_kind(r2r_kind) result(result_kind) Get the inverse R2R kind of transform for the given R2R kind Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: r2r_kind R2R kind Return Value type( dtfft_r2r_kind_t ) Called by proc~~get_inverse_kind~~CalledByGraph proc~get_inverse_kind get_inverse_kind proc~create~2 fftw_executor%create proc~create~2->proc~get_inverse_kind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_inverse_kind.html"},{"title":"is_null_ptr – dtFFT","text":"public elemental function is_null_ptr(ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to check Return Value logical","tags":"","loc":"proc/is_null_ptr.html"},{"title":"is_same_ptr – dtFFT","text":"public elemental function is_same_ptr(ptr1, ptr2) Checks if two pointer are the same Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr1 First pointer type(c_ptr), intent(in) :: ptr2 Second pointer Return Value logical Called by proc~~is_same_ptr~~CalledByGraph proc~is_same_ptr is_same_ptr proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~is_same_ptr proc~free_mem free_mem proc~free_mem->proc~is_same_ptr proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_same_ptr.html"},{"title":"count_unique – dtFFT","text":"public  function count_unique(x) result(n) Count the number of unique elements in the array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) Array of integers Return Value integer(kind=int32) Called by proc~~count_unique~~CalledByGraph proc~count_unique count_unique proc~create_private dtfft_plan_t%create_private proc~create_private->proc~count_unique proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/count_unique.html"},{"title":"mem_alloc_host – dtFFT","text":"public  function mem_alloc_host(alloc_size) result(ptr) Allocates memory using C11 Standard alloc_align with 16 bytes alignment Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_size Number of bytes to allocate Return Value type(c_ptr) Pointer to allocate Calls proc~~mem_alloc_host~~CallsGraph proc~mem_alloc_host mem_alloc_host interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mem_alloc_host~~CalledByGraph proc~mem_alloc_host mem_alloc_host proc~alloc_mem alloc_mem proc~alloc_mem->proc~mem_alloc_host proc~compile_program compile_program proc~compile_program->proc~mem_alloc_host proc~create~3 nvrtc_module%create proc~create~3->proc~mem_alloc_host proc~create~3->proc~compile_program proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_ptr->proc~mem_alloc_host proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~mem_alloc_ptr proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~autotune_grid_decomposition->proc~autotune_grid proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mem_alloc_host.html"},{"title":"string_constructor – dtFFT","text":"private  function string_constructor(str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string ) Called by proc~~string_constructor~~CalledByGraph proc~string_constructor string_constructor interface~string string interface~string->proc~string_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/string_constructor.html"},{"title":"load_library – dtFFT","text":"private  function load_library(name) result(lib_handle) Dynamically loads library Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of library to load Return Value type(c_ptr) Loaded handle Calls proc~~load_library~~CallsGraph proc~load_library load_library interface~dlopen dlopen proc~load_library->interface~dlopen interface~is_null_ptr is_null_ptr proc~load_library->interface~is_null_ptr proc~astring_f2c astring_f2c proc~load_library->proc~astring_f2c proc~dl_error dl_error proc~load_library->proc~dl_error interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_library~~CalledByGraph proc~load_library load_library proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_library.html"},{"title":"load_symbol – dtFFT","text":"private  function load_symbol(handle, name) result(symbol_handle) Dynamically loads symbol from library Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: handle Loaded handle character(len=*), intent(in) :: name Name of function to load Return Value type(c_funptr) Function pointer Calls proc~~load_symbol~~CallsGraph proc~load_symbol load_symbol interface~dlsym dlsym proc~load_symbol->interface~dlsym interface~is_null_ptr is_null_ptr proc~load_symbol->interface~is_null_ptr proc~astring_f2c astring_f2c proc~load_symbol->proc~astring_f2c proc~dl_error dl_error proc~load_symbol->proc~dl_error interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c interface~dlerror dlerror proc~dl_error->interface~dlerror proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_symbol~~CalledByGraph proc~load_symbol load_symbol proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_symbol proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/load_symbol.html"},{"title":"int8_to_string – dtFFT","text":"private  function int8_to_string(n) result(str) Convert 8-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string Called by proc~~int8_to_string~~CalledByGraph proc~int8_to_string int8_to_string interface~to_str to_str interface~to_str->proc~int8_to_string proc~add nvrtc_module_cache%add proc~add->interface~to_str proc~alloc_mem alloc_mem proc~alloc_mem->interface~to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~to_str proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->interface~to_str proc~compile_program compile_program proc~compile_program->interface~to_str proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~create_cart_comm create_cart_comm proc~create_cart_comm->interface~to_str proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->interface~to_str proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create~12 abstract_executor%create proc~create~12->interface~to_str proc~create~6 transpose_plan%create proc~create~6->interface~to_str proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create~6->proc~create_pencils_and_comm proc~create~6->proc~run_autotune_backend proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~to_str proc~execute~3 mkl_executor%execute proc~execute~3->interface~to_str proc~free_mem free_mem proc~free_mem->interface~to_str proc~get_kernel get_kernel proc~get_kernel->interface~to_str proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->interface~to_str proc~get nvrtc_module%get proc~get_kernel_instance->proc~get proc~get_name_expression get_name_expression proc~get_name_expression->interface~to_str proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->interface~to_str proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~make_plan make_plan proc~make_plan->interface~to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~to_str proc~report dtfft_plan_t%report proc~report->interface~to_str proc~report_timings->interface~to_str proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->interface~to_str proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_pencils_and_comm->proc~create_cart_comm proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~3->proc~compile_program proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~get_name_expression proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~set_name_expression->proc~get_name_expression proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~get->proc~get_mangled_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/int8_to_string.html"},{"title":"int32_to_string – dtFFT","text":"private  function int32_to_string(n) result(str) Convert 32-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string Called by proc~~int32_to_string~~CalledByGraph proc~int32_to_string int32_to_string interface~to_str to_str interface~to_str->proc~int32_to_string proc~add nvrtc_module_cache%add proc~add->interface~to_str proc~alloc_mem alloc_mem proc~alloc_mem->interface~to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~to_str proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->interface~to_str proc~compile_program compile_program proc~compile_program->interface~to_str proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~create_cart_comm create_cart_comm proc~create_cart_comm->interface~to_str proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->interface~to_str proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create~12 abstract_executor%create proc~create~12->interface~to_str proc~create~6 transpose_plan%create proc~create~6->interface~to_str proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create~6->proc~create_pencils_and_comm proc~create~6->proc~run_autotune_backend proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~to_str proc~execute~3 mkl_executor%execute proc~execute~3->interface~to_str proc~free_mem free_mem proc~free_mem->interface~to_str proc~get_kernel get_kernel proc~get_kernel->interface~to_str proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->interface~to_str proc~get nvrtc_module%get proc~get_kernel_instance->proc~get proc~get_name_expression get_name_expression proc~get_name_expression->interface~to_str proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->interface~to_str proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~make_plan make_plan proc~make_plan->interface~to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~to_str proc~report dtfft_plan_t%report proc~report->interface~to_str proc~report_timings->interface~to_str proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->interface~to_str proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_pencils_and_comm->proc~create_cart_comm proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~3->proc~compile_program proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~get_name_expression proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~set_name_expression->proc~get_name_expression proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~get->proc~get_mangled_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/int32_to_string.html"},{"title":"int64_to_string – dtFFT","text":"private  function int64_to_string(n) result(str) Convert 64-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string Called by proc~~int64_to_string~~CalledByGraph proc~int64_to_string int64_to_string interface~to_str to_str interface~to_str->proc~int64_to_string proc~add nvrtc_module_cache%add proc~add->interface~to_str proc~alloc_mem alloc_mem proc~alloc_mem->interface~to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~to_str proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->interface~to_str proc~compile_program compile_program proc~compile_program->interface~to_str proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~create_cart_comm create_cart_comm proc~create_cart_comm->interface~to_str proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->interface~to_str proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create~12 abstract_executor%create proc~create~12->interface~to_str proc~create~6 transpose_plan%create proc~create~6->interface~to_str proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create~6->proc~create_pencils_and_comm proc~create~6->proc~run_autotune_backend proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~to_str proc~execute~3 mkl_executor%execute proc~execute~3->interface~to_str proc~free_mem free_mem proc~free_mem->interface~to_str proc~get_kernel get_kernel proc~get_kernel->interface~to_str proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->interface~to_str proc~get nvrtc_module%get proc~get_kernel_instance->proc~get proc~get_name_expression get_name_expression proc~get_name_expression->interface~to_str proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->interface~to_str proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~make_plan make_plan proc~make_plan->interface~to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~to_str proc~report dtfft_plan_t%report proc~report->interface~to_str proc~report_timings->interface~to_str proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->interface~to_str proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_pencils_and_comm->proc~create_cart_comm proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~3->proc~compile_program proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~get_name_expression proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~set_name_expression->proc~get_name_expression proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~get->proc~get_mangled_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/int64_to_string.html"},{"title":"double_to_string – dtFFT","text":"private  function double_to_string(n) result(str) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string Called by proc~~double_to_string~~CalledByGraph proc~double_to_string double_to_string interface~to_str to_str interface~to_str->proc~double_to_string proc~add nvrtc_module_cache%add proc~add->interface~to_str proc~alloc_mem alloc_mem proc~alloc_mem->interface~to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~to_str proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->interface~to_str proc~compile_program compile_program proc~compile_program->interface~to_str proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~create_cart_comm create_cart_comm proc~create_cart_comm->interface~to_str proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->interface~to_str proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create~12 abstract_executor%create proc~create~12->interface~to_str proc~create~6 transpose_plan%create proc~create~6->interface~to_str proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create~6->proc~create_pencils_and_comm proc~create~6->proc~run_autotune_backend proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~to_str proc~execute~3 mkl_executor%execute proc~execute~3->interface~to_str proc~free_mem free_mem proc~free_mem->interface~to_str proc~get_kernel get_kernel proc~get_kernel->interface~to_str proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->interface~to_str proc~get nvrtc_module%get proc~get_kernel_instance->proc~get proc~get_name_expression get_name_expression proc~get_name_expression->interface~to_str proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->interface~to_str proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~make_plan make_plan proc~make_plan->interface~to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~to_str proc~report dtfft_plan_t%report proc~report->interface~to_str proc~report_timings->interface~to_str proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->interface~to_str proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_pencils_and_comm->proc~create_cart_comm proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~3->proc~compile_program proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~get_name_expression proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~set_name_expression->proc~get_name_expression proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~get->proc~get_mangled_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_to_string.html"},{"title":"float_to_string – dtFFT","text":"private  function float_to_string(n) result(str) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string Called by proc~~float_to_string~~CalledByGraph proc~float_to_string float_to_string interface~to_str to_str interface~to_str->proc~float_to_string proc~add nvrtc_module_cache%add proc~add->interface~to_str proc~alloc_mem alloc_mem proc~alloc_mem->interface~to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~to_str proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->interface~to_str proc~compile_program compile_program proc~compile_program->interface~to_str proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~create_cart_comm create_cart_comm proc~create_cart_comm->interface~to_str proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->interface~to_str proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create~12 abstract_executor%create proc~create~12->interface~to_str proc~create~6 transpose_plan%create proc~create~6->interface~to_str proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create~6->proc~create_pencils_and_comm proc~create~6->proc~run_autotune_backend proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~to_str proc~execute~3 mkl_executor%execute proc~execute~3->interface~to_str proc~free_mem free_mem proc~free_mem->interface~to_str proc~get_kernel get_kernel proc~get_kernel->interface~to_str proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->interface~to_str proc~get nvrtc_module%get proc~get_kernel_instance->proc~get proc~get_name_expression get_name_expression proc~get_name_expression->interface~to_str proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->interface~to_str proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~make_plan make_plan proc~make_plan->interface~to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~to_str proc~report dtfft_plan_t%report proc~report->interface~to_str proc~report_timings->interface~to_str proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->interface~to_str proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_pencils_and_comm->proc~create_cart_comm proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~3->proc~compile_program proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~get_name_expression proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~set_name_expression->proc~get_name_expression proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~get->proc~get_mangled_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/float_to_string.html"},{"title":"is_null_funptr – dtFFT","text":"private elemental function is_null_funptr(ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_funptr), intent(in) :: ptr Pointer to check Return Value logical Called by proc~~is_null_funptr~~CalledByGraph proc~is_null_funptr is_null_funptr interface~is_null_ptr is_null_ptr interface~is_null_ptr->proc~is_null_funptr interface~is_null_ptr->interface~is_null_ptr proc~dynamic_load dynamic_load proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library proc~load_library->interface~is_null_ptr proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr proc~load_symbol->proc~dl_error proc~string_c2f string_c2f proc~string_c2f->interface~is_null_ptr proc~compile_program compile_program proc~compile_program->proc~string_c2f proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_program->proc~nvrtcgeterrorstring proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~cudageterrorstring cudaGetErrorString proc~cudageterrorstring->proc~string_c2f proc~dftierrormessage DftiErrorMessage proc~dftierrormessage->proc~string_c2f proc~dl_error->proc~string_c2f proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~ncclgeterrorstring ncclGetErrorString proc~ncclgeterrorstring->proc~string_c2f proc~nvrtcgeterrorstring->proc~string_c2f proc~alloc_mem alloc_mem proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~ncclgeterrorstring proc~create abstract_backend%create proc~create->proc~cudageterrorstring proc~create_helper backend_helper%create_helper proc~create_helper->proc~ncclgeterrorstring proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_private dtfft_plan_t%create_private proc~create_private->proc~cudageterrorstring proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~create~11 kernel_device%create proc~create~11->proc~cudageterrorstring proc~get_kernel get_kernel proc~create~11->proc~get_kernel proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~create~3->proc~cudageterrorstring proc~create~3->proc~nvrtcgeterrorstring proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~create~6->proc~create_helper proc~create~6->proc~get_conf_stream proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy abstract_backend%destroy proc~destroy->proc~cudageterrorstring proc~destroy_helper->proc~ncclgeterrorstring proc~destroy_stream destroy_stream proc~destroy_stream->proc~cudageterrorstring proc~destroy~3->proc~cudageterrorstring proc~destroy~3->proc~nvrtcgeterrorstring proc~destroy~4 mkl_executor%destroy proc~destroy~4->proc~dftierrormessage proc~execute abstract_backend%execute proc~execute->proc~cudageterrorstring proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~cudageterrorstring proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~ncclgeterrorstring proc~execute~12 backend_cufftmp%execute proc~execute~12->proc~cudageterrorstring proc~execute~3 mkl_executor%execute proc~execute~3->proc~dftierrormessage proc~execute~9 kernel_device%execute proc~execute~9->proc~cudageterrorstring proc~free_mem free_mem proc~free_mem->proc~ncclgeterrorstring proc~get nvrtc_module%get proc~get->proc~cudageterrorstring proc~get_mangled_name get_mangled_name proc~get->proc~get_mangled_name proc~get_conf_stream->proc~cudageterrorstring proc~get_kernel->proc~cudageterrorstring proc~get_kernel->proc~get_conf_stream proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_mangled_name->proc~nvrtcgeterrorstring proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~make_plan make_plan proc~make_plan->proc~dftierrormessage proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->proc~dftierrormessage proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->proc~dftierrormessage proc~run_autotune_backend->proc~cudageterrorstring proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~destroy_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~set_name_expression->proc~nvrtcgeterrorstring proc~unload_library->proc~dl_error proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_nvrtc_module->proc~create~3 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~10 vkfft_executor%create proc~create~10->proc~get_conf_stream proc~create~10->proc~load_vkfft proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~create~8 cufft_executor%create proc~create~8->proc~get_conf_stream proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~destroy_stream proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~destroy_helper proc~mem_free~3 transpose_plan%mem_free proc~destroy~7->proc~mem_free~3 proc~get_kernel_instance->proc~get proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3->proc~free_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_null_funptr.html"},{"title":"destroy_strings – dtFFT","text":"public  subroutine destroy_strings(strings) Destroys array of string objects Arguments Type Intent Optional Attributes Name type( string ), intent(inout), allocatable :: strings (:) Array of strings Calls proc~~destroy_strings~~CallsGraph proc~destroy_strings destroy_strings proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_strings~~CalledByGraph proc~destroy_strings destroy_strings proc~compile_program compile_program proc~compile_program->proc~destroy_strings proc~init_environment init_environment proc~init_environment->proc~destroy_strings proc~load load proc~load->proc~destroy_strings proc~load_cuda load_cuda proc~load_cuda->proc~destroy_strings proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~destroy_strings proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~init_internal init_internal proc~init_internal->proc~init_environment proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_strings.html"},{"title":"string_f2c – dtFFT","text":"public  subroutine string_f2c(fstring, cstring, string_size) Convert Fortran string to C string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstring Fortran string character(kind=c_char, len=1), intent(inout) :: cstring (*) C string integer(kind=int64), intent(out), optional :: string_size Size of the C string Called by proc~~string_f2c~~CalledByGraph proc~string_f2c string_f2c proc~astring_f2c astring_f2c proc~astring_f2c->proc~string_f2c proc~dtfft_get_backend_string_c dtfft_get_backend_string_c proc~dtfft_get_backend_string_c->proc~string_f2c proc~dtfft_get_error_string_c dtfft_get_error_string_c proc~dtfft_get_error_string_c->proc~string_f2c proc~dtfft_get_executor_string_c dtfft_get_executor_string_c proc~dtfft_get_executor_string_c->proc~string_f2c proc~dtfft_get_precision_string_c dtfft_get_precision_string_c proc~dtfft_get_precision_string_c->proc~string_f2c proc~compile_program compile_program proc~compile_program->proc~astring_f2c proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~create_nvtx_domain create_nvtx_domain proc~create_nvtx_domain->proc~astring_f2c proc~get_name_expression get_name_expression proc~get_name_expression->proc~astring_f2c proc~load_library load_library proc~load_library->proc~astring_f2c proc~load_symbol load_symbol proc~load_symbol->proc~astring_f2c proc~push_nvtx_domain_range push_nvtx_domain_range proc~push_nvtx_domain_range->proc~astring_f2c proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create~12 abstract_executor%create proc~create~12->proc~push_nvtx_domain_range proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~create~3->proc~push_nvtx_domain_range proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~push_nvtx_domain_range proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~execute~10 abstract_executor%execute proc~execute~10->proc~push_nvtx_domain_range proc~execute~13 abstract_kernel%execute proc~execute~13->proc~push_nvtx_domain_range proc~execute~5 transpose_plan%execute proc~execute~5->proc~push_nvtx_domain_range proc~get_kernel get_kernel proc~get_kernel->proc~push_nvtx_domain_range proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~get_name_expression proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~set_name_expression->proc~get_name_expression proc~transpose_end dtfft_plan_t%transpose_end proc~transpose_end->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~push_nvtx_domain_range proc~transpose_start_ptr->proc~transpose_private proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_nvrtc_module->proc~create~3 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~create~6->proc~autotune_grid_decomposition proc~load_cuda load_cuda proc~create~6->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create~6->proc~load_nvrtc proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~execute abstract_backend%execute proc~execute->proc~execute~13 proc~execute_2d dtfft_plan_t%execute_2d proc~execute_2d->proc~execute~5 proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute~13 proc~execute_generic dtfft_plan_t%execute_generic proc~execute_generic->proc~execute~5 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~13 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~13 proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_z_slab->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~execute~6 transpose_handle_generic%execute proc~execute~6->proc~execute~13 proc~get nvrtc_module%get proc~get->proc~get_mangled_name proc~load load proc~load->proc~dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~dynamic_load proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_private->proc~execute~5 proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr proc~execute_private->proc~execute_2d proc~execute_private->proc~execute_generic proc~execute_private->proc~execute_z_slab proc~get_kernel_instance->proc~get proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~run_autotune_datatypes->proc~autotune_transpose_id proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/string_f2c.html"},{"title":"string_c2f – dtFFT","text":"public  subroutine string_c2f(cstring, fstring) Convert C string to Fortran string Arguments Type Intent Optional Attributes Name type(c_ptr) :: cstring C string character(len=:), allocatable :: fstring Fortran string Calls proc~~string_c2f~~CallsGraph proc~string_c2f string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~string_c2f~~CalledByGraph proc~string_c2f string_c2f proc~compile_program compile_program proc~compile_program->proc~string_c2f proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_program->proc~nvrtcgeterrorstring proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~cudageterrorstring cudaGetErrorString proc~cudageterrorstring->proc~string_c2f proc~dftierrormessage DftiErrorMessage proc~dftierrormessage->proc~string_c2f proc~dl_error dl_error proc~dl_error->proc~string_c2f proc~ncclgeterrorstring ncclGetErrorString proc~ncclgeterrorstring->proc~string_c2f proc~nvrtcgeterrorstring->proc~string_c2f proc~alloc_mem alloc_mem proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~ncclgeterrorstring proc~create abstract_backend%create proc~create->proc~cudageterrorstring proc~create_helper backend_helper%create_helper proc~create_helper->proc~ncclgeterrorstring proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_private dtfft_plan_t%create_private proc~create_private->proc~cudageterrorstring proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~create~11 kernel_device%create proc~create~11->proc~cudageterrorstring proc~get_kernel get_kernel proc~create~11->proc~get_kernel proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~create~3->proc~cudageterrorstring proc~create~3->proc~nvrtcgeterrorstring proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~destroy abstract_backend%destroy proc~destroy->proc~cudageterrorstring proc~destroy_helper->proc~ncclgeterrorstring proc~destroy_stream destroy_stream proc~destroy_stream->proc~cudageterrorstring proc~destroy~3->proc~cudageterrorstring proc~destroy~3->proc~nvrtcgeterrorstring proc~destroy~4 mkl_executor%destroy proc~destroy~4->proc~dftierrormessage proc~execute abstract_backend%execute proc~execute->proc~cudageterrorstring proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~cudageterrorstring proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~ncclgeterrorstring proc~execute~12 backend_cufftmp%execute proc~execute~12->proc~cudageterrorstring proc~execute~3 mkl_executor%execute proc~execute~3->proc~dftierrormessage proc~execute~9 kernel_device%execute proc~execute~9->proc~cudageterrorstring proc~free_mem free_mem proc~free_mem->proc~ncclgeterrorstring proc~get nvrtc_module%get proc~get->proc~cudageterrorstring proc~get_mangled_name get_mangled_name proc~get->proc~get_mangled_name proc~get_conf_stream->proc~cudageterrorstring proc~get_kernel->proc~cudageterrorstring proc~get_kernel->proc~get_conf_stream proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_mangled_name->proc~nvrtcgeterrorstring proc~load_library load_library proc~load_library->proc~dl_error proc~load_symbol load_symbol proc~load_symbol->proc~dl_error proc~make_plan make_plan proc~make_plan->proc~dftierrormessage proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->proc~dftierrormessage proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->proc~dftierrormessage proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~cudageterrorstring proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~destroy_helper proc~run_autotune_backend->proc~free_mem proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~set_name_expression->proc~nvrtcgeterrorstring proc~unload_library unload_library proc~unload_library->proc~dl_error proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_nvrtc_module->proc~create~3 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~10 vkfft_executor%create proc~create~10->proc~get_conf_stream proc~load_vkfft load_vkfft proc~create~10->proc~load_vkfft proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~create~6 transpose_plan%create proc~create~6->proc~create_helper proc~create~6->proc~get_conf_stream proc~create~6->proc~run_autotune_backend proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~load_cuda load_cuda proc~create~6->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create~6->proc~load_nvrtc proc~create~8 cufft_executor%create proc~create~8->proc~get_conf_stream proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~destroy_stream proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~destroy_helper proc~mem_free~3 transpose_plan%mem_free proc~destroy~7->proc~mem_free~3 proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~dynamic_load->proc~unload_library proc~get_kernel_instance->proc~get proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3->proc~free_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~load load proc~load->proc~dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~dynamic_load proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~load_vkfft->proc~load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/string_c2f.html"},{"title":"astring_f2c – dtFFT","text":"public  subroutine astring_f2c(fstring, cstring, string_size) Convert Fortran string to C allocatable string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstring Fortran string character(kind=c_char, len=1), intent(out), allocatable :: cstring (:) C string integer(kind=int64), intent(out), optional :: string_size Size of the C string Calls proc~~astring_f2c~~CallsGraph proc~astring_f2c astring_f2c proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~astring_f2c~~CalledByGraph proc~astring_f2c astring_f2c proc~compile_program compile_program proc~compile_program->proc~astring_f2c proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~create_nvtx_domain create_nvtx_domain proc~create_nvtx_domain->proc~astring_f2c proc~get_name_expression get_name_expression proc~get_name_expression->proc~astring_f2c proc~load_library load_library proc~load_library->proc~astring_f2c proc~load_symbol load_symbol proc~load_symbol->proc~astring_f2c proc~push_nvtx_domain_range push_nvtx_domain_range proc~push_nvtx_domain_range->proc~astring_f2c proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~autotune_grid autotune_grid proc~autotune_grid->proc~push_nvtx_domain_range proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~push_nvtx_domain_range proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~push_nvtx_domain_range proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~push_nvtx_domain_range proc~create~12 abstract_executor%create proc~create~12->proc~push_nvtx_domain_range proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~create~3->proc~push_nvtx_domain_range proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~push_nvtx_domain_range proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~push_nvtx_domain_range proc~execute_private dtfft_plan_t%execute_private proc~execute_ptr->proc~execute_private proc~execute~10 abstract_executor%execute proc~execute~10->proc~push_nvtx_domain_range proc~execute~13 abstract_kernel%execute proc~execute~13->proc~push_nvtx_domain_range proc~execute~5 transpose_plan%execute proc~execute~5->proc~push_nvtx_domain_range proc~get_kernel get_kernel proc~get_kernel->proc~push_nvtx_domain_range proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~get_name_expression proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~push_nvtx_domain_range proc~run_autotune_backend->proc~push_nvtx_domain_range proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~set_name_expression->proc~get_name_expression proc~transpose_end dtfft_plan_t%transpose_end proc~transpose_end->proc~push_nvtx_domain_range proc~transpose_ptr dtfft_plan_t%transpose_ptr proc~transpose_ptr->proc~push_nvtx_domain_range proc~transpose_private dtfft_plan_t%transpose_private proc~transpose_ptr->proc~transpose_private proc~transpose_start_ptr dtfft_plan_t%transpose_start_ptr proc~transpose_start_ptr->proc~push_nvtx_domain_range proc~transpose_start_ptr->proc~transpose_private proc~autotune_grid_decomposition autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_nvrtc_module->proc~create~3 proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~create~6->proc~autotune_grid_decomposition proc~load_cuda load_cuda proc~create~6->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create~6->proc~load_nvrtc proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_transpose_c dtfft_transpose_c proc~dtfft_transpose_c->proc~transpose_ptr proc~dtfft_transpose_end_c dtfft_transpose_end_c proc~dtfft_transpose_end_c->proc~transpose_end proc~dtfft_transpose_start_c dtfft_transpose_start_c proc~dtfft_transpose_start_c->proc~transpose_start_ptr proc~execute abstract_backend%execute proc~execute->proc~execute~13 proc~execute_2d dtfft_plan_t%execute_2d proc~execute_2d->proc~execute~5 proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute~13 proc~execute_generic dtfft_plan_t%execute_generic proc~execute_generic->proc~execute~5 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~13 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~13 proc~execute_z_slab dtfft_plan_t%execute_z_slab proc~execute_z_slab->proc~execute~5 proc~execute_z_slab->proc~execute_generic proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~execute~6 transpose_handle_generic%execute proc~execute~6->proc~execute~13 proc~get nvrtc_module%get proc~get->proc~get_mangled_name proc~load load proc~load->proc~dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~dynamic_load proc~transpose dtfft_plan_t%transpose proc~transpose->proc~transpose_ptr proc~transpose_private->proc~execute~5 proc~transpose_start dtfft_plan_t%transpose_start proc~transpose_start->proc~transpose_start_ptr proc~execute_private->proc~execute_2d proc~execute_private->proc~execute_generic proc~execute_private->proc~execute_z_slab proc~get_kernel_instance->proc~get proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~run_autotune_datatypes->proc~autotune_transpose_id proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/astring_f2c.html"},{"title":"write_message – dtFFT","text":"public  subroutine write_message(unit, message, prefix) Write message to the specified unit Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: unit Unit number character(len=*), intent(in) :: message Message to write character(len=*), intent(in), optional :: prefix Prefix to the message Calls proc~~write_message~~CallsGraph proc~write_message write_message mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_message~~CalledByGraph proc~write_message write_message proc~add nvrtc_module_cache%add proc~add->proc~write_message proc~alloc_mem alloc_mem proc~alloc_mem->proc~write_message proc~autotune_grid autotune_grid proc~autotune_grid->proc~write_message proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~write_message proc~get_element_size dtfft_plan_t%get_element_size proc~check_aux->proc~get_element_size proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~check_aux->proc~mem_alloc_ptr proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~check_aux->proc~get_alloc_size proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~write_message proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~write_message proc~create_c2c_pencil->proc~create_c2c_internal proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~write_message proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~write_message proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~write_message proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~write_message proc~create_r2c_pencil->proc~create_r2c_internal proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~write_message proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~write_message proc~create_r2r_pencil->proc~create_r2r_internal proc~create~3->proc~write_message proc~create~6 transpose_plan%create proc~create~6->proc~write_message proc~create~6->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create_helper backend_helper%create_helper proc~create~6->proc~create_helper proc~get_datatype_from_env get_datatype_from_env proc~create~6->proc~get_datatype_from_env proc~load_cuda load_cuda proc~create~6->proc~load_cuda proc~load_nvrtc load_nvrtc proc~create~6->proc~load_nvrtc proc~destroy_helper backend_helper%destroy_helper proc~destroy_helper->proc~write_message proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~write_message proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~destroy~6->proc~mem_free_ptr proc~dl_error dl_error proc~dl_error->proc~write_message proc~free_mem free_mem proc~free_mem->proc~write_message proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~write_message proc~get_alloc_bytes->proc~get_element_size proc~get_alloc_bytes->proc~get_alloc_size proc~get_backend dtfft_plan_t%get_backend proc~get_backend->proc~write_message proc~get_dims dtfft_plan_t%get_dims proc~get_dims->proc~write_message proc~get_element_size->proc~write_message proc~get_env_int32 get_env_int32 proc~get_env_int32->proc~write_message interface~get_env get_env proc~get_env_int32->interface~get_env proc~get_env_string get_env_string proc~get_env_string->proc~write_message proc~get_env_string->interface~get_env proc~get_executor dtfft_plan_t%get_executor proc~get_executor->proc~write_message proc~get_grid_dims dtfft_plan_t%get_grid_dims proc~get_grid_dims->proc~write_message proc~get_kernel get_kernel proc~get_kernel->proc~write_message proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->proc~write_message proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_local_sizes~2->proc~write_message proc~get_pencil dtfft_plan_t%get_pencil proc~get_pencil->proc~write_message proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~write_message proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~get_platform dtfft_plan_t%get_platform proc~get_platform->proc~write_message proc~get_precision dtfft_plan_t%get_precision proc~get_precision->proc~write_message proc~get_stream_ptr dtfft_plan_t%get_stream_ptr proc~get_stream_ptr->proc~write_message proc~get_y_slab_enabled dtfft_plan_t%get_y_slab_enabled proc~get_y_slab_enabled->proc~write_message proc~get_z_slab_enabled dtfft_plan_t%get_z_slab_enabled proc~get_z_slab_enabled->proc~write_message proc~init_environment init_environment proc~init_environment->proc~write_message proc~init_environment->interface~get_env proc~mem_alloc_ptr->proc~write_message proc~mem_free_ptr->proc~write_message proc~report dtfft_plan_t%report proc~report->proc~write_message proc~report_timings->proc~write_message proc~run_autotune_backend->proc~write_message proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~destroy_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~run_autotune_backend->proc~create_helper proc~run_autotune_datatypes->proc~write_message proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id interface~get_env->proc~get_env_int32 interface~get_env->proc~get_env_string proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical none~get_stream dtfft_plan_t%get_stream none~get_stream->proc~get_stream_ptr proc~get_stream_int64 dtfft_plan_t%get_stream_int64 none~get_stream->proc~get_stream_int64 proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_helper->proc~destroy_helper proc~create_helper->interface~get_env proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~destroy_helper proc~mem_free~3 transpose_plan%mem_free proc~destroy~7->proc~mem_free~3 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~dtfft_get_backend_c dtfft_get_backend_c proc~dtfft_get_backend_c->proc~get_backend proc~dtfft_get_dims_c dtfft_get_dims_c proc~dtfft_get_dims_c->proc~get_dims proc~dtfft_get_element_size_c dtfft_get_element_size_c proc~dtfft_get_element_size_c->proc~get_element_size proc~dtfft_get_executor_c dtfft_get_executor_c proc~dtfft_get_executor_c->proc~get_executor proc~dtfft_get_grid_dims_c dtfft_get_grid_dims_c proc~dtfft_get_grid_dims_c->proc~get_grid_dims proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 proc~dtfft_get_pencil_c dtfft_get_pencil_c proc~dtfft_get_pencil_c->proc~get_pencil proc~dtfft_get_platform_c dtfft_get_platform_c proc~dtfft_get_platform_c->proc~get_platform proc~dtfft_get_precision_c dtfft_get_precision_c proc~dtfft_get_precision_c->proc~get_precision proc~dtfft_get_y_slab_enabled_c dtfft_get_y_slab_enabled_c proc~dtfft_get_y_slab_enabled_c->proc~get_y_slab_enabled proc~dtfft_get_z_slab_enabled_c dtfft_get_z_slab_enabled_c proc~dtfft_get_z_slab_enabled_c->proc~get_z_slab_enabled proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~dtfft_mem_free_c dtfft_mem_free_c proc~dtfft_mem_free_c->proc~mem_free_ptr proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_alloc_size->proc~get_local_sizes~2 proc~init_internal init_internal proc~init_internal->proc~init_environment proc~load_library load_library proc~load_library->proc~dl_error proc~load_symbol load_symbol proc~load_symbol->proc~dl_error proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_c32_1d->proc~mem_free_ptr proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_c32_2d->proc~mem_free_ptr proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_c32_3d->proc~mem_free_ptr proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_c64_1d->proc~mem_free_ptr proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_c64_2d->proc~mem_free_ptr proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_c64_3d->proc~mem_free_ptr proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_r32_1d->proc~mem_free_ptr proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_r32_2d->proc~mem_free_ptr proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_r32_3d->proc~mem_free_ptr proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_r64_1d->proc~mem_free_ptr proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_r64_2d->proc~mem_free_ptr proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_r64_3d->proc~mem_free_ptr proc~mem_free~3->proc~free_mem proc~unload_library unload_library proc~unload_library->proc~dl_error proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~dynamic_load->proc~unload_library proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~get_datatype_from_env->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~get_stream_int64->none~get_stream proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~load load proc~load->proc~dynamic_load proc~load_cuda->proc~dynamic_load proc~load_nvrtc->proc~dynamic_load proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal->proc~create_private proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal->proc~create_c2c_core proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/write_message.html"},{"title":"create_subcomm_include_all – dtFFT","text":"public  subroutine create_subcomm_include_all(old_comm, new_comm) Creates communicator including all processes from old_comm Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: old_comm Communicator to create group from type(MPI_Comm), intent(out) :: new_comm New communicator Calls proc~~create_subcomm_include_all~~CallsGraph proc~create_subcomm_include_all create_subcomm_include_all mpi_comm_size mpi_comm_size proc~create_subcomm_include_all->mpi_comm_size proc~create_subcomm create_subcomm proc~create_subcomm_include_all->proc~create_subcomm mpi_comm_create mpi_comm_create proc~create_subcomm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_subcomm->mpi_comm_group mpi_group_free mpi_group_free proc~create_subcomm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_subcomm->mpi_group_incl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_subcomm_include_all~~CalledByGraph proc~create_subcomm_include_all create_subcomm_include_all proc~create_cart_comm create_cart_comm proc~create_cart_comm->proc~create_subcomm_include_all proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~create~6 transpose_plan%create proc~create~6->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_subcomm_include_all.html"},{"title":"create_subcomm – dtFFT","text":"public  subroutine create_subcomm(old_comm, processes, new_comm) Creates communicator with selected processes from old_comm Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: old_comm Communicator to create group from integer(kind=int32), intent(in) :: processes (:) Ranks of processes in old_comm to include in new group type(MPI_Comm), intent(out) :: new_comm New communicator Calls proc~~create_subcomm~~CallsGraph proc~create_subcomm create_subcomm mpi_comm_create mpi_comm_create proc~create_subcomm->mpi_comm_create mpi_comm_group mpi_comm_group proc~create_subcomm->mpi_comm_group mpi_group_free mpi_group_free proc~create_subcomm->mpi_group_free mpi_group_incl mpi_group_incl proc~create_subcomm->mpi_group_incl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_subcomm~~CalledByGraph proc~create_subcomm create_subcomm proc~create_1d_comm create_1d_comm proc~create_1d_comm->proc~create_subcomm proc~create_subcomm_include_all create_subcomm_include_all proc~create_subcomm_include_all->proc~create_subcomm proc~create_cart_comm create_cart_comm proc~create_cart_comm->proc~create_subcomm_include_all proc~create_pencil_init pencil_init%create_pencil_init proc~create_pencil_init->proc~create_1d_comm proc~create_pencils_and_comm create_pencils_and_comm proc~create_pencils_and_comm->proc~create_cart_comm proc~autotune_grid autotune_grid proc~autotune_grid->proc~create_pencils_and_comm proc~create~6 transpose_plan%create proc~create~6->proc~create_pencils_and_comm proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_subcomm.html"},{"title":"destroy_string – dtFFT","text":"private  subroutine destroy_string(self) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self Called by proc~~destroy_string~~CalledByGraph proc~destroy_string string%destroy_string proc~destroy_strings destroy_strings proc~destroy_strings->proc~destroy_string proc~get_env_base get_env_base proc~get_env_base->proc~destroy_string proc~get_env_string get_env_string proc~get_env_string->proc~destroy_string interface~get_env get_env proc~get_env_string->interface~get_env interface~get_env->proc~get_env_base interface~get_env->proc~get_env_string proc~get_env_int32 get_env_int32 interface~get_env->proc~get_env_int32 proc~get_env_int8 get_env_int8 interface~get_env->proc~get_env_int8 proc~get_env_logical get_env_logical interface~get_env->proc~get_env_logical proc~compile_program compile_program proc~compile_program->proc~destroy_strings proc~init_environment init_environment proc~init_environment->proc~destroy_strings proc~init_environment->interface~get_env proc~load load proc~load->proc~destroy_strings proc~load_cuda load_cuda proc~load_cuda->proc~destroy_strings proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~destroy_strings proc~create_helper backend_helper%create_helper proc~create_helper->interface~get_env proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~create~6->proc~create_helper proc~get_datatype_from_env get_datatype_from_env proc~create~6->proc~get_datatype_from_env proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~get_datatype_from_env->interface~get_env proc~get_env_int32->interface~get_env proc~get_env_int8->interface~get_env proc~get_env_logical->interface~get_env proc~init_internal init_internal proc~init_internal->proc~init_environment proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~init_internal proc~run_autotune_backend->proc~create_helper proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_string.html"},{"title":"dl_error – dtFFT","text":"private  subroutine dl_error(message) Writes error message to the error unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to write Calls proc~~dl_error~~CallsGraph proc~dl_error dl_error interface~dlerror dlerror proc~dl_error->interface~dlerror proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dl_error~~CalledByGraph proc~dl_error dl_error proc~load_library load_library proc~load_library->proc~dl_error proc~load_symbol load_symbol proc~load_symbol->proc~dl_error proc~unload_library unload_library proc~unload_library->proc~dl_error proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~dynamic_load->proc~unload_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dl_error.html"},{"title":"unload_library – dtFFT","text":"private  subroutine unload_library(handle) Unloads library Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: handle Loaded handle Calls proc~~unload_library~~CallsGraph proc~unload_library unload_library interface~dlclose dlclose proc~unload_library->interface~dlclose proc~dl_error dl_error proc~unload_library->proc~dl_error interface~dlerror dlerror proc~dl_error->interface~dlerror proc~string_c2f string_c2f proc~dl_error->proc~string_c2f proc~write_message write_message proc~dl_error->proc~write_message interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unload_library~~CalledByGraph proc~unload_library unload_library proc~dynamic_load dynamic_load proc~dynamic_load->proc~unload_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unload_library.html"},{"title":"to_str – dtFFT","text":"public interface to_str Convert various types to string Calls interface~~to_str~~CallsGraph interface~to_str to_str proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~to_str~~CalledByGraph interface~to_str to_str proc~add nvrtc_module_cache%add proc~add->interface~to_str proc~alloc_mem alloc_mem proc~alloc_mem->interface~to_str proc~autotune_grid autotune_grid proc~autotune_grid->interface~to_str proc~create_pencils_and_comm create_pencils_and_comm proc~autotune_grid->proc~create_pencils_and_comm proc~run_autotune_backend run_autotune_backend proc~autotune_grid->proc~run_autotune_backend proc~check_aux dtfft_plan_t%check_aux proc~check_aux->interface~to_str proc~compile_program compile_program proc~compile_program->interface~to_str proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~create_cart_comm create_cart_comm proc~create_cart_comm->interface~to_str proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->interface~to_str proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~create~12 abstract_executor%create proc~create~12->interface~to_str proc~create~6 transpose_plan%create proc~create~6->interface~to_str proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create~6->proc~create_pencils_and_comm proc~create~6->proc~run_autotune_backend proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~to_str proc~execute~3 mkl_executor%execute proc~execute~3->interface~to_str proc~free_mem free_mem proc~free_mem->interface~to_str proc~get_kernel get_kernel proc~get_kernel->interface~to_str proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->interface~to_str proc~get nvrtc_module%get proc~get_kernel_instance->proc~get proc~get_name_expression get_name_expression proc~get_name_expression->interface~to_str proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->interface~to_str proc~report_timings report_timings proc~get_plan_execution_time->proc~report_timings proc~make_plan make_plan proc~make_plan->interface~to_str proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~to_str proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~to_str proc~report dtfft_plan_t%report proc~report->interface~to_str proc~report_timings->interface~to_str proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->interface~to_str proc~autotune_transpose_id autotune_transpose_id proc~run_autotune_datatypes->proc~autotune_transpose_id proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~autotune_transpose_id->proc~get_plan_execution_time proc~create_pencils_and_comm->proc~create_cart_comm proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~3->proc~compile_program proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_mangled_name get_mangled_name proc~get_mangled_name->proc~get_name_expression proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~report_timings proc~run_autotune_backend->proc~run_autotune_datatypes proc~run_autotune_backend->proc~alloc_and_set_aux proc~set_name_expression->proc~get_name_expression proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr proc~get->proc~get_mangled_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function int8_to_string (n) result(str) Convert 8-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int32_to_string (n) result(str) Convert 32-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int64_to_string (n) result(str) Convert 64-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function double_to_string (n) result(str) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string private  function float_to_string (n) result(str) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string","tags":"","loc":"interface/to_str.html"},{"title":"mem_free_host – dtFFT","text":"interface Called by interface~~mem_free_host~~CalledByGraph interface~mem_free_host mem_free_host proc~create~3 nvrtc_module%create proc~create~3->interface~mem_free_host proc~free_mem free_mem proc~free_mem->interface~mem_free_host proc~mem_free_ptr dtfft_plan_t%mem_free_ptr proc~mem_free_ptr->interface~mem_free_host proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~mem_free_ptr proc~dtfft_mem_free_c dtfft_mem_free_c proc~dtfft_mem_free_c->proc~mem_free_ptr proc~mem_free_c32_1d dtfft_plan_t%mem_free_c32_1d proc~mem_free_c32_1d->proc~mem_free_ptr proc~mem_free_c32_2d dtfft_plan_t%mem_free_c32_2d proc~mem_free_c32_2d->proc~mem_free_ptr proc~mem_free_c32_3d dtfft_plan_t%mem_free_c32_3d proc~mem_free_c32_3d->proc~mem_free_ptr proc~mem_free_c64_1d dtfft_plan_t%mem_free_c64_1d proc~mem_free_c64_1d->proc~mem_free_ptr proc~mem_free_c64_2d dtfft_plan_t%mem_free_c64_2d proc~mem_free_c64_2d->proc~mem_free_ptr proc~mem_free_c64_3d dtfft_plan_t%mem_free_c64_3d proc~mem_free_c64_3d->proc~mem_free_ptr proc~mem_free_r32_1d dtfft_plan_t%mem_free_r32_1d proc~mem_free_r32_1d->proc~mem_free_ptr proc~mem_free_r32_2d dtfft_plan_t%mem_free_r32_2d proc~mem_free_r32_2d->proc~mem_free_ptr proc~mem_free_r32_3d dtfft_plan_t%mem_free_r32_3d proc~mem_free_r32_3d->proc~mem_free_ptr proc~mem_free_r64_1d dtfft_plan_t%mem_free_r64_1d proc~mem_free_r64_1d->proc~mem_free_ptr proc~mem_free_r64_2d dtfft_plan_t%mem_free_r64_2d proc~mem_free_r64_2d->proc~mem_free_ptr proc~mem_free_r64_3d dtfft_plan_t%mem_free_r64_3d proc~mem_free_r64_3d->proc~mem_free_ptr proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~autotune_grid_decomposition->proc~autotune_grid proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine mem_free_host(ptr) bind(C, name=\"free\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to free Description Frees memory allocated with aligned_alloc","tags":"","loc":"interface/mem_free_host.html"},{"title":"Comm_f2c – dtFFT","text":"interface Called by interface~~comm_f2c~~CalledByGraph interface~comm_f2c Comm_f2c proc~create~15 backend_cufftmp%create proc~create~15->interface~comm_f2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function Comm_f2c(fcomm) bind(C, name=\"Comm_f2c\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: fcomm Fortran communicator Return Value type(c_ptr) Description Converts Fortran communicator to C","tags":"","loc":"interface/comm_f2c.html"},{"title":"is_device_ptr – dtFFT","text":"interface Called by interface~~is_device_ptr~~CalledByGraph interface~is_device_ptr is_device_ptr proc~check_device_pointers check_device_pointers proc~check_device_pointers->interface~is_device_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function is_device_ptr(ptr) result(bool) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Device pointer Return Value logical(kind=c_bool) Result Description Checks if pointer can be accessed from device","tags":"","loc":"interface/is_device_ptr.html"},{"title":"string – dtFFT","text":"public interface string Creates string object Calls interface~~string~~CallsGraph interface~string string proc~string_constructor string_constructor interface~string->proc~string_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function string_constructor (str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string )","tags":"","loc":"interface/string.html"},{"title":"is_null_ptr – dtFFT","text":"private interface is_null_ptr Checks if pointer is NULL Calls interface~~is_null_ptr~~CallsGraph interface~is_null_ptr is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~is_null_ptr~~CalledByGraph interface~is_null_ptr is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~dynamic_load dynamic_load proc~dynamic_load->interface~is_null_ptr proc~load_library load_library proc~dynamic_load->proc~load_library proc~load_symbol load_symbol proc~dynamic_load->proc~load_symbol proc~unload_library unload_library proc~dynamic_load->proc~unload_library proc~load_library->interface~is_null_ptr proc~dl_error dl_error proc~load_library->proc~dl_error proc~load_symbol->interface~is_null_ptr proc~load_symbol->proc~dl_error proc~string_c2f string_c2f proc~string_c2f->interface~is_null_ptr proc~compile_program compile_program proc~compile_program->proc~string_c2f proc~nvrtcgeterrorstring nvrtcGetErrorString proc~compile_program->proc~nvrtcgeterrorstring proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~cudageterrorstring cudaGetErrorString proc~cudageterrorstring->proc~string_c2f proc~dftierrormessage DftiErrorMessage proc~dftierrormessage->proc~string_c2f proc~dl_error->proc~string_c2f proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~ncclgeterrorstring ncclGetErrorString proc~ncclgeterrorstring->proc~string_c2f proc~nvrtcgeterrorstring->proc~string_c2f proc~alloc_mem alloc_mem proc~alloc_mem->proc~cudageterrorstring proc~alloc_mem->proc~ncclgeterrorstring proc~create abstract_backend%create proc~create->proc~cudageterrorstring proc~create_helper backend_helper%create_helper proc~create_helper->proc~ncclgeterrorstring proc~destroy_helper backend_helper%destroy_helper proc~create_helper->proc~destroy_helper proc~create_private dtfft_plan_t%create_private proc~create_private->proc~cudageterrorstring proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~create~11 kernel_device%create proc~create~11->proc~cudageterrorstring proc~get_kernel get_kernel proc~create~11->proc~get_kernel proc~create~3 nvrtc_module%create proc~create~3->proc~compile_program proc~create~3->proc~cudageterrorstring proc~create~3->proc~nvrtcgeterrorstring proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~create~6->proc~create_helper proc~create~6->proc~get_conf_stream proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy abstract_backend%destroy proc~destroy->proc~cudageterrorstring proc~destroy_helper->proc~ncclgeterrorstring proc~destroy_stream destroy_stream proc~destroy_stream->proc~cudageterrorstring proc~destroy~3->proc~cudageterrorstring proc~destroy~3->proc~nvrtcgeterrorstring proc~destroy~4 mkl_executor%destroy proc~destroy~4->proc~dftierrormessage proc~execute abstract_backend%execute proc~execute->proc~cudageterrorstring proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~cudageterrorstring proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~ncclgeterrorstring proc~execute~12 backend_cufftmp%execute proc~execute~12->proc~cudageterrorstring proc~execute~3 mkl_executor%execute proc~execute~3->proc~dftierrormessage proc~execute~9 kernel_device%execute proc~execute~9->proc~cudageterrorstring proc~free_mem free_mem proc~free_mem->proc~ncclgeterrorstring proc~get nvrtc_module%get proc~get->proc~cudageterrorstring proc~get_mangled_name get_mangled_name proc~get->proc~get_mangled_name proc~get_conf_stream->proc~cudageterrorstring proc~get_kernel->proc~cudageterrorstring proc~get_kernel->proc~get_conf_stream proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_mangled_name->proc~nvrtcgeterrorstring proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~make_plan make_plan proc~make_plan->proc~dftierrormessage proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->proc~dftierrormessage proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->proc~dftierrormessage proc~run_autotune_backend->proc~cudageterrorstring proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~create_helper proc~run_autotune_backend->proc~destroy_helper proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~set_name_expression->proc~nvrtcgeterrorstring proc~unload_library->proc~dl_error proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_nvrtc_module->proc~create~3 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~10 vkfft_executor%create proc~create~10->proc~get_conf_stream proc~create~10->proc~load_vkfft proc~create~4 mkl_executor%create proc~create~4->proc~make_plan proc~create~8 cufft_executor%create proc~create~8->proc~get_conf_stream proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~destroy_stream proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~destroy_helper proc~mem_free~3 transpose_plan%mem_free proc~destroy~7->proc~mem_free~3 proc~get_kernel_instance->proc~get proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3->proc~free_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  interface is_null_ptr () Checks if pointer is NULL Arguments None private elemental function is_null_funptr (ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_funptr), intent(in) :: ptr Pointer to check Return Value logical","tags":"","loc":"interface/is_null_ptr.html"},{"title":"dlopen – dtFFT","text":"interface Called by interface~~dlopen~~CalledByGraph interface~dlopen dlopen proc~load_library load_library proc~load_library->interface~dlopen proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function dlopen(filename, mode) bind(C) Arguments Type Intent Optional Attributes Name character(len=c_char) :: filename (*) Name of the library integer(kind=c_int), value :: mode Options to dlopen Return Value type(c_ptr) Handle to the library Description Load and link a dynamic library","tags":"","loc":"interface/dlopen.html"},{"title":"dlsym – dtFFT","text":"interface Called by interface~~dlsym~~CalledByGraph interface~dlsym dlsym proc~load_symbol load_symbol proc~load_symbol->interface~dlsym proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_symbol proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function dlsym(handle, name) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Handle to the library character(len=c_char) :: name (*) Name of the symbol Return Value type(c_funptr) Address of the symbol Description Get address of a symbol from a dynamic library","tags":"","loc":"interface/dlsym.html"},{"title":"dlclose – dtFFT","text":"interface Called by interface~~dlclose~~CalledByGraph interface~dlclose dlclose proc~unload_library unload_library proc~unload_library->interface~dlclose proc~dynamic_load dynamic_load proc~dynamic_load->proc~unload_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function dlclose(handle) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Handle to the library Return Value integer(kind=c_int) Result of the operation Description Close a dynamic library","tags":"","loc":"interface/dlclose.html"},{"title":"dlerror – dtFFT","text":"interface Called by interface~~dlerror~~CalledByGraph interface~dlerror dlerror proc~dl_error dl_error proc~dl_error->interface~dlerror proc~load_library load_library proc~load_library->proc~dl_error proc~load_symbol load_symbol proc~load_symbol->proc~dl_error proc~unload_library unload_library proc~unload_library->proc~dl_error proc~dynamic_load dynamic_load proc~dynamic_load->proc~load_library proc~dynamic_load->proc~load_symbol proc~dynamic_load->proc~unload_library proc~load load proc~load->proc~dynamic_load proc~load_cuda load_cuda proc~load_cuda->proc~dynamic_load proc~load_nvrtc load_nvrtc proc~load_nvrtc->proc~dynamic_load proc~create~6 transpose_plan%create proc~create~6->proc~load_cuda proc~create~6->proc~load_nvrtc proc~load_vkfft load_vkfft proc~load_vkfft->proc~load proc~create~10 vkfft_executor%create proc~create~10->proc~load_vkfft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function dlerror() bind(C) Arguments None Return Value type(c_ptr) Error message Description Get diagnostic information","tags":"","loc":"interface/dlerror.html"},{"title":"aligned_alloc – dtFFT","text":"interface Called by interface~~aligned_alloc~~CalledByGraph interface~aligned_alloc aligned_alloc proc~mem_alloc_host mem_alloc_host proc~mem_alloc_host->interface~aligned_alloc proc~alloc_mem alloc_mem proc~alloc_mem->proc~mem_alloc_host proc~compile_program compile_program proc~compile_program->proc~mem_alloc_host proc~create~3 nvrtc_module%create proc~create~3->proc~mem_alloc_host proc~create~3->proc~compile_program proc~mem_alloc_ptr dtfft_plan_t%mem_alloc_ptr proc~mem_alloc_ptr->proc~mem_alloc_host proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~mem_alloc_ptr proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~create~3 proc~dtfft_mem_alloc_c dtfft_mem_alloc_c proc~dtfft_mem_alloc_c->proc~mem_alloc_ptr proc~mem_alloc_c32_1d dtfft_plan_t%mem_alloc_c32_1d proc~mem_alloc_c32_1d->proc~mem_alloc_ptr proc~mem_alloc_c32_2d dtfft_plan_t%mem_alloc_c32_2d proc~mem_alloc_c32_2d->proc~mem_alloc_ptr proc~mem_alloc_c32_3d dtfft_plan_t%mem_alloc_c32_3d proc~mem_alloc_c32_3d->proc~mem_alloc_ptr proc~mem_alloc_c64_1d dtfft_plan_t%mem_alloc_c64_1d proc~mem_alloc_c64_1d->proc~mem_alloc_ptr proc~mem_alloc_c64_2d dtfft_plan_t%mem_alloc_c64_2d proc~mem_alloc_c64_2d->proc~mem_alloc_ptr proc~mem_alloc_c64_3d dtfft_plan_t%mem_alloc_c64_3d proc~mem_alloc_c64_3d->proc~mem_alloc_ptr proc~mem_alloc_r32_1d dtfft_plan_t%mem_alloc_r32_1d proc~mem_alloc_r32_1d->proc~mem_alloc_ptr proc~mem_alloc_r32_2d dtfft_plan_t%mem_alloc_r32_2d proc~mem_alloc_r32_2d->proc~mem_alloc_ptr proc~mem_alloc_r32_3d dtfft_plan_t%mem_alloc_r32_3d proc~mem_alloc_r32_3d->proc~mem_alloc_ptr proc~mem_alloc_r64_1d dtfft_plan_t%mem_alloc_r64_1d proc~mem_alloc_r64_1d->proc~mem_alloc_ptr proc~mem_alloc_r64_2d dtfft_plan_t%mem_alloc_r64_2d proc~mem_alloc_r64_2d->proc~mem_alloc_ptr proc~mem_alloc_r64_3d dtfft_plan_t%mem_alloc_r64_3d proc~mem_alloc_r64_3d->proc~mem_alloc_ptr proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~get_kernel get_kernel proc~get_kernel->proc~create_nvrtc_module proc~autotune_grid_decomposition->proc~autotune_grid proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function aligned_alloc(alignment, alloc_size) result(ptr) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: alignment Alignment in bytes (16 bytes by default) integer(kind=c_size_t), value :: alloc_size Number of bytes to allocate Return Value type(c_ptr) Pointer to allocate Description Allocates memory using C11 Standard alloc_align with 16 bytes alignment","tags":"","loc":"interface/aligned_alloc.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, effort, base_storage, force_effort) Uses iso_fortran_env iso_c_binding proc~~create~11~~UsesGraph proc~create~11 kernel_device%create iso_c_binding iso_c_binding proc~create~11->iso_c_binding iso_fortran_env iso_fortran_env proc~create~11->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates kernel Type Bound kernel_device Arguments Type Intent Optional Attributes Name class( kernel_device ), intent(inout) :: self Device kernel class type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in), optional :: force_effort Should effort be forced or not Calls proc~~create~11~~CallsGraph proc~create~11 kernel_device%create fname fname proc~create~11->fname interface~cudagetdevice cudaGetDevice proc~create~11->interface~cudagetdevice interface~get_device_props get_device_props proc~create~11->interface~get_device_props mpi_abort mpi_abort proc~create~11->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~create~11->proc~cudageterrorstring proc~destroy~15 abstract_kernel%destroy proc~create~11->proc~destroy~15 proc~get_kernel get_kernel proc~create~11->proc~get_kernel interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f destroy_private destroy_private proc~destroy~15->destroy_private proc~get_kernel->fname proc~get_kernel->mpi_abort proc~get_kernel->proc~cudageterrorstring interface~cudaeventcreate cudaEventCreate proc~get_kernel->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~get_kernel->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~get_kernel->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~get_kernel->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~get_kernel->interface~cudaeventsynchronize interface~cudafree cudaFree proc~get_kernel->interface~cudafree interface~cudamalloc cudaMalloc proc~get_kernel->interface~cudamalloc interface~cudastreamsynchronize cudaStreamSynchronize proc~get_kernel->interface~cudastreamsynchronize interface~to_str to_str proc~get_kernel->interface~to_str proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~culaunchkernel cuLaunchKernel proc~get_kernel->proc~culaunchkernel proc~evaluate_analytical_performance evaluate_analytical_performance proc~get_kernel->proc~evaluate_analytical_performance proc~generate_candidates generate_candidates proc~get_kernel->proc~generate_candidates proc~get_conf_configs_to_test get_conf_configs_to_test proc~get_kernel->proc~get_conf_configs_to_test proc~get_conf_forced_kernel_optimization get_conf_forced_kernel_optimization proc~get_kernel->proc~get_conf_forced_kernel_optimization proc~get_conf_kernel_optimization_enabled get_conf_kernel_optimization_enabled proc~get_kernel->proc~get_conf_kernel_optimization_enabled proc~get_conf_log_enabled get_conf_log_enabled proc~get_kernel->proc~get_conf_log_enabled proc~get_conf_measure_iters get_conf_measure_iters proc~get_kernel->proc~get_conf_measure_iters proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~get_kernel->proc~get_conf_measure_warmup_iters proc~get_conf_stream get_conf_stream proc~get_kernel->proc~get_conf_stream proc~get_kernel_args get_kernel_args proc~get_kernel->proc~get_kernel_args proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_launch_params get_kernel_launch_params proc~get_kernel->proc~get_kernel_launch_params proc~get_kernel_string get_kernel_string proc~get_kernel->proc~get_kernel_string proc~is_unpack_kernel is_unpack_kernel proc~get_kernel->proc~is_unpack_kernel proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~get_kernel->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~get_kernel->proc~push_nvtx_domain_range proc~sort_candidates_by_score sort_candidates_by_score proc~get_kernel->proc~sort_candidates_by_score proc~write_message write_message proc~get_kernel->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~create_nvrtc_module->interface~to_str proc~create_nvrtc_module->proc~get_conf_log_enabled proc~create_nvrtc_module->proc~get_kernel_string proc~create_nvrtc_module->proc~write_message none~check nvrtc_module%check proc~create_nvrtc_module->none~check proc~add nvrtc_module_cache%add proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 proc~count_bank_conflicts count_bank_conflicts proc~evaluate_analytical_performance->proc~count_bank_conflicts proc~estimate_bank_conflict_ratio estimate_bank_conflict_ratio proc~evaluate_analytical_performance->proc~estimate_bank_conflict_ratio proc~estimate_coalescing estimate_coalescing proc~evaluate_analytical_performance->proc~estimate_coalescing proc~estimate_occupancy estimate_occupancy proc~evaluate_analytical_performance->proc~estimate_occupancy proc~estimate_memory_pressure estimate_memory_pressure proc~generate_candidates->proc~estimate_memory_pressure proc~estimate_optimal_padding estimate_optimal_padding proc~generate_candidates->proc~estimate_optimal_padding proc~find_valid_combination find_valid_combination proc~generate_candidates->proc~find_valid_combination interface~get_conf_internal get_conf_internal proc~get_conf_configs_to_test->interface~get_conf_internal proc~get_conf_forced_kernel_optimization->interface~get_conf_internal proc~get_conf_kernel_optimization_enabled->interface~get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate proc~get_kernel_instance->interface~to_str proc~get_kernel_instance->proc~get_conf_log_enabled proc~get_kernel_instance->proc~get_kernel_string proc~get_kernel_instance->proc~write_message is_null_ptr is_null_ptr proc~get_kernel_instance->is_null_ptr proc~get nvrtc_module%get proc~get_kernel_instance->proc~get interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~check_instance nvrtc_module%check_instance none~check->proc~check_instance proc~check_module nvrtc_module%check_module none~check->proc~check_module proc~add->interface~to_str proc~add->proc~get_conf_log_enabled proc~add->proc~write_message proc~create~9 nvrtc_module_cache%create proc~add->proc~create~9 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create~3->fname proc~create~3->mpi_abort proc~create~3->proc~cudageterrorstring proc~create~3->proc~get_conf_log_enabled proc~create~3->proc~pop_nvtx_domain_range proc~create~3->proc~push_nvtx_domain_range proc~create~3->proc~write_message interface~mem_free_host mem_free_host proc~create~3->interface~mem_free_host proc~compile_program compile_program proc~create~3->proc~compile_program proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~get_code get_code proc~create~3->proc~get_code proc~mem_alloc_host mem_alloc_host proc~create~3->proc~mem_alloc_host proc~nvrtcgeterrorstring nvrtcGetErrorString proc~create~3->proc~nvrtcgeterrorstring proc~estimate_bank_conflict_ratio->proc~count_bank_conflicts proc~estimate_optimal_padding->proc~count_bank_conflicts proc~get->fname proc~get->mpi_abort proc~get->proc~cudageterrorstring proc~get->none~check proc~get_mangled_name get_mangled_name proc~get->proc~get_mangled_name proc~check_instance->none~check proc~compile_program->fname proc~compile_program->mpi_abort proc~compile_program->interface~to_str proc~compile_program->proc~string_c2f proc~compile_program->proc~astring_f2c proc~compile_program->proc~mem_alloc_host proc~compile_program->proc~nvrtcgeterrorstring proc~destroy_strings destroy_strings proc~compile_program->proc~destroy_strings proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~destroy~3->fname proc~destroy~3->mpi_abort proc~destroy~3->proc~cudageterrorstring proc~destroy~3->is_null_ptr proc~destroy~3->proc~nvrtcgeterrorstring proc~get_code->proc~is_unpack_kernel proc~add_line codegen_t%add_line proc~get_code->proc~add_line proc~get_mangled_name->fname proc~get_mangled_name->mpi_abort proc~get_mangled_name->proc~nvrtcgeterrorstring proc~get_name_expression get_name_expression proc~get_mangled_name->proc~get_name_expression interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~nvrtcgeterrorstring->proc~string_c2f proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~get_name_expression->interface~to_str proc~get_name_expression->proc~astring_f2c proc~set_name_expression->fname proc~set_name_expression->mpi_abort proc~set_name_expression->proc~nvrtcgeterrorstring proc~set_name_expression->proc~get_name_expression Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~11.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, stream, neighbor) Uses iso_fortran_env iso_c_binding proc~~execute~9~~UsesGraph proc~execute~9 kernel_device%execute iso_c_binding iso_c_binding proc~execute~9->iso_c_binding iso_fortran_env iso_fortran_env proc~execute~9->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes kernel on stream Type Bound kernel_device Arguments Type Intent Optional Attributes Name class( kernel_device ), intent(inout) :: self Device kernel class real(kind=real32), intent(in), target :: in (:) Device pointer real(kind=real32), intent(inout), target :: out (:) Device pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking Calls proc~~execute~9~~CallsGraph proc~execute~9 kernel_device%execute fname fname proc~execute~9->fname interface~cudamemcpyasync cudaMemcpyAsync proc~execute~9->interface~cudamemcpyasync interface~cudastreamsynchronize cudaStreamSynchronize proc~execute~9->interface~cudastreamsynchronize mpi_abort mpi_abort proc~execute~9->mpi_abort proc~cudageterrorstring cudaGetErrorString proc~execute~9->proc~cudageterrorstring proc~culaunchkernel cuLaunchKernel proc~execute~9->proc~culaunchkernel proc~get_kernel_args get_kernel_args proc~execute~9->proc~get_kernel_args proc~get_kernel_launch_params get_kernel_launch_params proc~execute~9->proc~get_kernel_launch_params interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~9.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys kernel Type Bound kernel_device Arguments Type Intent Optional Attributes Name class( kernel_device ), intent(inout) :: self Device kernel class","tags":"","loc":"proc/destroy~11.html"},{"title":"get_kernel_args – dtFFT","text":"private  subroutine get_kernel_args(kernel_type, dims, nargs, args, neighbor_data) Populates kernel arguments based on kernel type Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: kernel_type Type of kernel integer(kind=int32), intent(in) :: dims (:) Local dimensions to process integer(kind=int32), intent(out) :: nargs Number of arguments set by this subroutine integer(kind=int32), intent(out) :: args (MAX_KERNEL_ARGS) Kernel arguments integer(kind=int32), intent(in), optional :: neighbor_data (:) Neighbor data for pipelined kernels Called by proc~~get_kernel_args~~CalledByGraph proc~get_kernel_args get_kernel_args proc~execute~9 kernel_device%execute proc~execute~9->proc~get_kernel_args proc~get_kernel get_kernel proc~get_kernel->proc~get_kernel_args proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_kernel_args.html"},{"title":"get_kernel_launch_params – dtFFT","text":"private  subroutine get_kernel_launch_params(kernel_type, dims, tile_size, block_rows, blocks, threads) Computes kernel launch parameters based on kernel type and dimensions Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: kernel_type Type of kernel integer(kind=int32), intent(in) :: dims (:) Local dimensions to process integer(kind=int32), intent(in) :: tile_size Size of the tile in shared memory integer(kind=int32), intent(in) :: block_rows Number of rows in each block type( dim3 ), intent(out) :: blocks Number of blocks to launch type( dim3 ), intent(out) :: threads Number of threads per block Called by proc~~get_kernel_launch_params~~CalledByGraph proc~get_kernel_launch_params get_kernel_launch_params proc~execute~9 kernel_device%execute proc~execute~9->proc~get_kernel_launch_params proc~get_kernel get_kernel proc~get_kernel->proc~get_kernel_launch_params proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_kernel_launch_params.html"},{"title":"get_kernel – dtFFT","text":"private  subroutine get_kernel(dims, kernel_type, effort, base_storage, props, tile_size, block_rows, kernel, force_effort, neighbor_data) Uses iso_fortran_env iso_c_binding proc~~get_kernel~~UsesGraph proc~get_kernel get_kernel iso_c_binding iso_c_binding proc~get_kernel->iso_c_binding iso_fortran_env iso_fortran_env proc~get_kernel->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compiles kernel and caches it. Returns compiled kernel. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Local dimensions to process type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal transpose kernel integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( device_props ), intent(in) :: props GPU architecture properties integer(kind=int32), intent(out) :: tile_size Size of the tile in shared memory integer(kind=int32), intent(out) :: block_rows Number of rows in each block processed by each thread type( CUfunction ), intent(out) :: kernel Compiled kernel to return logical, intent(in), optional :: force_effort Should effort be forced or not integer(kind=int32), intent(in), optional :: neighbor_data (:) Neighbor data for pipelined kernels Calls proc~~get_kernel~~CallsGraph proc~get_kernel get_kernel fname fname proc~get_kernel->fname interface~cudaeventcreate cudaEventCreate proc~get_kernel->interface~cudaeventcreate interface~cudaeventdestroy cudaEventDestroy proc~get_kernel->interface~cudaeventdestroy interface~cudaeventelapsedtime cudaEventElapsedTime proc~get_kernel->interface~cudaeventelapsedtime interface~cudaeventrecord cudaEventRecord proc~get_kernel->interface~cudaeventrecord interface~cudaeventsynchronize cudaEventSynchronize proc~get_kernel->interface~cudaeventsynchronize interface~cudafree cudaFree proc~get_kernel->interface~cudafree interface~cudamalloc cudaMalloc proc~get_kernel->interface~cudamalloc interface~cudastreamsynchronize cudaStreamSynchronize proc~get_kernel->interface~cudastreamsynchronize interface~to_str to_str proc~get_kernel->interface~to_str mpi_abort mpi_abort proc~get_kernel->mpi_abort proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~cudageterrorstring cudaGetErrorString proc~get_kernel->proc~cudageterrorstring proc~culaunchkernel cuLaunchKernel proc~get_kernel->proc~culaunchkernel proc~evaluate_analytical_performance evaluate_analytical_performance proc~get_kernel->proc~evaluate_analytical_performance proc~generate_candidates generate_candidates proc~get_kernel->proc~generate_candidates proc~get_conf_configs_to_test get_conf_configs_to_test proc~get_kernel->proc~get_conf_configs_to_test proc~get_conf_forced_kernel_optimization get_conf_forced_kernel_optimization proc~get_kernel->proc~get_conf_forced_kernel_optimization proc~get_conf_kernel_optimization_enabled get_conf_kernel_optimization_enabled proc~get_kernel->proc~get_conf_kernel_optimization_enabled proc~get_conf_log_enabled get_conf_log_enabled proc~get_kernel->proc~get_conf_log_enabled proc~get_conf_measure_iters get_conf_measure_iters proc~get_kernel->proc~get_conf_measure_iters proc~get_conf_measure_warmup_iters get_conf_measure_warmup_iters proc~get_kernel->proc~get_conf_measure_warmup_iters proc~get_conf_stream get_conf_stream proc~get_kernel->proc~get_conf_stream proc~get_kernel_args get_kernel_args proc~get_kernel->proc~get_kernel_args proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_launch_params get_kernel_launch_params proc~get_kernel->proc~get_kernel_launch_params proc~get_kernel_string get_kernel_string proc~get_kernel->proc~get_kernel_string proc~is_unpack_kernel is_unpack_kernel proc~get_kernel->proc~is_unpack_kernel proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~get_kernel->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~get_kernel->proc~push_nvtx_domain_range proc~sort_candidates_by_score sort_candidates_by_score proc~get_kernel->proc~sort_candidates_by_score proc~write_message write_message proc~get_kernel->proc~write_message proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string proc~create_nvrtc_module->interface~to_str proc~create_nvrtc_module->proc~get_conf_log_enabled proc~create_nvrtc_module->proc~get_kernel_string proc~create_nvrtc_module->proc~write_message none~check nvrtc_module%check proc~create_nvrtc_module->none~check proc~add nvrtc_module_cache%add proc~create_nvrtc_module->proc~add proc~create~3 nvrtc_module%create proc~create_nvrtc_module->proc~create~3 interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f proc~count_bank_conflicts count_bank_conflicts proc~evaluate_analytical_performance->proc~count_bank_conflicts proc~estimate_bank_conflict_ratio estimate_bank_conflict_ratio proc~evaluate_analytical_performance->proc~estimate_bank_conflict_ratio proc~estimate_coalescing estimate_coalescing proc~evaluate_analytical_performance->proc~estimate_coalescing proc~estimate_occupancy estimate_occupancy proc~evaluate_analytical_performance->proc~estimate_occupancy proc~estimate_memory_pressure estimate_memory_pressure proc~generate_candidates->proc~estimate_memory_pressure proc~estimate_optimal_padding estimate_optimal_padding proc~generate_candidates->proc~estimate_optimal_padding proc~find_valid_combination find_valid_combination proc~generate_candidates->proc~find_valid_combination interface~get_conf_internal get_conf_internal proc~get_conf_configs_to_test->interface~get_conf_internal proc~get_conf_forced_kernel_optimization->interface~get_conf_internal proc~get_conf_kernel_optimization_enabled->interface~get_conf_internal proc~get_conf_log_enabled->interface~get_conf_internal proc~get_conf_measure_iters->interface~get_conf_internal proc~get_conf_measure_warmup_iters->interface~get_conf_internal proc~get_conf_stream->fname proc~get_conf_stream->mpi_abort proc~get_conf_stream->proc~cudageterrorstring interface~cudastreamcreate cudaStreamCreate proc~get_conf_stream->interface~cudastreamcreate proc~get_kernel_instance->interface~to_str proc~get_kernel_instance->proc~get_conf_log_enabled proc~get_kernel_instance->proc~get_kernel_string proc~get_kernel_instance->proc~write_message is_null_ptr is_null_ptr proc~get_kernel_instance->is_null_ptr proc~get nvrtc_module%get proc~get_kernel_instance->proc~get interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain mpi_comm_rank mpi_comm_rank proc~write_message->mpi_comm_rank mpi_finalized mpi_finalized proc~write_message->mpi_finalized proc~get_conf_internal_int32 get_conf_internal_int32 interface~get_conf_internal->proc~get_conf_internal_int32 proc~get_conf_internal_logical get_conf_internal_logical interface~get_conf_internal->proc~get_conf_internal_logical proc~check_instance nvrtc_module%check_instance none~check->proc~check_instance proc~check_module nvrtc_module%check_module none~check->proc~check_module proc~add->interface~to_str proc~add->proc~get_conf_log_enabled proc~add->proc~write_message proc~create~9 nvrtc_module_cache%create proc~add->proc~create~9 proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c proc~create~3->fname proc~create~3->mpi_abort proc~create~3->proc~cudageterrorstring proc~create~3->proc~get_conf_log_enabled proc~create~3->proc~pop_nvtx_domain_range proc~create~3->proc~push_nvtx_domain_range proc~create~3->proc~write_message interface~mem_free_host mem_free_host proc~create~3->interface~mem_free_host proc~compile_program compile_program proc~create~3->proc~compile_program proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~get_code get_code proc~create~3->proc~get_code proc~mem_alloc_host mem_alloc_host proc~create~3->proc~mem_alloc_host proc~nvrtcgeterrorstring nvrtcGetErrorString proc~create~3->proc~nvrtcgeterrorstring proc~estimate_bank_conflict_ratio->proc~count_bank_conflicts proc~estimate_optimal_padding->proc~count_bank_conflicts proc~get->fname proc~get->mpi_abort proc~get->proc~cudageterrorstring proc~get->none~check proc~get_mangled_name get_mangled_name proc~get->proc~get_mangled_name interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr proc~check_instance->none~check proc~compile_program->fname proc~compile_program->interface~to_str proc~compile_program->mpi_abort proc~compile_program->proc~astring_f2c proc~compile_program->proc~string_c2f proc~compile_program->proc~mem_alloc_host proc~compile_program->proc~nvrtcgeterrorstring proc~destroy_strings destroy_strings proc~compile_program->proc~destroy_strings proc~set_name_expression set_name_expression proc~compile_program->proc~set_name_expression proc~destroy~3->fname proc~destroy~3->mpi_abort proc~destroy~3->proc~cudageterrorstring proc~destroy~3->is_null_ptr proc~destroy~3->proc~nvrtcgeterrorstring proc~get_code->proc~is_unpack_kernel proc~add_line codegen_t%add_line proc~get_code->proc~add_line proc~get_mangled_name->fname proc~get_mangled_name->mpi_abort proc~get_mangled_name->proc~nvrtcgeterrorstring proc~get_name_expression get_name_expression proc~get_mangled_name->proc~get_name_expression interface~aligned_alloc aligned_alloc proc~mem_alloc_host->interface~aligned_alloc proc~nvrtcgeterrorstring->proc~string_c2f proc~destroy_string string%destroy_string proc~destroy_strings->proc~destroy_string proc~get_name_expression->interface~to_str proc~get_name_expression->proc~astring_f2c proc~set_name_expression->fname proc~set_name_expression->mpi_abort proc~set_name_expression->proc~nvrtcgeterrorstring proc~set_name_expression->proc~get_name_expression Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_kernel~~CalledByGraph proc~get_kernel get_kernel proc~create~11 kernel_device%create proc~create~11->proc~get_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_kernel.html"},{"title":"cudaGetErrorString – dtFFT","text":"public  function cudaGetErrorString(errcode) result(string) Helper function that returns a string describing the given nvrtcResult code\nIf the error code is not recognized, “unrecognized error code” is returned. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: errcode CUDA Runtime Compilation API result code. Return Value character(len=:), allocatable Result string Calls proc~~cudageterrorstring~~CallsGraph proc~cudageterrorstring cudaGetErrorString interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cudageterrorstring~~CalledByGraph proc~cudageterrorstring cudaGetErrorString proc~alloc_mem alloc_mem proc~alloc_mem->proc~cudageterrorstring proc~create abstract_backend%create proc~create->proc~cudageterrorstring proc~create_private dtfft_plan_t%create_private proc~create_private->proc~cudageterrorstring proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~create~11 kernel_device%create proc~create~11->proc~cudageterrorstring proc~get_kernel get_kernel proc~create~11->proc~get_kernel proc~create~3 nvrtc_module%create proc~create~3->proc~cudageterrorstring proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~destroy abstract_backend%destroy proc~destroy->proc~cudageterrorstring proc~destroy_stream destroy_stream proc~destroy_stream->proc~cudageterrorstring proc~destroy~3->proc~cudageterrorstring proc~execute abstract_backend%execute proc~execute->proc~cudageterrorstring proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~cudageterrorstring proc~execute~12 backend_cufftmp%execute proc~execute~12->proc~cudageterrorstring proc~execute~9 kernel_device%execute proc~execute~9->proc~cudageterrorstring proc~get nvrtc_module%get proc~get->proc~cudageterrorstring proc~get_conf_stream->proc~cudageterrorstring proc~get_kernel->proc~cudageterrorstring proc~get_kernel->proc~get_conf_stream proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~cudageterrorstring proc~run_autotune_backend->proc~alloc_mem proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_nvrtc_module->proc~create~3 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~10 vkfft_executor%create proc~create~10->proc~get_conf_stream proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_stream proc~create~6->proc~run_autotune_backend proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create~8 cufft_executor%create proc~create~8->proc~get_conf_stream proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~destroy_stream proc~get_kernel_instance->proc~get proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cudageterrorstring.html"},{"title":"cudaStreamQuery – dtFFT","text":"interface Called by interface~~cudastreamquery~~CalledByGraph interface~cudastreamquery cudaStreamQuery proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->interface~cudastreamquery proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamQuery(stream) result(cudaError_t) bind(C, name=\"cudaStreamQuery\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if all operations in stream have completed,\nor cudaErrorNotReady if not. Description Queries an asynchronous stream for completion status.","tags":"","loc":"interface/cudastreamquery.html"},{"title":"cudaStreamCreate – dtFFT","text":"interface Called by interface~~cudastreamcreate~~CalledByGraph interface~cudastreamcreate cudaStreamCreate proc~create abstract_backend%create proc~create->interface~cudastreamcreate proc~get_conf_stream get_conf_stream proc~get_conf_stream->interface~cudastreamcreate proc~create_private dtfft_plan_t%create_private proc~create_private->proc~get_conf_stream proc~create~10 vkfft_executor%create proc~create~10->proc~get_conf_stream proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_stream proc~create~8 cufft_executor%create proc~create~8->proc~get_conf_stream proc~get_kernel get_kernel proc~get_kernel->proc~get_conf_stream proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamCreate(stream) result(cudaError_t) bind(C, name=\"cudaStreamCreate\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ) :: stream Pointer to the created stream Return Value integer(kind=c_int) Returns cudaSuccess if the stream was created successfully,\nor an error code if there was an issue. Description Creates an asynchronous stream.","tags":"","loc":"interface/cudastreamcreate.html"},{"title":"cudaStreamDestroy – dtFFT","text":"interface Called by interface~~cudastreamdestroy~~CalledByGraph interface~cudastreamdestroy cudaStreamDestroy proc~destroy abstract_backend%destroy proc~destroy->interface~cudastreamdestroy proc~destroy_stream destroy_stream proc~destroy_stream->interface~cudastreamdestroy proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~destroy_stream proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamDestroy(stream) result(cudaError_t) bind(C, name=\"cudaStreamDestroy\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the stream was destroyed successfully,\nor an error code if there was an issue. Description Destroys an asynchronous stream.","tags":"","loc":"interface/cudastreamdestroy.html"},{"title":"cudaStreamSynchronize – dtFFT","text":"interface Called by interface~~cudastreamsynchronize~~CalledByGraph interface~cudastreamsynchronize cudaStreamSynchronize proc~execute abstract_backend%execute proc~execute->interface~cudastreamsynchronize proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->interface~cudastreamsynchronize proc~execute~12 backend_cufftmp%execute proc~execute~12->interface~cudastreamsynchronize proc~execute~9 kernel_device%execute proc~execute~9->interface~cudastreamsynchronize proc~get_kernel get_kernel proc~get_kernel->interface~cudastreamsynchronize proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudastreamsynchronize proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamSynchronize(stream) result(cudaError_t) bind(C, name=\"cudaStreamSynchronize\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the stream tasks completed successfully,\nor an error code if there was an issue. Description Waits for stream tasks to complete.","tags":"","loc":"interface/cudastreamsynchronize.html"},{"title":"cudaMalloc – dtFFT","text":"interface Called by interface~~cudamalloc~~CalledByGraph interface~cudamalloc cudaMalloc proc~alloc_mem alloc_mem proc~alloc_mem->interface~cudamalloc proc~get_kernel get_kernel proc~get_kernel->interface~cudamalloc proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaMalloc(ptr, count) result(cudaError_t) bind(C, name=\"cudaMalloc\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr Pointer to allocated device memory integer(kind=c_size_t), value :: count Requested allocation size in bytes Return Value integer(kind=c_int) Returns cudaSuccess if memory was allocated successfully,\nor cudaErrorMemoryAllocation if the memory could not be allocated. Description Allocates memory on the device.","tags":"","loc":"interface/cudamalloc.html"},{"title":"cudaFree – dtFFT","text":"interface Called by interface~~cudafree~~CalledByGraph interface~cudafree cudaFree proc~free_mem free_mem proc~free_mem->interface~cudafree proc~get_kernel get_kernel proc~get_kernel->interface~cudafree proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~free_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaFree(ptr) result(cudaError_t) bind(C, name=\"cudaFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to memory to free Return Value integer(kind=c_int) Returns cudaSuccess if memory was freed successfully,\nor an error code if there was an issue. Description Frees memory on the device.","tags":"","loc":"interface/cudafree.html"},{"title":"cudaMemset – dtFFT","text":"interface public  function cudaMemset(ptr, val, count) result(cudaError_t) bind(C, name=\"cudaMemset\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to device memory integer(kind=c_int), value :: val Value to set integer(kind=c_size_t), value :: count Size in bytes to set Return Value integer(kind=c_int) Returns cudaSuccess if the memory was set successfully,\nor an error code if there was an issue. Description Initializes or sets device memory to a value.","tags":"","loc":"interface/cudamemset.html"},{"title":"cudaEventCreateWithFlags – dtFFT","text":"interface Called by interface~~cudaeventcreatewithflags~~CalledByGraph interface~cudaeventcreatewithflags cudaEventCreateWithFlags proc~create abstract_backend%create proc~create->interface~cudaeventcreatewithflags Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventCreateWithFlags(event, flags) result(cudaError_t) bind(C, name=\"cudaEventCreateWithFlags\") Arguments Type Intent Optional Attributes Name type( cudaEvent ) :: event Event identifier integer(kind=c_int), value :: flags Flags for event creation Return Value integer(kind=c_int) Returns cudaSuccess if the event was created successfully,\nor an error code if there was an issue. Description Creates an event with the specified flags.","tags":"","loc":"interface/cudaeventcreatewithflags.html"},{"title":"cudaEventRecord – dtFFT","text":"interface Called by interface~~cudaeventrecord~~CalledByGraph interface~cudaeventrecord cudaEventRecord proc~execute abstract_backend%execute proc~execute->interface~cudaeventrecord proc~get_kernel get_kernel proc~get_kernel->interface~cudaeventrecord proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventrecord proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventRecord(event, stream) result(cudaError_t) bind(C, name=\"cudaEventRecord\") Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was recorded successfully,\nor an error code if there was an issue. Description Records an event in a stream.","tags":"","loc":"interface/cudaeventrecord.html"},{"title":"cudaStreamWaitEvent – dtFFT","text":"interface Called by interface~~cudastreamwaitevent~~CalledByGraph interface~cudastreamwaitevent cudaStreamWaitEvent proc~execute abstract_backend%execute proc~execute->interface~cudastreamwaitevent Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaStreamWaitEvent(stream, event, flags) result(cudaError_t) bind(C, name=\"cudaStreamWaitEvent\") Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier type( cudaEvent ), value :: event Event identifier integer(kind=c_int), value :: flags Flags for the wait operation Return Value integer(kind=c_int) Returns cudaSuccess if the stream is waiting successfully,\nor an error code if there was an issue. Description Makes a stream wait on an event.","tags":"","loc":"interface/cudastreamwaitevent.html"},{"title":"cudaEventDestroy – dtFFT","text":"interface Called by interface~~cudaeventdestroy~~CalledByGraph interface~cudaeventdestroy cudaEventDestroy proc~destroy abstract_backend%destroy proc~destroy->interface~cudaeventdestroy proc~get_kernel get_kernel proc~get_kernel->interface~cudaeventdestroy proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventdestroy proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventDestroy(event) result(cudaError_t) bind(C, name=\"cudaEventDestroy\") Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was destroyed successfully,\nor an error code if there was an issue. Description Destroys an event.","tags":"","loc":"interface/cudaeventdestroy.html"},{"title":"cudaEventCreate – dtFFT","text":"interface Called by interface~~cudaeventcreate~~CalledByGraph interface~cudaeventcreate cudaEventCreate proc~get_kernel get_kernel proc~get_kernel->interface~cudaeventcreate proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventcreate proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventCreate(event) result(cudaError_t) bind(C, name=\"cudaEventCreate\") Arguments Type Intent Optional Attributes Name type( cudaEvent ) :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was created successfully,\nor an error code if there was an issue. Description Creates an event.","tags":"","loc":"interface/cudaeventcreate.html"},{"title":"cudaEventSynchronize – dtFFT","text":"interface Called by interface~~cudaeventsynchronize~~CalledByGraph interface~cudaeventsynchronize cudaEventSynchronize proc~get_kernel get_kernel proc~get_kernel->interface~cudaeventsynchronize proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventsynchronize proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventSynchronize(event) result(cudaError_t) bind(C, name=\"cudaEventSynchronize\") Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event completed successfully,\nor an error code if there was an issue. Description Waits for an event to complete.","tags":"","loc":"interface/cudaeventsynchronize.html"},{"title":"cudaEventElapsedTime – dtFFT","text":"interface Called by interface~~cudaeventelapsedtime~~CalledByGraph interface~cudaeventelapsedtime cudaEventElapsedTime proc~get_kernel get_kernel proc~get_kernel->interface~cudaeventelapsedtime proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->interface~cudaeventelapsedtime proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaEventElapsedTime(time, start, end) result(cudaError_t) bind(C, name=\"cudaEventElapsedTime\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: time Elapsed time in milliseconds type( cudaEvent ), value :: start Starting event type( cudaEvent ), value :: end Ending event Return Value integer(kind=c_int) Returns cudaSuccess if the elapsed time was computed successfully,\nor an error code if there was an issue. Description Computes the elapsed time between two events.","tags":"","loc":"interface/cudaeventelapsedtime.html"},{"title":"cudaMemcpyAsync – dtFFT","text":"public interface cudaMemcpyAsync Copies data asynchronously between host and device. Called by interface~~cudamemcpyasync~~CalledByGraph interface~cudamemcpyasync cudaMemcpyAsync proc~execute abstract_backend%execute proc~execute->interface~cudamemcpyasync proc~execute~9 kernel_device%execute proc~execute~9->interface~cudamemcpyasync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function cudaMemcpyAsync_ptr(dst, src, count, kdir, stream) result(cudaError_t) bind(C, name=\"cudaMemcpyAsync\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dst Destination pointer type(c_ptr), value :: src Source pointer integer(kind=c_size_t), value :: count Size in bytes to copy integer(kind=c_int), value :: kdir Direction of copy (host-to-device, device-to-host, etc.) type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the copy was initiated successfully,\nor an error code if there was an issue. private  function cudaMemcpyAsync_r32(dst, src, count, kdir, stream) result(cudaError_t) bind(C, name=\"cudaMemcpyAsync\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: dst Destination array (32-bit float) real(kind=c_float) :: src Source array (32-bit float) integer(kind=c_size_t), value :: count Number of elements to copy integer(kind=c_int), value :: kdir Direction of copy type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the copy was initiated successfully,\nor an error code if there was an issue.","tags":"","loc":"interface/cudamemcpyasync.html"},{"title":"cudaMemcpy – dtFFT","text":"public interface cudaMemcpy Copies data synchronously between host and device. Functions private  function cudaMemcpy_ptr(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dst Destination pointer type(c_ptr), value :: src Source pointer integer(kind=c_size_t), value :: count Size in bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully,\nor an error code if there was an issue. private  function cudaMemcpy_r64(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name real(kind=c_double) :: dst (*) Destination array (64-bit float) real(kind=c_double) :: src (*) Source array (64-bit float) integer(kind=c_size_t), value :: count Number of bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully,\nor an error code if there was an issue. private  function cudaMemcpy_r32(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: dst (*) Destination array (32-bit float) real(kind=c_float) :: src (*) Source array (32-bit float) integer(kind=c_size_t), value :: count Number of bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully,\nor an error code if there was an issue.","tags":"","loc":"interface/cudamemcpy.html"},{"title":"cudaGetDevice – dtFFT","text":"interface Called by interface~~cudagetdevice~~CalledByGraph interface~cudagetdevice cudaGetDevice proc~create_private dtfft_plan_t%create_private proc~create_private->interface~cudagetdevice proc~create~11 kernel_device%create proc~create~11->interface~cudagetdevice proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaGetDevice(num) result(cudaError_t) bind(C, name=\"cudaGetDevice\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: num Device number Return Value integer(kind=c_int) Returns cudaSuccess if the device was retrieved successfully,\nor an error code if there was an issue. Description Returns the current device.","tags":"","loc":"interface/cudagetdevice.html"},{"title":"cudaGetDeviceCount – dtFFT","text":"interface Called by interface~~cudagetdevicecount~~CalledByGraph interface~cudagetdevicecount cudaGetDeviceCount proc~create_private dtfft_plan_t%create_private proc~create_private->interface~cudagetdevicecount proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaGetDeviceCount(num) result(cudaError_t) bind(C, name=\"cudaGetDeviceCount\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: num Number of devices Return Value integer(kind=c_int) Returns cudaSuccess if the device count was retrieved successfully,\nor an error code if there was an issue. Description Returns the number of available devices.","tags":"","loc":"interface/cudagetdevicecount.html"},{"title":"cudaSetDevice – dtFFT","text":"interface public  function cudaSetDevice(num) result(cudaError_t) bind(C, name=\"cudaSetDevice\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: num Device number Return Value integer(kind=c_int) Returns cudaSuccess if the device was set successfully,\nor an error code if there was an issue. Description Sets the current device.","tags":"","loc":"interface/cudasetdevice.html"},{"title":"cudaMemGetInfo – dtFFT","text":"interface Called by interface~~cudamemgetinfo~~CalledByGraph interface~cudamemgetinfo cudaMemGetInfo proc~alloc_mem alloc_mem proc~alloc_mem->interface~cudamemgetinfo proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cudaMemGetInfo(free, total) result(cudaError_t) bind(C, name=\"cudaMemGetInfo\") Arguments Type Intent Optional Attributes Name integer(kind=c_size_t) :: free Free memory in bytes integer(kind=c_size_t) :: total Total memory in bytes Return Value integer(kind=c_int) Returns cudaSuccess if the memory information was retrieved successfully,\nor an error code if there was an issue. Description Returns the amount of free and total memory on the device.","tags":"","loc":"interface/cudamemgetinfo.html"},{"title":"cudaDeviceSynchronize – dtFFT","text":"interface public  function cudaDeviceSynchronize() result(cudaError_t) bind(C, name=\"cudaDeviceSynchronize\") Arguments None Return Value integer(kind=c_int) Returns cudaSuccess if syncronization was\nor an error code if there was an issue. Description Synchronizes the device, blocking until all preceding tasks in all streams have completed.","tags":"","loc":"interface/cudadevicesynchronize.html"},{"title":"cudaGetLastError – dtFFT","text":"interface public  function cudaGetLastError() result(cudaError_t) bind(C, name=\"cudaGetLastError\") Arguments None Return Value integer(kind=c_int) Returns cudaSuccess if no error was detected\nor an error code if there was an issue. Description Returns the last error from a runtime call.","tags":"","loc":"interface/cudagetlasterror.html"},{"title":"get_device_props – dtFFT","text":"interface Called by interface~~get_device_props~~CalledByGraph interface~get_device_props get_device_props proc~create~11 kernel_device%create proc~create~11->interface~get_device_props Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine get_device_props(device, props) bind(C, name=\"get_device_props_cuda\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: device Device number type( device_props ) :: props GPU Properties Description Returns the CUDA device properties for a given device number.","tags":"","loc":"interface/get_device_props.html"},{"title":"cudaGetErrorString_c – dtFFT","text":"interface Called by interface~~cudageterrorstring_c~~CalledByGraph interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring cudaGetErrorString proc~cudageterrorstring->interface~cudageterrorstring_c proc~alloc_mem alloc_mem proc~alloc_mem->proc~cudageterrorstring proc~create abstract_backend%create proc~create->proc~cudageterrorstring proc~create_private dtfft_plan_t%create_private proc~create_private->proc~cudageterrorstring proc~get_conf_stream get_conf_stream proc~create_private->proc~get_conf_stream proc~create~11 kernel_device%create proc~create~11->proc~cudageterrorstring proc~get_kernel get_kernel proc~create~11->proc~get_kernel proc~create~3 nvrtc_module%create proc~create~3->proc~cudageterrorstring proc~destroy~3 nvrtc_module%destroy proc~create~3->proc~destroy~3 proc~destroy abstract_backend%destroy proc~destroy->proc~cudageterrorstring proc~destroy_stream destroy_stream proc~destroy_stream->proc~cudageterrorstring proc~destroy~3->proc~cudageterrorstring proc~execute abstract_backend%execute proc~execute->proc~cudageterrorstring proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~cudageterrorstring proc~execute~12 backend_cufftmp%execute proc~execute~12->proc~cudageterrorstring proc~execute~9 kernel_device%execute proc~execute~9->proc~cudageterrorstring proc~get nvrtc_module%get proc~get->proc~cudageterrorstring proc~get_conf_stream->proc~cudageterrorstring proc~get_kernel->proc~cudageterrorstring proc~get_kernel->proc~get_conf_stream proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~cudageterrorstring proc~run_autotune_backend->proc~alloc_mem proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_nvrtc_module->proc~create~3 proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create~10 vkfft_executor%create proc~create~10->proc~get_conf_stream proc~create~6 transpose_plan%create proc~create~6->proc~get_conf_stream proc~create~6->proc~run_autotune_backend proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create~8 cufft_executor%create proc~create~8->proc~get_conf_stream proc~destroy~6 dtfft_plan_t%destroy proc~destroy~6->proc~destroy_stream proc~get_kernel_instance->proc~get proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~dtfft_destroy_c dtfft_destroy_c proc~dtfft_destroy_c->proc~destroy~6 proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function cudaGetErrorString_c(errcode) result(string) bind(C, name=\"cudaGetErrorString\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: errcode Error code Return Value type(c_ptr) Pointer to the error string Description Returns the string representation of an error code.","tags":"","loc":"interface/cudageterrorstring_c.html"},{"title":"create – dtFFT","text":"private  function create(self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Type Bound abstract_executor Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) Calls proc~~create~12~~CallsGraph proc~create~12 abstract_executor%create create_private create_private proc~create~12->create_private interface~to_str to_str proc~create~12->interface~to_str is_null_ptr is_null_ptr proc~create~12->is_null_ptr proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~create~12->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~create~12->proc~push_nvtx_domain_range proc~double_to_string double_to_string interface~to_str->proc~double_to_string proc~float_to_string float_to_string interface~to_str->proc~float_to_string proc~int32_to_string int32_to_string interface~to_str->proc~int32_to_string proc~int64_to_string int64_to_string interface~to_str->proc~int64_to_string proc~int8_to_string int8_to_string interface~to_str->proc~int8_to_string interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~12.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, sign) Executes plan Type Bound abstract_executor Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform Calls proc~~execute~10~~CallsGraph proc~execute~10 abstract_executor%execute execute_private execute_private proc~execute~10->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~10->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~10->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~10.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys plan Type Bound abstract_executor Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor Calls proc~~destroy~12~~CallsGraph proc~destroy~12 abstract_executor%destroy destroy_private destroy_private proc~destroy~12->destroy_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~12.html"},{"title":"get_async_active – dtFFT","text":"private elemental function get_async_active(self) Returns if async transpose is active Type Bound transpose_handle_datatype Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(in) :: self Transpose handle Return Value logical","tags":"","loc":"proc/get_async_active~5.html"},{"title":"create_handle – dtFFT","text":"private  subroutine create_handle(self, n) Creates transposition handle Type Bound handle_t Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle integer(kind=int32), intent(in) :: n Number of datatypes to be created Calls proc~~create_handle~~CallsGraph proc~create_handle handle_t%create_handle proc~destroy_handle handle_t%destroy_handle proc~create_handle->proc~destroy_handle mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_handle~~CalledByGraph proc~create_handle handle_t%create_handle proc~create~13 transpose_handle_datatype%create proc~create~13->proc~create_handle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_handle.html"},{"title":"destroy_handle – dtFFT","text":"private  subroutine destroy_handle(self) Destroys transposition handle Type Bound handle_t Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle Calls proc~~destroy_handle~~CallsGraph proc~destroy_handle handle_t%destroy_handle mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_handle~~CalledByGraph proc~destroy_handle handle_t%destroy_handle proc~create_handle handle_t%create_handle proc~create_handle->proc~destroy_handle proc~destroy~13 transpose_handle_datatype%destroy proc~destroy~13->proc~destroy_handle proc~create~13 transpose_handle_datatype%create proc~create~13->proc~create_handle proc~create~13->proc~destroy~13 proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~destroy~13 proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->proc~autotune_transpose_id proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy_handle.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, comm, send, recv, transpose_type, base_storage, kwargs) Creates transpose_handle_datatype class Type Bound transpose_handle_datatype Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle type(MPI_Comm), intent(in) :: comm MPI Communicator type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Base storage type( create_args ), intent(in) :: kwargs Additional arguments Calls proc~~create~13~~CallsGraph proc~create~13 transpose_handle_datatype%create mpi_allgather mpi_allgather proc~create~13->mpi_allgather mpi_comm_size mpi_comm_size proc~create~13->mpi_comm_size proc~create_back_permutation create_back_permutation proc~create~13->proc~create_back_permutation proc~create_forw_permutation create_forw_permutation proc~create~13->proc~create_forw_permutation proc~create_handle handle_t%create_handle proc~create~13->proc~create_handle proc~create_transpose_2d create_transpose_2d proc~create~13->proc~create_transpose_2d proc~create_transpose_xz create_transpose_XZ proc~create~13->proc~create_transpose_xz proc~create_transpose_zx create_transpose_ZX proc~create~13->proc~create_transpose_zx proc~destroy~13 transpose_handle_datatype%destroy proc~create~13->proc~destroy~13 mpi_type_commit mpi_type_commit proc~create_back_permutation->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_back_permutation->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_back_permutation->mpi_type_create_hvector mpi_type_create_resized mpi_type_create_resized proc~create_back_permutation->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_back_permutation->mpi_type_vector proc~free_datatypes free_datatypes proc~create_back_permutation->proc~free_datatypes proc~create_forw_permutation->mpi_type_commit proc~create_forw_permutation->mpi_type_contiguous proc~create_forw_permutation->mpi_type_create_hvector proc~create_forw_permutation->mpi_type_create_resized proc~create_forw_permutation->mpi_type_vector proc~create_forw_permutation->proc~free_datatypes proc~destroy_handle handle_t%destroy_handle proc~create_handle->proc~destroy_handle proc~create_transpose_2d->mpi_type_commit proc~create_transpose_2d->mpi_type_contiguous proc~create_transpose_2d->mpi_type_create_resized proc~create_transpose_2d->mpi_type_vector proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xz->mpi_type_commit proc~create_transpose_xz->mpi_type_contiguous proc~create_transpose_xz->mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_resized proc~create_transpose_xz->mpi_type_vector proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_zx->mpi_type_commit proc~create_transpose_zx->mpi_type_contiguous proc~create_transpose_zx->mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_resized proc~create_transpose_zx->mpi_type_vector proc~create_transpose_zx->proc~free_datatypes mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy~13->proc~destroy_handle mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~13.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, kwargs, error_code) Executes transposition Type Bound transpose_handle_datatype Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Result of execution Calls proc~~execute~11~~CallsGraph proc~execute~11 transpose_handle_datatype%execute mpi_alltoall_init mpi_alltoall_init proc~execute~11->mpi_alltoall_init mpi_alltoallw_init mpi_alltoallw_init proc~execute~11->mpi_alltoallw_init mpi_comm_size mpi_comm_size proc~execute~11->mpi_comm_size mpi_startall mpi_startall proc~execute~11->mpi_startall proc~execute_end~4 transpose_handle_datatype%execute_end proc~execute~11->proc~execute_end~4 mpi_waitall mpi_waitall proc~execute_end~4->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute~11~~CalledByGraph proc~execute~11 transpose_handle_datatype%execute proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~execute~11 proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->proc~autotune_transpose_id proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~11.html"},{"title":"execute_end – dtFFT","text":"private  subroutine execute_end(self, kwargs, error_code) Ends execution of transposition Type Bound transpose_handle_datatype Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code Calls proc~~execute_end~4~~CallsGraph proc~execute_end~4 transpose_handle_datatype%execute_end mpi_waitall mpi_waitall proc~execute_end~4->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_end~4~~CalledByGraph proc~execute_end~4 transpose_handle_datatype%execute_end proc~execute~11 transpose_handle_datatype%execute proc~execute~11->proc~execute_end~4 proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~execute~11 proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->proc~autotune_transpose_id proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_end~4.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys transpose_handle_datatype class Type Bound transpose_handle_datatype Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle Calls proc~~destroy~13~~CallsGraph proc~destroy~13 transpose_handle_datatype%destroy mpi_request_free mpi_request_free proc~destroy~13->mpi_request_free proc~destroy_handle handle_t%destroy_handle proc~destroy~13->proc~destroy_handle mpi_type_free mpi_type_free proc~destroy_handle->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy~13~~CalledByGraph proc~destroy~13 transpose_handle_datatype%destroy proc~create~13 transpose_handle_datatype%create proc~create~13->proc~destroy~13 proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~destroy~13 proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->proc~autotune_transpose_id proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~13.html"},{"title":"create_transpose_2d – dtFFT","text":"private  subroutine create_transpose_2d(send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates two-dimensional transposition datatypes Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes Calls proc~~create_transpose_2d~~CallsGraph proc~create_transpose_2d create_transpose_2d mpi_type_commit mpi_type_commit proc~create_transpose_2d->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_2d->mpi_type_contiguous mpi_type_create_resized mpi_type_create_resized proc~create_transpose_2d->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_2d->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_2d->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_transpose_2d~~CalledByGraph proc~create_transpose_2d create_transpose_2d proc~create~13 transpose_handle_datatype%create proc~create~13->proc~create_transpose_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_transpose_2d.html"},{"title":"create_forw_permutation – dtFFT","text":"private  subroutine create_forw_permutation(send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates three-dimensional X –> Y and Y -> Z transposition datatypes Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes Calls proc~~create_forw_permutation~~CallsGraph proc~create_forw_permutation create_forw_permutation mpi_type_commit mpi_type_commit proc~create_forw_permutation->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_forw_permutation->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_forw_permutation->mpi_type_create_hvector mpi_type_create_resized mpi_type_create_resized proc~create_forw_permutation->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_forw_permutation->mpi_type_vector proc~free_datatypes free_datatypes proc~create_forw_permutation->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_forw_permutation~~CalledByGraph proc~create_forw_permutation create_forw_permutation proc~create~13 transpose_handle_datatype%create proc~create~13->proc~create_forw_permutation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_forw_permutation.html"},{"title":"create_back_permutation – dtFFT","text":"private  subroutine create_back_permutation(send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates three-dimensional Y –> X and Z –> Y transposition datatypes Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes Calls proc~~create_back_permutation~~CallsGraph proc~create_back_permutation create_back_permutation mpi_type_commit mpi_type_commit proc~create_back_permutation->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_back_permutation->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_back_permutation->mpi_type_create_hvector mpi_type_create_resized mpi_type_create_resized proc~create_back_permutation->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_back_permutation->mpi_type_vector proc~free_datatypes free_datatypes proc~create_back_permutation->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_back_permutation~~CalledByGraph proc~create_back_permutation create_back_permutation proc~create~13 transpose_handle_datatype%create proc~create~13->proc~create_back_permutation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_back_permutation.html"},{"title":"create_transpose_XZ – dtFFT","text":"private  subroutine create_transpose_XZ(send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates three-dimensional X –> Z transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes Calls proc~~create_transpose_xz~~CallsGraph proc~create_transpose_xz create_transpose_XZ mpi_type_commit mpi_type_commit proc~create_transpose_xz->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_xz->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_xz->mpi_type_create_hvector mpi_type_create_resized mpi_type_create_resized proc~create_transpose_xz->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_xz->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_xz->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_transpose_xz~~CalledByGraph proc~create_transpose_xz create_transpose_XZ proc~create~13 transpose_handle_datatype%create proc~create~13->proc~create_transpose_xz Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_transpose_xz.html"},{"title":"create_transpose_ZX – dtFFT","text":"private  subroutine create_transpose_ZX(send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates three-dimensional Z –> X transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes Calls proc~~create_transpose_zx~~CallsGraph proc~create_transpose_zx create_transpose_ZX mpi_type_commit mpi_type_commit proc~create_transpose_zx->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~create_transpose_zx->mpi_type_contiguous mpi_type_create_hvector mpi_type_create_hvector proc~create_transpose_zx->mpi_type_create_hvector mpi_type_create_resized mpi_type_create_resized proc~create_transpose_zx->mpi_type_create_resized mpi_type_vector mpi_type_vector proc~create_transpose_zx->mpi_type_vector proc~free_datatypes free_datatypes proc~create_transpose_zx->proc~free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_transpose_zx~~CalledByGraph proc~create_transpose_zx create_transpose_ZX proc~create~13 transpose_handle_datatype%create proc~create~13->proc~create_transpose_zx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create_transpose_zx.html"},{"title":"free_datatypes – dtFFT","text":"private  subroutine free_datatypes(t1, t2, t3, t4) Frees temporary datatypes Arguments Type Intent Optional Attributes Name type(MPI_Datatype), intent(inout), optional :: t1 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t2 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t3 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t4 Temporary datatype Calls proc~~free_datatypes~~CallsGraph proc~free_datatypes free_datatypes mpi_type_free mpi_type_free proc~free_datatypes->mpi_type_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~free_datatypes~~CalledByGraph proc~free_datatypes free_datatypes proc~create_back_permutation create_back_permutation proc~create_back_permutation->proc~free_datatypes proc~create_forw_permutation create_forw_permutation proc~create_forw_permutation->proc~free_datatypes proc~create_transpose_2d create_transpose_2d proc~create_transpose_2d->proc~free_datatypes proc~create_transpose_xz create_transpose_XZ proc~create_transpose_xz->proc~free_datatypes proc~create_transpose_zx create_transpose_ZX proc~create_transpose_zx->proc~free_datatypes proc~create~13 transpose_handle_datatype%create proc~create~13->proc~create_back_permutation proc~create~13->proc~create_forw_permutation proc~create~13->proc~create_transpose_2d proc~create~13->proc~create_transpose_xz proc~create~13->proc~create_transpose_zx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/free_datatypes.html"},{"title":"DftiErrorMessage – dtFFT","text":"public  function DftiErrorMessage(error_code) result(string) Generates an error message. Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in) :: error_code Completion status of a function. Return Value character(len=:), allocatable Error message Calls proc~~dftierrormessage~~CallsGraph proc~dftierrormessage DftiErrorMessage interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage->interface~dftierrormessage_c proc~string_c2f string_c2f proc~dftierrormessage->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dftierrormessage~~CalledByGraph proc~dftierrormessage DftiErrorMessage proc~destroy~4 mkl_executor%destroy proc~destroy~4->proc~dftierrormessage proc~execute~3 mkl_executor%execute proc~execute~3->proc~dftierrormessage proc~make_plan make_plan proc~make_plan->proc~dftierrormessage proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->proc~dftierrormessage proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->proc~dftierrormessage proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dftierrormessage.html"},{"title":"mkl_dfti_set_value – dtFFT","text":"public interface mkl_dfti_set_value Sets one particular configuration parameter with the specified configuration value. Called by interface~~mkl_dfti_set_value~~CalledByGraph interface~mkl_dfti_set_value mkl_dfti_set_value proc~execute~3 mkl_executor%execute proc~execute~3->interface~mkl_dfti_set_value proc~make_plan make_plan proc~make_plan->interface~mkl_dfti_set_value proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function mkl_dfti_set_integer(desc, param, value) result(status) bind(C) Sets one particular configuration parameter with integer value. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. integer(kind=c_int), intent(in), value :: param Configuration parameter. integer(kind=c_int), intent(in), value :: value Configuration value. Return Value integer(kind=c_long) Function completion status. private  function mkl_dfti_set_pointer(desc, param, value) result(status) bind(C) Sets one particular configuration parameter with pointer value. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. integer(kind=c_int), intent(in), value :: param Configuration parameter. integer(kind=c_long), intent(in) :: value (*) Configuration value. Return Value integer(kind=c_long) Function completion status.","tags":"","loc":"interface/mkl_dfti_set_value.html"},{"title":"mkl_dfti_create_desc – dtFFT","text":"interface Called by interface~~mkl_dfti_create_desc~~CalledByGraph interface~mkl_dfti_create_desc mkl_dfti_create_desc proc~make_plan make_plan proc~make_plan->interface~mkl_dfti_create_desc proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_create_desc(precision, domain, dim, length, desc) result(status) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: precision Precision of the transform: DFTI_SINGLE or DFTI_DOUBLE. integer(kind=c_int), intent(in), value :: domain Forward domain of the transform: DFTI_COMPLEX or DFTI_REAL. integer(kind=c_long), intent(in), value :: dim Dimension of the transform. integer(kind=c_long), intent(in) :: length (*) Length of the transform for a one-dimensional transform.\nLengths of each dimension for a multi-dimensional transform. type(c_ptr) :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status. Description Allocates the descriptor data structure and initializes it with default configuration values.","tags":"","loc":"interface/mkl_dfti_create_desc.html"},{"title":"mkl_dfti_commit_desc – dtFFT","text":"interface Called by interface~~mkl_dfti_commit_desc~~CalledByGraph interface~mkl_dfti_commit_desc mkl_dfti_commit_desc proc~execute~3 mkl_executor%execute proc~execute~3->interface~mkl_dfti_commit_desc proc~make_plan make_plan proc~make_plan->interface~mkl_dfti_commit_desc proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_commit_desc(desc) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status. Description Performs all initialization for the actual FFT computation.","tags":"","loc":"interface/mkl_dfti_commit_desc.html"},{"title":"mkl_dfti_execute – dtFFT","text":"interface Called by interface~~mkl_dfti_execute~~CalledByGraph interface~mkl_dfti_execute mkl_dfti_execute proc~execute~3 mkl_executor%execute proc~execute~3->interface~mkl_dfti_execute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_execute(desc, in, out, sign) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. type(c_ptr), value :: in Data to be transformed type(c_ptr), value :: out The transformed data integer(kind=c_int), intent(in), value :: sign Sign of transform Return Value integer(kind=c_long) Function completion status. Description Computes FFT.","tags":"","loc":"interface/mkl_dfti_execute.html"},{"title":"mkl_dfti_free_desc – dtFFT","text":"interface Called by interface~~mkl_dfti_free_desc~~CalledByGraph interface~mkl_dfti_free_desc mkl_dfti_free_desc proc~destroy~4 mkl_executor%destroy proc~destroy~4->interface~mkl_dfti_free_desc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_free_desc(desc) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status. Description Frees the memory allocated for a descriptor.","tags":"","loc":"interface/mkl_dfti_free_desc.html"},{"title":"mkl_dfti_mem_alloc – dtFFT","text":"interface Called by interface~~mkl_dfti_mem_alloc~~CalledByGraph interface~mkl_dfti_mem_alloc mkl_dfti_mem_alloc proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->interface~mkl_dfti_mem_alloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_mem_alloc(alloc_bytes, ptr) result(status) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: alloc_bytes Number of bytes to allocate. type(c_ptr) :: ptr Pointer to allocated memory. Return Value integer(kind=c_long) Function completion status. Description Allocates pointer via mkl_malloc","tags":"","loc":"interface/mkl_dfti_mem_alloc.html"},{"title":"mkl_dfti_mem_free – dtFFT","text":"interface Called by interface~~mkl_dfti_mem_free~~CalledByGraph interface~mkl_dfti_mem_free mkl_dfti_mem_free proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->interface~mkl_dfti_mem_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function mkl_dfti_mem_free(ptr) result(status) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to allocated memory. Return Value integer(kind=c_long) Function completion status. Description Frees pointer via mkl_free","tags":"","loc":"interface/mkl_dfti_mem_free.html"},{"title":"DftiErrorMessage_c – dtFFT","text":"interface Called by interface~~dftierrormessage_c~~CalledByGraph interface~dftierrormessage_c DftiErrorMessage_c proc~dftierrormessage DftiErrorMessage proc~dftierrormessage->interface~dftierrormessage_c proc~destroy~4 mkl_executor%destroy proc~destroy~4->proc~dftierrormessage proc~execute~3 mkl_executor%execute proc~execute~3->proc~dftierrormessage proc~make_plan make_plan proc~make_plan->proc~dftierrormessage proc~mem_alloc~2 mkl_executor%mem_alloc proc~mem_alloc~2->proc~dftierrormessage proc~mem_free~2 mkl_executor%mem_free proc~mem_free~2->proc~dftierrormessage proc~create~4 mkl_executor%create proc~create~4->proc~make_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function DftiErrorMessage_c(error_code) result(message) bind(C, name=\"DftiErrorMessage\") Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in), value :: error_code Completion status of a function. Return Value type(c_ptr) Pointer to message Description Generates an error message.","tags":"","loc":"interface/dftierrormessage_c.html"},{"title":"get_aux_size – dtFFT","text":"private pure function get_aux_size(self) Returns number of bytes required by aux buffer Type Bound abstract_transpose_handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(in) :: self Abstract Transpose Handle Return Value integer(kind=int64) Called by proc~~get_aux_size~4~~CalledByGraph proc~get_aux_size~4 abstract_transpose_handle%get_aux_size proc~get_aux_size_generic get_aux_size_generic proc~get_aux_size_generic->proc~get_aux_size~4 proc~alloc_and_set_aux alloc_and_set_aux proc~alloc_and_set_aux->proc~get_aux_size_generic proc~get_aux_size~2 transpose_plan%get_aux_size proc~get_aux_size~2->proc~get_aux_size_generic proc~create~6 transpose_plan%create proc~create~6->proc~alloc_and_set_aux proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_local_sizes~2->proc~get_aux_size~2 proc~run_autotune_backend->proc~alloc_and_set_aux proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes~2 proc~autotune_grid_decomposition->proc~autotune_grid proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_aux_size~4.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, send, recv, base_storage, kwargs) Creates transpose handle Type Bound abstract_transpose_handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract transpose handle type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil integer(kind=int64), intent(in) :: base_storage Base storage size type( create_args ), intent(inout) :: kwargs Additional arguments Calls proc~~create~14~~CallsGraph proc~create~14 abstract_transpose_handle%create create_private create_private proc~create~14->create_private proc~get_transpose_type get_transpose_type proc~create~14->proc~get_transpose_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~14~~CalledByGraph proc~create~14 abstract_transpose_handle%create proc~get_plan_execution_time get_plan_execution_time proc~get_plan_execution_time->proc~create~14 proc~autotune_transpose_id autotune_transpose_id proc~autotune_transpose_id->proc~get_plan_execution_time proc~run_autotune_datatypes run_autotune_datatypes proc~run_autotune_datatypes->proc~autotune_transpose_id proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~run_autotune_datatypes proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~14.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, helper, base_storage) Uses iso_fortran_env iso_c_binding proc~~create~15~~UsesGraph proc~create~15 backend_cufftmp%create iso_c_binding iso_c_binding proc~create~15->iso_c_binding iso_fortran_env iso_fortran_env proc~create~15->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Creates cuFFTMp GPU Backend Type Bound backend_cufftmp Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element Calls proc~~create~15~~CallsGraph proc~create~15 backend_cufftmp%create fname fname proc~create~15->fname interface~comm_f2c Comm_f2c proc~create~15->interface~comm_f2c interface~cufftmpattachreshapecomm cufftMpAttachReshapeComm proc~create~15->interface~cufftmpattachreshapecomm interface~cufftmpcreatereshape cufftMpCreateReshape proc~create~15->interface~cufftmpcreatereshape interface~cufftmpgetreshapesize cufftMpGetReshapeSize proc~create~15->interface~cufftmpgetreshapesize interface~cufftmpmakereshape cufftMpMakeReshape proc~create~15->interface~cufftmpmakereshape mpi_abort mpi_abort proc~create~15->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~create~15->proc~cufftgeterrorstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~15.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, stream, aux, exec_type, error_code) Uses iso_fortran_env iso_c_binding proc~~execute~12~~UsesGraph proc~execute~12 backend_cufftmp%execute iso_c_binding iso_c_binding proc~execute~12->iso_c_binding iso_fortran_env iso_fortran_env proc~execute~12->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Executes cuFFTMp GPU Backend Type Bound backend_cufftmp Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code Calls proc~~execute~12~~CallsGraph proc~execute~12 backend_cufftmp%execute fname fname proc~execute~12->fname interface~cudastreamsynchronize cudaStreamSynchronize proc~execute~12->interface~cudastreamsynchronize interface~cufftmpexecreshapeasync cufftMpExecReshapeAsync proc~execute~12->interface~cufftmpexecreshapeasync mpi_abort mpi_abort proc~execute~12->mpi_abort mpi_barrier mpi_barrier proc~execute~12->mpi_barrier proc~cudageterrorstring cudaGetErrorString proc~execute~12->proc~cudageterrorstring proc~cufftgeterrorstring cufftGetErrorString proc~execute~12->proc~cufftgeterrorstring interface~cudageterrorstring_c cudaGetErrorString_c proc~cudageterrorstring->interface~cudageterrorstring_c proc~string_c2f string_c2f proc~cudageterrorstring->proc~string_c2f interface~is_null_ptr is_null_ptr proc~string_c2f->interface~is_null_ptr interface~is_null_ptr->interface~is_null_ptr proc~is_null_funptr is_null_funptr interface~is_null_ptr->proc~is_null_funptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~12.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Uses iso_fortran_env iso_c_binding proc~~destroy~14~~UsesGraph proc~destroy~14 backend_cufftmp%destroy iso_c_binding iso_c_binding proc~destroy~14->iso_c_binding iso_fortran_env iso_fortran_env proc~destroy~14->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Destroys cuFFTMp GPU Backend Type Bound backend_cufftmp Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend Calls proc~~destroy~14~~CallsGraph proc~destroy~14 backend_cufftmp%destroy fname fname proc~destroy~14->fname interface~cufftmpdestroyreshape cufftMpDestroyReshape proc~destroy~14->interface~cufftmpdestroyreshape mpi_abort mpi_abort proc~destroy~14->mpi_abort proc~cufftgeterrorstring cufftGetErrorString proc~destroy~14->proc~cufftgeterrorstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~14.html"},{"title":"fftw_plan_many_dft – dtFFT","text":"interface public  function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2C plan, double precision.","tags":"","loc":"interface/fftw_plan_many_dft.html"},{"title":"fftwf_plan_many_dft – dtFFT","text":"interface public  function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2C plan, single precision.","tags":"","loc":"interface/fftwf_plan_many_dft.html"},{"title":"fftw_plan_many_dft_r2c – dtFFT","text":"interface public  function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2C plan, double precision.","tags":"","loc":"interface/fftw_plan_many_dft_r2c.html"},{"title":"fftwf_plan_many_dft_r2c – dtFFT","text":"interface public  function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2C plan, single precision.","tags":"","loc":"interface/fftwf_plan_many_dft_r2c.html"},{"title":"fftw_plan_many_dft_c2r – dtFFT","text":"interface public  function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2R plan, double precision.","tags":"","loc":"interface/fftw_plan_many_dft_c2r.html"},{"title":"fftwf_plan_many_dft_c2r – dtFFT","text":"interface public  function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates C2R plan, single precision.","tags":"","loc":"interface/fftwf_plan_many_dft_c2r.html"},{"title":"fftw_plan_many_r2r – dtFFT","text":"interface public  function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kind (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2R plan, double precision.","tags":"","loc":"interface/fftw_plan_many_r2r.html"},{"title":"fftwf_plan_many_r2r – dtFFT","text":"interface public  function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kind (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) Description Creates R2R plan, single precision.","tags":"","loc":"interface/fftwf_plan_many_r2r.html"},{"title":"fftw_execute_dft – dtFFT","text":"interface public  subroutine fftw_execute_dft(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes C2C plan, double precision.","tags":"","loc":"interface/fftw_execute_dft.html"},{"title":"fftwf_execute_dft – dtFFT","text":"interface public  subroutine fftwf_execute_dft(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes C2C plan, single precision.","tags":"","loc":"interface/fftwf_execute_dft.html"},{"title":"fftw_execute_dft_r2c – dtFFT","text":"interface public  subroutine fftw_execute_dft_r2c(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes R2C plan, double precision.","tags":"","loc":"interface/fftw_execute_dft_r2c.html"},{"title":"fftwf_execute_dft_r2c – dtFFT","text":"interface public  subroutine fftwf_execute_dft_r2c(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes R2C plan, single precision.","tags":"","loc":"interface/fftwf_execute_dft_r2c.html"},{"title":"fftw_execute_dft_c2r – dtFFT","text":"interface public  subroutine fftw_execute_dft_c2r(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes C2R plan, double precision.","tags":"","loc":"interface/fftw_execute_dft_c2r.html"},{"title":"fftwf_execute_dft_c2r – dtFFT","text":"interface public  subroutine fftwf_execute_dft_c2r(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes C2R plan, single precision.","tags":"","loc":"interface/fftwf_execute_dft_c2r.html"},{"title":"fftw_execute_r2r – dtFFT","text":"interface public  subroutine fftw_execute_r2r(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes R2R plan, double precision.","tags":"","loc":"interface/fftw_execute_r2r.html"},{"title":"fftwf_execute_r2r – dtFFT","text":"interface public  subroutine fftwf_execute_r2r(plan, in, out) bind(C) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out Description Executes R2R plan, single precision.","tags":"","loc":"interface/fftwf_execute_r2r.html"},{"title":"is_valid_execute_type – dtFFT","text":"public pure elemental function is_valid_execute_type(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: param Return Value logical","tags":"","loc":"proc/is_valid_execute_type.html"},{"title":"is_valid_transpose_type – dtFFT","text":"public pure elemental function is_valid_transpose_type(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: param Return Value logical","tags":"","loc":"proc/is_valid_transpose_type.html"},{"title":"is_valid_executor – dtFFT","text":"public pure elemental function is_valid_executor(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_executor~~CalledByGraph proc~is_valid_executor is_valid_executor proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_executor proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_executor.html"},{"title":"is_valid_effort – dtFFT","text":"public pure elemental function is_valid_effort(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_effort~~CalledByGraph proc~is_valid_effort is_valid_effort proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_effort proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_effort.html"},{"title":"is_valid_precision – dtFFT","text":"public pure elemental function is_valid_precision(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_precision~~CalledByGraph proc~is_valid_precision is_valid_precision proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_precision proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_precision.html"},{"title":"is_valid_r2r_kind – dtFFT","text":"public pure elemental function is_valid_r2r_kind(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_r2r_kind~~CalledByGraph proc~is_valid_r2r_kind is_valid_r2r_kind proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_r2r_kind proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_r2r_kind.html"},{"title":"is_valid_dimension – dtFFT","text":"public pure elemental function is_valid_dimension(param) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: param Return Value logical Called by proc~~is_valid_dimension~~CalledByGraph proc~is_valid_dimension is_valid_dimension proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_dimension proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_dimension.html"},{"title":"is_valid_comm_type – dtFFT","text":"public pure elemental function is_valid_comm_type(param) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: param Return Value logical Called by proc~~is_valid_comm_type~~CalledByGraph proc~is_valid_comm_type is_valid_comm_type proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_valid_comm_type proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_comm_type.html"},{"title":"dtfft_get_precision_string – dtFFT","text":"public  function dtfft_get_precision_string(precision) result(string) Gets the string description of a precision Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: precision Precision type Return Value character(len=:), allocatable Precision string Called by proc~~dtfft_get_precision_string~~CalledByGraph proc~dtfft_get_precision_string dtfft_get_precision_string proc~dtfft_get_precision_string_c dtfft_get_precision_string_c proc~dtfft_get_precision_string_c->proc~dtfft_get_precision_string proc~report dtfft_plan_t%report proc~report->proc~dtfft_get_precision_string proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_precision_string.html"},{"title":"dtfft_get_executor_string – dtFFT","text":"public  function dtfft_get_executor_string(executor) result(string) Gets the string description of an executor Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: executor Executor type Return Value character(len=:), allocatable Executor string Called by proc~~dtfft_get_executor_string~~CalledByGraph proc~dtfft_get_executor_string dtfft_get_executor_string proc~dtfft_get_executor_string_c dtfft_get_executor_string_c proc~dtfft_get_executor_string_c->proc~dtfft_get_executor_string proc~report dtfft_plan_t%report proc~report->proc~dtfft_get_executor_string proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_executor_string.html"},{"title":"dtfft_get_backend_string – dtFFT","text":"public  function dtfft_get_backend_string(backend) result(string) Gets the string description of a GPU backend Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: backend GPU backend Return Value character(len=:), allocatable Backend string Called by proc~~dtfft_get_backend_string~~CalledByGraph proc~dtfft_get_backend_string dtfft_get_backend_string proc~alloc_mem alloc_mem proc~alloc_mem->proc~dtfft_get_backend_string proc~create~6 transpose_plan%create proc~create~6->proc~dtfft_get_backend_string proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~dtfft_get_backend_string_c dtfft_get_backend_string_c proc~dtfft_get_backend_string_c->proc~dtfft_get_backend_string proc~report dtfft_plan_t%report proc~report->proc~dtfft_get_backend_string proc~run_autotune_backend->proc~dtfft_get_backend_string proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~dtfft_report_c dtfft_report_c proc~dtfft_report_c->proc~report proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_backend_string.html"},{"title":"is_backend_pipelined – dtFFT","text":"public pure elemental function is_backend_pipelined(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_pipelined~~CalledByGraph proc~is_backend_pipelined is_backend_pipelined proc~create abstract_backend%create proc~create->proc~is_backend_pipelined proc~create~7 transpose_handle_generic%create proc~create~7->proc~is_backend_pipelined proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~is_backend_pipelined proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_pipelined.html"},{"title":"is_backend_mpi – dtFFT","text":"public pure elemental function is_backend_mpi(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_mpi~~CalledByGraph proc~is_backend_mpi is_backend_mpi proc~create abstract_backend%create proc~create->proc~is_backend_mpi proc~create_mpi backend_mpi%create_mpi proc~create_mpi->proc~is_backend_mpi proc~create~7 transpose_handle_generic%create proc~create~7->proc~is_backend_mpi proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~is_backend_mpi proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~autotune_grid_decomposition->proc~autotune_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_mpi.html"},{"title":"is_valid_backend – dtFFT","text":"public pure elemental function is_valid_backend(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_backend~~CalledByGraph proc~is_valid_backend is_valid_backend proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~is_valid_backend proc~init_internal init_internal proc~dtfft_set_config->proc~init_internal proc~init_environment init_environment proc~init_environment->proc~is_valid_backend proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config proc~init_internal->proc~init_environment proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~init_internal proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_backend.html"},{"title":"is_backend_nccl – dtFFT","text":"public pure elemental function is_backend_nccl(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_nccl~~CalledByGraph proc~is_backend_nccl is_backend_nccl proc~alloc_mem alloc_mem proc~alloc_mem->proc~is_backend_nccl proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_backend_nccl proc~create_nccl backend_nccl%create_nccl proc~create_nccl->proc~is_backend_nccl proc~create~6 transpose_plan%create proc~create~6->proc~is_backend_nccl proc~run_autotune_backend run_autotune_backend proc~create~6->proc~run_autotune_backend proc~alloc_and_set_aux alloc_and_set_aux proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~create~7 transpose_handle_generic%create proc~create~7->proc~is_backend_nccl proc~free_mem free_mem proc~free_mem->proc~is_backend_nccl proc~run_autotune_backend->proc~is_backend_nccl proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_nccl.html"},{"title":"is_backend_cufftmp – dtFFT","text":"public pure elemental function is_backend_cufftmp(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_cufftmp~~CalledByGraph proc~is_backend_cufftmp is_backend_cufftmp proc~create~7 transpose_handle_generic%create proc~create~7->proc~is_backend_cufftmp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_cufftmp.html"},{"title":"is_backend_nvshmem – dtFFT","text":"public pure elemental function is_backend_nvshmem(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical Called by proc~~is_backend_nvshmem~~CalledByGraph proc~is_backend_nvshmem is_backend_nvshmem proc~alloc_mem alloc_mem proc~alloc_mem->proc~is_backend_nvshmem proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_backend_nvshmem proc~check_device_pointers check_device_pointers proc~check_device_pointers->proc~is_backend_nvshmem proc~free_mem free_mem proc~free_mem->proc~is_backend_nvshmem proc~get_local_sizes~2 dtfft_plan_t%get_local_sizes proc~get_local_sizes~2->proc~is_backend_nvshmem proc~run_autotune_backend run_autotune_backend proc~run_autotune_backend->proc~is_backend_nvshmem proc~run_autotune_backend->proc~alloc_mem proc~run_autotune_backend->proc~free_mem proc~alloc_and_set_aux alloc_and_set_aux proc~run_autotune_backend->proc~alloc_and_set_aux proc~alloc_and_set_aux->proc~alloc_mem proc~autotune_grid autotune_grid proc~autotune_grid->proc~run_autotune_backend proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create~6 transpose_plan%create proc~create~6->proc~run_autotune_backend proc~create~6->proc~alloc_and_set_aux proc~autotune_grid_decomposition autotune_grid_decomposition proc~create~6->proc~autotune_grid_decomposition proc~dtfft_get_local_sizes_c dtfft_get_local_sizes_c proc~dtfft_get_local_sizes_c->proc~get_local_sizes~2 proc~get_alloc_size dtfft_plan_t%get_alloc_size proc~get_alloc_size->proc~get_local_sizes~2 proc~mem_alloc~3 transpose_plan%mem_alloc proc~mem_alloc~3->proc~alloc_mem proc~mem_free~3 transpose_plan%mem_free proc~mem_free~3->proc~free_mem proc~autotune_grid_decomposition->proc~autotune_grid proc~check_aux dtfft_plan_t%check_aux proc~check_aux->proc~get_alloc_size proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~destroy~7 transpose_plan%destroy proc~destroy~7->proc~mem_free~3 proc~dtfft_get_alloc_size_c dtfft_get_alloc_size_c proc~dtfft_get_alloc_size_c->proc~get_alloc_size proc~get_alloc_bytes dtfft_plan_t%get_alloc_bytes proc~get_alloc_bytes->proc~get_alloc_size proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~dtfft_get_alloc_bytes_c dtfft_get_alloc_bytes_c proc~dtfft_get_alloc_bytes_c->proc~get_alloc_bytes proc~execute_ptr dtfft_plan_t%execute_ptr proc~execute_ptr->proc~check_aux proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal proc~dtfft_execute_c dtfft_execute_c proc~dtfft_execute_c->proc~execute_ptr proc~execute~4 dtfft_plan_t%execute proc~execute~4->proc~execute_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_backend_nvshmem.html"},{"title":"is_host_executor – dtFFT","text":"public pure elemental function is_host_executor(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical Called by proc~~is_host_executor~~CalledByGraph proc~is_host_executor is_host_executor proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_host_executor proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_host_executor.html"},{"title":"is_cuda_executor – dtFFT","text":"public pure elemental function is_cuda_executor(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical Called by proc~~is_cuda_executor~~CalledByGraph proc~is_cuda_executor is_cuda_executor proc~check_create_args dtfft_plan_t%check_create_args proc~check_create_args->proc~is_cuda_executor proc~create_private dtfft_plan_t%create_private proc~create_private->proc~check_create_args proc~create_c2c_core dtfft_core_c2c%create_c2c_core proc~create_c2c_core->proc~create_private proc~create_r2r_internal dtfft_plan_r2r_t%create_r2r_internal proc~create_r2r_internal->proc~create_private proc~create_c2c_internal dtfft_plan_c2c_t%create_c2c_internal proc~create_c2c_internal->proc~create_c2c_core proc~create_r2c_internal dtfft_plan_r2c_t%create_r2c_internal proc~create_r2c_internal->proc~create_c2c_core proc~create_r2r dtfft_plan_r2r_t%create_r2r proc~create_r2r->proc~create_r2r_internal proc~create_r2r_pencil dtfft_plan_r2r_t%create_r2r_pencil proc~create_r2r_pencil->proc~create_r2r_internal proc~create_c2c dtfft_plan_c2c_t%create_c2c proc~create_c2c->proc~create_c2c_internal proc~create_c2c_pencil dtfft_plan_c2c_t%create_c2c_pencil proc~create_c2c_pencil->proc~create_c2c_internal proc~create_r2c dtfft_plan_r2c_t%create_r2c proc~create_r2c->proc~create_r2c_internal proc~create_r2c_pencil dtfft_plan_r2c_t%create_r2c_pencil proc~create_r2c_pencil->proc~create_r2c_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_cuda_executor.html"},{"title":"is_valid_platform – dtFFT","text":"public pure elemental function is_valid_platform(param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: param Return Value logical Called by proc~~is_valid_platform~~CalledByGraph proc~is_valid_platform is_valid_platform proc~dtfft_set_config dtfft_set_config proc~dtfft_set_config->proc~is_valid_platform proc~dtfft_set_config_c dtfft_set_config_c proc~dtfft_set_config_c->proc~dtfft_set_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_valid_platform.html"},{"title":"dtfft_get_cuda_stream – dtFFT","text":"public  function dtfft_get_cuda_stream(stream) result(cuda_stream) Returns the CUDA stream from dtfft_stream_t Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), intent(in) :: stream dtfft stream Return Value integer(kind=int64) CUDA stream Called by proc~~dtfft_get_cuda_stream~~CalledByGraph proc~dtfft_get_cuda_stream dtfft_get_cuda_stream proc~get_stream_int64 dtfft_plan_t%get_stream_int64 proc~get_stream_int64->proc~dtfft_get_cuda_stream none~get_stream dtfft_plan_t%get_stream proc~get_stream_int64->none~get_stream none~get_stream->proc~get_stream_int64 proc~dtfft_get_stream_c dtfft_get_stream_c proc~dtfft_get_stream_c->none~get_stream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_cuda_stream.html"},{"title":"execute_type_eq – dtFFT","text":"private pure elemental function execute_type_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical Called by proc~~execute_type_eq~~CalledByGraph proc~execute_type_eq execute_type_eq interface~operator(==) operator(==) interface~operator(==)->proc~execute_type_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_type_eq.html"},{"title":"transpose_type_eq – dtFFT","text":"private pure elemental function transpose_type_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical Called by proc~~transpose_type_eq~~CalledByGraph proc~transpose_type_eq transpose_type_eq interface~operator(==) operator(==) interface~operator(==)->proc~transpose_type_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_type_eq.html"},{"title":"executor_eq – dtFFT","text":"private pure elemental function executor_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical Called by proc~~executor_eq~~CalledByGraph proc~executor_eq executor_eq interface~operator(==) operator(==) interface~operator(==)->proc~executor_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/executor_eq.html"},{"title":"effort_eq – dtFFT","text":"private pure elemental function effort_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical Called by proc~~effort_eq~~CalledByGraph proc~effort_eq effort_eq interface~operator(==) operator(==) interface~operator(==)->proc~effort_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/effort_eq.html"},{"title":"precision_eq – dtFFT","text":"private pure elemental function precision_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical Called by proc~~precision_eq~~CalledByGraph proc~precision_eq precision_eq interface~operator(==) operator(==) interface~operator(==)->proc~precision_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/precision_eq.html"},{"title":"r2r_kind_eq – dtFFT","text":"private pure elemental function r2r_kind_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical Called by proc~~r2r_kind_eq~~CalledByGraph proc~r2r_kind_eq r2r_kind_eq interface~operator(==) operator(==) interface~operator(==)->proc~r2r_kind_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/r2r_kind_eq.html"},{"title":"platform_eq – dtFFT","text":"private pure elemental function platform_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical Called by proc~~platform_eq~~CalledByGraph proc~platform_eq platform_eq interface~operator(==) operator(==) interface~operator(==)->proc~platform_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/platform_eq.html"},{"title":"exec_eq – dtFFT","text":"private pure elemental function exec_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( async_exec_t ), intent(in) :: left type( async_exec_t ), intent(in) :: right Return Value logical Called by proc~~exec_eq~~CalledByGraph proc~exec_eq exec_eq interface~operator(==) operator(==) interface~operator(==)->proc~exec_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/exec_eq.html"},{"title":"execute_type_ne – dtFFT","text":"private pure elemental function execute_type_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical Called by proc~~execute_type_ne~~CalledByGraph proc~execute_type_ne execute_type_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~execute_type_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute_type_ne.html"},{"title":"transpose_type_ne – dtFFT","text":"private pure elemental function transpose_type_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical Called by proc~~transpose_type_ne~~CalledByGraph proc~transpose_type_ne transpose_type_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~transpose_type_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/transpose_type_ne.html"},{"title":"executor_ne – dtFFT","text":"private pure elemental function executor_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical Called by proc~~executor_ne~~CalledByGraph proc~executor_ne executor_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~executor_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/executor_ne.html"},{"title":"effort_ne – dtFFT","text":"private pure elemental function effort_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical Called by proc~~effort_ne~~CalledByGraph proc~effort_ne effort_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~effort_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/effort_ne.html"},{"title":"precision_ne – dtFFT","text":"private pure elemental function precision_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical Called by proc~~precision_ne~~CalledByGraph proc~precision_ne precision_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~precision_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/precision_ne.html"},{"title":"r2r_kind_ne – dtFFT","text":"private pure elemental function r2r_kind_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical Called by proc~~r2r_kind_ne~~CalledByGraph proc~r2r_kind_ne r2r_kind_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~r2r_kind_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/r2r_kind_ne.html"},{"title":"platform_ne – dtFFT","text":"private pure elemental function platform_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical Called by proc~~platform_ne~~CalledByGraph proc~platform_ne platform_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~platform_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/platform_ne.html"},{"title":"dtfft_get_version_current – dtFFT","text":"private  function dtfft_get_version_current() bind(C) Returns the current version code Arguments None Return Value integer(kind=c_int32_t) Called by proc~~dtfft_get_version_current~~CalledByGraph proc~dtfft_get_version_current dtfft_get_version_current interface~dtfft_get_version dtfft_get_version interface~dtfft_get_version->proc~dtfft_get_version_current Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_version_current.html"},{"title":"dtfft_get_version_required – dtFFT","text":"private  function dtfft_get_version_required(major, minor, patch) Returns the version code required by the user Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: major Major version integer(kind=int32), intent(in) :: minor Minor version integer(kind=int32), intent(in) :: patch Patch version Return Value integer(kind=int32) Called by proc~~dtfft_get_version_required~~CalledByGraph proc~dtfft_get_version_required dtfft_get_version_required interface~dtfft_get_version dtfft_get_version interface~dtfft_get_version->proc~dtfft_get_version_required Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dtfft_get_version_required.html"},{"title":"gpu_backend_eq – dtFFT","text":"private pure elemental function gpu_backend_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical Called by proc~~gpu_backend_eq~~CalledByGraph proc~gpu_backend_eq gpu_backend_eq interface~operator(==) operator(==) interface~operator(==)->proc~gpu_backend_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/gpu_backend_eq.html"},{"title":"gpu_backend_ne – dtFFT","text":"private pure elemental function gpu_backend_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical Called by proc~~gpu_backend_ne~~CalledByGraph proc~gpu_backend_ne gpu_backend_ne interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~gpu_backend_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/gpu_backend_ne.html"},{"title":"stream_from_int64 – dtFFT","text":"private  function stream_from_int64(cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream Called by proc~~stream_from_int64~~CalledByGraph proc~stream_from_int64 stream_from_int64 interface~dtfft_stream_t dtfft_stream_t interface~dtfft_stream_t->proc~stream_from_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/stream_from_int64.html"},{"title":"dtfft_get_version – dtFFT","text":"public interface dtfft_get_version Get dtFFT version Calls interface~~dtfft_get_version~~CallsGraph interface~dtfft_get_version dtfft_get_version proc~dtfft_get_version_current dtfft_get_version_current interface~dtfft_get_version->proc~dtfft_get_version_current proc~dtfft_get_version_required dtfft_get_version_required interface~dtfft_get_version->proc~dtfft_get_version_required Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function dtfft_get_version_current () bind(C) Returns the current version code Arguments None Return Value integer(kind=c_int32_t) private  function dtfft_get_version_required (major, minor, patch) Returns the version code required by the user Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: major Major version integer(kind=int32), intent(in) :: minor Minor version integer(kind=int32), intent(in) :: patch Patch version Return Value integer(kind=int32)","tags":"","loc":"interface/dtfft_get_version.html"},{"title":"operator(==) – dtFFT","text":"public interface operator(==) Calls interface~~operator(==)~~CallsGraph interface~operator(==) operator(==) proc~effort_eq effort_eq interface~operator(==)->proc~effort_eq proc~exec_eq exec_eq interface~operator(==)->proc~exec_eq proc~execute_type_eq execute_type_eq interface~operator(==)->proc~execute_type_eq proc~executor_eq executor_eq interface~operator(==)->proc~executor_eq proc~gpu_backend_eq gpu_backend_eq interface~operator(==)->proc~gpu_backend_eq proc~platform_eq platform_eq interface~operator(==)->proc~platform_eq proc~precision_eq precision_eq interface~operator(==)->proc~precision_eq proc~r2r_kind_eq r2r_kind_eq interface~operator(==)->proc~r2r_kind_eq proc~transpose_type_eq transpose_type_eq interface~operator(==)->proc~transpose_type_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure elemental function execute_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function exec_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( async_exec_t ), intent(in) :: left type( async_exec_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical","tags":"","loc":"interface/operator(==).html"},{"title":"operator(/=) – dtFFT","text":"public interface operator(/=) Calls interface~~operator(SLASH=)~~CallsGraph interface~operator(SLASH=) operator(/=) proc~effort_ne effort_ne interface~operator(SLASH=)->proc~effort_ne proc~execute_type_ne execute_type_ne interface~operator(SLASH=)->proc~execute_type_ne proc~executor_ne executor_ne interface~operator(SLASH=)->proc~executor_ne proc~gpu_backend_ne gpu_backend_ne interface~operator(SLASH=)->proc~gpu_backend_ne proc~platform_ne platform_ne interface~operator(SLASH=)->proc~platform_ne proc~precision_ne precision_ne interface~operator(SLASH=)->proc~precision_ne proc~r2r_kind_ne r2r_kind_ne interface~operator(SLASH=)->proc~r2r_kind_ne proc~transpose_type_ne transpose_type_ne interface~operator(SLASH=)->proc~transpose_type_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure elemental function execute_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical","tags":"","loc":"interface/operator(SLASH=).html"},{"title":"dtfft_stream_t – dtFFT","text":"public interface dtfft_stream_t Creates dtfft_stream_t from integer(cuda_stream_kind) Calls interface~~dtfft_stream_t~~CallsGraph interface~dtfft_stream_t dtfft_stream_t proc~stream_from_int64 stream_from_int64 interface~dtfft_stream_t->proc~stream_from_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function stream_from_int64 (cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream","tags":"","loc":"interface/dtfft_stream_t.html"},{"title":"get_kernel_string – dtFFT","text":"public  function get_kernel_string(kernel) result(string) Gets the string description of a kernel Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: kernel kernel type Return Value character(len=:), allocatable kernel string Called by proc~~get_kernel_string~~CalledByGraph proc~get_kernel_string get_kernel_string proc~create_nvrtc_module create_nvrtc_module proc~create_nvrtc_module->proc~get_kernel_string proc~create~16 abstract_kernel%create proc~create~16->proc~get_kernel_string proc~get_kernel get_kernel proc~get_kernel->proc~get_kernel_string proc~get_kernel->proc~create_nvrtc_module proc~get_kernel_instance get_kernel_instance proc~get_kernel->proc~get_kernel_instance proc~get_kernel_instance->proc~get_kernel_string proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~7 transpose_handle_generic%create proc~create~7->proc~create~16 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_kernel_string.html"},{"title":"is_transpose_kernel – dtFFT","text":"public pure elemental function is_transpose_kernel(param) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: param Return Value logical","tags":"","loc":"proc/is_transpose_kernel.html"},{"title":"is_unpack_kernel – dtFFT","text":"public pure elemental function is_unpack_kernel(param) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: param Return Value logical Called by proc~~is_unpack_kernel~~CalledByGraph proc~is_unpack_kernel is_unpack_kernel proc~get_code get_code proc~get_code->proc~is_unpack_kernel proc~get_kernel get_kernel proc~get_kernel->proc~is_unpack_kernel proc~create_nvrtc_module create_nvrtc_module proc~get_kernel->proc~create_nvrtc_module proc~create~11 kernel_device%create proc~create~11->proc~get_kernel proc~create~3 nvrtc_module%create proc~create~3->proc~get_code proc~create_nvrtc_module->proc~create~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_unpack_kernel.html"},{"title":"kernel_type_eq – dtFFT","text":"private pure elemental function kernel_type_eq(left, right) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: left type( kernel_type_t ), intent(in) :: right Return Value logical Called by proc~~kernel_type_eq~~CalledByGraph proc~kernel_type_eq kernel_type_eq interface~operator(==)~2 operator(==) interface~operator(==)~2->proc~kernel_type_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/kernel_type_eq.html"},{"title":"kernel_type_ne – dtFFT","text":"private pure elemental function kernel_type_ne(left, right) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: left type( kernel_type_t ), intent(in) :: right Return Value logical Called by proc~~kernel_type_ne~~CalledByGraph proc~kernel_type_ne kernel_type_ne interface~operator(SLASH=)~2 operator(/=) interface~operator(SLASH=)~2->proc~kernel_type_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/kernel_type_ne.html"},{"title":"create – dtFFT","text":"private  subroutine create(self, dims, effort, base_storage, kernel_type, neighbor_data, force_effort) Creates kernel Type Bound abstract_kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel integer(kind=int32), intent(in) :: dims (:) Local dimensions to process type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int32), intent(in), optional :: neighbor_data (:,:) Optional pointers for unpack kernels logical, intent(in), optional :: force_effort Should effort be forced or not Calls proc~~create~16~~CallsGraph proc~create~16 abstract_kernel%create create_private create_private proc~create~16->create_private proc~destroy~15 abstract_kernel%destroy proc~create~16->proc~destroy~15 proc~get_kernel_string get_kernel_string proc~create~16->proc~get_kernel_string destroy_private destroy_private proc~destroy~15->destroy_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~16~~CalledByGraph proc~create~16 abstract_kernel%create proc~create~7 transpose_handle_generic%create proc~create~7->proc~create~16 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~16.html"},{"title":"execute – dtFFT","text":"private  subroutine execute(self, in, out, stream, neighbor) Executes kernel Type Bound abstract_kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel real(kind=real32), intent(in) :: in (:) Source buffer, can be device or host pointer real(kind=real32), intent(inout) :: out (:) Target buffer, can be device or host pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, used only for device pointers integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking Calls proc~~execute~13~~CallsGraph proc~execute~13 abstract_kernel%execute execute_private execute_private proc~execute~13->execute_private proc~pop_nvtx_domain_range pop_nvtx_domain_range proc~execute~13->proc~pop_nvtx_domain_range proc~push_nvtx_domain_range push_nvtx_domain_range proc~execute~13->proc~push_nvtx_domain_range interface~nvtxdomainrangepop_c nvtxDomainRangePop_c proc~pop_nvtx_domain_range->interface~nvtxdomainrangepop_c interface~nvtxdomainrangepushex_c nvtxDomainRangePushEx_c proc~push_nvtx_domain_range->interface~nvtxdomainrangepushex_c proc~astring_f2c astring_f2c proc~push_nvtx_domain_range->proc~astring_f2c proc~create_nvtx_domain create_nvtx_domain proc~push_nvtx_domain_range->proc~create_nvtx_domain proc~string_f2c string_f2c proc~astring_f2c->proc~string_f2c proc~create_nvtx_domain->proc~astring_f2c interface~nvtxdomaincreate_c nvtxDomainCreate_c proc~create_nvtx_domain->interface~nvtxdomaincreate_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute~13~~CalledByGraph proc~execute~13 abstract_kernel%execute proc~execute abstract_backend%execute proc~execute->proc~execute~13 proc~execute_end~3 transpose_handle_generic%execute_end proc~execute_end~3->proc~execute~13 proc~execute_mpi backend_mpi%execute_mpi proc~execute_mpi->proc~execute~13 proc~execute_nccl backend_nccl%execute_nccl proc~execute_nccl->proc~execute~13 proc~execute~6 transpose_handle_generic%execute proc~execute~6->proc~execute~13 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/execute~13.html"},{"title":"destroy – dtFFT","text":"private  subroutine destroy(self) Destroys kernel Type Bound abstract_kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel Calls proc~~destroy~15~~CallsGraph proc~destroy~15 abstract_kernel%destroy destroy_private destroy_private proc~destroy~15->destroy_private Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy~15~~CalledByGraph proc~destroy~15 abstract_kernel%destroy proc~create~11 kernel_device%create proc~create~11->proc~destroy~15 proc~create~16 abstract_kernel%create proc~create~16->proc~destroy~15 proc~destroy~8 transpose_handle_generic%destroy proc~destroy~8->proc~destroy~15 proc~create~7 transpose_handle_generic%create proc~create~7->proc~create~16 proc~create~7->proc~destroy~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/destroy~15.html"},{"title":"operator(==) – dtFFT","text":"public interface operator(==) Calls interface~~operator(==)~2~~CallsGraph interface~operator(==)~2 operator(==) proc~kernel_type_eq kernel_type_eq interface~operator(==)~2->proc~kernel_type_eq Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure elemental function kernel_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: left type( kernel_type_t ), intent(in) :: right Return Value logical","tags":"","loc":"interface/operator(==)~2.html"},{"title":"operator(/=) – dtFFT","text":"public interface operator(/=) Calls interface~~operator(SLASH=)~2~~CallsGraph interface~operator(SLASH=)~2 operator(/=) proc~kernel_type_ne kernel_type_ne interface~operator(SLASH=)~2->proc~kernel_type_ne Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure elemental function kernel_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: left type( kernel_type_t ), intent(in) :: right Return Value logical","tags":"","loc":"interface/operator(SLASH=)~2.html"},{"title":"dtfft_abstract_backend – dtFFT","text":"This module describes Abstraction for all Backends: abstract_backend Uses dtfft_interface_nccl dtfft_parameters dtfft_errors dtfft_interface_cuda_runtime dtfft_config iso_fortran_env dtfft_pencil dtfft_utils dtfft_abstract_kernel iso_c_binding mpi_f08 module~~dtfft_abstract_backend~~UsesGraph module~dtfft_abstract_backend dtfft_abstract_backend iso_c_binding iso_c_binding module~dtfft_abstract_backend->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_abstract_backend->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_parameters dtfft_parameters module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_backend->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_abstract_backend~~UsedByGraph module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: NCCL_REGISTER_PREALLOC_SIZE = 8 Number of register elements to preallocate Abstract Interfaces abstract interface private  subroutine create_interface(self, helper, base_storage) Creates overriding class Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element abstract interface private  subroutine execute_interface(self, in, out, stream, aux, exec_type, error_code) Executes Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code abstract interface private  subroutine destroy_interface(self) Destroys overriding class Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend Derived Types type, public :: backend_helper Helper with nccl, mpi and nvshmem communicators Components Type Visibility Attributes Name Initial logical, public :: is_nccl_created = .false. Flag is nccl_comm has been created type( ncclComm ), public :: nccl_comm NCCL communicator logical, public :: should_register If NCCL buffer should be registered type(c_ptr), public, allocatable :: nccl_register (:,:) NCCL register cache integer(kind=int32), public :: nccl_register_size Number of elements in nccl_register type(MPI_Comm), public, allocatable :: comms (:) MPI communicators integer(kind=int32), public, allocatable :: comm_mappings (:,:) Mapping of 1d comm ranks to global comm type( dtfft_transpose_t ), public :: tranpose_type Type of transpose to create type( pencil ), public, pointer :: pencils (:) Pencils Type-Bound Procedures procedure, public, pass(self) :: create => create_helper ../../ Creates helper procedure, public, pass(self) :: destroy => destroy_helper ../../ Destroys helper type, public, abstract :: abstract_backend The most Abstract Backend Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type type( dtfft_platform_t ), public :: platform Platform to use logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer class( abstract_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates Abstract Backend procedure, public, non_overridable, pass(self) :: execute ../../ Executes Backend procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys Abstract Backend procedure, public, non_overridable, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, non_overridable, pass(self) :: set_unpack_kernel ../../ Sets unpack kernel for pipelined backend procedure, public, pass(self) :: execute_end ../../ Ends execution of Backend procedure, public, pass(self) :: get_async_active ../../ Returns if async execution is active procedure( create_interface ), public, deferred, pass(self) :: create_private ../../ Creates overriding class procedure( execute_interface ), public, deferred, pass(self) :: execute_private ../../ Executes Backend procedure( destroy_interface ), public, deferred, pass(self) :: destroy_private ../../ Destroys overriding class Functions private elemental function get_async_active (self) Returns if async execution is active Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value logical private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(in) :: self Abstract backend Return Value integer(kind=int64) Subroutines private  subroutine create (self, backend, helper, platform, comm_id, send_displs, send_counts, recv_displs, recv_counts, base_storage) Creates Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract Backend type( dtfft_backend_t ), intent(in) :: backend Backend type type( backend_helper ), intent(in) :: helper Backend helper type( dtfft_platform_t ), intent(in) :: platform Platform to use integer(kind=int8), intent(in) :: comm_id Id of communicator to use integer(kind=int32), intent(in) :: send_displs (:) Send data displacements, in original elements integer(kind=int32), intent(in) :: send_counts (:) Send data elements, in float elements integer(kind=int32), intent(in) :: recv_displs (:) Recv data displacements, in float elements integer(kind=int32), intent(in) :: recv_counts (:) Recv data elements, in float elements integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element private  subroutine execute (self, in, out, stream, aux, exec_type, error_code) Executes Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Self-copying backend real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream CUDA stream real(kind=real32), intent(inout) :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code private  subroutine execute_end (self, error_code) Ends execution of Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend integer(kind=int32), intent(out) :: error_code Error code private  subroutine destroy (self) Destroys Abstract Backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Abstract backend private  subroutine set_unpack_kernel (self, unpack_kernel) Sets unpack kernel for pipelined backend Arguments Type Intent Optional Attributes Name class( abstract_backend ), intent(inout) :: self Pipelined backend class( abstract_kernel ), intent(in), target :: unpack_kernel Kernel for unpacking data private  subroutine create_helper (self, platform, base_comm, comms, is_nccl_needed, pencils) Creates helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper type( dtfft_platform_t ), intent(in) :: platform Platform to use type(MPI_Comm), intent(in) :: base_comm MPI communicator type(MPI_Comm), intent(in) :: comms (:) 1D Communicators logical, intent(in) :: is_nccl_needed If nccl communicator will be needed type( pencil ), intent(in), target :: pencils (:) Pencils private  subroutine destroy_helper (self) Destroys helper Arguments Type Intent Optional Attributes Name class( backend_helper ), intent(inout) :: self Backend helper","tags":"","loc":"module/dtfft_abstract_backend.html"},{"title":"dtfft_executor_fftw_m – dtFFT","text":"This module describes FFTW3 based FFT Executor: fftw_executor http://www.fftw.org Uses dtfft_parameters dtfft_abstract_executor dtfft_errors dtfft_interface_fftw_m iso_fortran_env dtfft_pencil dtfft_utils iso_c_binding module~~dtfft_executor_fftw_m~~UsesGraph module~dtfft_executor_fftw_m dtfft_executor_fftw_m iso_c_binding iso_c_binding module~dtfft_executor_fftw_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_executor_fftw_m->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_errors dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_parameters dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_errors->iso_fortran_env module~dtfft_interface_fftw_m->iso_c_binding dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_executor_fftw_m~~UsedByGraph module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private, parameter :: FFTW3_FLAGS = FFTW_MEASURE+FFTW_DESTROY_INPUT FFTW3 planner flags Abstract Interfaces abstract interface private  function create_c2c_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Creates C2C FFTW3 Plan Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) abstract interface private  function create_r2c_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates R2C FFTW3 Plan Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) abstract interface private  function create_r2r_plan(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kinds, flags) bind(C) Creates R2R FFTW3 Plan Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kinds (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) abstract interface private  subroutine apply_interface(plan, in, out) bind(C) Executes FFTW3 Plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out abstract interface private  subroutine free_interface(plan) bind(C) Destroys FFTW3 Plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Derived Types type, public, extends( abstract_executor ) :: fftw_executor FFTW3 FFT Executor Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile procedure( apply_interface ), private, nopass, pointer :: apply => NULL() Pointer to FFTW3 function that executes FFT plan procedure( free_interface ), private, nopass, pointer :: free => NULL() Pointer to FFTW3 function that destroys FFT plan procedure( apply_interface ), private, nopass, pointer :: apply_inverse => NULL() Pointer to FFTW3 function that executes inverse FFT plan\nUsed in R2C only Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure, public :: create_private => create ../../ Creates FFT plan via FFTW3 Interface procedure, public :: execute_private => execute ../../ Executes FFTW3 plan procedure, public :: destroy_private => destroy ../../ Destroys FFTW3 plan procedure, public, nopass :: mem_alloc ../../ Allocates FFTW3 memory procedure, public, nopass :: mem_free ../../ Frees FFTW3 aligned memory Subroutines private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via FFTW3 Interface Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform private  subroutine execute (self, a, b, sign) Executes FFTW3 plan Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(in) :: self FFTW FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys FFTW3 plan Arguments Type Intent Optional Attributes Name class( fftw_executor ), intent(inout) :: self FFTW FFT Executor private  subroutine mem_alloc (alloc_bytes, ptr) Allocates FFTW3 memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer private  subroutine mem_free (ptr) Frees FFTW3 aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"module/dtfft_executor_fftw_m.html"},{"title":"dtfft_nvrtc_module – dtFFT","text":"Module for managing nvRTC compiled CUDA kernels\nEach module has only one templated kernel that can be instantiated with different parameters Uses dtfft_interface_nvtx dtfft_interface_cuda dtfft_parameters dtfft_interface_cuda_runtime dtfft_config iso_fortran_env dtfft_interface_nvrtc dtfft_utils dtfft_nvrtc_block_optimizer dtfft_abstract_kernel iso_c_binding mpi_f08 module~~dtfft_nvrtc_module~~UsesGraph module~dtfft_nvrtc_module dtfft_nvrtc_module iso_c_binding iso_c_binding module~dtfft_nvrtc_module->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_nvrtc_module->iso_fortran_env module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_parameters dtfft_parameters module~dtfft_nvrtc_module->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_nvrtc_module->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_nvrtc_module->mpi_f08 module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors dtfft_errors module~dtfft_config->module~dtfft_errors module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->iso_fortran_env module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_nvrtc_module~~UsedByGraph module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: DEFAULT_KERNEL_NAME = \"dtfft_kernel\" Basic kernel name Derived Types type, public :: nvrtc_module Class for managing nvRTC compiled CUDA kernels Components Type Visibility Attributes Name Initial logical, private :: is_created = .false. Is module created character(len=:), private, allocatable :: basic_name Basic kernel name integer(kind=int32), private :: ndims Number of dimensions, used only for forward permutation type( CUmodule ), private :: cumod CUDA module type( nvrtcProgram ), private :: prog nvRTC program type( kernel_type_t ), private :: kernel_type Type of kernel integer(kind=int64), private :: base_storage Number of bytes needed to store single element type( kernel_config ), private, allocatable :: configs (:) Kernel configurations that this module was compiled for Type-Bound Procedures procedure, public, pass(self) :: create ../../ Creates module with given parameters procedure, public, pass(self) :: destroy ../../ Destroys module and frees resources procedure, public, pass(self) :: get ../../ Returns kernel ready to be executed generic, public :: check => check_instance , check_module ../../ Checks if kernel is with given parameters is available in this module procedure, private, pass(self) :: check_instance ../../ Checks if kernel with given parameters is available in this module procedure, private, pass(self) :: check_module ../../ Basic check that this module provides kernels of given type type, private, extends( string ) :: codegen_t Class for generating CUDA code Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: raw String Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_string procedure, public, pass(self) :: add => add_line ../../ Adds new line to CUDA code Functions private  function get (self, ndims, kernel_type, base_storage, tile_size, block_rows) result(fun) Returns kernel ready to be executed Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions, used only for forward permutation type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter Return Value type( CUfunction ) Resulting kernel private  function check_instance (self, ndims, kernel_type, base_storage, tile_size, block_rows) Checks if kernel with given parameters is available in this module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter Return Value logical private  function check_module (self, ndims, kernel_type, base_storage) Basic check that this module provides kernels of given type Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(in) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value logical private  function compile_program (code, prog_name, configs, props) result(prog) Compiles nvRTC program with given configurations Arguments Type Intent Optional Attributes Name type( codegen_t ), intent(in) :: code CUDA code to compile character(len=*), intent(in) :: prog_name Basic kernel name type( kernel_config ), intent(in) :: configs (:) Kernel configurations that this module should be compiled for type( device_props ), intent(in) :: props GPU architecture properties Return Value type( nvrtcProgram ) Resulting nvRTC program private  function get_name_expression (basic_name, tile_dim, block_rows, padding) result(expression) Generates name expression for given template parameters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basic_name Basic kernel name integer(kind=int32), intent(in) :: tile_dim Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter integer(kind=int32), intent(in) :: padding Padding to avoid shared memory bank conflicts, template parameter Return Value character(len=c_char), allocatable, (:) Resulting name expression private  function get_mangled_name (basic_name, prog, tile_dim, block_rows, padding) result(mangled) Gets mangled name for given template parameters from nvRTC program Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basic_name Basic kernel name type( nvrtcProgram ), intent(in) :: prog nvRTC program integer(kind=int32), intent(in) :: tile_dim Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter integer(kind=int32), intent(in) :: padding Padding to avoid shared memory bank conflicts, template parameter Return Value type(c_ptr) Mangled kernel name private  function get_code (kernel_name, ndims, base_storage, kernel_type) result(code) Generates code that will be used to locally tranpose data and prepares to send it to other processes Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: kernel_name Name of CUDA kernel integer(kind=int32), intent(in) :: ndims Number of dimensions integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to generate code for Return Value type( codegen_t ) Resulting code Subroutines private  subroutine add_line (self, line) Adds new line to CUDA code Arguments Type Intent Optional Attributes Name class( codegen_t ), intent(inout) :: self Kernel code character(len=*), intent(in) :: line Line to add private  subroutine create (self, ndims, kernel_type, base_storage, configs, props) Creates module with given parameters, compiles nvRTC program and loads it as CUDA module Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(inout) :: self This module integer(kind=int32), intent(in) :: ndims Number of dimensions, used only for forward permutation type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_config ), intent(in) :: configs (:) Kernel configurations that this module should be compiled for type( device_props ), intent(in) :: props GPU architecture properties private  subroutine destroy (self) Destroys module and frees resources Arguments Type Intent Optional Attributes Name class( nvrtc_module ), intent(inout) :: self private  subroutine set_name_expression (prog, basic_name, tile_dim, block_rows, padding) Sets name expression for given template parameters to nvRTC program Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), intent(in) :: prog nvRTC program character(len=*), intent(in) :: basic_name Basic kernel name integer(kind=int32), intent(in) :: tile_dim Size of shared memory tile, template parameter integer(kind=int32), intent(in) :: block_rows Number of rows processed by single thread, template parameter integer(kind=int32), intent(in) :: padding Padding to avoid shared memory bank conflicts, template parameter","tags":"","loc":"module/dtfft_nvrtc_module.html"},{"title":"dtfft_executor_mkl_m – dtFFT","text":"This module describes MKL based FFT Executor: mkl_executor https://software.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/fourier-transform-functions/fft-functions.html Uses dtfft_interface_mkl_native_m dtfft_parameters dtfft_abstract_executor dtfft_errors iso_fortran_env dtfft_utils dtfft_interface_mkl_m iso_c_binding mpi_f08 module~~dtfft_executor_mkl_m~~UsesGraph module~dtfft_executor_mkl_m dtfft_executor_mkl_m iso_c_binding iso_c_binding module~dtfft_executor_mkl_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_executor_mkl_m->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_errors dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_parameters dtfft_parameters module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_executor_mkl_m->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_executor_mkl_m->mpi_f08 module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_pencil dtfft_pencil module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_errors->iso_fortran_env module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_interface_mkl_m->module~dtfft_utils MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_executor_mkl_m~~UsedByGraph module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_executor ) :: mkl_executor MKL FFT Executor Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile logical, private :: need_reconfigure Needed for R2C plans integer(kind=c_long), private, allocatable :: istrides (:) Input strides. Needed for R2C plans to reconfigure plan integer(kind=c_long), private, allocatable :: ostrides (:) Output strides. Needed for R2C plans to reconfigure plan integer(kind=int32), private :: idist Input distance between the first data elements of consecutive data sets integer(kind=int32), private :: odist Output distance between the first data elements of consecutive data sets Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure, public :: create_private => create ../../ Creates FFT plan via MKL DFTI Interface procedure, public :: execute_private => execute ../../ Executes MKL plan procedure, public :: destroy_private => destroy ../../ Destroys MKL plan procedure, public, nopass :: mem_alloc ../../ Allocates MKL memory procedure, public, nopass :: mem_free ../../ Frees MKL aligned memory Subroutines private  subroutine make_plan (fft_rank, fft_sizes, mkl_precision, forward_domain, how_many, idist, odist, plan) Creates general MKL plan Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=c_long), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: mkl_precision MKL Precision integer(kind=int32), intent(in) :: forward_domain C2C or R2C flag integer(kind=int32), intent(in) :: how_many Sets DFTI_NUMBER_OF_TRANSFORMS integer(kind=int32), intent(in) :: idist Sets DFTI_INPUT_DISTANCE integer(kind=int32), intent(in) :: odist Sets DFTI_OUTPUT_DISTANCE type(c_ptr), intent(inout) :: plan Resulting plan private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via MKL DFTI Interface Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform private  subroutine execute (self, a, b, sign) Executes MKL plan Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(in) :: self MKL FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys MKL plan Arguments Type Intent Optional Attributes Name class( mkl_executor ), intent(inout) :: self MKL FFT Executor private  subroutine mem_alloc (alloc_bytes, ptr) Allocates MKL memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer private  subroutine mem_free (ptr) Frees MKL aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"module/dtfft_executor_mkl_m.html"},{"title":"dtfft_pencil – dtFFT","text":"This module describes private pencil and public dtfft_pencil_t classes Uses dtfft_parameters dtfft_errors dtfft_utils iso_fortran_env dtfft_interface_cuda_runtime iso_c_binding mpi_f08 module~~dtfft_pencil~~UsesGraph module~dtfft_pencil dtfft_pencil iso_c_binding iso_c_binding module~dtfft_pencil->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_pencil->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_pencil->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_parameters dtfft_parameters module~dtfft_pencil->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_pencil->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_pencil->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_pencil~~UsedByGraph module~dtfft_pencil dtfft_pencil module~dtfft dtfft module~dtfft->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_pencil module~dtfft_api->module~dtfft_plan module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_pencil module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_transpose_plan->module~dtfft_pencil module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface dtfft_pencil_t Type bound constuctor for dtfft_pencil_t private  function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t ) Derived Types type, public :: dtfft_pencil_t Structure to hold pencil decomposition info Components Type Visibility Attributes Name Initial integer(kind=int8), public :: dim Aligned dimension id integer(kind=int8), public :: ndims = 0 Number of dimensions integer(kind=int32), public, allocatable :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), public, allocatable :: counts (:) Local counts of data, in elements integer(kind=int64), public :: size Total number of elements in a pencil logical, private :: is_created = .false. Is pencil created Constructor Type bound constuctor for dtfft_pencil_t private\n\n                    \n                    function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Type-Bound Procedures procedure, private, pass(self) :: destroy => destroy_pencil_t_private ../../ Destroys pencil type, public, bind(C) :: dtfft_pencil_c Structure to hold pencil decomposition info Components Type Visibility Attributes Name Initial integer(kind=c_int8_t), public :: dim Aligned dimension id integer(kind=c_int8_t), public :: ndims Number of dimensions integer(kind=c_int32_t), public :: starts (3) Local starts, starting from 0 for both C and Fortran integer(kind=c_int32_t), public :: counts (3) Local counts of data, in elements integer(kind=c_size_t), public :: size Total number of elements in a pencil type, public :: pencil Class that describes information about data layout Components Type Visibility Attributes Name Initial integer(kind=int8), public :: aligned_dim Position of aligned dimension. For example: X pencil aligned_dim = 1, Z pencil aligned_dim = 3 integer(kind=int8), public :: rank Rank of buffer: 2 or 3 integer(kind=int32), public, allocatable :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), public, allocatable :: counts (:) Local counts of data, in elements logical, public :: is_even Is data evenly distributed across processes Type-Bound Procedures procedure, public, pass(self) :: create ../../ Creates pencil procedure, public, pass(self) :: destroy ../../ Destroys pencil procedure, public, pass(self) :: make_public ../../ Creates public object that users can use to create own FFT backends type, public :: pencil_init Class that describes information about data layout Read more… Components Type Visibility Attributes Name Initial type(MPI_Comm), public, allocatable :: comms (:) 1D communicators for each dimension integer(kind=int32), public, allocatable :: starts (:) Local starts integer(kind=int32), public, allocatable :: counts (:) Local counts integer(kind=int32), public, allocatable :: dims (:) Global dimensions of entire region Type-Bound Procedures procedure, public, pass(self) :: create => create_pencil_init ../../ Creates and validates pencil passed by user to plan constructors procedure, public, pass(self) :: destroy => destroy_pencil_init ../../ Destroys pencil_init Functions public pure function get_transpose_type (send, recv) result(transpose_type) Determines transpose ID based on pencils Arguments Type Intent Optional Attributes Name type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Receive pencil Return Value type( dtfft_transpose_t ) Transpose ID private  function check_if_even (count, comm) Checks if data is evenly distributed across processes Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: count Local count type(MPI_Comm), intent(in) :: comm Grid communicator Return Value logical private  function make_public (self) Creates public object that users can use to create own FFT backends Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: self Pencil Return Value type( dtfft_pencil_t ) private  function create_pencil_t (starts, counts) Creates pencil object, that can be used to create dtFFT plans Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: starts (:) Local starts, starting from 0 for both C and Fortran integer(kind=int32), intent(in) :: counts (:) Local counts of data, in elements Return Value type( dtfft_pencil_t ) private  function create_pencil_init (self, pencil, comm) result(error_code) Creates and validates pencil passed by user to plan constructors Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t type( dtfft_pencil_t ), intent(in) :: pencil Pencil passed by user to plan constructors type(MPI_Comm), intent(in) :: comm MPI Communicator passed to plan constructors Return Value integer(kind=int32) Error code private pure function check_overlap (lbounds1, sizes1, lbounds2, sizes2, ndims) Check if two pencols overlap in ndims-dimensional space Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lbounds1 (:) Lower bounds of first pencil integer(kind=int32), intent(in) :: sizes1 (:) Sizes of first pencil integer(kind=int32), intent(in) :: lbounds2 (:) Lower bounds of second pencil integer(kind=int32), intent(in) :: sizes2 (:) Sizes of second pencil integer(kind=int32), intent(in) :: ndims Number of dimensions Return Value logical private  function check_continuity (all_lbounds, all_sizes, global_dims, comm_size) Check if the local pencils cover the global space without gaps Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: all_lbounds (:,:) Lower bounds of local pencils for each process integer(kind=int32), intent(in) :: all_sizes (:,:) Sizes of local pencils for each process integer(kind=int32), intent(in) :: global_dims (:) Global dimensions of the problem integer(kind=int32), intent(in) :: comm_size Number of processes in the communicator Return Value logical private  function get_varying_dim (fixed_dims, total_dims) result(varying_dim) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: fixed_dims (:) integer(kind=int32), intent(in) :: total_dims Return Value integer(kind=int32) Subroutines public  subroutine pencil_f2c (pencil, c_pencil) Converts Fortran pencil to C pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_t ), intent(in) :: pencil Fortran pencil type( dtfft_pencil_c ), intent(out) :: c_pencil C pencil public  subroutine pencil_c2f (c_pencil, pencil, error_code) Converts C pencil to Fortran pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: c_pencil C pencil type( dtfft_pencil_t ), intent(out) :: pencil Fortran pencil integer(kind=int32), intent(out) :: error_code Error code public  subroutine get_local_sizes (pencils, in_starts, in_counts, out_starts, out_counts, alloc_size, is_y_slab) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name type( pencil ), intent(in) :: pencils (:) Array of pencils integer(kind=int32), intent(out), optional :: in_starts (:) Start indexes in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements in real space integer(kind=int32), intent(out), optional :: out_starts (:) Start indexes in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan logical, intent(in), optional :: is_y_slab Is Y-slab optimization used private  subroutine create (self, rank, aligned_dim, counts, comms, lstarts, lcounts, order) Creates pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil integer(kind=int8), intent(in) :: rank Rank of buffer integer(kind=int8), intent(in) :: aligned_dim Position of aligned dimension integer(kind=int32), intent(in) :: counts (:) Global counts type(MPI_Comm), intent(in) :: comms (:) Grid communicators integer(kind=int32), intent(in), optional :: lstarts (:) Local starts integer(kind=int32), intent(in), optional :: lcounts (:) Local counts integer(kind=int8), intent(in), optional :: order (:) Order of dimensions private  subroutine destroy (self) Destroys pencil Arguments Type Intent Optional Attributes Name class( pencil ), intent(inout) :: self Pencil private  subroutine get_local_size (n_global, comm, start, count, start_to_keep, size_to_keep) Computes local portions of data based on global count and position inside grid communicator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n_global Global number of points type(MPI_Comm), intent(in) :: comm Grid communicator integer(kind=int32), intent(out) :: start Local start integer(kind=int32), intent(out) :: count Local count integer(kind=int32), intent(in), optional :: start_to_keep Start to keep in case of user defined decomposition integer(kind=int32), intent(in), optional :: size_to_keep Size to keep in case of user defined decomposition private  subroutine destroy_pencil_t_private (self) Destroys pencil Arguments Type Intent Optional Attributes Name class( dtfft_pencil_t ), intent(inout) :: self Public pencil private  subroutine destroy_pencil_t (self) Destroys pencil Arguments Type Intent Optional Attributes Name type( dtfft_pencil_t ), intent(inout) :: self Public pencil private  subroutine destroy_pencil_init (self) Destroys pencil_init Arguments Type Intent Optional Attributes Name class( pencil_init ), intent(inout) :: self Internal pencil representation based on dtfft_pencil_t private  subroutine sort_by_varying_dim (ranks, coords) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: ranks (:) integer(kind=int32), intent(in) :: coords (:) private  subroutine create_1d_comm (lbounds, all_lbounds, fixed_dims, comm, new_comm) Creates a new 1D communicator based on the fixed dimensions of the current pencil Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lbounds (:) Local starts of the current pencil integer(kind=int32), intent(in) :: all_lbounds (:,:) Local starts of all processes integer(kind=int32), intent(in) :: fixed_dims (:) Indices of fixed coordinates type(MPI_Comm), intent(in) :: comm Original MPI communicator type(MPI_Comm), intent(out) :: new_comm New 1D MPI communicator","tags":"","loc":"module/dtfft_pencil.html"},{"title":"dtfft_interface_mkl_native_m – dtFFT","text":"This module creates native interface with MKL library Uses MKL_DFTI module~~dtfft_interface_mkl_native_m~~UsesGraph module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_mkl_native_m~~UsedByGraph module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/dtfft_interface_mkl_native_m.html"},{"title":"dtfft_plan – dtFFT","text":"This module describes dtfft_plan_t , dtfft_plan_c2c_t , dtfft_plan_r2c_t and dtfft_plan_r2r_t types Uses dtfft_interface_nvshmem dtfft_transpose_plan dtfft_interface_nvtx dtfft_executor_mkl_m dtfft_executor_cufft_m dtfft_parameters dtfft_abstract_executor dtfft_executor_fftw_m dtfft_errors dtfft_config iso_fortran_env dtfft_pencil dtfft_utils dtfft_executor_vkfft_m dtfft_interface_cuda_runtime iso_c_binding mpi_f08 module~~dtfft_plan~~UsesGraph module~dtfft_plan dtfft_plan iso_c_binding iso_c_binding module~dtfft_plan->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_plan->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_config dtfft_config module~dtfft_plan->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_plan->module~dtfft_errors module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_plan->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_utils dtfft_utils module~dtfft_plan->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_plan->mpi_f08 module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_executor_cufft_m->iso_c_binding module~dtfft_executor_cufft_m->iso_fortran_env module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->mpi_f08 module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m->iso_c_binding module~dtfft_executor_fftw_m->iso_fortran_env module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_executor_mkl_m->iso_c_binding module~dtfft_executor_mkl_m->iso_fortran_env module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_executor_mkl_m->mpi_f08 module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_executor_vkfft_m->iso_c_binding module~dtfft_executor_vkfft_m->iso_fortran_env module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvshmem->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_transpose_plan->iso_c_binding module~dtfft_transpose_plan->iso_fortran_env module~dtfft_transpose_plan->module~dtfft_config module~dtfft_transpose_plan->module~dtfft_errors module~dtfft_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_transpose_plan->module~dtfft_interface_nvtx module~dtfft_transpose_plan->module~dtfft_parameters module~dtfft_transpose_plan->module~dtfft_pencil module~dtfft_transpose_plan->module~dtfft_utils module~dtfft_transpose_plan->mpi_f08 module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_transpose_plan->module~dtfft_interface_cuda module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_transpose_plan->module~dtfft_interface_nvrtc module~dtfft_kernel_device dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_config module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_abstract_transpose_handle->iso_fortran_env module~dtfft_abstract_transpose_handle->module~dtfft_parameters module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_abstract_transpose_handle->mpi_f08 module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_fftw_m->iso_c_binding dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_interface_mkl_m->module~dtfft_utils MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_vkfft_m->iso_c_binding module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_kernel_device->iso_c_binding module~dtfft_kernel_device->iso_fortran_env module~dtfft_kernel_device->module~dtfft_config module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_kernel_device->module~dtfft_parameters module~dtfft_kernel_device->module~dtfft_utils module~dtfft_kernel_device->mpi_f08 module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_transpose_handle_datatype->iso_fortran_env module~dtfft_transpose_handle_datatype->module~dtfft_errors module~dtfft_transpose_handle_datatype->module~dtfft_interface_nvtx module~dtfft_transpose_handle_datatype->module~dtfft_parameters module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_transpose_handle_datatype->module~dtfft_utils module~dtfft_transpose_handle_datatype->mpi_f08 module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->iso_c_binding module~dtfft_transpose_handle_generic->iso_fortran_env module~dtfft_transpose_handle_generic->module~dtfft_errors module~dtfft_transpose_handle_generic->module~dtfft_parameters module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_transpose_handle_generic->module~dtfft_utils module~dtfft_transpose_handle_generic->mpi_f08 module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_kernel_host dtfft_kernel_host module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_errors module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_errors module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_errors module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_kernel_host->iso_c_binding module~dtfft_kernel_host->iso_fortran_env module~dtfft_kernel_host->module~dtfft_parameters module~dtfft_kernel_host->mpi_f08 module~dtfft_kernel_host->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->iso_fortran_env module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->iso_c_binding module~dtfft_nvrtc_module_cache->iso_fortran_env module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_utils module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_nvrtc_module->iso_c_binding module~dtfft_nvrtc_module->iso_fortran_env module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_parameters module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_nvrtc_module->mpi_f08 module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_plan~~UsedByGraph module~dtfft_plan dtfft_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, abstract :: dtfft_plan_t Abstract class for all dtFFT plans Components Type Visibility Attributes Name Initial integer(kind=int8), private :: ndims Number of global dimensions integer(kind=int32), private, allocatable :: dims (:) Global dimensions integer(kind=int32), private, allocatable :: grid_dims (:) Grid decomposition dimensions type( dtfft_precision_t ), private :: precision Precision of transform logical, private :: is_created = .false. Plan creation flag logical, private :: is_transpose_plan = .false. Plan is transpose only logical, private :: is_aux_alloc = .false. Auxiliary buffer is allocated internally logical, private :: is_z_slab = .false. Using Z-slab optimization Read more… logical, private :: is_y_slab = .false. Using Y-slab optimization Read more… type( dtfft_effort_t ), private :: effort User defined type of effort integer(kind=int64), private :: storage_size Single element size in bytes type( dtfft_executor_t ), private :: executor FFT executor type type(MPI_Comm), private :: comm Grid communicator type(MPI_Comm), private, allocatable :: comms (:) Local 1d communicators type( transpose_plan ), private :: plan Transpose plan handle type( pencil ), private, allocatable :: pencils (:) Information about data aligment and datatypes type( dtfft_platform_t ), private :: platform Execution platform type( dtfft_stream_t ), private :: stream CUDA Stream associated with current plan type(c_ptr), private :: aux_ptr Auxiliary pointer type( fft_executor ), private, allocatable :: fft (:) Internal fft runners integer(kind=int32), private, allocatable :: fft_mapping (:) Memory and plan creation optimization.\nIn case same FFTs needs to be run in different dimensions\nonly single FFT plan needs to be created Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_start ../../ Starts an asynchronous transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr ../../ Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_end ../../ Ends previously started transposition procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_y_slab_enabled ../../ Returns logical value is Y-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_grid_dims ../../ Returns grid decomposition dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected backend during autotuning procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan procedure, private, pass(self), non_overridable :: get_stream_ptr ../../ Returns CUDA stream associated with plan procedure, private, pass(self), non_overridable :: get_stream_int64 ../../ Returns CUDA stream associated with plan procedure, private, pass(self), non_overridable :: execute_private ../../ Executes plan procedure, private, pass(self), non_overridable :: execute_2d ../../ Executes 2d plan procedure, private, pass(self), non_overridable :: execute_z_slab ../../ Executes Z slab plan procedure, private, pass(self), non_overridable :: execute_generic ../../ Executes plan with specified auxiliary buffer procedure, private, pass(self), non_overridable :: transpose_private ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, private, pass(self), non_overridable :: check_create_args ../../ Check arguments provided to create subroutines procedure, private, pass(self), non_overridable :: create_private ../../ Creates core procedure, private, pass(self), non_overridable :: alloc_fft_plans ../../ Allocates fft_executor classes procedure, private, pass(self), non_overridable :: check_aux ../../ Checks if aux buffer was passed\nand if not will allocate one internally procedure, private, pass(self), non_overridable :: mem_alloc_r32_1d ../../ Allocates memory for 1d real32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r64_1d ../../ Allocates memory for 1d real64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r32_2d ../../ Allocates memory for 2d real32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r64_2d ../../ Allocates memory for 2d real64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r32_3d ../../ Allocates memory for 2d real32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_r64_3d ../../ Allocates memory for 2d real64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c32_1d ../../ Allocates memory for 1d complex32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c64_1d ../../ Allocates memory for 1d complex64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c32_2d ../../ Allocates memory for 2d complex32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c64_2d ../../ Allocates memory for 2d complex64 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c32_3d ../../ Allocates memory for 3d complex32 pointer procedure, private, pass(self), non_overridable :: mem_alloc_c64_3d ../../ Allocates memory for 3d complex64 pointer procedure, private, pass(self), non_overridable :: mem_free_r32_1d ../../ Frees real32 1d pointer procedure, private, pass(self), non_overridable :: mem_free_r64_1d ../../ Frees real64 1d pointer procedure, private, pass(self), non_overridable :: mem_free_r32_2d ../../ Frees real32 2d pointer procedure, private, pass(self), non_overridable :: mem_free_r64_2d ../../ Frees real64 2d pointer procedure, private, pass(self), non_overridable :: mem_free_r32_3d ../../ Frees real32 3d pointer procedure, private, pass(self), non_overridable :: mem_free_r64_3d ../../ Frees real64 3d pointer procedure, private, pass(self), non_overridable :: mem_free_c32_1d ../../ Frees complex32 1d pointer procedure, private, pass(self), non_overridable :: mem_free_c64_1d ../../ Frees complex64 1d pointer procedure, private, pass(self), non_overridable :: mem_free_c32_2d ../../ Frees complex32 2d pointer procedure, private, pass(self), non_overridable :: mem_free_c64_2d ../../ Frees complex64 2d pointer procedure, private, pass(self), non_overridable :: mem_free_c32_3d ../../ Frees complex32 3d pointer procedure, private, pass(self), non_overridable :: mem_free_c64_3d ../../ Frees complex64 3d pointer type, public, extends( dtfft_core_c2c ) :: dtfft_plan_c2c_t C2C Plan Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_start ../../ Starts an asynchronous transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr ../../ Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_end ../../ Ends previously started transposition procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_y_slab_enabled ../../ Returns logical value is Y-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_grid_dims ../../ Returns grid decomposition dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected backend during autotuning procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan generic, public :: create => create_c2c , create_c2c_pencil ../../ Creates C2C plan procedure, private, pass(self) :: create_c2c ../../ Creates C2C plan using global dimensions procedure, private, pass(self) :: create_c2c_pencil ../../ Creates C2C plan using Pencil of local data procedure, private, pass(self) :: create_c2c_internal ../../ Private method that combines common logic for C2C plan creation type, public, extends( dtfft_core_c2c ) :: dtfft_plan_r2c_t R2C Plan Components Type Visibility Attributes Name Initial type( pencil ), private :: real_pencil “Real” pencil decomposition info Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_start ../../ Starts an asynchronous transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr ../../ Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_end ../../ Ends previously started transposition procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_y_slab_enabled ../../ Returns logical value is Y-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_grid_dims ../../ Returns grid decomposition dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected backend during autotuning procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan generic, public :: create => create_r2c , create_r2c_pencil ../../ Creates R2C plan procedure, private, pass(self) :: create_r2c ../../ Creates R2C plan using global dimensions procedure, private, pass(self) :: create_r2c_pencil ../../ Creates R2C plan using Pencil of local data procedure, private, pass(self) :: create_r2c_internal ../../ Private method that combines common logic for R2C plan creation type, public, extends( dtfft_plan_t ) :: dtfft_plan_r2r_t R2R Plan Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_start ../../ Starts an asynchronous transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr ../../ Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_end ../../ Ends previously started transposition procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_y_slab_enabled ../../ Returns logical value is Y-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_grid_dims ../../ Returns grid decomposition dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected backend during autotuning procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan generic, public :: create => create_r2r , create_r2r_pencil ../../ Creates R2R plan procedure, private, pass(self) :: create_r2r ../../ Creates R2R plan using global dimensions procedure, private, pass(self) :: create_r2r_pencil ../../ Creates R2R plan using Pencil of local data procedure, private, pass(self) :: create_r2r_internal ../../ Private method that combines common logic for R2R plan creation type, private :: transpose_request Handle for async transpose operation Components Type Visibility Attributes Name Initial type( dtfft_transpose_t ), public :: transpose_type Type of transposition requested logical, public :: is_started = .false. Flag that indicates if transpose was started type(c_ptr), public :: in Input pointer type(c_ptr), public :: out Output pointer type, private :: fft_executor FFT handle Components Type Visibility Attributes Name Initial class( abstract_executor ), public, allocatable :: fft Executor type, private, abstract, extends( dtfft_plan_t ) :: dtfft_core_c2c Abstract C2C Plan Type-Bound Procedures procedure, public, pass(self), non_overridable :: transpose ../../ Performs single transposition procedure, public, pass(self), non_overridable :: transpose_ptr ../../ Performs single transposition using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_start ../../ Starts an asynchronous transpose operation procedure, public, pass(self), non_overridable :: transpose_start_ptr ../../ Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: transpose_end ../../ Ends previously started transposition procedure, public, pass(self), non_overridable :: execute ../../ Executes plan procedure, public, pass(self), non_overridable :: execute_ptr ../../ Executes plan using type(c_ptr) pointers instead of buffers procedure, public, pass(self), non_overridable :: destroy ../../ Destroys plan procedure, public, pass(self), non_overridable :: get_local_sizes ../../ Returns local starts and counts in real and fourier spaces procedure, public, pass(self), non_overridable :: get_alloc_size ../../ Wrapper around get_local_sizes to obtain number of elements only procedure, public, pass(self), non_overridable :: get_z_slab_enabled ../../ Returns logical value is Z-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_y_slab_enabled ../../ Returns logical value is Y-slab optimization is enabled procedure, public, pass(self), non_overridable :: get_pencil ../../ Returns pencil decomposition procedure, public, pass(self), non_overridable :: get_element_size ../../ Returns number of bytes required to store single element. procedure, public, pass(self), non_overridable :: get_alloc_bytes ../../ Returns minimum number of bytes required to execute plan procedure, public, pass(self), non_overridable :: get_executor ../../ Returns FFT Executor associated with plan procedure, public, pass(self), non_overridable :: get_dims ../../ Returns global dimensions procedure, public, pass(self), non_overridable :: get_grid_dims ../../ Returns grid decomposition dimensions procedure, public, pass(self), non_overridable :: get_precision ../../ Returns precision of plan procedure, public, pass(self), non_overridable :: report ../../ Prints plan details procedure, public, pass(self), non_overridable :: mem_alloc_ptr ../../ Allocates memory for type(c_ptr) generic, public :: mem_alloc => mem_alloc_r32_1d , mem_alloc_r64_1d , mem_alloc_r32_2d , mem_alloc_r64_2d , mem_alloc_r32_3d , mem_alloc_r64_3d , mem_alloc_c32_1d , mem_alloc_c64_1d , mem_alloc_c32_2d , mem_alloc_c64_2d , mem_alloc_c32_3d , mem_alloc_c64_3d ../../ Allocates memory specific for this plan procedure, public, pass(self), non_overridable :: mem_free_ptr ../../ Frees previously allocated memory for type(c_ptr) generic, public :: mem_free => mem_free_r32_1d , mem_free_r32_2d , mem_free_r32_3d , mem_free_r64_1d , mem_free_r64_2d , mem_free_r64_3d , mem_free_c32_1d , mem_free_c32_2d , mem_free_c32_3d , mem_free_c64_1d , mem_free_c64_2d , mem_free_c64_3d ../../ Frees previously allocated memory specific for this plan procedure, public, pass(self), non_overridable :: get_backend ../../ Returns selected backend during autotuning procedure, public, pass(self), non_overridable :: get_platform ../../ Returns plan execution platform generic, public :: get_stream => get_stream_ptr , get_stream_int64 ../../ Returns CUDA stream associated with plan procedure, private, pass(self), non_overridable :: create_c2c_core ../../ Creates plan for both C2C and R2C Functions private  function transpose_start (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation private  function transpose_start_ptr (self, in, out, transpose_type, error_code) result(request) Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_request_t ) Asynchronous handle describing started transpose operation private  function get_z_slab_enabled (self, error_code) Returns logical value is Z-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical private  function get_y_slab_enabled (self, error_code) Returns logical value is Y-slab optimization enabled internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value logical private  function get_pencil (self, layout, error_code) Returns pencil decomposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(in) :: layout Required layout: Read more… integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_pencil_t ) private  function get_element_size (self, error_code) Returns number of bytes required to store single element. Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) private  function get_alloc_bytes (self, error_code) Returns minimum number of bytes required to execute plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) private  function get_executor (self, error_code) Returns FFT Executor associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_executor_t ) private  function get_precision (self, error_code) Returns precision of the plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_precision_t ) private  function get_backend (self, error_code) Returns selected GPU backend during autotuning Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_backend_t ) private  function get_platform (self, error_code) Returns execution platform of the plan (HOST or CUDA) Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type( dtfft_platform_t ) private  function check_device_pointers (in, out, backend, aux) result(error_code) Checks if device pointers are provided by user Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: in First pointer type(c_ptr), intent(in) :: out Second pointer type( dtfft_backend_t ), intent(in) :: backend Backend. Required to check for nvshmem pointer type(c_ptr), intent(in) :: aux Optional auxiliary pointer. Return Value integer(kind=int32) private  function get_alloc_size (self, error_code) result(alloc_size) Wrapper around get_local_sizes to obtain number of elements only Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value integer(kind=int64) Minimal number of elements required to execute plan private  function create_private (self, sngl_type, sngl_storage_size, dbl_type, dbl_storage_size, dims, pencil, comm, precision, effort, executor, kinds) Creates core Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(MPI_Datatype), intent(in) :: sngl_type MPI_Datatype for single precision plan integer(kind=int64), intent(in) :: sngl_storage_size Number of bytes needed to store single element (single precision) type(MPI_Datatype), intent(in) :: dbl_type MPI_Datatype for double precision plan integer(kind=int64), intent(in) :: dbl_storage_size Number of bytes needed to store single element (double precision) integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm User-defined communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) private  function check_create_args (self, dims, pencil, comm, precision, effort, executor, kinds) Check arguments provided by user and sets private variables Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of local portion of data type(MPI_Comm), intent(in), optional :: comm Optional MPI Communicator type( dtfft_precision_t ), intent(in), optional :: precision Precision of transform: DTFFT_SINGLE or DTFFT_DOUBLE type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform Return Value integer(kind=int32) private  function create_r2r_internal (self, dims, pencil, kinds, comm, precision, effort, executor) Creates plan for R2R plans Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) private  function create_c2c_internal (self, dims, pencil, comm, precision, effort, executor) Private method that combines common logic for C2C plan creation Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) private  function create_c2c_core (self, dims, pencil, comm, precision, effort, executor) Creates plan for both C2C and R2C Arguments Type Intent Optional Attributes Name class( dtfft_core_c2c ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor Return Value integer(kind=int32) private  function create_r2c_internal (self, executor, dims, pencil, comm, precision, effort) Private method that combines common logic for R2C plan creation Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor integer(kind=int32), intent(in), optional :: dims (:) Global dimensions of transform type( dtfft_pencil_t ), intent(in), optional :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan Return Value integer(kind=int32) private  function mem_alloc_ptr (self, alloc_bytes, error_code) result(ptr) Allocates memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user Return Value type(c_ptr) Allocated pointer Subroutines private  subroutine transpose (self, in, out, transpose_type, error_code) Performs single transposition Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind. Note that this buffer\nwill be modified in GPU build type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine transpose_ptr (self, in, out, transpose_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine transpose_end (self, request, error_code) Ends previously started transposition Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_request_t ), intent(inout) :: request Handle obtained from transpose_start or transpose_start_ptr integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine transpose_private (self, in, out, transpose_type, exec_type, error_code) Performs single transposition using type(c_ptr) pointers instead of buffers Read more… Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. type( async_exec_t ), intent(in) :: exec_type Type of asynchronous execution. integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine execute (self, in, out, execute_type, aux, error_code) Executes plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(*), intent(inout), target :: in (..) Incoming buffer of any rank and kind type(*), intent(inout), target :: out (..) Resulting buffer of any rank and kind type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(*), intent(inout), optional, target :: aux (..) Optional auxiliary buffer.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine execute_ptr (self, in, out, execute_type, aux, error_code) Executes plan using type(c_ptr) pointers instead of buffers Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Incoming pointer. Note that values of this pointer\nwill be modified in GPU build type(c_ptr), intent(in) :: out Resulting pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary buffer. Not optional. If not required, c_null_ptr must be passed.\nSize of buffer must be greater than value\nreturned by alloc_size parameter of get_local_sizes subroutine integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine execute_private (self, in, out, execute_type, aux, inplace) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. logical, intent(in) :: inplace Inplace execution flag private  subroutine execute_2d (self, in, out, execute_type, aux) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. private  subroutine execute_z_slab (self, in, out, execute_type, aux, inplace) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. logical, intent(in) :: inplace Inplace execution flag private  subroutine execute_generic (self, in, out, execute_type, aux) Executes plan with specified auxiliary buffer Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: in Source pointer type(c_ptr), intent(in) :: out Target pointer type( dtfft_execute_t ), intent(in) :: execute_type Type of execution. type(c_ptr), intent(in) :: aux Auxiliary pointer. private  subroutine destroy (self, error_code) Destroys plan, frees all memory Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine get_dims (self, dims, error_code) Returns global dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: dims (:) Global dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_grid_dims (self, grid_dims, error_code) Returns grid decomposition dimensions Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in), target :: self Abstract plan integer(kind=int32), intent(out), pointer :: grid_dims (:) Grid dimensions integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine report (self, error_code) Prints plan-related information to stdout Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_ptr (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan type( dtfft_stream_t ), intent(out) :: stream dtFFT Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_stream_int64 (self, stream, error_code) Returns CUDA stream associated with plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int64), intent(out) :: stream CUDA-Fortran Stream integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine get_local_sizes (self, in_starts, in_counts, out_starts, out_counts, alloc_size, error_code) Obtain local starts and counts in real and fourier spaces Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(in) :: self Abstract plan integer(kind=int32), intent(out), optional :: in_starts (:) Starts of local portion of data in real space (0-based) integer(kind=int32), intent(out), optional :: in_counts (:) Number of elements of local portion of data in ‘real’ space integer(kind=int32), intent(out), optional :: out_starts (:) Starts of local portion of data in fourier space (0-based) integer(kind=int32), intent(out), optional :: out_counts (:) Number of elements of local portion of data in fourier space integer(kind=int64), intent(out), optional :: alloc_size Minimal number of elements required to execute plan integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine alloc_fft_plans (self, kinds) Allocates abstract_executor with required FFT class\nand populates fft_mapping with similar FFT ids Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform private  subroutine check_aux (self, aux) Checks if aux buffer was passed by user and if not will allocate one internally Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: aux Optional auxiliary buffer. private  subroutine create_r2r (self, dims, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2r_pencil (self, pencil, kinds, comm, precision, effort, executor, error_code) R2R Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2r_t ), intent(inout) :: self R2R Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_r2r_kind_t ), intent(in), optional :: kinds (:) Kinds of R2R transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_c2c (self, dims, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_c2c_pencil (self, pencil, comm, precision, effort, executor, error_code) C2C Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_c2c_t ), intent(inout) :: self C2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan type( dtfft_executor_t ), intent(in), optional :: executor Type of External FFT Executor integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2c (self, dims, executor, comm, precision, effort, error_code) R2C Generic Plan Constructor Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self C2C Plan integer(kind=int32), intent(in) :: dims (:) Global dimensions of transform type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine create_r2c_pencil (self, pencil, executor, comm, precision, effort, error_code) R2C Plan Constructor with pencil Arguments Type Intent Optional Attributes Name class( dtfft_plan_r2c_t ), intent(inout) :: self R2C Plan type( dtfft_pencil_t ), intent(in) :: pencil Local pencil of data to be transformed type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(MPI_Comm), intent(in), optional :: comm Communicator type( dtfft_precision_t ), intent(in), optional :: precision Presicion of Transform type( dtfft_effort_t ), intent(in), optional :: effort How thoroughly dtFFT searches for the optimal plan integer(kind=int32), intent(out), optional :: error_code Optional Error Code returned to user private  subroutine mem_free_ptr (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan type(c_ptr), intent(in) :: ptr Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_r64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate real(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_r64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan real(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c32_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real32), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c32_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real32), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_1d (self, alloc_size, ptr, lbound, error_code) Allocates pointer of rank 1 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:) Allocated pointer integer(kind=int32), intent(in), optional :: lbound Lower boundary of pointer, default is 1 integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_2d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 2 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (2) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (2) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_alloc_c64_3d (self, alloc_size, ptr, sizes, lbounds, error_code) Allocates pointer of rank 3 Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan integer(kind=int64), intent(in) :: alloc_size Number of elements to allocate complex(kind=real64), intent(out), pointer :: ptr (:,:,:) Allocated pointer integer(kind=int32), intent(in) :: sizes (3) Number of elements in each direction integer(kind=int32), intent(in), optional :: lbounds (3) Lower boundaries of pointer, default is (1, 1) integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_1d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_2d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user private  subroutine mem_free_c64_3d (self, ptr, error_code) Frees previously allocated memory specific for this plan Arguments Type Intent Optional Attributes Name class( dtfft_plan_t ), intent(inout) :: self Abstract plan complex(kind=real64), intent(inout), target :: ptr (:,:,:) Pointer allocated with mem_alloc integer(kind=int32), intent(out), optional :: error_code Optional error code returned to user","tags":"","loc":"module/dtfft_plan.html"},{"title":"dtfft_interface_vkfft_m – dtFFT","text":"This module creates interface with VkFFT library VkFFT is loaded at runtime via dynamic loading. Uses dtfft_parameters dtfft_errors dtfft_utils iso_fortran_env iso_c_binding module~~dtfft_interface_vkfft_m~~UsesGraph module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m iso_c_binding iso_c_binding module~dtfft_interface_vkfft_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_vkfft_m~~UsedByGraph module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( vkfft_wrapper ), public, save, target :: cuda_wrapper VkFFT Wrapper for CUDA platform Abstract Interfaces abstract interface private  subroutine vkfft_create_interface(rank, dims, double_precision, how_many, r2c, c2r, dct, dst, stream, app_handle) bind(C) Creates FFT plan via vkFFT Interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), value :: rank Rank of fft: 1 or 2 integer(kind=c_int) :: dims (*) Dimensions of transform integer(kind=c_int), value :: double_precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=c_int), value :: how_many Number of transforms to create integer(kind=c_int8_t), value :: r2c Is R2C transform required integer(kind=c_int8_t), value :: c2r Is C2R transform required integer(kind=c_int8_t), value :: dct Is DCT transform required integer(kind=c_int8_t), value :: dst Is DST transform required type( dtfft_stream_t ), value :: stream CUDA stream type(c_ptr) :: app_handle vkFFT application handle abstract interface private  subroutine vkfft_execute_interface(app_handle, in, out, sign) bind(C) Executes vkFFT plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: app_handle vkFFT application handle type(c_ptr), value :: in Input data type(c_ptr), value :: out Output data integer(kind=c_int8_t), value :: sign Sign of FFT abstract interface private  subroutine vkfft_destroy_interface(app_handle) bind(C) Destroys vkFFT plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: app_handle vkFFT application handle Derived Types type, public :: vkfft_wrapper VkFFT Wrapper Components Type Visibility Attributes Name Initial procedure( vkfft_create_interface ), public, pointer, nopass :: create Fortran Pointer to vkFFT create function procedure( vkfft_execute_interface ), public, pointer, nopass :: execute Fortran Pointer to vkFFT execute function procedure( vkfft_destroy_interface ), public, pointer, nopass :: destroy Fortran Pointer to vkFFT destroy function logical, private :: is_loaded = .false. Is VkFFT library loaded type(c_ptr), private :: lib_handle Handle to the loaded library type(c_funptr), private :: vkfft_functions (3) Array of VkFFT functions Functions public  function load_vkfft (platform) Loads VkFFT library based on the platform Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to load VkFFT library for Return Value integer(kind=int32) private  function load (wrapper, suffix) result(error_code) Loads VkFFT library Arguments Type Intent Optional Attributes Name class( vkfft_wrapper ), intent(inout) :: wrapper VkFFT Wrapper character(len=*), intent(in) :: suffix Suffix for the library name Return Value integer(kind=int32) Error code","tags":"","loc":"module/dtfft_interface_vkfft_m.html"},{"title":"dtfft_transpose_plan – dtFFT","text":"This module describes transpose_plan class Uses dtfft_transpose_handle_datatype dtfft_interface_nvtx iso_fortran_env dtfft_abstract_backend dtfft_interface_cuda_runtime dtfft_errors dtfft_pencil iso_c_binding mpi_f08 dtfft_interface_nccl dtfft_parameters dtfft_config dtfft_interface_nvrtc dtfft_abstract_transpose_handle dtfft_interface_nvshmem dtfft_transpose_handle_generic dtfft_kernel_device dtfft_utils dtfft_interface_cuda module~~dtfft_transpose_plan~~UsesGraph module~dtfft_transpose_plan dtfft_transpose_plan iso_c_binding iso_c_binding module~dtfft_transpose_plan->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_transpose_plan->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_config dtfft_config module~dtfft_transpose_plan->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_transpose_plan->module~dtfft_errors module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_transpose_plan->module~dtfft_interface_cuda module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_transpose_plan->module~dtfft_interface_nvrtc module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_transpose_plan->module~dtfft_interface_nvtx module~dtfft_kernel_device dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_parameters dtfft_parameters module~dtfft_transpose_plan->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_transpose_plan->module~dtfft_pencil module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_utils dtfft_utils module~dtfft_transpose_plan->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_transpose_plan->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_config module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_abstract_transpose_handle->iso_fortran_env module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle->module~dtfft_parameters module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_abstract_transpose_handle->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvshmem->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_kernel_device->iso_c_binding module~dtfft_kernel_device->iso_fortran_env module~dtfft_kernel_device->module~dtfft_config module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_kernel_device->module~dtfft_parameters module~dtfft_kernel_device->module~dtfft_utils module~dtfft_kernel_device->mpi_f08 module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_transpose_handle_datatype->iso_fortran_env module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype->module~dtfft_errors module~dtfft_transpose_handle_datatype->module~dtfft_interface_nvtx module~dtfft_transpose_handle_datatype->module~dtfft_parameters module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_transpose_handle_datatype->module~dtfft_utils module~dtfft_transpose_handle_datatype->mpi_f08 module~dtfft_transpose_handle_generic->iso_c_binding module~dtfft_transpose_handle_generic->iso_fortran_env module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_errors module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_parameters module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_transpose_handle_generic->module~dtfft_utils module~dtfft_transpose_handle_generic->mpi_f08 module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_kernel_host dtfft_kernel_host module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_errors module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_errors module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_errors module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_kernel_host->iso_c_binding module~dtfft_kernel_host->iso_fortran_env module~dtfft_kernel_host->module~dtfft_parameters module~dtfft_kernel_host->mpi_f08 module~dtfft_kernel_host->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->iso_fortran_env module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->iso_c_binding module~dtfft_nvrtc_module_cache->iso_fortran_env module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_utils module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_nvrtc_module->iso_c_binding module~dtfft_nvrtc_module->iso_fortran_env module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_parameters module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_nvrtc_module->mpi_f08 module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_transpose_plan~~UsedByGraph module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int8), private, save :: FORWARD_PLAN_IDS (3) Default data types for forward transpositions integer(kind=int8), private, save :: BACKWARD_PLAN_IDS (3) Default data types for backward transpositions logical, private, save :: ARE_DATATYPES_SET = .false. Are default data types set Derived Types type, public :: transpose_plan Transpose Plan class\nThis class is a container for transposition plans Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), private :: backend Backend type( backend_helper ), private :: helper Backend helper logical, private :: is_z_slab Z-slab optimization flag (for 3D transforms) integer(kind=int64), private :: min_buffer_size Minimal buffer size for transposition type( dtfft_platform_t ), private :: platform Platform used for transposition type( dtfft_stream_t ), private :: stream CUDA stream type(c_ptr), private :: aux Auxiliary memory real(kind=real32), private, pointer :: paux (:) Pointer to auxiliary memory logical, private :: is_aux_alloc = .false. Is auxiliary memory allocated type( plan_t ), private, allocatable :: plans (:) Plans for each transposition Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates transpose plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes transposition procedure, public, non_overridable, pass(self) :: execute_end ../../ Finishes asynchronous transposition procedure, public, non_overridable, pass(self) :: get_async_active ../../ Returns .true. if any of the plans is running asynchronously procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys transpose plan procedure, public, non_overridable, pass(self) :: get_aux_size ../../ Returns auxiliary buffer size procedure, public, non_overridable, pass(self) :: get_backend ../../ Returns backend id procedure, public, non_overridable, pass(self) :: get_z_slab ../../ Returns .true. if Z-slab optimization is enabled procedure, public, non_overridable, pass(self) :: mem_alloc ../../ Allocates memory based on selected backend procedure, public, non_overridable, pass(self) :: mem_free ../../ Frees memory allocated with mem_alloc type, private :: plan_t This type is a container for allocatable transpose handles Components Type Visibility Attributes Name Initial class( abstract_transpose_handle ), public, allocatable :: p Transpose handle Functions private  function create (self, platform, dims, base_comm, effort, base_dtype, base_storage, cart_comm, comms, pencils, ipencil) result(error_code) Creates transposition plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type( dtfft_platform_t ), intent(in) :: platform Platform to create plan for integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested type(MPI_Comm), intent(in) :: base_comm Base communicator type( dtfft_effort_t ), intent(in) :: effort dtFFT planner type of effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Comm), intent(out) :: cart_comm Cartesian communicator type(MPI_Comm), intent(out) :: comms (:) Array of 1d communicators type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Pencil passed by user Return Value integer(kind=int32) Error code private  function get_async_active (self) Returns .true. if any of the plans is running asynchronously Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value logical private  function get_z_slab (self) Returns .true. if Z-slab optimization is enabled Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value logical private  function autotune_transpose_id (helper, from, to, base_dtype, base_storage, transpose_name_id, a, b, forward_id, backward_id) result(elapsed_time) Creates forward and backward transpose plans for backend DTFFT_BACKEND_MPI_DATATYPE based on source and target data distributions and,\nexecutes them DTFFT_MEASURE_ITERS times ( 4 * DTFFT_MEASURE_ITERS iterations total ) + 4 * DTFFT_MEASURE_WARMUP_ITERS warmup iterations Read more… Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer integer(kind=int8), intent(out) :: forward_id Best forward plan ID integer(kind=int8), intent(out) :: backward_id Best backward plan ID Return Value real(kind=real32) Elapsed time for best plans selected private  function get_plan_execution_time (helper, from, to, base_dtype, base_storage, datatype_id, transpose_name_id, a, b) result(elapsed_time) Creates transpose plan for backend DTFFT_BACKEND_MPI_DATATYPE and executes it DTFFT_MEASURE_WARMUP_ITERS + DTFFT_MEASURE_ITERS times Read more… Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper Backend helper type( pencil ), intent(in) :: from Source meta type( pencil ), intent(in) :: to Target meta type(MPI_Datatype), intent(in) :: base_dtype Basic MPI Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store Basic MPI Datatype integer(kind=int8), intent(in) :: datatype_id ID of transpose (1 or 2) integer(kind=int8), intent(in) :: transpose_name_id ID of transpose name (from -3 to 3, except 0) real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer Return Value real(kind=real32) Execution time [ms] private  function report_timings (comm, elapsed_time, n_iters, space_count) result(max_time) Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm real(kind=real32), intent(in) :: elapsed_time integer(kind=int32), intent(in) :: n_iters integer(kind=int32), intent(in), optional :: space_count Return Value real(kind=real32) private  function get_aux_size (self) result(aux_size) Returns maximum auxiliary memory size needed by transpose plan Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value integer(kind=int64) private  function get_aux_size_generic (plans) result(aux_size) Returns maximum auxiliary memory size needed by plans Arguments Type Intent Optional Attributes Name type( plan_t ), intent(in) :: plans (:) Transpose plans Return Value integer(kind=int64) Maximum auxiliary memory size needed private  function get_backend (self) Returns plan GPU backend Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(in) :: self Transposition class Return Value type( dtfft_backend_t ) Subroutines private  subroutine execute (self, in, out, transpose_type, exec_type, error_code) Executes transposition Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming buffer type(c_ptr), intent(in) :: out Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to execute type( async_exec_t ), intent(in) :: exec_type Type of execution (sync/async) integer(kind=int32), intent(out), optional :: error_code Error code private  subroutine execute_end (self, in, out, transpose_type, error_code) Finishes asynchronous transposition Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: in Incoming buffer type(c_ptr), intent(in) :: out Resulting buffer type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose integer(kind=int32), intent(out) :: error_code Error code private  subroutine destroy (self) Destroys transposition plans Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class private  subroutine allocate_plans (plans, backend) Allocates array of plans Arguments Type Intent Optional Attributes Name type( plan_t ), intent(inout) :: plans (:) Plans to allocate type( dtfft_backend_t ), intent(in) :: backend Backend to use private  subroutine destroy_plans (plans) Destroys array of plans Arguments Type Intent Optional Attributes Name type( plan_t ), intent(inout) :: plans (:) Plans to destroy private  subroutine autotune_grid_decomposition (platform, dims, transposed_dims, base_comm, effort, base_dtype, base_storage, stream, best_forward_ids, best_backward_ids, best_decomposition, backend, min_execution_time, best_backend) Runs through all possible grid decompositions and selects the best one based on the lowest average execution time Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to use integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm 3D comm type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use integer(kind=int8), intent(inout) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(inout) :: best_backward_ids (:) Best Datatype ids for backward plan integer(kind=int32), intent(out) :: best_decomposition (:) Best decomposition found type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: min_execution_time Elapsed time for best plan selected type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected private  subroutine autotune_grid (platform, dims, transposed_dims, base_comm, effort, base_dtype, comm_dims, base_storage, stream, is_z_slab, best_forward_ids, best_backward_ids, backend, best_time, best_backend) Creates cartesian grid and runs various backends on it. Returns best backend and execution time Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to create plan for integer(kind=int32), intent(in) :: dims (:) Global sizes of the transform requested integer(kind=int32), intent(in) :: transposed_dims (:,:) Transposed dimensions type(MPI_Comm), intent(in) :: base_comm Basic communicator to create 3d grid from type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal plan type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype integer(kind=int32), intent(in) :: comm_dims (:) Number of processors in each dimension integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use logical, intent(in) :: is_z_slab Is Z-slab optimization enabled integer(kind=int8), intent(inout) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(inout) :: best_backward_ids (:) Best Datatype ids for backward plan type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: best_time Elapsed time for best plan selected type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected for the grid private  subroutine run_autotune_backend (platform, comms, cart_comm, effort, base_dtype, pencils, base_storage, stream, is_z_slab, best_forward_ids, best_backward_ids, backend, best_time, best_backend) Runs autotune for all backends\nSymmetric heap can be allocated after nvshmem_init, which is done during plan creation Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform Platform to create plan for type(MPI_Comm), intent(in) :: comms (:) 1D comms type(MPI_Comm), intent(in) :: cart_comm 3D Cartesian comm type( dtfft_effort_t ), intent(in) :: effort type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype type( pencil ), intent(in) :: pencils (:) Source meta integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( dtfft_stream_t ), intent(in) :: stream Stream to use logical, intent(in) :: is_z_slab Is Z-slab optimization enabled integer(kind=int8), intent(inout) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(inout) :: best_backward_ids (:) Best Datatype ids for backward plan type( dtfft_backend_t ), intent(in), optional :: backend GPU Backend to test. Should be passed only when effort is DTFFT_ESTIMATE or DTFFT_MEASURE real(kind=real32), intent(out), optional :: best_time Elapsed time for best backend type( dtfft_backend_t ), intent(out), optional :: best_backend Best backend selected private  subroutine run_autotune_datatypes (helper, base_dtype, pencils, base_storage, is_z_slab, best_forward_ids, best_backward_ids, a, b, elapsed_time) Arguments Type Intent Optional Attributes Name type( backend_helper ), intent(inout) :: helper type(MPI_Datatype), intent(in) :: base_dtype Base MPI_Datatype type( pencil ), intent(in) :: pencils (:) Source meta integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in) :: is_z_slab Is Z-slab optimization enabled integer(kind=int8), intent(out) :: best_forward_ids (:) Best Datatype ids for forward plan integer(kind=int8), intent(out) :: best_backward_ids (:) Best Datatype ids for backward plan real(kind=real32), intent(inout) :: a (:) Source buffer real(kind=real32), intent(inout) :: b (:) Target buffer real(kind=real32), intent(out) :: elapsed_time Elapsed time for best plans selected in [ms] private  subroutine alloc_and_set_aux (platform, helper, backend, cart_comm, aux, paux, plans, is_aux_alloc) Allocates auxiliary memory according to the backend and sets it to the plans Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(MPI_Comm), intent(in) :: cart_comm Cartesian communicator type(c_ptr), intent(inout) :: aux Allocatable auxiliary memory real(kind=real32), intent(inout), pointer :: paux (:) Pointer to auxiliary memory type( plan_t ), intent(in) :: plans (:) logical :: is_aux_alloc Is auxiliary memory allocated private  subroutine create_pencils_and_comm (transposed_dims, old_comm, comm_dims, comm, local_comms, pencils, ipencil) Creates cartesian communicator Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: transposed_dims (:,:) Global counts in transposed coordinates type(MPI_Comm), intent(in) :: old_comm Communicator to create cartesian from integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type(MPI_Comm), intent(out) :: comm Cartesian communicator type(MPI_Comm), intent(out) :: local_comms (:) 1d communicators in cartesian communicator type( pencil ), intent(out) :: pencils (:) Data distributing meta type( pencil_init ), intent(in), optional :: ipencil Pencil passed by user private  subroutine create_cart_comm (old_comm, comm_dims, comm, local_comms, ipencil) Creates cartesian communicator Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: old_comm Communicator to create cartesian from integer(kind=int32), intent(in) :: comm_dims (:) Dims in cartesian communicator type(MPI_Comm), intent(out) :: comm Cartesian communicator type(MPI_Comm), intent(out) :: local_comms (:) 1d communicators in cartesian communicator type( pencil_init ), intent(in), optional :: ipencil Pencil passed by user private  subroutine mem_alloc (self, comm, alloc_bytes, ptr, error_code) Allocates memory based on selected backend Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code private  subroutine mem_free (self, ptr, error_code) Frees memory allocated with mem_alloc Arguments Type Intent Optional Attributes Name class( transpose_plan ), intent(inout) :: self Transposition class type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code private  subroutine alloc_mem (platform, helper, backend, comm, alloc_bytes, ptr, error_code) Allocates memory based on backend Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Pointer to the allocated memory integer(kind=int32), intent(out) :: error_code Error code private  subroutine free_mem (platform, helper, backend, ptr, error_code) Frees memory based on backend Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: platform type( backend_helper ), intent(inout) :: helper Backend helper type( dtfft_backend_t ), intent(in) :: backend GPU backend type(c_ptr), intent(in) :: ptr Pointer to the memory to free integer(kind=int32), intent(out) :: error_code Error code","tags":"","loc":"module/dtfft_transpose_plan.html"},{"title":"dtfft_transpose_handle_generic – dtFFT","text":"This module describes transpose_handle_generic class\nIt is responsible for managing both Host and CUDA-based transposition operations\nIt executes transpose kernels, memory transfers between GPUs/Hosts, and data unpacking if required Uses dtfft_kernel_host dtfft_backend_nccl_m dtfft_parameters dtfft_backend_cufftmp_m dtfft_errors dtfft_backend_mpi iso_fortran_env dtfft_kernel_device dtfft_pencil dtfft_abstract_backend dtfft_abstract_transpose_handle dtfft_utils dtfft_abstract_kernel iso_c_binding mpi_f08 module~~dtfft_transpose_handle_generic~~UsesGraph module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic iso_c_binding iso_c_binding module~dtfft_transpose_handle_generic->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_transpose_handle_generic->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_errors dtfft_errors module~dtfft_transpose_handle_generic->module~dtfft_errors module~dtfft_kernel_device dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_kernel_host dtfft_kernel_host module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_parameters dtfft_parameters module~dtfft_transpose_handle_generic->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_transpose_handle_generic->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_transpose_handle_generic->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_config dtfft_config module~dtfft_abstract_backend->module~dtfft_config module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_handle->iso_fortran_env module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle->module~dtfft_parameters module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_abstract_transpose_handle->mpi_f08 module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_errors module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_errors module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_errors module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_errors->iso_fortran_env module~dtfft_kernel_device->iso_c_binding module~dtfft_kernel_device->iso_fortran_env module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_kernel_device->module~dtfft_parameters module~dtfft_kernel_device->module~dtfft_utils module~dtfft_kernel_device->mpi_f08 module~dtfft_kernel_device->module~dtfft_config module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_kernel_host->iso_c_binding module~dtfft_kernel_host->iso_fortran_env module~dtfft_kernel_host->module~dtfft_abstract_kernel module~dtfft_kernel_host->module~dtfft_parameters module~dtfft_kernel_host->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvshmem->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->iso_fortran_env module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->iso_c_binding module~dtfft_nvrtc_module_cache->iso_fortran_env module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_utils module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_nvrtc_module->iso_c_binding module~dtfft_nvrtc_module->iso_fortran_env module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_parameters module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_nvrtc_module->mpi_f08 module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_transpose_handle_generic~~UsedByGraph module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_transpose_handle ) :: transpose_handle_generic Generic Transpose Handle\nExecutes transposition in 3 steps: Read more… Components Type Visibility Attributes Name Initial logical, private :: has_exchange = .false. If current handle has exchanges between GPUs logical, private :: is_pipelined = .false. If underlying exchanges are pipelined logical, private :: is_async_supported = .false. If underlying backend support async execution(execute/execute_end) class( abstract_kernel ), private, allocatable :: transpose_kernel Kernel for data transposition class( abstract_kernel ), private, allocatable :: unpack_kernel Kernel for unpacking data class( abstract_backend ), private, allocatable :: comm_handle Communication handle Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates transpose handle procedure, public, pass(self) :: create_private => create ../../ Creates Generic Transpose Handle procedure, public, pass(self) :: execute ../../ Executes transpose - exchange - unpack procedure, public, pass(self) :: execute_end ../../ Finalizes async transpose procedure, public, pass(self) :: get_async_active ../../ Returns if async transpose is active procedure, public, pass(self) :: destroy ../../ Destroys Generic Transpose Handle procedure, public, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer type, private :: data_handle Helper class used to obtain displacements and\ncounts needed to send to other processes Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: ls (:,:) Starts of my data that I should send or recv\nwhile communicating with other processes integer(kind=int32), public, allocatable :: ln (:,:) Counts of my data that I should send or recv\nwhile communicating with other processes integer(kind=int32), public, allocatable :: sizes (:,:) Counts of every rank in a comm integer(kind=int32), public, allocatable :: starts (:,:) Starts of every rank in a comm integer(kind=int32), public, allocatable :: displs (:) Local buffer displacement integer(kind=int32), public, allocatable :: counts (:) Number of elements to send or recv Type-Bound Procedures procedure, public, pass(self) :: create => create_data_handle ../../ Creates handle procedure, public, pass(self) :: destroy => destroy_data_handle ../../ Destroys handle Functions private elemental function get_async_active (self) Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(in) :: self Generic Transpose Handle Return Value logical private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(in) :: self Generic Transpose Handle Return Value integer(kind=int64) Subroutines private  subroutine create_data_handle (self, info, comm, comm_size) Creates handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class type( pencil ), intent(in) :: info Pencil info type(MPI_Comm), intent(in) :: comm MPI communicator integer(kind=int32), intent(in) :: comm_size Size of comm private  subroutine destroy_data_handle (self) Destroys handle Arguments Type Intent Optional Attributes Name class( data_handle ), intent(inout) :: self Helper class private  subroutine check_if_overflow (sizes) Checks if product of sizes fits into integer(int32) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: sizes (:) Sizes to check private  subroutine create (self, comm, send, recv, transpose_type, base_storage, kwargs) Creates Generic Transpose Handle Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle type(MPI_Comm), intent(in) :: comm MPI Communicator type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Base storage type( create_args ), intent(in) :: kwargs Additional arguments private  subroutine execute (self, in, out, kwargs, error_code) Executes transpose - exchange - unpack Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code private  subroutine execute_end (self, kwargs, error_code) Ends execution of transposition Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code private  subroutine destroy (self) Destroys Generic Transpose Handle Arguments Type Intent Optional Attributes Name class( transpose_handle_generic ), intent(inout) :: self Generic Transpose Handle","tags":"","loc":"module/dtfft_transpose_handle_generic.html"},{"title":"dtfft_nvrtc_block_optimizer – dtFFT","text":"Module that provides functionality to analytically optimize CUDA kernel configurations Uses dtfft_interface_cuda dtfft_parameters dtfft_abstract_kernel dtfft_config iso_fortran_env dtfft_utils dtfft_interface_cuda_runtime module~~dtfft_nvrtc_block_optimizer~~UsesGraph module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer iso_fortran_env iso_fortran_env module~dtfft_nvrtc_block_optimizer->iso_fortran_env module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_parameters dtfft_parameters module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_interface_nvtx mpi_f08 mpi_f08 module~dtfft_abstract_kernel->mpi_f08 module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils iso_c_binding iso_c_binding module~dtfft_config->iso_c_binding module~dtfft_errors dtfft_errors module~dtfft_config->module~dtfft_errors module~dtfft_config->mpi_f08 module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->iso_c_binding module~dtfft_utils->module~dtfft_errors module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_nvrtc_block_optimizer~~UsedByGraph module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: N_TILES_CANDIDATES = 5 Maximum number of tile candidates to generate integer(kind=int32), public, parameter :: N_BLOCKS_CANDIDATES = 5 Maximum number of block candidates to generate integer(kind=int32), public, parameter :: N_CANDIDATES = N_TILES_CANDIDATES*N_BLOCKS_CANDIDATES Maximum number of candidates to generate integer(kind=int32), private, parameter :: NUM_BANKS = 32 Number of banks in shared memory integer(kind=int32), private, parameter :: WARP_SIZE = 32 Warp size in threads integer(kind=int32), private, parameter :: BANK_WIDTH_BYTES = 4 Bank width in bytes Derived Types type, public :: kernel_config Configuration for the potential kernel Components Type Visibility Attributes Name Initial integer(kind=int32), public :: tile_size Tile size (number of columns) integer(kind=int32), public :: block_rows Block rows integer(kind=int32), public :: padding Padding added to the tile Functions public  function get_ampere_architecture () result(props) Ampere architecture (Compute Capability 8.0) Arguments None Return Value type( device_props ) Ampere architecture properties public  function get_volta_architecture () result(props) Volta architecture (Compute Capability 7.0) Arguments None Return Value type( device_props ) Volta architecture properties public pure function count_bank_conflicts (tile_size, block_rows, base_storage, padding) result(total_conflicts) Counts bank conflicts for a given tile size, padding, element size, and block rows. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: tile_size Size of the tile integer(kind=int32), intent(in) :: block_rows Number of rows in the block integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: padding Padding added to the tile Return Value integer(kind=int32) Total number of bank conflicts public  function evaluate_analytical_performance (dims, tile_dim, other_dim, kernel_type, config, props, base_storage, neighbor_data) result(score) This function evaluates the performance of a kernel configuration\nbased on various architectural and problem-specific parameters. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Problem dimensions integer(kind=int32), intent(in) :: tile_dim Tile dimension integer(kind=int32), intent(in) :: other_dim Other dimension (not tiled) type( kernel_type_t ), intent(in) :: kernel_type Type of kernel_type to evaluate type( kernel_config ), intent(in) :: config Kernel configuration type( device_props ), intent(in) :: props GPU architecture properties integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in), optional :: neighbor_data (:) Neighboring data dimensions for pipelined kernels Return Value real(kind=real32) Performance score private pure function estimate_optimal_padding (tile_size, block_rows, base_storage) result(padding) Estimates the optimal padding for a given tile size and element size Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: tile_size Size of the tile integer(kind=int32), intent(in) :: block_rows Number of rows in the block integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value integer(kind=int32) Optimal padding to reduce bank conflicts private pure function estimate_bank_conflict_ratio (config, base_storage) result(ratio) Estimates the bank conflict ratio for a given kernel configuration Arguments Type Intent Optional Attributes Name type( kernel_config ), intent(in) :: config Kernel configuration integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value real(kind=real32) Bank conflict estimation private pure function estimate_occupancy (config, props, base_storage) result(occupancy) Calculates theoretical occupancy for a given kernel configuration Arguments Type Intent Optional Attributes Name type( kernel_config ), intent(in) :: config Kernel configuration type( device_props ), intent(in) :: props GPU architecture properties integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element Return Value real(kind=real32) Estimated occupancy private  function estimate_memory_pressure (dims, tile_dim, other_dim, base_storage, props) result(pressure) Analytical estimation of memory pressure based on GPU architecture Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Size of the problem integer(kind=int32), intent(in) :: tile_dim Tile dimension integer(kind=int32), intent(in) :: other_dim Other dimension (not tiled) integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( device_props ), intent(in) :: props GPU architecture properties Return Value real(kind=real32) Pressure metric private  function estimate_coalescing (dims, tile_dim, other_dim, kernel_type, config, base_storage, neighbor_data) result(score) Estimate memory coalescing efficiency for a given kernel configuration and transpose type Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Local dimensions of the input data integer(kind=int32), intent(in) :: tile_dim Tile dimension integer(kind=int32), intent(in) :: other_dim Other dimension (not tiled) type( kernel_type_t ), intent(in) :: kernel_type Type of kernel type( kernel_config ), intent(in) :: config Kernel configuration integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in), optional :: neighbor_data (:) Neighboring data dimensions for pipelined kernels Return Value real(kind=real32) Coalescing score Subroutines public  subroutine generate_candidates (dims, tile_dim, other_dim, base_storage, props, candidates, num_candidates) Generate kernel configuration candidates for given problem Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Local dimensions of the input data, always 3D integer(kind=int32), intent(in) :: tile_dim Tile dimension integer(kind=int32), intent(in) :: other_dim Other dimension (not tiled) integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( device_props ), intent(in) :: props GPU architecture properties type( kernel_config ), intent(out) :: candidates (:) Generated kernel configurations integer(kind=int32), intent(out) :: num_candidates Number of generated candidates public  subroutine sort_candidates_by_score (scores, num_candidates, sorted_indices) Sorting candidates by their performance scores Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: scores (:) Performance scores of candidates generated by evaluate_analytical_performance integer(kind=int32), intent(in) :: num_candidates Number of candidates integer(kind=int32), intent(out) :: sorted_indices (:) Sorted indices of candidates private  subroutine find_valid_combination (base_tile, base_rows) This subroutine optimizes the tile size and number of rows for narrow matrices\nby adjusting them to be compatible with the warp size. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: base_tile < Tile size integer(kind=int32), intent(inout) :: base_rows < Number of rows","tags":"","loc":"module/dtfft_nvrtc_block_optimizer.html"},{"title":"dtfft_errors – dtFFT","text":"Module that defines error codes and provides utility to get error string Uses iso_fortran_env module~~dtfft_errors~~UsesGraph module~dtfft_errors dtfft_errors iso_fortran_env iso_fortran_env module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_errors~~UsedByGraph module~dtfft_errors dtfft_errors module~dtfft dtfft module~dtfft->module~dtfft_errors module~dtfft_config dtfft_config module~dtfft->module~dtfft_config module~dtfft_pencil dtfft_pencil module~dtfft->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_config module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_errors module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_pencil module~dtfft_api->module~dtfft_plan module~dtfft_api->module~dtfft_utils module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_errors module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_errors module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_errors module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_utils module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_errors module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_plan->module~dtfft_utils module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_handle_datatype->module~dtfft_errors module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_transpose_handle_datatype->module~dtfft_utils module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype->module~dtfft_interface_nvtx module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_errors module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_transpose_handle_generic->module~dtfft_utils module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_kernel_device dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_kernel_host dtfft_kernel_host module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_transpose_plan->module~dtfft_errors module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_config module~dtfft_transpose_plan->module~dtfft_interface_cuda module~dtfft_transpose_plan->module~dtfft_interface_nvrtc module~dtfft_transpose_plan->module~dtfft_pencil module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_utils module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan->module~dtfft_interface_nccl module~dtfft_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_transpose_plan->module~dtfft_interface_nvtx module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_utils->module~dtfft_errors module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_mkl_m->module~dtfft_utils module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_kernel_device->module~dtfft_config module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_utils module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_utils module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_kernel_host->module~dtfft_abstract_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DTFFT_SUCCESS = 0 Successful execution integer(kind=int32), public, parameter :: DTFFT_ERROR_MPI_FINALIZED = (-1) MPI_Init is not called or MPI_Finalize has already been called integer(kind=int32), public, parameter :: DTFFT_ERROR_PLAN_NOT_CREATED = 1 Plan not created integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_TRANSPOSE_TYPE = 2 Invalid transpose_type provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_N_DIMENSIONS = 3 Invalid Number of dimensions provided. Valid options are 2 and 3 integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_DIMENSION_SIZE = 4 One or more provided dimension sizes <= 0 integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_COMM_TYPE = 5 Invalid communicator type provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_PRECISION = 6 Invalid precision parameter provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_EFFORT = 7 Invalid effort parameter provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_EXECUTOR = 8 Invalid executor parameter provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_COMM_DIMS = 9 Number of dimensions in provided Cartesian communicator > Number of dimension passed to create subroutine integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_COMM_FAST_DIM = 10 Passed Cartesian communicator with number of processes in 1st (fastest varying) dimension > 1 integer(kind=int32), public, parameter :: DTFFT_ERROR_MISSING_R2R_KINDS = 11 For R2R plan, kinds parameter must be passed if executor != DTFFT_EXECUTOR_NONE integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_R2R_KINDS = 12 Invalid values detected in kinds parameter integer(kind=int32), public, parameter :: DTFFT_ERROR_R2C_TRANSPOSE_PLAN = 13 Transpose plan is not supported in R2C, use R2R or C2C plan instead integer(kind=int32), public, parameter :: DTFFT_ERROR_INPLACE_TRANSPOSE = 14 Inplace transpose is not supported integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_AUX = 15 Invalid aux buffer provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_DIM = 16 Invalid dim passed to plan.get_pencil integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_USAGE = 17 Invalid API Usage. integer(kind=int32), public, parameter :: DTFFT_ERROR_PLAN_IS_CREATED = 18 Trying to create already created plan integer(kind=int32), public, parameter :: DTFFT_ERROR_ALLOC_FAILED = 19 Internal allocation failed integer(kind=int32), public, parameter :: DTFFT_ERROR_FREE_FAILED = 20 Internal memory free failed integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_ALLOC_BYTES = 21 Invalid alloc_bytes provided integer(kind=int32), public, parameter :: DTFFT_ERROR_DLOPEN_FAILED = 22 dlopen failed integer(kind=int32), public, parameter :: DTFFT_ERROR_DLSYM_FAILED = 23 dlsym failed integer(kind=int32), public, parameter :: DTFFT_ERROR_R2C_TRANSPOSE_CALLED = 24 Calling to transpose method for R2C plan is not allowed integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH = 25 Sizes of starts and counts arrays passed to dtfft_pencil_t constructor do not match integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES = 26 Sizes of starts and counts < 2 or > 3 provided to dtfft_pencil_t constructor integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_INVALID_COUNTS = 27 Invalid counts provided to dtfft_pencil_t constructor integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_INVALID_STARTS = 28 Invalid starts provided to dtfft_pencil_t constructor integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_SHAPE_MISMATCH = 29 Processes have same lower bounds but different sizes in some dimensions integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_OVERLAP = 30 Pencil overlap detected, i.e. two processes share same part of global space integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_NOT_CONTINUOUS = 31 Local pencils do not cover the global space without gaps integer(kind=int32), public, parameter :: DTFFT_ERROR_PENCIL_NOT_INITIALIZED = 32 Pencil is not initialized, i.e. constructor subroutine was not called integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_MEASURE_WARMUP_ITERS = 33 Invalid n_measure_warmup_iters provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_MEASURE_ITERS = 34 Invalid n_measure_iters provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_REQUEST = 35 Invalid dtfft_request_t provided integer(kind=int32), public, parameter :: DTFFT_ERROR_TRANSPOSE_ACTIVE = 36 Attempting to execute already active transposition integer(kind=int32), public, parameter :: DTFFT_ERROR_TRANSPOSE_NOT_ACTIVE = 37 Attempting to finalize non-active transposition integer(kind=int32), public, parameter :: DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED = 101 Selected executor do not support R2R FFTs integer(kind=int32), public, parameter :: DTFFT_ERROR_GPU_INVALID_STREAM = 201 Invalid stream provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_BACKEND = 202 Invalid GPU backend provided integer(kind=int32), public, parameter :: DTFFT_ERROR_GPU_NOT_SET = 203 Multiple MPI Processes located on same host share same GPU which is not supported integer(kind=int32), public, parameter :: DTFFT_ERROR_VKFFT_R2R_2D_PLAN = 204 When using R2R FFT and executor type is vkFFT and plan uses Z-slab optimization, it is required that types of R2R transform are same in X and Y directions integer(kind=int32), public, parameter :: DTFFT_ERROR_BACKENDS_DISABLED = 205 Passed effort == DTFFT_PATIENT but all GPU Backends has been disabled by dtfft_config_t */ integer(kind=int32), public, parameter :: DTFFT_ERROR_NOT_DEVICE_PTR = 300 One of pointers passed to plan.execute or plan.transpose cannot be accessed from device integer(kind=int32), public, parameter :: DTFFT_ERROR_NOT_NVSHMEM_PTR = 301 One of pointers passed to plan.execute or plan.transpose is not an NVSHMEM pointer integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_PLATFORM = 400 Invalid platform provided integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR = 401 Invalid executor provided for selected platform integer(kind=int32), public, parameter :: DTFFT_ERROR_INVALID_PLATFORM_BACKEND = 402 Invalid backend provided for selected platform Functions public pure function dtfft_get_error_string (error_code) result(error_string) Gets the string description of an error code Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: error_code Error code Return Value character(len=:), allocatable Error string","tags":"","loc":"module/dtfft_errors.html"},{"title":"dtfft_executor_cufft_m – dtFFT","text":"This module describes cuFFT based FFT Executor: vkfft_executor https://docs.nvidia.com/cuda/cufft/index.html Uses dtfft_parameters dtfft_abstract_executor dtfft_errors dtfft_config iso_fortran_env dtfft_interface_cufft dtfft_utils dtfft_interface_cuda_runtime iso_c_binding mpi_f08 module~~dtfft_executor_cufft_m~~UsesGraph module~dtfft_executor_cufft_m dtfft_executor_cufft_m iso_c_binding iso_c_binding module~dtfft_executor_cufft_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_executor_cufft_m->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_config dtfft_config module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_parameters dtfft_parameters module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_executor_cufft_m->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_executor_cufft_m->mpi_f08 module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_pencil dtfft_pencil module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_executor_cufft_m~~UsedByGraph module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_executor ) :: cufft_executor cuFFT FFT Executor Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure, public :: create_private => create ../../ Creates FFT plan via cuFFT Interface procedure, public :: execute_private => execute ../../ Executes cuFFT plan procedure, public :: destroy_private => destroy ../../ Destroys cuFFT plan procedure, public, nopass :: mem_alloc ../../ Dummy method. Raises error stop procedure, public, nopass :: mem_free ../../ Dummy method. Raises error stop Subroutines private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via cuFFT Interface Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform private  subroutine execute (self, a, b, sign) Executes cuFFT plan Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(in) :: self cuFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys cuFFT plan Arguments Type Intent Optional Attributes Name class( cufft_executor ), intent(inout) :: self cuFFT FFT Executor private  subroutine mem_alloc (alloc_bytes, ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer private  subroutine mem_free (ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"module/dtfft_executor_cufft_m.html"},{"title":"dtfft_nvrtc_module_cache – dtFFT","text":"Module that implements a cache for nvrtc modules\nCache is used to avoid recompilation of kernels with the same parameters Uses dtfft_nvrtc_module dtfft_abstract_kernel dtfft_interface_cuda_runtime dtfft_config iso_fortran_env dtfft_utils dtfft_nvrtc_block_optimizer dtfft_interface_cuda iso_c_binding module~~dtfft_nvrtc_module_cache~~UsesGraph module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache iso_c_binding iso_c_binding module~dtfft_nvrtc_module_cache->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_nvrtc_module_cache->iso_fortran_env module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_utils dtfft_utils module~dtfft_nvrtc_module_cache->module~dtfft_utils module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_parameters mpi_f08 mpi_f08 module~dtfft_abstract_kernel->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_utils module~dtfft_errors dtfft_errors module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters module~dtfft_config->mpi_f08 module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_nvrtc_block_optimizer->iso_fortran_env module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_nvrtc_module->iso_c_binding module~dtfft_nvrtc_module->iso_fortran_env module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_parameters module~dtfft_nvrtc_module->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_nvrtc_module_cache~~UsedByGraph module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private, parameter :: CACHE_PREALLOC_SIZE = 10 Number of preallocated cache entries type( nvrtc_module_cache ), private, save :: cache Cache instance Derived Types type, private :: nvrtc_module_cache Cache for nvrtc modules Read more… Components Type Visibility Attributes Name Initial logical, private :: is_created = .false. Flag that indicates if cache is created type( nvrtc_module ), private, allocatable :: cache (:) Array of cached modules integer(kind=int32), private :: size Number of entries in cache Type-Bound Procedures procedure, private, pass(self) :: create ../../ Creates cache procedure, private, pass(self) :: add ../../ Adds new entry to cache Functions public  function get_kernel_instance (ndims, kernel_type, base_storage, tile_size, block_rows) result(fun) Retrieves a kernel instance from the cache\nIf the instance is not found, an error is raised Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ndims Number of dimensions (2 or 3) type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element integer(kind=int32), intent(in) :: tile_size Tile size (number of columns) integer(kind=int32), intent(in) :: block_rows Block rows Return Value type( CUfunction ) Retrieved kernel instance Subroutines public  subroutine create_nvrtc_module (ndims, kernel_type, base_storage, configs, props) Creates and adds a new nvrtc module to the cache if it does not already exist Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: ndims Number of dimensions (2 or 3) type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_config ), intent(in) :: configs (:) Array of kernel configurations to build type( device_props ), intent(in) :: props GPU architecture properties private  subroutine create (self) Creates cache Arguments Type Intent Optional Attributes Name class( nvrtc_module_cache ), intent(inout) :: self Cache instance private  subroutine add (self, m) Adds new entry to cache Arguments Type Intent Optional Attributes Name class( nvrtc_module_cache ), intent(inout) :: self Cache instance type( nvrtc_module ), intent(in) :: m Module to add","tags":"","loc":"module/dtfft_nvrtc_module_cache.html"},{"title":"dtfft_config – dtFFT","text":"Configuration module for dtFFT.\nIt handles both runtime (environment variables) and compile-time ( dtfft_config_t ) configurations. Uses dtfft_parameters dtfft_errors dtfft_utils iso_fortran_env dtfft_interface_cuda_runtime iso_c_binding mpi_f08 module~~dtfft_config~~UsesGraph module~dtfft_config dtfft_config iso_c_binding iso_c_binding module~dtfft_config->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_config->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_config->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_parameters dtfft_parameters module~dtfft_config->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_config->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_config~~UsedByGraph module~dtfft_config dtfft_config module~dtfft dtfft module~dtfft->module~dtfft_config module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_config module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_plan module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_config module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_config module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private, save :: is_init_called = .false. Has init_internal already been called or not integer(kind=int32), private, save :: log_enabled_from_env = VARIABLE_NOT_SET Should we log messages to stdout or not type( dtfft_platform_t ), private, save :: platform_from_env = PLATFORM_NOT_SET Platform obtained from environ integer(kind=int32), private, save :: z_slab_from_env = VARIABLE_NOT_SET Should Z-slab be used if possible integer(kind=int32), private, save :: y_slab_from_env = VARIABLE_NOT_SET Should Y-slab be used if possible integer(kind=int32), private, save :: n_measure_warmup_iters_from_env = VARIABLE_NOT_SET Number of warmup iterations for measurements integer(kind=int32), private, save :: n_measure_iters_from_env = VARIABLE_NOT_SET Number of measurement iterations logical, private, save :: is_log_enabled = .false. Should we print additional information during plan creation logical, private, save :: is_z_slab_enabled = .true. Should we use Z-slab optimization or not logical, private, save :: is_y_slab_enabled = .false. Should we use Y-slab optimization or not type( dtfft_platform_t ), private, save :: platform = DTFFT_PLATFORM_HOST Default platform integer(kind=int32), private, save :: n_measure_warmup_iters = 2 Number of warmup iterations for measurements integer(kind=int32), private, save :: n_measure_iters = 5 Number of measurement iterations type( dtfft_backend_t ), private, save :: backend_from_env = BACKEND_NOT_SET Backend obtained from environ integer(kind=int32), private, save :: datatype_enabled_from_env = VARIABLE_NOT_SET Should we use MPI Datatype backend during autotune or not integer(kind=int32), private, save :: mpi_enabled_from_env = VARIABLE_NOT_SET Should we use MPI backends during autotune or not integer(kind=int32), private, save :: pipelined_enabled_from_env = VARIABLE_NOT_SET Should we use pipelined backends during autotune or not integer(kind=int32), private, save :: nccl_enabled_from_env = VARIABLE_NOT_SET Should we use NCCL backends during autotune or not integer(kind=int32), private, save :: nvshmem_enabled_from_env = VARIABLE_NOT_SET Should we use NVSHMEM backends during autotune or not integer(kind=int32), private, save :: kernel_optimization_enabled_from_env = VARIABLE_NOT_SET Should we enable kernel block optimization during autotune or not integer(kind=int32), private, save :: n_configs_to_test_from_env = VARIABLE_NOT_SET Number of blocks to test during nvrtc kernel autotune integer(kind=int32), private, save :: forced_kernel_optimization_from_env = VARIABLE_NOT_SET Should we force kernel optimization even when effort is not DTFFT_PATIENT type( dtfft_backend_t ), private, parameter :: DEFAULT_BACKEND = BACKEND_NOT_SET Default backend when cuda is enabled type( dtfft_stream_t ), private, save :: main_stream = NULL_STREAM Default dtFFT CUDA stream type( dtfft_stream_t ), private, save :: custom_stream = NULL_STREAM CUDA stream set by the user logical, private, save :: is_stream_created = .false. Is the default stream created? logical, private, save :: is_custom_stream = .false. Is the custom stream provided by the user? logical, private, save :: is_datatype_enabled = .true. Should we use MPI Datatype backend or not logical, private, save :: is_pipelined_enabled = .true. Should we use pipelined backends or not logical, private, save :: is_mpi_enabled = .false. Should we use MPI backends or not logical, private, save :: is_nccl_enabled = .true. Should we use NCCL backends or not logical, private, save :: is_nvshmem_enabled = .true. Should we use NCCL backends or not logical, private, save :: is_kernel_optimization_enabled = .true. Should we use kernel optimization or not integer(kind=int32), private, save :: n_configs_to_test = 5 Number of different NVRTC kernel configurations to try during autotune logical, private, save :: is_forced_kernel_optimization = .false. Should we use forced kernel optimization or not type( dtfft_backend_t ), private, save :: backend = DEFAULT_BACKEND Default backend character(len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. Interfaces public        interface dtfft_config_t Interface to create a new configuration private pure function config_constructor (enable_log, enable_z_slab, enable_y_slab, n_measure_warmup_iters, n_measure_iters, platform, stream, backend, enable_datatype_backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends, enable_kernel_optimization, n_configs_to_test, force_kernel_optimization) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_log Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_y_slab Should dtFFT use Y-slab optimization or not. integer(kind=int32), intent(in), optional :: n_measure_warmup_iters Number of warmup iterations for measurements integer(kind=int32), intent(in), optional :: n_measure_iters Number of measurement iterations type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_datatype_backend Should DTFFT_BACKEND_MPI_DATATYPE be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_kernel_optimization Should dtFFT try to optimize NVRTC kernel block size during autotune or not. integer(kind=int32), intent(in), optional :: n_configs_to_test Number of top theoretical best performing blocks of threads to test for transposition kernels when effort is DTFFT_PATIENT . logical, intent(in), optional :: force_kernel_optimization Whether to force kernel optimization when effort is not DTFFT_PATIENT . Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config public        interface get_env Obtains environment variable private  function get_env_base (name) result(env) Base function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value type( string ) private  function get_env_string (name, default, valid_values) result(env) Obtains string environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix character(len=*), intent(in) :: default Name of environment variable without prefix type( string ), intent(in) :: valid_values (:) List of valid variable values Return Value type( string ) private  function get_env_int32 (name, default, valid_values, min_valid_value) result(env) Base Integer function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int32), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in), optional :: valid_values (:) List of valid values integer(kind=int32), intent(in), optional :: min_valid_value Mininum valid value. Usually 0 or 1 Return Value integer(kind=int32) private  function get_env_int8 (name, default, valid_values) result(env) Obtains int8 environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int8), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in) :: valid_values (:) List of valid values Return Value integer(kind=int8) private  function get_env_logical (name, default) result(env) Obtains logical environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix logical, intent(in) :: default Default value in case env is not set or it has wrong value Return Value logical private        interface get_conf_internal Returns value from configuration unless environment variable is set private elemental function get_conf_internal_logical (from_conf, from_env) Returns value from configuration unless environment variable is set Arguments Type Intent Optional Attributes Name logical, intent(in) :: from_conf Value from configuration integer(kind=int32), intent(in) :: from_env Value from environment variable Return Value logical private elemental function get_conf_internal_int32 (from_conf, from_env) Returns value from configuration unless environment variable is set Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: from_conf Value from configuration integer(kind=int32), intent(in) :: from_env Value from environment variable Return Value integer(kind=int32) Derived Types type, public, bind(C) :: dtfft_config_t Type that can be used to set additional configuration parameters to dtFFT Components Type Visibility Attributes Name Initial logical(kind=c_bool), public :: enable_log Should dtFFT print additional information during plan creation or not. Read more… logical(kind=c_bool), public :: enable_z_slab Should dtFFT use Z-slab optimization or not. Read more… logical(kind=c_bool), public :: enable_y_slab Should dtFFT use Y-slab optimization or not. Read more… integer(kind=c_int32_t), public :: n_measure_warmup_iters Number of warmup iterations to execute when effort level is higher or equal to DTFFT_MEASURE Read more… integer(kind=c_int32_t), public :: n_measure_iters Number of iterations to execute when effort level is higher or equal to DTFFT_MEASURE Read more… type( dtfft_platform_t ), public :: platform Selects platform to execute plan. Read more… type( dtfft_stream_t ), public :: stream Main CUDA stream that will be used in dtFFT. Read more… type( dtfft_backend_t ), public :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . Read more… logical(kind=c_bool), public :: enable_datatype_backend Should DTFFT_BACKEND_MPI_DATATYPE be enabled when effort is DTFFT_PATIENT or not. Read more… logical(kind=c_bool), public :: enable_mpi_backends Should MPI Backends be enabled when effort is DTFFT_PATIENT or not. Read more… logical(kind=c_bool), public :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. Read more… logical(kind=c_bool), public :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. Read more… logical(kind=c_bool), public :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. Read more… logical(kind=c_bool), public :: enable_kernel_optimization Should dtFFT try to optimize NVRTC kernel block size when effort is DTFFT_PATIENT or not. Read more… integer(kind=c_int32_t), public :: n_configs_to_test Number of top theoretical best performing blocks of threads to test for transposition kernels\nwhen effort is DTFFT_PATIENT or force_kernel_optimization set to true . Read more… logical(kind=c_bool), public :: force_kernel_optimization Whether to force kernel optimization when effort is not DTFFT_PATIENT . Read more… Constructor Interface to create a new configuration private\n\n                    pure\n                    function config_constructor (enable_log, enable_z_slab, enable_y_slab, n_measure_warmup_iters, n_measure_iters, platform, stream, backend, enable_datatype_backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends, enable_kernel_optimization, n_configs_to_test, force_kernel_optimization) Creates a new configuration Functions public  function init_internal () Checks if MPI is initialized and loads environment variables Arguments None Return Value integer(kind=int32) public elemental function get_conf_log_enabled () result(bool) Whether logging is enabled or not Arguments None Return Value logical Result flag public elemental function get_conf_z_slab_enabled () result(bool) Whether Z-slab optimization is enabled or not Arguments None Return Value logical Result flag public elemental function get_conf_y_slab_enabled () result(bool) Whether Y-slab optimization is enabled or not Arguments None Return Value logical Result flag public elemental function get_conf_measure_warmup_iters () result(iters) Returns the number of warmup iterations Arguments None Return Value integer(kind=int32) Result public elemental function get_conf_measure_iters () result(iters) Returns the number of measurement iterations Arguments None Return Value integer(kind=int32) Result public elemental function get_conf_platform () Returns platform set by the user or default one Arguments None Return Value type( dtfft_platform_t ) public  function get_conf_stream () result(stream) Returns either the custom provided by user or creates a new one Arguments None Return Value type( dtfft_stream_t ) public elemental function get_conf_backend () Returns backend set by the user or default one Arguments None Return Value type( dtfft_backend_t ) public elemental function get_conf_datatype_enabled () result(bool) Whether MPI Datatype backend is enabled or not Arguments None Return Value logical Result flag public elemental function get_conf_pipelined_enabled () result(bool) Whether pipelined backends are enabled or not Arguments None Return Value logical Result flag public elemental function get_conf_mpi_enabled () result(bool) Whether MPI backends are enabled or not Arguments None Return Value logical Result flag public elemental function get_conf_nccl_enabled () result(bool) Whether NCCL backends are enabled or not Arguments None Return Value logical Result flag public elemental function get_conf_nvshmem_enabled () result(bool) Whether nvshmem backends are enabled or not Arguments None Return Value logical Result flag public elemental function get_conf_kernel_optimization_enabled () result(bool) Whether kernel optimization is enabled or not Arguments None Return Value logical Result flag public pure function get_conf_configs_to_test () result(n) Returns the number of configurations to test Arguments None Return Value integer(kind=int32) Result public elemental function get_conf_forced_kernel_optimization () result(bool) Whether forced kernel optimization is enabled or not Arguments None Return Value logical Result flag public  function get_datatype_from_env (name) result(env) Obtains datatype id from environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value integer(kind=int8) private pure function config_constructor (enable_log, enable_z_slab, enable_y_slab, n_measure_warmup_iters, n_measure_iters, platform, stream, backend, enable_datatype_backend, enable_mpi_backends, enable_pipelined_backends, enable_nccl_backends, enable_nvshmem_backends, enable_kernel_optimization, n_configs_to_test, force_kernel_optimization) result(config) Creates a new configuration Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: enable_log Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_z_slab Should dtFFT use Z-slab optimization or not. logical, intent(in), optional :: enable_y_slab Should dtFFT use Y-slab optimization or not. integer(kind=int32), intent(in), optional :: n_measure_warmup_iters Number of warmup iterations for measurements integer(kind=int32), intent(in), optional :: n_measure_iters Number of measurement iterations type( dtfft_platform_t ), intent(in), optional :: platform Selects platform to execute plan. type( dtfft_stream_t ), intent(in), optional :: stream Main CUDA stream that will be used in dtFFT. type( dtfft_backend_t ), intent(in), optional :: backend Backend that will be used by dtFFT when effort is DTFFT_ESTIMATE or DTFFT_MEASURE . logical, intent(in), optional :: enable_datatype_backend Should DTFFT_BACKEND_MPI_DATATYPE be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_mpi_backends Should MPI GPU Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_pipelined_backends Should pipelined GPU backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nccl_backends Should NCCL Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_nvshmem_backends Should NVSHMEM Backends be enabled when effort is DTFFT_PATIENT or not. logical, intent(in), optional :: enable_kernel_optimization Should dtFFT try to optimize NVRTC kernel block size during autotune or not. integer(kind=int32), intent(in), optional :: n_configs_to_test Number of top theoretical best performing blocks of threads to test for transposition kernels when effort is DTFFT_PATIENT . logical, intent(in), optional :: force_kernel_optimization Whether to force kernel optimization when effort is not DTFFT_PATIENT . Return Value type( dtfft_config_t ) Constructed dtFFT config ready to be set by call to dtfft_set_config private elemental function get_correct_backend (back) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: back Return Value type( dtfft_backend_t ) private elemental function get_conf_internal_logical (from_conf, from_env) Returns value from configuration unless environment variable is set Arguments Type Intent Optional Attributes Name logical, intent(in) :: from_conf Value from configuration integer(kind=int32), intent(in) :: from_env Value from environment variable Return Value logical private elemental function get_conf_internal_int32 (from_conf, from_env) Returns value from configuration unless environment variable is set Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: from_conf Value from configuration integer(kind=int32), intent(in) :: from_env Value from environment variable Return Value integer(kind=int32) private  function get_env_base (name) result(env) Base function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix Return Value type( string ) private  function get_env_string (name, default, valid_values) result(env) Obtains string environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix character(len=*), intent(in) :: default Name of environment variable without prefix type( string ), intent(in) :: valid_values (:) List of valid variable values Return Value type( string ) private  function get_env_int32 (name, default, valid_values, min_valid_value) result(env) Base Integer function of obtaining dtFFT environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int32), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in), optional :: valid_values (:) List of valid values integer(kind=int32), intent(in), optional :: min_valid_value Mininum valid value. Usually 0 or 1 Return Value integer(kind=int32) private  function get_env_int8 (name, default, valid_values) result(env) Obtains int8 environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix integer(kind=int8), intent(in) :: default Default value in case env is not set or it has wrong value integer(kind=int32), intent(in) :: valid_values (:) List of valid values Return Value integer(kind=int8) private  function get_env_logical (name, default) result(env) Obtains logical environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of environment variable without prefix logical, intent(in) :: default Default value in case env is not set or it has wrong value Return Value logical Subroutines public pure subroutine dtfft_create_config (config) bind(C, name=\"dtfft_create_config_c\") Creates a new configuration and sets default values. Read more… Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(out) :: config Configuration to create public  subroutine dtfft_set_config (config, error_code) Sets configuration parameters Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(in) :: config Configuration to set integer(kind=int32), intent(out), optional :: error_code Error code public  subroutine destroy_stream () Destroy the default stream if it was created Arguments None private  subroutine init_environment () Arguments None","tags":"","loc":"module/dtfft_config.html"},{"title":"dtfft_interface_nvrtc – dtFFT","text":"nvRTC Interfaces. nvRTC is loaded at runtime via dynamic loading due to explicit cuda_driver linking by cmake. Uses dtfft_utils dtfft_errors iso_fortran_env iso_c_binding module~~dtfft_interface_nvrtc~~UsesGraph module~dtfft_interface_nvrtc dtfft_interface_nvrtc iso_c_binding iso_c_binding module~dtfft_interface_nvrtc->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_utils dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_utils->module~dtfft_parameters mpi_f08 mpi_f08 module~dtfft_utils->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_nvrtc~~UsedByGraph module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_interface_nvrtc module~dtfft_kernel_device dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_transpose_handle_generic->module~dtfft_kernel_device Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial procedure( nvrtcCreateProgram_interface ), public, pointer :: nvrtcCreateProgram Fortran pointer to the nvrtcCreateProgram function procedure( nvrtcDestroyProgram_interface ), public, pointer :: nvrtcDestroyProgram Fortran pointer to the nvrtcDestroyProgram function procedure( nvrtcCompileProgram_interface ), public, pointer :: nvrtcCompileProgram Fortran pointer to the nvrtcCompileProgram function procedure( nvrtcGetProgramLogSize_interface ), public, pointer :: nvrtcGetProgramLogSize Fortran pointer to the nvrtcGetProgramLogSize function procedure( nvrtcGetProgramLog_interface ), public, pointer :: nvrtcGetProgramLog Fortran pointer to the nvrtcGetProgramLog function procedure( nvrtcGetCUBINSize_interface ), public, pointer :: nvrtcGetCUBINSize Fortran pointer to the nvrtcGetCUBINSize function procedure( nvrtcGetCUBIN_interface ), public, pointer :: nvrtcGetCUBIN Fortran pointer to the nvrtcGetCUBIN function procedure( nvrtcGetLoweredName_interface ), public, pointer :: nvrtcGetLoweredName Fortran pointer to the nvrtcGetLoweredName function procedure( nvrtcAddNameExpression_interface ), public, pointer :: nvrtcAddNameExpression Fortran pointer to the nvrtcAddNameExpression function integer(kind=int32), private, parameter :: N_FUNCTIONS_TO_LOAD = 10 Number of functions to load from nvrtc library logical, private, save :: is_loaded = .false. Flag indicating whether the library is loaded type(c_ptr), private, save :: libnvrtc Handle to the loaded library type(c_funptr), private, save :: nvrtcFunctions (N_FUNCTIONS_TO_LOAD) Array of pointers to the nvRTC functions procedure( nvrtcGetErrorString_interface ), private, pointer :: nvrtcGetErrorString_c Fortran pointer to the nvrtcGetErrorString function Abstract Interfaces abstract interface private  function nvrtcGetErrorString_interface(error_code) result(string) Helper function that returns a string describing the given nvrtcResult code\nFor unrecognized enumeration values, it returns “NVRTC_ERROR unknown” Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: error_code CUDA Runtime Compilation API result code. Return Value type(c_ptr) Pointer to C string abstract interface private  function nvrtcCreateProgram_interface(prog, src, name, numHeaders, headers, includeNames) result(nvrtcResult) Creates an instance of nvrtcProgram with the given input parameters, \nand sets the output parameter prog with it. Arguments Type Intent Optional Attributes Name type( nvrtcProgram ) :: prog CUDA Runtime Compilation program. character(len=c_char) :: src (*) CUDA program source. character(len=c_char) :: name (*) CUDA program name. integer(kind=c_int), value :: numHeaders Number of headers used. Must be greater than or equal to 0. type(c_ptr), value :: headers Sources of the headers type(c_ptr), value :: includeNames Name of each header by which they can be included in the CUDA program source Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcDestroyProgram_interface(prog) result(nvrtcResult) Destroys the given program. Arguments Type Intent Optional Attributes Name type( nvrtcProgram ) :: prog CUDA Runtime Compilation program. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcCompileProgram_interface(prog, numOptions, options) result(nvrtcResult) Compiles the given program. Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_int), value :: numOptions Number of compiler options passed. type(c_ptr) :: options (*) Compiler options in the form of C string array Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcGetProgramLogSize_interface(prog, logSizeRet) result(nvrtcResult) Sets the value of logSizeRet with the size of the log generated by the previous compilation of prog .\nThe log is a null-terminated string. Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_size_t) :: logSizeRet Size of the compilation log. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcGetProgramLog_interface(prog, log) result(nvrtcResult) Stores the log generated by the previous compilation of prog in the memory pointed by log Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. type(c_ptr), value :: log Compilation log. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcGetCUBINSize_interface(prog, cubinSizeRet) result(nvrtcResult) Sets the value of cubinSizeRet with the size of the cubin generated by the previous compilation of prog . Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. integer(kind=c_size_t) :: cubinSizeRet Size of the generated cubin. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcGetCUBIN_interface(prog, cubin) result(nvrtcResult) Stores the cubin generated by the previous compilation of prog in the memory pointed by cubin . Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. type(c_ptr), value :: cubin Compiled and assembled result. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcGetLoweredName_interface(prog, name_expression, lowered_name) result(nvrtcResult) Extracts the lowered (mangled) name for a global function or device/ constant variable, \nand updates *lowered_name to point to it. Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. character(len=c_char) :: name_expression (*) Name expression. type(c_ptr) :: lowered_name Mangled name. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. abstract interface private  function nvrtcAddNameExpression_interface(prog, name_expression) result(nvrtcResult) Notes the given name expression denoting the address of a global function or device/ constant variable. Arguments Type Intent Optional Attributes Name type( nvrtcProgram ), value :: prog CUDA Runtime Compilation program. character(len=c_char) :: name_expression (*) Name expression. Return Value integer(kind=c_int) The enumerated type nvrtcResult defines API call result codes. Derived Types type, public, bind(C) :: nvrtcProgram nvrtcProgram is the unit of compilation, and an opaque handle for a program. Components Type Visibility Attributes Name Initial type(c_ptr), public :: cptr Actual pointer Functions public  function nvrtcGetErrorString (error_code) result(string) Helper function that returns a string describing the given nvrtcResult code\nFor unrecognized enumeration values, it returns “NVRTC_ERROR unknown” Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: error_code CUDA Runtime Compilation API result code. Return Value character(len=:), allocatable Result string public  function load_nvrtc () result(error_code) Dynamically loads nvRTC library and its functions Arguments None Return Value integer(kind=int32) Error code","tags":"","loc":"module/dtfft_interface_nvrtc.html"},{"title":"dtfft_interface_cuda – dtFFT","text":"CUDA Driver Interfaces CUDA Driver is loaded at runtime via dynamic loading. Uses dtfft_parameters dtfft_errors dtfft_utils iso_fortran_env iso_c_binding module~~dtfft_interface_cuda~~UsesGraph module~dtfft_interface_cuda dtfft_interface_cuda iso_c_binding iso_c_binding module~dtfft_interface_cuda->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_cuda->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_cuda~~UsedByGraph module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_interface_cuda module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: MAX_KERNEL_ARGS = 9 procedure( cuModuleLoadData_interface ), public, pointer :: cuModuleLoadData Fortran pointer to the cuModuleLoadData function procedure( cuModuleUnload_interface ), public, pointer :: cuModuleUnload Fortran pointer to the cuModuleUnload function procedure( cuModuleGetFunction_interface ), public, pointer :: cuModuleGetFunction Fortran pointer to the cuModuleGetFunction function logical, private, save :: is_loaded = .false. Flag indicating whether the library is loaded type(c_ptr), private, save :: libcuda Handle to the loaded library type(c_funptr), private, save :: cuFunctions (4) Array of pointers to the CUDA functions procedure( cuLaunchKernel_interface ), private, pointer :: cuLaunchKernel_ Fortran pointer to the cuLaunchKernel function Abstract Interfaces abstract interface private  function cuModuleLoadData_interface(mod, image) result(cuResult) Load a module’s data with options. Takes a pointer image and loads the corresponding module module into the current context. \nThe image may be a cubin or fatbin as output by nvcc, or a NULL-terminated PTX, either as output by nvcc or hand-written. Arguments Type Intent Optional Attributes Name type( CUmodule ) :: mod Returned module type(c_ptr), value :: image Module data to load Return Value integer(kind=c_int) Driver result code abstract interface private  function cuModuleUnload_interface(hmod) result(cuResult) Unloads a module. Unloads a module hmod from the current context. \nAttempting to unload a module which was obtained from the Library Management API \nsuch as cuLibraryGetModule will return CUDA_ERROR_NOT_PERMITTED . Arguments Type Intent Optional Attributes Name type( CUmodule ), value :: hmod Module to unload Return Value integer(kind=c_int) Driver result code abstract interface private  function cuModuleGetFunction_interface(hfunc, hmod, name) result(cuResult) Returns a function handle. Returns in hfunc the handle of the function of name name located in module hmod.\nIf no function of that name exists, cuModuleGetFunction returns CUDA_ERROR_NOT_FOUND . Arguments Type Intent Optional Attributes Name type( CUfunction ) :: hfunc Returns a function handle. type( CUmodule ), value :: hmod Module to retrieve function from type(c_ptr), value :: name Name of function to retrieve Return Value integer(kind=c_int) Driver result code abstract interface private  function cuLaunchKernel_interface(func, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, stream, kernelParams, extra) result(cuResult) Launches a CUDA function CUfunction. Arguments Type Intent Optional Attributes Name type( CUfunction ), value :: func CUDA function to launch integer(kind=c_int), value :: gridDimX Grid dimensions in X integer(kind=c_int), value :: gridDimY Grid dimensions in Y integer(kind=c_int), value :: gridDimZ Grid dimensions in Z integer(kind=c_int), value :: blockDimX Block dimensions in X integer(kind=c_int), value :: blockDimY Block dimensions in Y integer(kind=c_int), value :: blockDimZ Block dimensions in Z integer(kind=c_int), value :: sharedMemBytes Dynamic shared memory size type( dtfft_stream_t ), value :: stream Stream identifier type(c_ptr) :: kernelParams (*) Array of pointers to kernel parameters type(c_ptr) :: extra Dynamic shared-memory size per thread block in bytes Return Value integer(kind=c_int) Driver result code Derived Types type, public, bind(C) :: dim3 Dimension specification type Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: x integer(kind=c_int), public :: y integer(kind=c_int), public :: z type, public, bind(C) :: CUmodule CUDA module Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr Actual pointer type, public, bind(C) :: CUfunction CUDA function Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr Actual pointer Functions public  function load_cuda () result(error_code) Loads the CUDA Driver library and needed symbols Arguments None Return Value integer(kind=int32) Error code public  function cuLaunchKernel (func, in, out, blocks, threads, stream, nargs, args) result(cuResult) Launches a CUDA kernel Arguments Type Intent Optional Attributes Name type( CUfunction ), intent(in) :: func Function CUfunction or Kernel CUkernel to launch type(c_ptr), intent(in), target :: in Input pointer type(c_ptr), intent(in), target :: out Output pointer type( dim3 ), intent(in) :: blocks Grid in blocks type( dim3 ), intent(in) :: threads Thread block type( dtfft_stream_t ), intent(in) :: stream Stream identifier integer(kind=int32), intent(in) :: nargs integer(kind=int32), intent(in), target :: args (MAX_KERNEL_ARGS) Input parameters of kernel func Return Value integer(kind=c_int) Driver result code","tags":"","loc":"module/dtfft_interface_cuda.html"},{"title":"dtfft_executor_vkfft_m – dtFFT","text":"This module describes VkFFT based FFT Executor: vkfft_executor https://github.com/DTolm/VkFFT/tree/master Uses dtfft_interface_vkfft_m dtfft_parameters dtfft_abstract_executor dtfft_errors dtfft_config iso_fortran_env iso_c_binding module~~dtfft_executor_vkfft_m~~UsesGraph module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m iso_c_binding iso_c_binding module~dtfft_executor_vkfft_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_executor_vkfft_m->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_config dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_parameters dtfft_parameters module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_pencil dtfft_pencil module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_interface_vkfft_m->iso_c_binding module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_executor_vkfft_m~~UsedByGraph module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_executor ) :: vkfft_executor vkFFT FFT Executor Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile type( vkfft_wrapper ), private, pointer :: wrapper => null() VkFFT Wrapper logical, private :: is_inverse_required Should be create separate inverse FFT Plan or not Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure, public, pass(self) :: create_private => create ../../ Creates FFT plan via vkFFT Interface procedure, public, pass(self) :: execute_private => execute ../../ Executes vkFFT plan procedure, public, pass(self) :: destroy_private => destroy ../../ Destroys vkFFT plan procedure, public, nopass :: mem_alloc ../../ Dummy method. Raises error stop procedure, public, nopass :: mem_free ../../ Dummy method. Raises error stop Subroutines private  subroutine create (self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan via vkFFT Interface Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform private  subroutine execute (self, a, b, sign) Executes vkFFT plan Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(in) :: self vkFFT FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys vkFFT plan Arguments Type Intent Optional Attributes Name class( vkfft_executor ), intent(inout) :: self vkFFT FFT Executor private  subroutine mem_alloc (alloc_bytes, ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer private  subroutine mem_free (ptr) Dummy method. Raises error stop Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free","tags":"","loc":"module/dtfft_executor_vkfft_m.html"},{"title":"dtfft_api – dtFFT","text":"This module is a Fortran part of C interface Uses dtfft_parameters dtfft_errors dtfft_config dtfft_plan iso_fortran_env dtfft_pencil dtfft_utils iso_c_binding mpi_f08 module~~dtfft_api~~UsesGraph module~dtfft_api dtfft_api iso_c_binding iso_c_binding module~dtfft_api->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_api->iso_fortran_env module~dtfft_config dtfft_config module~dtfft_api->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_api->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_api->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_api->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft_api->module~dtfft_plan module~dtfft_utils dtfft_utils module~dtfft_api->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_api->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_plan->iso_c_binding module~dtfft_plan->iso_fortran_env module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_errors module~dtfft_plan->module~dtfft_parameters module~dtfft_plan->module~dtfft_pencil module~dtfft_plan->module~dtfft_utils module~dtfft_plan->mpi_f08 module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_executor_cufft_m->iso_c_binding module~dtfft_executor_cufft_m->iso_fortran_env module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->mpi_f08 module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m->iso_c_binding module~dtfft_executor_fftw_m->iso_fortran_env module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_executor_mkl_m->iso_c_binding module~dtfft_executor_mkl_m->iso_fortran_env module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_executor_mkl_m->mpi_f08 module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_executor_vkfft_m->iso_c_binding module~dtfft_executor_vkfft_m->iso_fortran_env module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvshmem->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_transpose_plan->iso_c_binding module~dtfft_transpose_plan->iso_fortran_env module~dtfft_transpose_plan->module~dtfft_config module~dtfft_transpose_plan->module~dtfft_errors module~dtfft_transpose_plan->module~dtfft_parameters module~dtfft_transpose_plan->module~dtfft_pencil module~dtfft_transpose_plan->module~dtfft_utils module~dtfft_transpose_plan->mpi_f08 module~dtfft_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_transpose_plan->module~dtfft_interface_nvtx module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_transpose_plan->module~dtfft_interface_cuda module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_transpose_plan->module~dtfft_interface_nvrtc module~dtfft_kernel_device dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_config module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_abstract_transpose_handle->iso_fortran_env module~dtfft_abstract_transpose_handle->module~dtfft_parameters module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_abstract_transpose_handle->mpi_f08 module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_fftw_m->iso_c_binding dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_interface_mkl_m->module~dtfft_utils MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_vkfft_m->iso_c_binding module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_kernel_device->iso_c_binding module~dtfft_kernel_device->iso_fortran_env module~dtfft_kernel_device->module~dtfft_config module~dtfft_kernel_device->module~dtfft_parameters module~dtfft_kernel_device->module~dtfft_utils module~dtfft_kernel_device->mpi_f08 module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_transpose_handle_datatype->iso_fortran_env module~dtfft_transpose_handle_datatype->module~dtfft_errors module~dtfft_transpose_handle_datatype->module~dtfft_parameters module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_transpose_handle_datatype->module~dtfft_utils module~dtfft_transpose_handle_datatype->mpi_f08 module~dtfft_transpose_handle_datatype->module~dtfft_interface_nvtx module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->iso_c_binding module~dtfft_transpose_handle_generic->iso_fortran_env module~dtfft_transpose_handle_generic->module~dtfft_errors module~dtfft_transpose_handle_generic->module~dtfft_parameters module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_transpose_handle_generic->module~dtfft_utils module~dtfft_transpose_handle_generic->mpi_f08 module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_kernel_host dtfft_kernel_host module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_errors module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_errors module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_errors module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_kernel_host->iso_c_binding module~dtfft_kernel_host->iso_fortran_env module~dtfft_kernel_host->module~dtfft_parameters module~dtfft_kernel_host->mpi_f08 module~dtfft_kernel_host->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->iso_fortran_env module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->iso_c_binding module~dtfft_nvrtc_module_cache->iso_fortran_env module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_utils module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_nvrtc_module->iso_c_binding module~dtfft_nvrtc_module->iso_fortran_env module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_parameters module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_nvrtc_module->mpi_f08 module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, private :: plan_c C pointer to Fortran plan Components Type Visibility Attributes Name Initial class( dtfft_plan_t ), public, allocatable :: p Actual Fortran plan Functions private pure function get_comm (c_comm) Converts C communicator to Fortran communicator Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: c_comm C communicator Return Value type(mpi_comm) private  function dtfft_create_plan_r2r_c (ndims, dims, kinds, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates R2R dtFFT Plan, allocates all structures and prepares FFT, C interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: ndims Rank of transform. Can be 2 or 3. type(c_ptr), intent(in), value :: dims Global sizes of transform type(c_ptr), intent(in), value :: kinds FFT R2R kinds integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_create_plan_r2r_pencil_c (pencil, kinds, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates R2R dtFFT Plan from Pencil, allocates all structures and prepares FFT, C interface Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: pencil C pointer to Fortran pencil type(c_ptr), intent(in), value :: kinds FFT R2R kinds integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_create_plan_c2c_c (ndims, dims, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates C2C dtFFT Plan, allocates all structures and prepares FFT, C interface Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: ndims Rank of transform. Can be 2 or 3. type(c_ptr), intent(in), value :: dims Global sizes of transform integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_create_plan_c2c_pencil_c (pencil, comm, precision, effort, executor, plan_ptr) result(error_code) bind(C) Creates C2C dtFFT plan from Pencil, allocates all structures and prepares FFT, C interface Arguments Type Intent Optional Attributes Name type( dtfft_pencil_c ), intent(in) :: pencil C pointer to Fortran pencil integer(kind=c_int32_t), intent(in), value :: comm Communicator type( dtfft_precision_t ), intent(in) :: precision Precision of transform type( dtfft_effort_t ), intent(in) :: effort dtFFT planner effort type type( dtfft_executor_t ), intent(in) :: executor Type of External FFT Executor type(c_ptr), intent(out) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_z_slab_enabled_c (plan_ptr, is_z_slab_enabled) result(error_code) bind(C) Checks if dtFFT Plan is using Z-slab optimization Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan logical(kind=c_bool), intent(out) :: is_z_slab_enabled Is plan internally using Z-slab optimization Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_y_slab_enabled_c (plan_ptr, is_y_slab_enabled) result(error_code) bind(C) Checks if dtFFT Plan is using Y-slab optimization Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan logical(kind=c_bool), intent(out) :: is_y_slab_enabled Is plan internally using Y-slab optimization Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_execute_c (plan_ptr, in, out, execute_type, aux) result(error_code) bind(C) Executes dtFFT Plan, C interface. aux can be NULL. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_execute_t ), intent(in) :: execute_type Type of execution type(c_ptr), intent(in), value :: aux Aux buffer, can be NULL Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_transpose_c (plan_ptr, in, out, transpose_type) result(error_code) bind(C) Executes single transposition, C interface. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_transpose_start_c (plan_ptr, in, out, transpose_type, request) result(error_code) bind(C) Starts asynchronous transposition, returns transpose handle, C interface. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type(c_ptr), intent(in), value :: in Incomming pointer, not NULL type(c_ptr), intent(in), value :: out Outgoing buffer, not NULL type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transposition. type( dtfft_request_t ), intent(out) :: request Async transpose handle Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_transpose_end_c (plan_ptr, request) result(error_code) bind(C) Finishes asynchronous transposition, C interface. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: plan_ptr C pointer to Fortran plan type( dtfft_request_t ), intent(inout) :: request Async transpose handle Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_destroy_c (plan_ptr) result(error_code) bind(C) Destroys dtFFT Plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr) :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_local_sizes_c (plan_ptr, in_starts, in_counts, out_starts, out_counts, alloc_size) result(error_code) bind(C) Returns local sizes, counts in real and Fourier spaces and number of elements to be allocated for in and out buffers,\nC interface. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int32_t), intent(out), optional :: in_starts (3) Starts of local portion of data in ‘real’ space integer(kind=c_int32_t), intent(out), optional :: in_counts (3) Counts of local portion of data in ‘real’ space integer(kind=c_int32_t), intent(out), optional :: out_starts (3) Starts of local portion of data in ‘fourier’ space integer(kind=c_int32_t), intent(out), optional :: out_counts (3) Counts of local portion of data in ‘fourier’ space integer(kind=c_size_t), intent(out), optional :: alloc_size Minimum data needs to be allocated Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_alloc_size_c (plan_ptr, alloc_size) result(error_code) bind(C) Returns minimum number of bytes to be allocated for in and out buffers, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: alloc_size Minimum data needs to be allocated Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_pencil_c (plan_ptr, dim, pencil) result(error_code) bind(C) Returns pencil decomposition info, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int32_t), intent(in) :: dim Dimension requested type( dtfft_pencil_c ) :: pencil Pencil pointer Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_element_size_c (plan_ptr, element_size) result(error_code) bind(C) Returns size of element in bytes, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: element_size Size of element in bytes Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_alloc_bytes_c (plan_ptr, alloc_bytes) result(error_code) bind(C) Returns minimum number of bytes required to execute plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), intent(out) :: alloc_bytes Number of bytes required Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_executor_c (plan_ptr, executor) result(error_code) bind(C) Returns executor type used in plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_executor_t ), intent(out) :: executor The enumerated type dtfft_executor_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_precision_c (plan_ptr, precision) result(error_code) bind(C) Returns precision used in plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_precision_t ), intent(out) :: precision The enumerated type dtfft_precision_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_dims_c (plan_ptr, ndims, dims) result(error_code) bind(C) Returns dimensions of plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int8_t), intent(out) :: ndims Number of dimensions type(c_ptr), intent(out) :: dims Array of dimensions Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_grid_dims_c (plan_ptr, ndims, grid_dims) result(error_code) bind(C) Returns grid decomposition dimensions of plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_int8_t), intent(out) :: ndims Number of dimensions type(c_ptr), intent(out) :: grid_dims Array of dimensions Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_set_config_c (config) result(error_code) bind(C) Sets dtFFT configuration, C interface Arguments Type Intent Optional Attributes Name type( dtfft_config_t ), intent(in) :: config Configuration to set Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_report_c (plan_ptr) result(error_code) bind(C) Reports dtFFT Plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_mem_alloc_c (plan_ptr, alloc_bytes, ptr) result(error_code) bind(C) Allocates memory for dtFFT Plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan integer(kind=c_size_t), value :: alloc_bytes Number of bytes to allocate type(c_ptr) :: ptr Allocated pointer Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_mem_free_c (plan_ptr, ptr) result(error_code) bind(C) Frees memory for dtFFT Plan, C interface Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type(c_ptr), value :: ptr Pointer to deallocate Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_backend_c (plan_ptr, backend) result(error_code) bind(C) Returns selected dtfft_backend_t during autotuning Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_backend_t ), intent(out) :: backend The enumerated type dtfft_backend_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_stream_c (plan_ptr, stream) result(error_code) bind(C) Returns Stream associated with plan Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_stream_t ), intent(out) :: stream CUDA stream Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. private  function dtfft_get_platform_c (plan_ptr, platform) result(error_code) bind(C) Returns selected dtfft_platform_t during autotuning Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan_ptr C pointer to Fortran plan type( dtfft_platform_t ), intent(out) :: platform The enumerated type dtfft_platform_t Return Value integer(kind=c_int32_t) The enumerated type dtfft_error_t\ndefines API call result codes. Subroutines private  subroutine dtfft_get_error_string_c (error_code, error_string, error_string_size) bind(C) Returns an explaination of error_code that could have been previously returned by one of dtFFT API calls,\nC interface Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: error_code The enumerated type dtfft_error_t\ndefines API call result codes. character(len=c_char), intent(out) :: error_string (*) Explanation of error integer(kind=c_size_t), intent(out) :: error_string_size Size of error_string private  subroutine dtfft_get_precision_string_c (precision, precision_string, precision_string_size) bind(C) Returns string representation of dtfft_precision_t , C interface Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: precision The enumerated type dtfft_precision_t character(len=c_char), intent(out) :: precision_string (*) Resulting string integer(kind=c_size_t), intent(out) :: precision_string_size Size of string private  subroutine dtfft_get_executor_string_c (executor, executor_string, executor_string_size) bind(C) Returns string representation of dtfft_executor_t , C interface Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: executor The enumerated type dtfft_executor_t character(len=c_char), intent(out) :: executor_string (*) Resulting string integer(kind=c_size_t), intent(out) :: executor_string_size Size of string private  subroutine dtfft_get_backend_string_c (backend, backend_string, backend_string_size) bind(C) Returns string representation of dtfft_backend_t Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: backend The enumerated type dtfft_backend_t character(len=c_char), intent(out) :: backend_string (*) Resulting string integer(kind=c_size_t), intent(out) :: backend_string_size Size of string","tags":"","loc":"module/dtfft_api.html"},{"title":"dtfft_interface_nvshmem – dtFFT","text":"NVSHMEM Interfaces Uses dtfft_parameters dtfft_utils iso_fortran_env iso_c_binding mpi_f08 module~~dtfft_interface_nvshmem~~UsesGraph module~dtfft_interface_nvshmem dtfft_interface_nvshmem iso_c_binding iso_c_binding module~dtfft_interface_nvshmem->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_parameters dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_nvshmem->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_interface_nvshmem->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_nvshmem~~UsedByGraph module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( nvshmem_team_t ), public, parameter :: NVSHMEM_TEAM_WORLD = nvshmem_team_t(0) Global NVSHMEM team. logical, private, save :: is_init = .false. Flag indicating whether NVSHMEM is initialized logical, private, save :: is_external_init = .false. Flag indicating whether NVSHMEM was initialized externally Interfaces interface public  function nvshmem_malloc(size) result(ptr) bind(C) Allocates symmetric memory in the NVSHMEM heap. Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: size Size of the allocation in bytes. Return Value type(c_ptr) Pointer to the allocated memory. public        interface nvshmem_free private  subroutine nvshmem_free(ptr) bind(C) Frees symmetric memory allocated by nvshmem_malloc. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to the memory to free. interface public  subroutine nvshmemx_sync_all_on_stream(stream) bind(C) Synchronizes all PEs (Processing Elements) on the specified stream. Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), intent(in), value :: stream CUDA stream for synchronization. interface public  function nvshmemx_float_alltoall_on_stream(team, dest, source, nelems, stream) result(ierr) bind(C) Performs an all-to-all exchange of floating-point data on the specified stream. Arguments Type Intent Optional Attributes Name type( nvshmem_team_t ), intent(in), value :: team NVSHMEM team. type(c_ptr), value :: dest Destination buffer. type(c_ptr), value :: source Source buffer. integer(kind=c_size_t), intent(in), value :: nelems Number of elements to exchange. type( dtfft_stream_t ), intent(in), value :: stream CUDA stream for the operation. Return Value integer(kind=c_int) Completion status. interface public  function nvshmem_ptr(ptr, pe) result(pe_ptr) bind(C) Returns a pointer to a symmetric memory location on a specified PE. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Local pointer to the symmetric memory. integer(kind=c_int), value :: pe PE (Processing Element) number. Return Value type(c_ptr) Pointer to the symmetric memory on the specified PE. interface public  function nvshmem_my_pe() result(pe) bind(C) Returns the PE (Processing Element) number of the calling thread. Arguments None Return Value integer(kind=c_int) PE number of the calling thread. interface private  function nvshmemx_init_status() result(status) bind(C) Arguments None Return Value integer(kind=c_int) Completion status. interface private  subroutine init_nvshmem(comm) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: comm MPI communicator (C handle) interface private  subroutine nvshmem_finalize_() bind(C, name=\"nvshmemi_finalize\") Finalizes the NVSHMEM library. Arguments None Derived Types type, public, bind(C) :: nvshmem_team_t NVSHMEM team. Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal representation of the NVSHMEM team. Functions public  function is_nvshmem_ptr (ptr) result(bool) Checks if pointer is a symmetric nvshmem allocated pointer Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr Device pointer Return Value logical Result","tags":"","loc":"module/dtfft_interface_nvshmem.html"},{"title":"dtfft_interface_cufft – dtFFT","text":"cuFFT Interfaces Uses dtfft_utils dtfft_parameters iso_fortran_env iso_c_binding module~~dtfft_interface_cufft~~UsesGraph module~dtfft_interface_cufft dtfft_interface_cufft iso_c_binding iso_c_binding module~dtfft_interface_cufft->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_interface_cufft->iso_fortran_env module~dtfft_parameters dtfft_parameters module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_cufft~~UsedByGraph module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public, parameter :: CUFFT_COMM_MPI = 0 Enumerations enum, bind(c) Enumerators enumerator :: CUFFT_R2C = 42 enumerator :: CUFFT_C2R = 44 enumerator :: CUFFT_C2C = 41 enumerator :: CUFFT_D2Z = 106 enumerator :: CUFFT_Z2D = 108 enumerator :: CUFFT_Z2Z = 105 enum, bind(c) Enumerators enumerator :: CUFFT_SUCCESS = 0 enumerator :: CUFFT_INVALID_PLAN = 1 enumerator :: CUFFT_ALLOC_FAILED = 2 enumerator :: CUFFT_INVALID_TYPE = 3 enumerator :: CUFFT_INVALID_VALUE = 4 enumerator :: CUFFT_INTERNAL_ERROR = 5 enumerator :: CUFFT_EXEC_FAILED = 6 enumerator :: CUFFT_SETUP_FAILED = 7 enumerator :: CUFFT_INVALID_SIZE = 8 enumerator :: CUFFT_UNALIGNED_DATA = 9 enumerator :: CUFFT_INCOMPLETE_PARAMETER_LIST = 10 enumerator :: CUFFT_INVALID_DEVICE = 11 enumerator :: CUFFT_PARSE_ERROR = 12 enumerator :: CUFFT_NO_WORKSPACE = 13 enumerator :: CUFFT_NOT_IMPLEMENTED = 14 enumerator :: CUFFT_LICENSE_ERROR = 15 enumerator :: CUFFT_NOT_SUPPORTED = 16 Interfaces interface Creates a FFT plan configuration of dimension rank, with sizes specified in the array n. public  function cufftPlanMany(plan, rank, n, inembed, istride, idist, onembed, ostride, odist, ffttype, batch) result(cufftResult) bind(C, name=\"cufftPlanMany\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: plan Pointer to an uninitialized cufftHandle object. integer(kind=c_int), value :: rank Dimensionality of the transform (1, 2, or 3). integer(kind=c_int) :: n (*) Array of size rank, describing the size of each dimension,\nn[0] being the size of the outermost\nand n[rank-1] innermost (contiguous) dimension of a transform. integer(kind=c_int) :: inembed (*) Pointer of size rank that indicates the storage dimensions of the input data in memory.\nIf set to NULL, all other advanced data layout parameters are ignored. integer(kind=c_int), value :: istride Indicates the distance between two successive input elements in the least\nsignificant (i.e., innermost) dimension. integer(kind=c_int), value :: idist Indicates the distance between the first element of two consecutive signals\nin a batch of the input data. integer(kind=c_int) :: onembed (*) Pointer of size rank that indicates the storage dimensions of the output data in memory.\nIf set to NULL, all other advanced data layout parameters are ignored. integer(kind=c_int), value :: ostride Indicates the distance between two successive output elements in the output array\nin the least significant (i.e., innermost) dimension. integer(kind=c_int), value :: odist Indicates the distance between the first element of two consecutive signals\nin a batch of the output data. integer(kind=c_int), value :: ffttype The transform data type (e.g., CUFFT_R2C for single precision real to complex). integer(kind=c_int), value :: batch Batch size for this transform. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Executes any cuFFT transform regardless of precision and type.\nIn case of complex-to-real and real-to-complex transforms, the direction parameter is ignored. public  function cufftXtExec(plan, input, output, direction) result(cufftResult) bind(C, name=\"cufftXtExec\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan cufftHandle returned by cufftCreate. type(c_ptr), value :: input Pointer to the input data (in GPU memory) to transform. type(c_ptr), value :: output Pointer to the output data (in GPU memory). integer(kind=c_int), value :: direction The transform direction: CUFFT_FORWARD or CUFFT_INVERSE.\nIgnored for complex-to-real and real-to-complex transforms. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Frees all GPU resources associated with a cuFFT plan and destroys the internal plan data structure. public  function cufftDestroy(plan) result(cufftResult) bind(C, name=\"cufftDestroy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Object of the plan to be destroyed. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Associates a CUDA stream with a cuFFT plan. public  function cufftSetStream(plan, stream) result(cufftResult) bind(C, name=\"cufftSetStream\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan Object to associate with the stream. type( dtfft_stream_t ), value :: stream A valid CUDA stream. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Initializes a reshape handle for future use. This function is not collective. public  function cufftMpCreateReshape(reshapeHandle) result(cufftResult) bind(C, name=\"cufftMpCreateReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ) :: reshapeHandle The reshape handle. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Attaches a communication handle to a reshape. This function is not collective. public  function cufftMpAttachReshapeComm(reshapeHandle, commType, comm) result(cufftResult) bind(C, name=\"cufftMpAttachReshapeComm\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_int), value :: commType An enum describing the communication type of the handle. type(c_ptr) :: comm If commType is CUFFT_COMM_MPI, this should be a pointer to an MPI communicator.\nThe pointer should remain valid until destruction of the handle.\nOtherwise, this should be NULL. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Returns the amount (in bytes) of workspace required to execute the handle. public  function cufftMpGetReshapeSize(reshapeHandle, workSize) result(cufftResult) bind(C, name=\"cufftMpGetReshapeSize\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_size_t) :: workSize The size, in bytes, of the workspace required during reshape execution. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Creates a reshape intended to re-distribute a global array of 3D data. public  function cufftMpMakeReshape(reshapeHandle, elementSize, rank, lower_input, upper_input, lower_output, upper_output, strides_input, strides_output) result(cufftResult) bind(C, name=\"cufftMpMakeReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. integer(kind=c_long_long), value :: elementSize The size of the individual elements, in bytes. Allowed values are 4, 8, and 16. integer(kind=c_int), value :: rank The length of the lower_input, upper_input, lower_output, upper_output, strides_input, and strides_output arrays. rank should be 3. integer(kind=c_long_long) :: lower_input (*) An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer(kind=c_long_long) :: upper_input (*) An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer(kind=c_long_long) :: lower_output (*) An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer(kind=c_long_long) :: upper_output (*) An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer(kind=c_long_long) :: strides_input (*) An array of length rank, representing the local data layout of the input descriptor in memory. All entries must be decreasing and positive. integer(kind=c_long_long) :: strides_output (*) An array of length rank, representing the local data layout of the output descriptor in memory. All entries must be decreasing and positive. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Executes the reshape, redistributing data_in into data_out using the workspace in workspace. public  function cufftMpExecReshapeAsync(reshapeHandle, dataOut, dataIn, workSpace, stream) result(cufftResult) bind(C, name=\"cufftMpExecReshapeAsync\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. type(c_ptr), value :: dataOut A symmetric-heap pointer to the output data. This memory should be NVSHMEM allocated and identical on all processes. type(c_ptr), value :: dataIn A symmetric-heap pointer to the input data. This memory should be NVSHMEM allocated and identical on all processes. type(c_ptr), value :: workSpace A symmetric-heap pointer to the workspace data. This memory should be NVSHMEM allocated and identical on all processes. type( dtfft_stream_t ), value :: stream The CUDA stream in which to run the reshape operation. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. interface Destroys a reshape and all its associated data. public  function cufftMpDestroyReshape(reshapeHandle) result(cufftResult) bind(C, name=\"cufftMpDestroyReshape\") Arguments Type Intent Optional Attributes Name type( cufftReshapeHandle ), value :: reshapeHandle The reshape handle. Return Value integer(kind=c_int) The enumerated type cufftResult defines API call result codes. Derived Types type, public, bind(C) :: cufftReshapeHandle An opaque handle to a reshape operation. Components Type Visibility Attributes Name Initial type(c_ptr), public :: cptr Functions public  function cufftGetErrorString (error_code) result(string) Returns a string representation of the cuFFT error code. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: error_code cuFFT error code Return Value character(len=:), allocatable String representation of the cuFFT error code","tags":"","loc":"module/dtfft_interface_cufft.html"},{"title":"dtfft_backend_mpi – dtFFT","text":"MPI Based Backends backend_mpi Uses dtfft_interface_nvtx dtfft_parameters dtfft_errors iso_fortran_env dtfft_utils dtfft_abstract_backend dtfft_interface_cuda_runtime iso_c_binding mpi_f08 module~~dtfft_backend_mpi~~UsesGraph module~dtfft_backend_mpi dtfft_backend_mpi iso_c_binding iso_c_binding module~dtfft_backend_mpi->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_backend_mpi->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_errors dtfft_errors module~dtfft_backend_mpi->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_backend_mpi->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_backend_mpi->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_abstract_backend->module~dtfft_config module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_backend_mpi~~UsedByGraph module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_backend ) :: backend_mpi MPI Backend Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type type( dtfft_platform_t ), public :: platform Platform to use logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer class( abstract_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data logical, private :: is_active If async transpose is active type( mpi_backend_helper ), private :: send MPI Helper for send data type( mpi_backend_helper ), private :: recv MPI Helper for recv data logical, private :: is_rma Using RMA backend type(MPI_Win), private :: win MPI Window for RMA backend logical, private :: is_request_created Request created flag. Used for persistent functions Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates Abstract Backend procedure, public, non_overridable, pass(self) :: execute ../../ Executes Backend procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys Abstract Backend procedure, public, non_overridable, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, non_overridable, pass(self) :: set_unpack_kernel ../../ Sets unpack kernel for pipelined backend procedure, public :: create_private => create_mpi ../../ Creates MPI backend procedure, public :: execute_private => execute_mpi ../../ Executes MPI backend procedure, public :: destroy_private => destroy_mpi ../../ Destroys MPI backend procedure, public :: execute_end => execute_end_mpi ../../ Finalizes async transpose procedure, public :: get_async_active ../../ Overrides abstract method and returns if async transpose is active type, private :: mpi_backend_helper MPI Helper Components Type Visibility Attributes Name Initial integer(kind=CNT_KIND), public, allocatable :: counts (:) Counts of data to send or recv integer(kind=ADDR_KIND), public, allocatable :: displs (:) Displacements of data to send or recv type(MPI_Request), public, allocatable :: requests (:) MPI Requests integer(kind=int32), public, allocatable :: process_map (:) Process map for pipelined communication integer(kind=int32), public :: n_requests Number of requests Type-Bound Procedures procedure, public, pass(self) :: create => create_helper ../../ Creates MPI helper procedure, public, pass(self) :: destroy => destroy_helper ../../ Destroys MPI helper Functions private elemental function get_async_active (self) Returns if async transpose is active Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(in) :: self MPI Backend Return Value logical Subroutines private  subroutine create_helper (self, counts, displs, max_requests) Creates MPI helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper integer(kind=int64), intent(in) :: counts (:) Counts of data to send or recv integer(kind=int64), intent(in) :: displs (:) Displacements of data to send or recv integer(kind=int32), intent(in) :: max_requests Maximum number of requests required private  subroutine destroy_helper (self, is_request_created) Destroys MPI helper Arguments Type Intent Optional Attributes Name class( mpi_backend_helper ), intent(inout) :: self MPI Helper logical, intent(in) :: is_request_created private  subroutine create_mpi (self, helper, base_storage) Creates MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend type( backend_helper ), intent(in) :: helper Backend helper (unused) integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) private  subroutine destroy_mpi (self) Destroys MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend private  subroutine execute_mpi (self, in, out, stream, aux, exec_type, error_code) Executes MPI backend Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code private  subroutine execute_end_mpi (self, error_code) Arguments Type Intent Optional Attributes Name class( backend_mpi ), intent(inout) :: self MPI Backend integer(kind=int32), intent(out) :: error_code Error code private  subroutine run_mpi_p2p (comm, send, recv, in, out, is_request_created) Executes MPI point-to-point communication Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI communicator type( mpi_backend_helper ), intent(inout) :: send MPI Helper for send data type( mpi_backend_helper ), intent(inout) :: recv MPI Helper for recv data real(kind=real32), intent(in) :: in (:) Data to be sent real(kind=real32), intent(inout) :: out (:) Data to be received logical, intent(inout) :: is_request_created private  subroutine run_mpi_a2a (comm, send, recv, in, out, is_request_created) Executes MPI all-to-all communication Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: comm MPI communicator type( mpi_backend_helper ), intent(inout) :: send MPI Helper for send data type( mpi_backend_helper ), intent(inout) :: recv MPI Helper for recv data real(kind=real32), intent(in) :: in (:) Data to be sent real(kind=real32), intent(inout) :: out (:) Data to be received logical, intent(inout) :: is_request_created","tags":"","loc":"module/dtfft_backend_mpi.html"},{"title":"dtfft_kernel_host – dtFFT","text":"This module defines kernel_host type and its type bound procedures.\nThe host kernel is an implementation of the abstract_kernel type\nthat runs on the host CPU. Uses dtfft_parameters iso_fortran_env dtfft_abstract_kernel iso_c_binding mpi_f08 module~~dtfft_kernel_host~~UsesGraph module~dtfft_kernel_host dtfft_kernel_host iso_c_binding iso_c_binding module~dtfft_kernel_host->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_kernel_host->iso_fortran_env module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_kernel_host->module~dtfft_abstract_kernel module~dtfft_parameters dtfft_parameters module~dtfft_kernel_host->module~dtfft_parameters mpi_f08 mpi_f08 module~dtfft_kernel_host->mpi_f08 module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->mpi_f08 module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_utils dtfft_utils module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_kernel_host~~UsedByGraph module~dtfft_kernel_host dtfft_kernel_host module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_kernel ) :: kernel_host Host kernel implementation Components Type Visibility Attributes Name Initial logical, public :: is_created = .false. Kernel is created flag. logical, public :: is_dummy = .false. If kernel should do anything or not. type( kernel_type_t ), public :: kernel_type Type of the kernel character(len=:), public, allocatable :: kernel_string integer(kind=int32), public, allocatable :: neighbor_data (:,:) Neighbor data for pipelined unpacking integer(kind=int32), public, allocatable :: dims (:) Local dimensions to process integer(kind=int64), public :: base_storage Type-Bound Procedures procedure, public, pass(self) :: create ../../ Creates kernel procedure, public, pass(self) :: execute ../../ Executes kernel procedure, public, pass(self) :: destroy ../../ Destroys kernel procedure, public :: create_private => create_host ../../ Creates kernel procedure, public :: execute_private => execute_host ../../ Executes kernel procedure, public :: destroy_private => destroy_host ../../ Destroys kernel Subroutines private  subroutine create_host (self, effort, base_storage, force_effort) Creates kernel Arguments Type Intent Optional Attributes Name class( kernel_host ), intent(inout) :: self Host kernel class type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in), optional :: force_effort Should effort be forced or not private  subroutine execute_host (self, in, out, stream, neighbor) Executes host kernel Arguments Type Intent Optional Attributes Name class( kernel_host ), intent(inout) :: self Host kernel class real(kind=real32), intent(in), target :: in (:) Source host-allocated buffer real(kind=real32), intent(inout), target :: out (:) Target host-allocated buffer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, unused here integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking private  subroutine destroy_host (self) Destroys host kernel Arguments Type Intent Optional Attributes Name class( kernel_host ), intent(inout) :: self Host kernel class private  subroutine permute_forward_f128 (in, out, dims) Forward permutation of a 2D and 3D arrays Read more… Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array private  subroutine permute_backward_f128 (in, out, dims) Backward permutation of a 2D and 3D arrays Read more… Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array private  subroutine permute_backward_start_f128 (in, out, dims) Backward permutation start of a 3D array Read more… Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array private  subroutine permute_backward_end_pipelined_f128 (in, out, dims, neighbor_data) Backward permutation end of a 3D array for a single neighbor Read more… Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data private  subroutine permute_backward_end_f128 (in, out, dims, neighbor_data) Backward permutation end of a 3D array for all neighbors Read more… Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data private  subroutine unpack_pipelined_f128 (in, out, dims, neighbor_data) Unpacks part of contiguous buffer recieved from a single rank. Read more… Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data private  subroutine unpack_f128 (in, out, dims, neighbor_data) Unpacks pack of contiguous buffer recieved from all ranks. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: in (:) Source host-allocated buffer complex(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data private  subroutine permute_forward_f64 (in, out, dims) Forward permutation of a 2D and 3D arrays Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array private  subroutine permute_backward_f64 (in, out, dims) Backward permutation of a 2D and 3D arrays Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array private  subroutine permute_backward_start_f64 (in, out, dims) Backward permutation start of a 3D array Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array private  subroutine permute_backward_end_pipelined_f64 (in, out, dims, neighbor_data) Backward permutation end of a 3D array for a single neighbor Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data private  subroutine permute_backward_end_f64 (in, out, dims, neighbor_data) Backward permutation end of a 3D array for all neighbors Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data private  subroutine unpack_pipelined_f64 (in, out, dims, neighbor_data) Unpacks part of contiguous buffer recieved from a single rank. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data private  subroutine unpack_f64 (in, out, dims, neighbor_data) Unpacks pack of contiguous buffer recieved from all ranks. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in (:) Source host-allocated buffer real(kind=real64), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data private  subroutine permute_forward_f32 (in, out, dims) Forward permutation of a 2D and 3D arrays Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array private  subroutine permute_backward_f32 (in, out, dims) Backward permutation of a 2D and 3D arrays Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array private  subroutine permute_backward_start_f32 (in, out, dims) Backward permutation start of a 3D array Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array private  subroutine permute_backward_end_pipelined_f32 (in, out, dims, neighbor_data) Backward permutation end of a 3D array for a single neighbor Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data private  subroutine permute_backward_end_f32 (in, out, dims, neighbor_data) Backward permutation end of a 3D array for all neighbors Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data private  subroutine unpack_pipelined_f32 (in, out, dims, neighbor_data) Unpacks part of contiguous buffer recieved from a single rank. Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:) Neighbor data private  subroutine unpack_f32 (in, out, dims, neighbor_data) Unpacks pack of contiguous buffer recieved from all ranks. Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: in (:) Source host-allocated buffer real(kind=real32), intent(inout) :: out (:) Target host-allocated buffer integer(kind=int32), intent(in) :: dims (:) Dimensions of the array integer(kind=int32), intent(in) :: neighbor_data (:,:) Neighbor data","tags":"","loc":"module/dtfft_kernel_host.html"},{"title":"dtfft_interface_nccl – dtFFT","text":"NCCL Interfaces Uses dtfft_parameters dtfft_utils iso_c_binding module~~dtfft_interface_nccl~~UsesGraph module~dtfft_interface_nccl dtfft_interface_nccl iso_c_binding iso_c_binding module~dtfft_interface_nccl->iso_c_binding module~dtfft_parameters dtfft_parameters module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_parameters->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_nccl~~UsedByGraph module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_interface_nccl module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( ncclDataType ), public, parameter :: ncclFloat = ncclDataType(7) Interfaces interface Generates an Id to be used in ncclCommInitRank. \nncclGetUniqueId should be called once when creating a communicator and the Id should be \ndistributed to all ranks in the communicator before calling ncclCommInitRank. \nuniqueId should point to a ncclUniqueId object allocated by the user. public  function ncclGetUniqueId(uniqueId) result(ncclResult_t) bind(C, name=\"ncclGetUniqueId\") Arguments Type Intent Optional Attributes Name type( ncclUniqueId ), intent(out) :: uniqueId Unique ID Return Value integer(kind=c_int32_t) Completion status interface Allocate a GPU buffer with size.\nAllocated buffer head address will be returned by ptr, and the actual allocated size can be larger \nthan requested because of the buffer granularity requirements from all types of NCCL optimizations. public  function ncclMemAlloc(ptr, alloc_bytes) result(ncclResult_t) bind(C, name=\"ncclMemAlloc\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: ptr Buffer address integer(kind=c_size_t), intent(in), value :: alloc_bytes Number of bytes to allocate Return Value integer(kind=c_int32_t) Completion status interface Free memory allocated by ncclMemAlloc(). public  function ncclMemFree(ptr) result(ncclResult_t) bind(C, name=\"ncclMemFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: ptr Buffer address Return Value integer(kind=c_int32_t) Completion status interface Creates a new communicator (multi thread/process version). rank must be between 0 and nranks-1 and unique within a communicator clique.\nEach rank is associated to a CUDA device, which has to be set before calling ncclCommInitRank. ncclCommInitRank implicitly synchronizes with other ranks, hence it must be called by different\nthreads/processes or used within ncclGroupStart/ncclGroupEnd. public  function ncclCommInitRank(comm, nranks, uniqueId, rank) result(ncclResult_t) bind(C, name=\"ncclCommInitRank\") Arguments Type Intent Optional Attributes Name type( ncclComm ) :: comm Communicator integer(kind=c_int), value :: nranks Number of ranks in communicator type( ncclUniqueId ), value :: uniqueId Unique ID integer(kind=c_int), value :: rank Calling rank Return Value integer(kind=c_int32_t) Completion status interface Send data from sendbuff to rank peer. Rank peer needs to call ncclRecv with the same datatype and the same count as this rank. This operation is blocking for the GPU.\nIf multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, \nthey must be fused within a ncclGroupStart()/ ncclGroupEnd() section. public  function ncclSend(sendbuff, count, datatype, peer, comm, stream) result(ncclResult_t) bind(c, name='ncclSend') Arguments Type Intent Optional Attributes Name real(kind=c_float) :: sendbuff Buffer to send data from integer(kind=c_size_t), value :: count Number of elements to send type( ncclDataType ), value :: datatype Datatype to send integer(kind=c_int), value :: peer Target GPU type( ncclComm ), value :: comm Communicator type( dtfft_stream_t ), value :: stream CUDA Stream Return Value integer(kind=c_int32_t) Completion status interface Receive data from rank peer into recvbuff. Rank peer needs to call ncclSend with the same datatype and the same count as this rank. This operation is blocking for the GPU.\nIf multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, \nthey must be fused within a ncclGroupStart()/ ncclGroupEnd() section. public  function ncclRecv(recvbuff, count, datatype, peer, comm, stream) result(ncclResult_t) bind(c, name='ncclRecv') Arguments Type Intent Optional Attributes Name real(kind=c_float) :: recvbuff Buffer to recv data into integer(kind=c_size_t), value :: count Number of elements to recv type( ncclDataType ), value :: datatype Datatype to recv integer(kind=c_int), value :: peer Source GPU type( ncclComm ), value :: comm Communicator type( dtfft_stream_t ), value :: stream CUDA Stream Return Value integer(kind=c_int32_t) Completion status interface Start a group call. All subsequent calls to NCCL until ncclGroupEnd will not block due to inter-CPU synchronization. public  function ncclGroupStart() result(ncclResult_t) bind(C, name=\"ncclGroupStart\") Arguments None Return Value integer(kind=c_int32_t) Completion status interface End a group call. Returns when all operations since ncclGroupStart have been processed.\nThis means the communication primitives have been enqueued to the provided streams, \nbut are not necessarily complete. public  function ncclGroupEnd() result(ncclResult_t) bind(C, name=\"ncclGroupEnd\") Arguments None Return Value integer(kind=c_int32_t) Completion status interface Destroy a communicator object comm. public  function ncclCommDestroy(comm) result(ncclResult_t) bind(C, name=\"ncclCommDestroy\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator Return Value integer(kind=c_int32_t) Completion status interface Register a buffer for collective communication. public  function ncclCommRegister(comm, buff, size, handle) result(ncclResult_t) bind(C, name=\"ncclCommRegister\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator type(c_ptr), value :: buff Buffer to register integer(kind=c_size_t), value :: size Size of the buffer in bytes type(c_ptr) :: handle Handle to the registered buffer Return Value integer(kind=c_int32_t) Completion status interface Deregister a buffer for collective communication. public  function ncclCommDeregister(comm, handle) result(ncclResult_t) bind(C, name=\"ncclCommDeregister\") Arguments Type Intent Optional Attributes Name type( ncclComm ), value :: comm Communicator type(c_ptr), value :: handle Handle to the registered buffer Return Value integer(kind=c_int32_t) Completion status interface Returns a human-readable string corresponding to the passed error code. private  function ncclGetErrorString_c(ncclResult_t) result(message) bind(C, name=\"ncclGetErrorString\") Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in), value :: ncclResult_t Completion status of a NCCL function. Return Value type(c_ptr) Pointer to message Derived Types type, public, bind(c) :: ncclUniqueId Components Type Visibility Attributes Name Initial character(len=c_char), public :: internal (128) type, public, bind(c) :: ncclComm Components Type Visibility Attributes Name Initial type(c_ptr), public :: member type, public, bind(c) :: ncclDataType Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: member Functions public  function ncclGetErrorString (ncclResult_t) result(string) Generates an error message. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ncclResult_t Completion status of a function. Return Value character(len=:), allocatable Error message","tags":"","loc":"module/dtfft_interface_nccl.html"},{"title":"dtfft_backend_nccl_m – dtFFT","text":"NCCL Based GPU Backends backend_nccl Uses dtfft_parameters dtfft_errors dtfft_interface_cuda_runtime iso_fortran_env dtfft_utils dtfft_abstract_backend dtfft_interface_nccl iso_c_binding mpi_f08 module~~dtfft_backend_nccl_m~~UsesGraph module~dtfft_backend_nccl_m dtfft_backend_nccl_m iso_c_binding iso_c_binding module~dtfft_backend_nccl_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_errors dtfft_errors module~dtfft_backend_nccl_m->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_parameters dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_backend_nccl_m->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_abstract_backend->module~dtfft_config module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_backend_nccl_m~~UsedByGraph module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_backend ) :: backend_nccl NCCL backend Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type type( dtfft_platform_t ), public :: platform Platform to use logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer class( abstract_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( ncclComm ), private :: nccl_comm NCCL Communicator Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates Abstract Backend procedure, public, non_overridable, pass(self) :: execute ../../ Executes Backend procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys Abstract Backend procedure, public, non_overridable, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, non_overridable, pass(self) :: set_unpack_kernel ../../ Sets unpack kernel for pipelined backend procedure, public, pass(self) :: execute_end ../../ Ends execution of Backend procedure, public, pass(self) :: get_async_active ../../ Returns if async execution is active procedure, public :: create_private => create_nccl ../../ Creates NCCL backend procedure, public :: execute_private => execute_nccl ../../ Executes NCCL backend procedure, public :: destroy_private => destroy_nccl ../../ Destroys NCCL backend Subroutines private  subroutine create_nccl (self, helper, base_storage) Creates NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element (unused) private  subroutine execute_nccl (self, in, out, stream, aux, exec_type, error_code) Executes NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code private  subroutine destroy_nccl (self) Destroys NCCL backend Arguments Type Intent Optional Attributes Name class( backend_nccl ), intent(inout) :: self NCCL backend","tags":"","loc":"module/dtfft_backend_nccl_m.html"},{"title":"dtfft_interface_nvtx – dtFFT","text":"nvtx3 Interfaces Uses dtfft_utils iso_c_binding module~~dtfft_interface_nvtx~~UsesGraph module~dtfft_interface_nvtx dtfft_interface_nvtx iso_c_binding iso_c_binding module~dtfft_interface_nvtx->iso_c_binding module~dtfft_utils dtfft_utils module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_utils->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_utils->module~dtfft_parameters mpi_f08 mpi_f08 module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_nvtx~~UsedByGraph module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_handle_datatype->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_interface_nvtx module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_kernel_host dtfft_kernel_host module~dtfft_kernel_host->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( nvtxDomainHandle ), private, save :: domain_nvtx NVTX domain handle logical, private, save :: domain_created = .false. Has domain been created? Interfaces interface private  subroutine nvtxDomainCreate_c(name, domain) bind(C, name=\"nvtxDomainCreate_c\") Creates an NVTX domain with the specified name. Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: name (*) Name of the NVTX domain. type( nvtxDomainHandle ) :: domain Handle to the created NVTX domain. interface private  subroutine nvtxDomainRangePushEx_c(domain, message, color) bind(C, name=\"nvtxDomainRangePushEx_c\") Pushes a range with a custom message and color onto the specified NVTX domain. Arguments Type Intent Optional Attributes Name type( nvtxDomainHandle ), value :: domain NVTX domain handle. character(len=c_char), intent(in) :: message (*) Custom message for the range. integer(kind=c_int), intent(in), value :: color Color for the range. interface private  subroutine nvtxDomainRangePop_c(domain) bind(C, name=\"nvtxDomainRangePop_c\") Pops a range from the specified NVTX domain. Arguments Type Intent Optional Attributes Name type( nvtxDomainHandle ), value :: domain NVTX domain handle. Derived Types type, private, bind(C) :: nvtxDomainHandle NVTX domain handle. Components Type Visibility Attributes Name Initial type(c_ptr), public :: handle Internal handle for the NVTX domain. Subroutines public  subroutine push_nvtx_domain_range (message, color) Pushes a range to the NVTX domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to push integer(kind=c_int), intent(in) :: color Color of the range public  subroutine pop_nvtx_domain_range () Pops a range from the NVTX domain Arguments None private  subroutine create_nvtx_domain () Creates a new NVTX domain Arguments None","tags":"","loc":"module/dtfft_interface_nvtx.html"},{"title":"dtfft_utils – dtFFT","text":"All Utilities functions are located here Uses dtfft_parameters dtfft_errors iso_fortran_env iso_c_binding mpi_f08 module~~dtfft_utils~~UsesGraph module~dtfft_utils dtfft_utils iso_c_binding iso_c_binding module~dtfft_utils->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_utils->module~dtfft_parameters mpi_f08 mpi_f08 module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_utils~~UsedByGraph module~dtfft_utils dtfft_utils module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_abstract_backend->module~dtfft_config module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_utils module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft_api->module~dtfft_plan module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_config->module~dtfft_utils module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_mkl_m->module~dtfft_utils module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_utils module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_kernel_device->module~dtfft_config module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_utils module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_utils module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_handle_datatype->module~dtfft_utils module~dtfft_transpose_handle_datatype->module~dtfft_interface_nvtx module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_utils module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_kernel_host dtfft_kernel_host module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_transpose_plan->module~dtfft_utils module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_config module~dtfft_transpose_plan->module~dtfft_interface_cuda module~dtfft_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan->module~dtfft_interface_nccl module~dtfft_transpose_plan->module~dtfft_interface_nvrtc module~dtfft_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_transpose_plan->module~dtfft_interface_nvtx module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_pencil module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft dtfft module~dtfft->module~dtfft_config module~dtfft->module~dtfft_pencil module~dtfft->module~dtfft_plan module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_kernel_host->module~dtfft_abstract_kernel Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=c_int), private, parameter :: RTLD_LAZY = 1_c_int Each external function reference is bound the first time the function is called. integer(kind=c_int), private, parameter :: RTLD_NOW = 2_c_int All external function references are bound when the library is loaded. Interfaces public        interface to_str Convert various types to string private  function int8_to_string (n) result(str) Convert 8-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int32_to_string (n) result(str) Convert 32-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int64_to_string (n) result(str) Convert 64-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function double_to_string (n) result(str) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string private  function float_to_string (n) result(str) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string interface public  subroutine mem_free_host(ptr) bind(C, name=\"free\") Frees memory allocated with aligned_alloc Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to free interface public  function Comm_f2c(fcomm) bind(C, name=\"Comm_f2c\") Converts Fortran communicator to C Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: fcomm Fortran communicator Return Value type(c_ptr) interface public  function is_device_ptr(ptr) result(bool) bind(C) Checks if pointer can be accessed from device Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Device pointer Return Value logical(kind=c_bool) Result public        interface string Creates string object private  function string_constructor (str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string ) private        interface is_null_ptr Checks if pointer is NULL private  interface is_null_ptr () Checks if pointer is NULL Arguments None private elemental function is_null_funptr (ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_funptr), intent(in) :: ptr Pointer to check Return Value logical interface private  function dlopen(filename, mode) bind(C) Load and link a dynamic library Arguments Type Intent Optional Attributes Name character(len=c_char) :: filename (*) Name of the library integer(kind=c_int), value :: mode Options to dlopen Return Value type(c_ptr) Handle to the library interface private  function dlsym(handle, name) bind(C) Get address of a symbol from a dynamic library Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Handle to the library character(len=c_char) :: name (*) Name of the symbol Return Value type(c_funptr) Address of the symbol interface private  function dlclose(handle) bind(C) Close a dynamic library Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Handle to the library Return Value integer(kind=c_int) Result of the operation interface private  function dlerror() bind(C) Get diagnostic information Arguments None Return Value type(c_ptr) Error message interface private  function aligned_alloc(alignment, alloc_size) result(ptr) bind(C) Allocates memory using C11 Standard alloc_align with 16 bytes alignment Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: alignment Alignment in bytes (16 bytes by default) integer(kind=c_size_t), value :: alloc_size Number of bytes to allocate Return Value type(c_ptr) Pointer to allocate Derived Types type, public :: string Class used to create array of strings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: raw String Constructor Creates string object private\n\n                    \n                    function string_constructor (str) Creates string object Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_string Functions public  function dynamic_load (name, symbol_names, handle, symbols) result(error_code) Dynamically loads library and its symbols Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of library to load type( string ), intent(in) :: symbol_names (:) Names of functions to load type(c_ptr), intent(out) :: handle Loaded handle type(c_funptr), intent(out) :: symbols (:) Function pointers Return Value integer(kind=int32) Error code public elemental function get_inverse_kind (r2r_kind) result(result_kind) Get the inverse R2R kind of transform for the given R2R kind Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: r2r_kind R2R kind Return Value type( dtfft_r2r_kind_t ) public elemental function is_null_ptr (ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to check Return Value logical public elemental function is_same_ptr (ptr1, ptr2) Checks if two pointer are the same Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr1 First pointer type(c_ptr), intent(in) :: ptr2 Second pointer Return Value logical public  function count_unique (x) result(n) Count the number of unique elements in the array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) Array of integers Return Value integer(kind=int32) public  function mem_alloc_host (alloc_size) result(ptr) Allocates memory using C11 Standard alloc_align with 16 bytes alignment Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_size Number of bytes to allocate Return Value type(c_ptr) Pointer to allocate private  function string_constructor (str) Creates string object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String Return Value type( string ) private  function load_library (name) result(lib_handle) Dynamically loads library Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of library to load Return Value type(c_ptr) Loaded handle private  function load_symbol (handle, name) result(symbol_handle) Dynamically loads symbol from library Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: handle Loaded handle character(len=*), intent(in) :: name Name of function to load Return Value type(c_funptr) Function pointer private  function int8_to_string (n) result(str) Convert 8-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int32_to_string (n) result(str) Convert 32-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function int64_to_string (n) result(str) Convert 64-bit integer to string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Integer to convert Return Value character(len=:), allocatable Resulting string private  function double_to_string (n) result(str) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string private  function float_to_string (n) result(str) Convert double to string Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: n Double to convert Return Value character(len=:), allocatable Resulting string private elemental function is_null_funptr (ptr) Checks if pointer is NULL Arguments Type Intent Optional Attributes Name type(c_funptr), intent(in) :: ptr Pointer to check Return Value logical Subroutines public  subroutine destroy_strings (strings) Destroys array of string objects Arguments Type Intent Optional Attributes Name type( string ), intent(inout), allocatable :: strings (:) Array of strings public  subroutine string_f2c (fstring, cstring, string_size) Convert Fortran string to C string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstring Fortran string character(kind=c_char, len=1), intent(inout) :: cstring (*) C string integer(kind=int64), intent(out), optional :: string_size Size of the C string public  subroutine string_c2f (cstring, fstring) Convert C string to Fortran string Arguments Type Intent Optional Attributes Name type(c_ptr) :: cstring C string character(len=:), allocatable :: fstring Fortran string public  subroutine astring_f2c (fstring, cstring, string_size) Convert Fortran string to C allocatable string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstring Fortran string character(kind=c_char, len=1), intent(out), allocatable :: cstring (:) C string integer(kind=int64), intent(out), optional :: string_size Size of the C string public  subroutine write_message (unit, message, prefix) Write message to the specified unit Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: unit Unit number character(len=*), intent(in) :: message Message to write character(len=*), intent(in), optional :: prefix Prefix to the message public  subroutine create_subcomm_include_all (old_comm, new_comm) Creates communicator including all processes from old_comm Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: old_comm Communicator to create group from type(MPI_Comm), intent(out) :: new_comm New communicator public  subroutine create_subcomm (old_comm, processes, new_comm) Creates communicator with selected processes from old_comm Arguments Type Intent Optional Attributes Name type(MPI_Comm), intent(in) :: old_comm Communicator to create group from integer(kind=int32), intent(in) :: processes (:) Ranks of processes in old_comm to include in new group type(MPI_Comm), intent(out) :: new_comm New communicator private  subroutine destroy_string (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self private  subroutine dl_error (message) Writes error message to the error unit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to write private  subroutine unload_library (handle) Unloads library Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: handle Loaded handle","tags":"","loc":"module/dtfft_utils.html"},{"title":"dtfft – dtFFT","text":"Main dtFFT module. Should be used in a Fortran program. Uses dtfft_parameters dtfft_errors dtfft_config dtfft_plan dtfft_pencil module~~dtfft~~UsesGraph module~dtfft dtfft module~dtfft_config dtfft_config module~dtfft->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters iso_c_binding iso_c_binding module~dtfft_config->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_config->iso_fortran_env module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_utils dtfft_utils module~dtfft_config->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_config->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_errors module~dtfft_plan->module~dtfft_parameters module~dtfft_plan->module~dtfft_pencil module~dtfft_plan->iso_c_binding module~dtfft_plan->iso_fortran_env module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_plan->module~dtfft_utils module~dtfft_plan->mpi_f08 module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->iso_c_binding module~dtfft_abstract_executor->iso_fortran_env module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_errors module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_executor_cufft_m->iso_c_binding module~dtfft_executor_cufft_m->iso_fortran_env module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_cufft_m->mpi_f08 module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_fftw_m->module~dtfft_errors module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->iso_c_binding module~dtfft_executor_fftw_m->iso_fortran_env module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_executor_mkl_m->module~dtfft_errors module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_executor_mkl_m->iso_c_binding module~dtfft_executor_mkl_m->iso_fortran_env module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_executor_mkl_m->mpi_f08 module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_interface_mkl_native_m dtfft_interface_mkl_native_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_native_m module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_errors module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_executor_vkfft_m->iso_c_binding module~dtfft_executor_vkfft_m->iso_fortran_env module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvshmem->mpi_f08 module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_transpose_plan->module~dtfft_config module~dtfft_transpose_plan->module~dtfft_errors module~dtfft_transpose_plan->module~dtfft_parameters module~dtfft_transpose_plan->module~dtfft_pencil module~dtfft_transpose_plan->iso_c_binding module~dtfft_transpose_plan->iso_fortran_env module~dtfft_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_transpose_plan->module~dtfft_interface_nvtx module~dtfft_transpose_plan->module~dtfft_utils module~dtfft_transpose_plan->mpi_f08 module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_transpose_plan->module~dtfft_interface_cuda module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_transpose_plan->module~dtfft_interface_nccl module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_transpose_plan->module~dtfft_interface_nvrtc module~dtfft_kernel_device dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->mpi_f08 module~dtfft_abstract_backend->module~dtfft_config module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_abstract_transpose_handle->module~dtfft_parameters module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_abstract_transpose_handle->iso_fortran_env module~dtfft_abstract_transpose_handle->mpi_f08 module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_fftw_m->iso_c_binding dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_interface_mkl_m->module~dtfft_utils MKL_DFTI MKL_DFTI module~dtfft_interface_mkl_native_m->MKL_DFTI module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_vkfft_m->module~dtfft_errors module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->iso_c_binding module~dtfft_interface_vkfft_m->iso_fortran_env module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_kernel_device->module~dtfft_config module~dtfft_kernel_device->module~dtfft_parameters module~dtfft_kernel_device->iso_c_binding module~dtfft_kernel_device->iso_fortran_env module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_kernel_device->module~dtfft_utils module~dtfft_kernel_device->mpi_f08 module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_transpose_handle_datatype->module~dtfft_errors module~dtfft_transpose_handle_datatype->module~dtfft_parameters module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_transpose_handle_datatype->iso_fortran_env module~dtfft_transpose_handle_datatype->module~dtfft_interface_nvtx module~dtfft_transpose_handle_datatype->module~dtfft_utils module~dtfft_transpose_handle_datatype->mpi_f08 module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_errors module~dtfft_transpose_handle_generic->module~dtfft_parameters module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_transpose_handle_generic->iso_c_binding module~dtfft_transpose_handle_generic->iso_fortran_env module~dtfft_transpose_handle_generic->module~dtfft_utils module~dtfft_transpose_handle_generic->mpi_f08 module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_kernel_host dtfft_kernel_host module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_errors module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->iso_c_binding module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_backend_mpi->module~dtfft_errors module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->iso_c_binding module~dtfft_backend_mpi->iso_fortran_env module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->mpi_f08 module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_errors module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->iso_c_binding module~dtfft_backend_nccl_m->iso_fortran_env module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_backend_nccl_m->mpi_f08 module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_kernel_host->module~dtfft_parameters module~dtfft_kernel_host->iso_c_binding module~dtfft_kernel_host->iso_fortran_env module~dtfft_kernel_host->mpi_f08 module~dtfft_kernel_host->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_nvrtc_block_optimizer->iso_fortran_env module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->iso_c_binding module~dtfft_nvrtc_module_cache->iso_fortran_env module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_utils module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_parameters module~dtfft_nvrtc_module->iso_c_binding module~dtfft_nvrtc_module->iso_fortran_env module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_nvrtc_module->mpi_f08 module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/dtfft.html"},{"title":"dtfft_kernel_device – dtFFT","text":"This module defines kernel_device type and its type bound procedures.\nIt extends abstract_kernel type and implements its type bound procedures. Uses dtfft_interface_nvtx dtfft_parameters dtfft_abstract_kernel dtfft_interface_cuda_runtime dtfft_config dtfft_nvrtc_module_cache iso_fortran_env dtfft_utils dtfft_nvrtc_block_optimizer dtfft_interface_cuda iso_c_binding mpi_f08 module~~dtfft_kernel_device~~UsesGraph module~dtfft_kernel_device dtfft_kernel_device iso_c_binding iso_c_binding module~dtfft_kernel_device->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_kernel_device->iso_fortran_env module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_kernel_device->module~dtfft_config module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_parameters dtfft_parameters module~dtfft_kernel_device->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_kernel_device->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_kernel_device->mpi_f08 module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_errors dtfft_errors module~dtfft_config->module~dtfft_errors module~dtfft_interface_cuda->iso_c_binding module~dtfft_interface_cuda->iso_fortran_env module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda->module~dtfft_errors module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_block_optimizer->iso_fortran_env module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_module_cache->iso_c_binding module~dtfft_nvrtc_module_cache->iso_fortran_env module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_utils module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env module~dtfft_nvrtc_module->iso_c_binding module~dtfft_nvrtc_module->iso_fortran_env module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module->module~dtfft_parameters module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_nvrtc_module->mpi_f08 module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_interface_nvrtc->iso_c_binding module~dtfft_interface_nvrtc->iso_fortran_env module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_errors Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_kernel_device~~UsedByGraph module~dtfft_kernel_device dtfft_kernel_device module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DEF_TILE_SIZE = 32 Default tile size Derived Types type, public, extends( abstract_kernel ) :: kernel_device Device kernel class Components Type Visibility Attributes Name Initial logical, public :: is_created = .false. Kernel is created flag. logical, public :: is_dummy = .false. If kernel should do anything or not. type( kernel_type_t ), public :: kernel_type Type of the kernel character(len=:), public, allocatable :: kernel_string integer(kind=int32), public, allocatable :: neighbor_data (:,:) Neighbor data for pipelined unpacking integer(kind=int32), public, allocatable :: dims (:) Local dimensions to process type( kernel_type_t ), private :: internal_kernel_type Actual kernel type used for execution, can be different from kernel_type type( CUfunction ), private :: cuda_kernel Pointer to CUDA kernel. integer(kind=int32), private :: tile_size Tile size used for this kernel integer(kind=int32), private :: block_rows Number of rows in each block processed by each thread integer(kind=int64), private :: copy_bytes Number of bytes to copy for KERNEL_UNPACK_SIMPLE_COPY kernel Type-Bound Procedures procedure, public, pass(self) :: create ../../ Creates kernel procedure, public, pass(self) :: execute ../../ Executes kernel procedure, public, pass(self) :: destroy ../../ Destroys kernel procedure, public :: create_private => create ../../ Creates kernel procedure, public :: execute_private => execute ../../ Executes kernel procedure, public :: destroy_private => destroy ../../ Destroys kernel Subroutines private  subroutine create (self, effort, base_storage, force_effort) Creates kernel Arguments Type Intent Optional Attributes Name class( kernel_device ), intent(inout) :: self Device kernel class type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in), optional :: force_effort Should effort be forced or not private  subroutine execute (self, in, out, stream, neighbor) Executes kernel on stream Arguments Type Intent Optional Attributes Name class( kernel_device ), intent(inout) :: self Device kernel class real(kind=real32), intent(in), target :: in (:) Device pointer real(kind=real32), intent(inout), target :: out (:) Device pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking private  subroutine destroy (self) Destroys kernel Arguments Type Intent Optional Attributes Name class( kernel_device ), intent(inout) :: self Device kernel class private  subroutine get_kernel_args (kernel_type, dims, nargs, args, neighbor_data) Populates kernel arguments based on kernel type Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: kernel_type Type of kernel integer(kind=int32), intent(in) :: dims (:) Local dimensions to process integer(kind=int32), intent(out) :: nargs Number of arguments set by this subroutine integer(kind=int32), intent(out) :: args (MAX_KERNEL_ARGS) Kernel arguments integer(kind=int32), intent(in), optional :: neighbor_data (:) Neighbor data for pipelined kernels private  subroutine get_kernel_launch_params (kernel_type, dims, tile_size, block_rows, blocks, threads) Computes kernel launch parameters based on kernel type and dimensions Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: kernel_type Type of kernel integer(kind=int32), intent(in) :: dims (:) Local dimensions to process integer(kind=int32), intent(in) :: tile_size Size of the tile in shared memory integer(kind=int32), intent(in) :: block_rows Number of rows in each block type( dim3 ), intent(out) :: blocks Number of blocks to launch type( dim3 ), intent(out) :: threads Number of threads per block private  subroutine get_kernel (dims, kernel_type, effort, base_storage, props, tile_size, block_rows, kernel, force_effort, neighbor_data) Compiles kernel and caches it. Returns compiled kernel. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dims (:) Local dimensions to process type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build type( dtfft_effort_t ), intent(in) :: effort How thoroughly dtFFT searches for the optimal transpose kernel integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( device_props ), intent(in) :: props GPU architecture properties integer(kind=int32), intent(out) :: tile_size Size of the tile in shared memory integer(kind=int32), intent(out) :: block_rows Number of rows in each block processed by each thread type( CUfunction ), intent(out) :: kernel Compiled kernel to return logical, intent(in), optional :: force_effort Should effort be forced or not integer(kind=int32), intent(in), optional :: neighbor_data (:) Neighbor data for pipelined kernels","tags":"","loc":"module/dtfft_kernel_device.html"},{"title":"dtfft_interface_cuda_runtime – dtFFT","text":"CUDA Runtime Interfaces Uses dtfft_parameters dtfft_utils iso_c_binding module~~dtfft_interface_cuda_runtime~~UsesGraph module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime iso_c_binding iso_c_binding module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_parameters dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_parameters->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_cuda_runtime~~UsedByGraph module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_config dtfft_config module~dtfft_abstract_backend->module~dtfft_config module~dtfft_pencil dtfft_pencil module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_kernel_device->module~dtfft_config module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_config module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_pencil module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft dtfft module~dtfft->module~dtfft_config module~dtfft->module~dtfft_pencil module~dtfft->module~dtfft_plan module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_pencil module~dtfft_api->module~dtfft_plan module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_executor_mkl_m->module~dtfft_abstract_executor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public, parameter :: cudaEventDisableTiming = 2 Enumerations enum, bind(c) Enumerators enumerator :: cudaSuccess = 0 enumerator :: cudaErrorInvalidValue = 1 enumerator :: cudaErrorMemoryAllocation = 2 enumerator :: cudaErrorInitializationError = 3 enumerator :: cudaErrorCudartUnloading = 4 enumerator :: cudaErrorProfilerDisabled = 5 enumerator :: cudaErrorProfilerNotInitialized = 6 enumerator :: cudaErrorProfilerAlreadyStarted = 7 enumerator :: cudaErrorProfilerAlreadyStopped = 8 enumerator :: cudaErrorInvalidConfiguration = 9 enumerator :: cudaErrorInvalidPitchValue = 12 enumerator :: cudaErrorInvalidSymbol = 13 enumerator :: cudaErrorInvalidHostPointer = 16 enumerator :: cudaErrorInvalidDevicePointer = 17 enumerator :: cudaErrorInvalidTexture = 18 enumerator :: cudaErrorInvalidTextureBinding = 19 enumerator :: cudaErrorInvalidChannelDescriptor = 20 enumerator :: cudaErrorInvalidMemcpyDirection = 21 enumerator :: cudaErrorAddressOfConstant = 22 enumerator :: cudaErrorTextureFetchFailed = 23 enumerator :: cudaErrorTextureNotBound = 24 enumerator :: cudaErrorSynchronizationError = 25 enumerator :: cudaErrorInvalidFilterSetting = 26 enumerator :: cudaErrorInvalidNormSetting = 27 enumerator :: cudaErrorMixedDeviceExecution = 28 enumerator :: cudaErrorNotYetImplemented = 31 enumerator :: cudaErrorMemoryValueTooLarge = 32 enumerator :: cudaErrorInsufficientDriver = 35 enumerator :: cudaErrorInvalidSurface = 37 enumerator :: cudaErrorDuplicateVariableName = 43 enumerator :: cudaErrorDuplicateTextureName = 44 enumerator :: cudaErrorDuplicateSurfaceName = 45 enumerator :: cudaErrorDevicesUnavailable = 46 enumerator :: cudaErrorIncompatibleDriverContext = 49 enumerator :: cudaErrorMissingConfiguration = 52 enumerator :: cudaErrorPriorLaunchFailure = 53 enumerator :: cudaErrorLaunchMaxDepthExceeded = 65 enumerator :: cudaErrorLaunchFileScopedTex = 66 enumerator :: cudaErrorLaunchFileScopedSurf = 67 enumerator :: cudaErrorSyncDepthExceeded = 68 enumerator :: cudaErrorLaunchPendingCountExceeded = 69 enumerator :: cudaErrorInvalidDeviceFunction = 98 enumerator :: cudaErrorNoDevice = 100 enumerator :: cudaErrorInvalidDevice = 101 enumerator :: cudaErrorStartupFailure = 127 enumerator :: cudaErrorInvalidKernelImage = 200 enumerator :: cudaErrorDeviceUninitialized = 201 enumerator :: cudaErrorMapBufferObjectFailed = 205 enumerator :: cudaErrorUnmapBufferObjectFailed = 206 enumerator :: cudaErrorArrayIsMapped = 207 enumerator :: cudaErrorAlreadyMapped = 208 enumerator :: cudaErrorNoKernelImageForDevice = 209 enumerator :: cudaErrorAlreadyAcquired = 210 enumerator :: cudaErrorNotMapped = 211 enumerator :: cudaErrorNotMappedAsArray = 212 enumerator :: cudaErrorNotMappedAsPointer = 213 enumerator :: cudaErrorECCUncorrectable = 214 enumerator :: cudaErrorUnsupportedLimit = 215 enumerator :: cudaErrorDeviceAlreadyInUse = 216 enumerator :: cudaErrorPeerAccessUnsupported = 217 enumerator :: cudaErrorInvalidPtx = 218 enumerator :: cudaErrorInvalidGraphicsContext = 219 enumerator :: cudaErrorNvlinkUncorrectable = 220 enumerator :: cudaErrorJitCompilerNotFound = 221 enumerator :: cudaErrorInvalidSource = 300 enumerator :: cudaErrorFileNotFound = 301 enumerator :: cudaErrorSharedObjectSymbolNotFound = 302 enumerator :: cudaErrorSharedObjectInitFailed = 303 enumerator :: cudaErrorOperatingSystem = 304 enumerator :: cudaErrorInvalidResourceHandle = 400 enumerator :: cudaErrorIllegalState = 401 enumerator :: cudaErrorSymbolNotFound = 500 enumerator :: cudaErrorNotReady = 600 enumerator :: cudaErrorIllegalAddress = 700 enumerator :: cudaErrorLaunchOutOfResources = 701 enumerator :: cudaErrorLaunchTimeout = 702 enumerator :: cudaErrorLaunchIncompatibleTexturing = 703 enumerator :: cudaErrorPeerAccessAlreadyEnabled = 704 enumerator :: cudaErrorPeerAccessNotEnabled = 705 enumerator :: cudaErrorSetOnActiveProcess = 708 enumerator :: cudaErrorContextIsDestroyed = 709 enumerator :: cudaErrorAssert = 710 enumerator :: cudaErrorTooManyPeers = 711 enumerator :: cudaErrorHostMemoryAlreadyRegistered = 712 enumerator :: cudaErrorHostMemoryNotRegistered = 713 enumerator :: cudaErrorHardwareStackError = 714 enumerator :: cudaErrorIllegalInstruction = 715 enumerator :: cudaErrorMisalignedAddress = 716 enumerator :: cudaErrorInvalidAddressSpace = 717 enumerator :: cudaErrorInvalidPc = 718 enumerator :: cudaErrorLaunchFailure = 719 enumerator :: cudaErrorCooperativeLaunchTooLarge = 720 enumerator :: cudaErrorNotPermitted = 800 enumerator :: cudaErrorNotSupported = 801 enumerator :: cudaErrorSystemNotReady = 802 enumerator :: cudaErrorSystemDriverMismatch = 803 enumerator :: cudaErrorCompatNotSupportedOnDevice = 804 enumerator :: cudaErrorStreamCaptureUnsupported = 900 enumerator :: cudaErrorStreamCaptureInvalidated = 901 enumerator :: cudaErrorStreamCaptureMerge = 902 enumerator :: cudaErrorStreamCaptureUnmatched = 903 enumerator :: cudaErrorStreamCaptureUnjoined = 904 enumerator :: cudaErrorStreamCaptureIsolation = 905 enumerator :: cudaErrorStreamCaptureImplicit = 906 enumerator :: cudaErrorCapturedEvent = 907 enumerator :: cudaErrorStreamCaptureWrongThread = 908 enumerator :: cudaErrorTimeout = 909 enumerator :: cudaErrorGraphExecUpdateFailure = 910 enumerator :: cudaErrorUnknown = 999 enumerator :: cudaErrorApiFailureBase = 10000 enum, bind(c) Enumerators enumerator :: cudaMemcpyHostToHost = 0 enumerator :: cudaMemcpyHostToDevice = 1 enumerator :: cudaMemcpyDeviceToHost = 2 enumerator :: cudaMemcpyDeviceToDevice = 3 enumerator :: cudaMemcpyDefault = 4 Interfaces interface public  function cudaStreamQuery(stream) result(cudaError_t) bind(C, name=\"cudaStreamQuery\") Queries an asynchronous stream for completion status. Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if all operations in stream have completed,\nor cudaErrorNotReady if not. interface public  function cudaStreamCreate(stream) result(cudaError_t) bind(C, name=\"cudaStreamCreate\") Creates an asynchronous stream. Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ) :: stream Pointer to the created stream Return Value integer(kind=c_int) Returns cudaSuccess if the stream was created successfully,\nor an error code if there was an issue. interface public  function cudaStreamDestroy(stream) result(cudaError_t) bind(C, name=\"cudaStreamDestroy\") Destroys an asynchronous stream. Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the stream was destroyed successfully,\nor an error code if there was an issue. interface public  function cudaStreamSynchronize(stream) result(cudaError_t) bind(C, name=\"cudaStreamSynchronize\") Waits for stream tasks to complete. Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the stream tasks completed successfully,\nor an error code if there was an issue. interface public  function cudaMalloc(ptr, count) result(cudaError_t) bind(C, name=\"cudaMalloc\") Allocates memory on the device. Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr Pointer to allocated device memory integer(kind=c_size_t), value :: count Requested allocation size in bytes Return Value integer(kind=c_int) Returns cudaSuccess if memory was allocated successfully,\nor cudaErrorMemoryAllocation if the memory could not be allocated. interface public  function cudaFree(ptr) result(cudaError_t) bind(C, name=\"cudaFree\") Frees memory on the device. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to memory to free Return Value integer(kind=c_int) Returns cudaSuccess if memory was freed successfully,\nor an error code if there was an issue. interface public  function cudaMemset(ptr, val, count) result(cudaError_t) bind(C, name=\"cudaMemset\") Initializes or sets device memory to a value. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to device memory integer(kind=c_int), value :: val Value to set integer(kind=c_size_t), value :: count Size in bytes to set Return Value integer(kind=c_int) Returns cudaSuccess if the memory was set successfully,\nor an error code if there was an issue. interface public  function cudaEventCreateWithFlags(event, flags) result(cudaError_t) bind(C, name=\"cudaEventCreateWithFlags\") Creates an event with the specified flags. Arguments Type Intent Optional Attributes Name type( cudaEvent ) :: event Event identifier integer(kind=c_int), value :: flags Flags for event creation Return Value integer(kind=c_int) Returns cudaSuccess if the event was created successfully,\nor an error code if there was an issue. interface public  function cudaEventRecord(event, stream) result(cudaError_t) bind(C, name=\"cudaEventRecord\") Records an event in a stream. Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was recorded successfully,\nor an error code if there was an issue. interface public  function cudaStreamWaitEvent(stream, event, flags) result(cudaError_t) bind(C, name=\"cudaStreamWaitEvent\") Makes a stream wait on an event. Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), value :: stream Stream identifier type( cudaEvent ), value :: event Event identifier integer(kind=c_int), value :: flags Flags for the wait operation Return Value integer(kind=c_int) Returns cudaSuccess if the stream is waiting successfully,\nor an error code if there was an issue. interface public  function cudaEventDestroy(event) result(cudaError_t) bind(C, name=\"cudaEventDestroy\") Destroys an event. Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was destroyed successfully,\nor an error code if there was an issue. interface public  function cudaEventCreate(event) result(cudaError_t) bind(C, name=\"cudaEventCreate\") Creates an event. Arguments Type Intent Optional Attributes Name type( cudaEvent ) :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event was created successfully,\nor an error code if there was an issue. interface public  function cudaEventSynchronize(event) result(cudaError_t) bind(C, name=\"cudaEventSynchronize\") Waits for an event to complete. Arguments Type Intent Optional Attributes Name type( cudaEvent ), value :: event Event identifier Return Value integer(kind=c_int) Returns cudaSuccess if the event completed successfully,\nor an error code if there was an issue. interface public  function cudaEventElapsedTime(time, start, end) result(cudaError_t) bind(C, name=\"cudaEventElapsedTime\") Computes the elapsed time between two events. Arguments Type Intent Optional Attributes Name real(kind=c_float) :: time Elapsed time in milliseconds type( cudaEvent ), value :: start Starting event type( cudaEvent ), value :: end Ending event Return Value integer(kind=c_int) Returns cudaSuccess if the elapsed time was computed successfully,\nor an error code if there was an issue. public        interface cudaMemcpyAsync Copies data asynchronously between host and device. private  function cudaMemcpyAsync_ptr(dst, src, count, kdir, stream) result(cudaError_t) bind(C, name=\"cudaMemcpyAsync\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dst Destination pointer type(c_ptr), value :: src Source pointer integer(kind=c_size_t), value :: count Size in bytes to copy integer(kind=c_int), value :: kdir Direction of copy (host-to-device, device-to-host, etc.) type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the copy was initiated successfully,\nor an error code if there was an issue. private  function cudaMemcpyAsync_r32(dst, src, count, kdir, stream) result(cudaError_t) bind(C, name=\"cudaMemcpyAsync\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: dst Destination array (32-bit float) real(kind=c_float) :: src Source array (32-bit float) integer(kind=c_size_t), value :: count Number of elements to copy integer(kind=c_int), value :: kdir Direction of copy type( dtfft_stream_t ), value :: stream Stream identifier Return Value integer(kind=c_int) Returns cudaSuccess if the copy was initiated successfully,\nor an error code if there was an issue. public        interface cudaMemcpy Copies data synchronously between host and device. private  function cudaMemcpy_ptr(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dst Destination pointer type(c_ptr), value :: src Source pointer integer(kind=c_size_t), value :: count Size in bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully,\nor an error code if there was an issue. private  function cudaMemcpy_r64(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name real(kind=c_double) :: dst (*) Destination array (64-bit float) real(kind=c_double) :: src (*) Source array (64-bit float) integer(kind=c_size_t), value :: count Number of bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully,\nor an error code if there was an issue. private  function cudaMemcpy_r32(dst, src, count, kdir) result(cudaError_t) bind(C, name=\"cudaMemcpy\") Arguments Type Intent Optional Attributes Name real(kind=c_float) :: dst (*) Destination array (32-bit float) real(kind=c_float) :: src (*) Source array (32-bit float) integer(kind=c_size_t), value :: count Number of bytes to copy integer(kind=c_int), value :: kdir Direction of copy Return Value integer(kind=c_int) Returns cudaSuccess if the copy was completed successfully,\nor an error code if there was an issue. interface public  function cudaGetDevice(num) result(cudaError_t) bind(C, name=\"cudaGetDevice\") Returns the current device. Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: num Device number Return Value integer(kind=c_int) Returns cudaSuccess if the device was retrieved successfully,\nor an error code if there was an issue. interface public  function cudaGetDeviceCount(num) result(cudaError_t) bind(C, name=\"cudaGetDeviceCount\") Returns the number of available devices. Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: num Number of devices Return Value integer(kind=c_int) Returns cudaSuccess if the device count was retrieved successfully,\nor an error code if there was an issue. interface public  function cudaSetDevice(num) result(cudaError_t) bind(C, name=\"cudaSetDevice\") Sets the current device. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: num Device number Return Value integer(kind=c_int) Returns cudaSuccess if the device was set successfully,\nor an error code if there was an issue. interface public  function cudaMemGetInfo(free, total) result(cudaError_t) bind(C, name=\"cudaMemGetInfo\") Returns the amount of free and total memory on the device. Arguments Type Intent Optional Attributes Name integer(kind=c_size_t) :: free Free memory in bytes integer(kind=c_size_t) :: total Total memory in bytes Return Value integer(kind=c_int) Returns cudaSuccess if the memory information was retrieved successfully,\nor an error code if there was an issue. interface public  function cudaDeviceSynchronize() result(cudaError_t) bind(C, name=\"cudaDeviceSynchronize\") Synchronizes the device, blocking until all preceding tasks in all streams have completed. Arguments None Return Value integer(kind=c_int) Returns cudaSuccess if syncronization was\nor an error code if there was an issue. interface public  function cudaGetLastError() result(cudaError_t) bind(C, name=\"cudaGetLastError\") Returns the last error from a runtime call. Arguments None Return Value integer(kind=c_int) Returns cudaSuccess if no error was detected\nor an error code if there was an issue. interface public  subroutine get_device_props(device, props) bind(C, name=\"get_device_props_cuda\") Returns the CUDA device properties for a given device number. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: device Device number type( device_props ) :: props GPU Properties interface private  function cudaGetErrorString_c(errcode) result(string) bind(C, name=\"cudaGetErrorString\") Returns the string representation of an error code. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: errcode Error code Return Value type(c_ptr) Pointer to the error string Derived Types type, public, bind(C) :: cudaEvent CUDA event types Components Type Visibility Attributes Name Initial type(c_ptr), public :: event Handle type, public, bind(C) :: device_props GPU device properties obtained from cudaDeviceProp Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: sm_count Number of multiprocessors on device (cudaDeviceProp.multiProcessorCount) integer(kind=c_int), public :: max_threads_per_sm Maximum resident threads per multiprocessor (cudaDeviceProp.maxThreadsPerMultiProcessor) integer(kind=c_int), public :: max_blocks_per_sm Maximum number of resident blocks per multiprocessor (cudaDeviceProp.maxBlocksPerMultiProcessor) integer(kind=c_size_t), public :: shared_mem_per_sm Shared memory per multiprocessor (cudaDeviceProp.sharedMemPerMultiprocessor) integer(kind=c_int), public :: max_threads_per_block Maximum number of threads per block (cudaDeviceProp.maxThreadsPerBlock) integer(kind=c_size_t), public :: shared_mem_per_block Shared memory available per block in bytes (cudaDeviceProp.sharedMemPerBlock) integer(kind=c_int), public :: l2_cache_size Size of L2 cache in bytes (cudaDeviceProp.l2CacheSize) integer(kind=c_int), public :: compute_capability_major Major compute capability (cudaDeviceProp.major) integer(kind=c_int), public :: compute_capability_minor Minor compute capability (cudaDeviceProp.minor) Functions public  function cudaGetErrorString (errcode) result(string) Helper function that returns a string describing the given nvrtcResult code\nIf the error code is not recognized, “unrecognized error code” is returned. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: errcode CUDA Runtime Compilation API result code. Return Value character(len=:), allocatable Result string","tags":"","loc":"module/dtfft_interface_cuda_runtime.html"},{"title":"dtfft_abstract_executor – dtFFT","text":"This module describes Abstraction for all FFT Executors: abstract_executor Uses dtfft_interface_nvtx dtfft_parameters dtfft_errors iso_fortran_env dtfft_pencil dtfft_utils iso_c_binding module~~dtfft_abstract_executor~~UsesGraph module~dtfft_abstract_executor dtfft_abstract_executor iso_c_binding iso_c_binding module~dtfft_abstract_executor->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_abstract_executor->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_abstract_executor->module~dtfft_errors module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_abstract_executor~~UsedByGraph module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int8), public, parameter :: FFT_C2C = 0 Complex to complex FFT integer(kind=int8), public, parameter :: FFT_R2C = 1 Real to complex FFT integer(kind=int8), public, parameter :: FFT_R2R = 2 Real to real FFT integer(kind=int8), public, parameter :: FFT_1D = 1 1D FFT integer(kind=int8), public, parameter :: FFT_2D = 2 2D FFT Abstract Interfaces abstract interface private  subroutine create_interface(self, fft_rank, fft_type, precision, idist, odist, how_many, fft_sizes, inembed, onembed, error_code, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer(kind=int32), intent(in) :: idist Distance between the first element of two consecutive signals in a batch of the input data. integer(kind=int32), intent(in) :: odist Distance between the first element of two consecutive signals in a batch of the output data. integer(kind=int32), intent(in) :: how_many Number of transforms to create integer(kind=int32), intent(in) :: fft_sizes (:) Dimensions of transform integer(kind=int32), intent(in) :: inembed (:) Storage dimensions of the input data in memory. integer(kind=int32), intent(in) :: onembed (:) Storage dimensions of the output data in memory. integer(kind=int32), intent(inout) :: error_code Error code to be returned to user type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform abstract interface private  subroutine execute_interface(self, a, b, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: a Source pointer type(c_ptr), intent(in) :: b Target pointer integer(kind=int8), intent(in) :: sign Sign of transform abstract interface private  subroutine destroy_interface(self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor abstract interface private  subroutine mem_alloc_interface(alloc_bytes, ptr) Allocates aligned memory Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: alloc_bytes Number of bytes to allocate type(c_ptr), intent(out) :: ptr Allocated pointer abstract interface private  subroutine mem_free_interface(ptr) Frees aligned memory Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: ptr Pointer to free Derived Types type, public, abstract :: abstract_executor The “most” abstract executor.\nAll FFT executors are extending this class. Components Type Visibility Attributes Name Initial type(c_ptr), public :: plan_forward Pointer to forward plan type(c_ptr), public :: plan_backward Pointer to backward plan logical, public :: is_inverse_copied = .false. Is inverse plan copied? character(len=:), public, allocatable :: profile logical, private :: is_created = .false. Is plan created? Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates FFT plan procedure, public, non_overridable, pass(self) :: execute ../../ Executes plan procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys plan procedure( mem_alloc_interface ), public, deferred, nopass :: mem_alloc ../../ Allocates aligned memory procedure( mem_free_interface ), public, deferred, nopass :: mem_free ../../ Frees aligned memory procedure( create_interface ), public, deferred, pass(self) :: create_private ../../ Creates FFT plan procedure( execute_interface ), public, deferred, pass(self) :: execute_private ../../ Executes plan procedure( destroy_interface ), public, deferred, pass(self) :: destroy_private ../../ Destroys plan Functions private  function create (self, fft_rank, fft_type, precision, real_pencil, complex_pencil, r2r_kinds) Creates FFT plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor integer(kind=int8), intent(in) :: fft_rank Rank of fft: 1 or 2 integer(kind=int8), intent(in) :: fft_type Type of fft: r2r, r2c, c2c type( dtfft_precision_t ), intent(in) :: precision Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type( pencil ), intent(in), optional :: real_pencil Real data layout type( pencil ), intent(in), optional :: complex_pencil Complex data layout type( dtfft_r2r_kind_t ), intent(in), optional :: r2r_kinds (:) Kinds of r2r transform Return Value integer(kind=int32) Subroutines private  subroutine execute (self, in, out, sign) Executes plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(in) :: self FFT Executor type(c_ptr), intent(in) :: in Source buffer type(c_ptr), intent(in) :: out Target buffer integer(kind=int8), intent(in) :: sign Sign of transform private  subroutine destroy (self) Destroys plan Arguments Type Intent Optional Attributes Name class( abstract_executor ), intent(inout) :: self FFT Executor","tags":"","loc":"module/dtfft_abstract_executor.html"},{"title":"dtfft_transpose_handle_datatype – dtFFT","text":"This module describes transpose_handle_datatype class\nThis class implements transposition using MPI_Ialltoall(w)\nwith custom MPI datatypes\nFor the end user this is DTFFT_BACKEND_MPI_DATATYPE - backend.\nBut since it does not perform sequence: transpose -> exchange -> unpack, it is internally treated as tranpose_handle. Uses dtfft_interface_nvtx dtfft_parameters dtfft_errors iso_fortran_env dtfft_pencil dtfft_utils dtfft_abstract_transpose_handle mpi_f08 module~~dtfft_transpose_handle_datatype~~UsesGraph module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype iso_fortran_env iso_fortran_env module~dtfft_transpose_handle_datatype->iso_fortran_env module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_errors dtfft_errors module~dtfft_transpose_handle_datatype->module~dtfft_errors module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_transpose_handle_datatype->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_transpose_handle_datatype->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_transpose_handle_datatype->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_transpose_handle_datatype->mpi_f08 module~dtfft_abstract_transpose_handle->iso_fortran_env module~dtfft_abstract_transpose_handle->module~dtfft_parameters module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_abstract_transpose_handle->mpi_f08 module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_errors->iso_fortran_env module~dtfft_interface_nvtx->module~dtfft_utils iso_c_binding iso_c_binding module~dtfft_interface_nvtx->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_abstract_backend->module~dtfft_config module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nccl->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_transpose_handle_datatype~~UsedByGraph module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=MPI_ADDRESS_KIND), private, parameter :: LB = 0 Lower bound for all derived datatypes logical, private, parameter :: IS_P2P_ENABLED = .false. Is point-to-point communication enabled Derived Types type, public, extends( abstract_transpose_handle ) :: transpose_handle_datatype Tranpose backend that uses MPI_Ialltoall(w) with custom MPI datatypes Components Type Visibility Attributes Name Initial type(MPI_Comm), private :: comm 1d communicator logical, private :: is_even = .false. Is decomposition even logical, private :: is_active = .false. Is async transposition active type( handle_t ), private :: send Handle to send data type( handle_t ), private :: recv Handle to recieve data type(MPI_Request), private, allocatable :: requests (:) Requests for communication integer(kind=int32), private :: n_requests Actual number of requests, can be less than size(requests) logical, private :: is_request_created = .false. Is request created Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates transpose handle procedure, public, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, pass(self) :: create_private => create ../../ Initializes class procedure, public, pass(self) :: execute ../../ Performs MPI_Ialltoall(w) procedure, public, pass(self) :: execute_end ../../ Waits for MPI_Ialltoall(w) to complete procedure, public, pass(self) :: destroy ../../ Destroys class procedure, public, pass(self) :: get_async_active ../../ Returns .true. if async transposition is active type, private :: handle_t Transposition handle class Components Type Visibility Attributes Name Initial type(MPI_Datatype), public, allocatable :: dtypes (:) Datatypes buffer integer(kind=int32), public, allocatable :: counts (:) Number of datatypes (always equals 1) integer(kind=int32), public, allocatable :: displs (:) Displacements is bytes Type-Bound Procedures procedure, public, pass(self) :: create => create_handle ../../ Creates transposition handle procedure, public, pass(self) :: destroy => destroy_handle ../../ Destroys transposition handle Functions private elemental function get_async_active (self) Returns if async transpose is active Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(in) :: self Transpose handle Return Value logical Subroutines private  subroutine create_handle (self, n) Creates transposition handle Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle integer(kind=int32), intent(in) :: n Number of datatypes to be created private  subroutine destroy_handle (self) Destroys transposition handle Arguments Type Intent Optional Attributes Name class( handle_t ), intent(inout) :: self Transposition handle private  subroutine create (self, comm, send, recv, transpose_type, base_storage, kwargs) Creates transpose_handle_datatype class Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle type(MPI_Comm), intent(in) :: comm MPI Communicator type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Base storage type( create_args ), intent(in) :: kwargs Additional arguments private  subroutine execute (self, in, out, kwargs, error_code) Executes transposition Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Result of execution private  subroutine execute_end (self, kwargs, error_code) Ends execution of transposition Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code private  subroutine destroy (self) Destroys transpose_handle_datatype class Arguments Type Intent Optional Attributes Name class( transpose_handle_datatype ), intent(inout) :: self Transpose handle private  subroutine create_transpose_2d (send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates two-dimensional transposition datatypes Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes private  subroutine create_forw_permutation (send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates three-dimensional X –> Y and Y -> Z transposition datatypes Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes private  subroutine create_back_permutation (send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates three-dimensional Y –> X and Z –> Y transposition datatypes Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes private  subroutine create_transpose_XZ (send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates three-dimensional X –> Z transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes private  subroutine create_transpose_ZX (send, send_counts, recv, recv_counts, datatype_id, base_type, base_storage, send_dtype, send_displ, recv_dtype, recv_displ) Creates three-dimensional Z –> X transposition datatypes\nCan only be used with 3D slab decomposition when slabs are distributed in Z direction Arguments Type Intent Optional Attributes Name class( pencil ), intent(in) :: send Information about send buffer integer(kind=int32), intent(in) :: send_counts (:) Rank i is sending this counts class( pencil ), intent(in) :: recv Information about send buffer integer(kind=int32), intent(in) :: recv_counts (:) Rank i is recieving this counts integer(kind=int8), intent(in) :: datatype_id Id of transpose plan to use type(MPI_Datatype), intent(in) :: base_type Base MPI_Datatype integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type(MPI_Datatype), intent(out) :: send_dtype Datatype used to send data integer(kind=int32), intent(out) :: send_displ Send displacement in bytes type(MPI_Datatype), intent(out) :: recv_dtype Datatype used to recv data integer(kind=int32), intent(out) :: recv_displ Recv displacement in bytes private  subroutine free_datatypes (t1, t2, t3, t4) Frees temporary datatypes Arguments Type Intent Optional Attributes Name type(MPI_Datatype), intent(inout), optional :: t1 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t2 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t3 Temporary datatype type(MPI_Datatype), intent(inout), optional :: t4 Temporary datatype","tags":"","loc":"module/dtfft_transpose_handle_datatype.html"},{"title":"dtfft_interface_mkl_m – dtFFT","text":"This module creates C interface with MKL library Uses dtfft_utils iso_c_binding module~~dtfft_interface_mkl_m~~UsesGraph module~dtfft_interface_mkl_m dtfft_interface_mkl_m iso_c_binding iso_c_binding module~dtfft_interface_mkl_m->iso_c_binding module~dtfft_utils dtfft_utils module~dtfft_interface_mkl_m->module~dtfft_utils module~dtfft_utils->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_utils->iso_fortran_env module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_parameters dtfft_parameters module~dtfft_utils->module~dtfft_parameters mpi_f08 mpi_f08 module~dtfft_utils->mpi_f08 module~dtfft_errors->iso_fortran_env module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_mkl_m~~UsedByGraph module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface mkl_dfti_set_value Sets one particular configuration parameter with the specified configuration value. private  function mkl_dfti_set_integer(desc, param, value) result(status) bind(C) Sets one particular configuration parameter with integer value. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. integer(kind=c_int), intent(in), value :: param Configuration parameter. integer(kind=c_int), intent(in), value :: value Configuration value. Return Value integer(kind=c_long) Function completion status. private  function mkl_dfti_set_pointer(desc, param, value) result(status) bind(C) Sets one particular configuration parameter with pointer value. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. integer(kind=c_int), intent(in), value :: param Configuration parameter. integer(kind=c_long), intent(in) :: value (*) Configuration value. Return Value integer(kind=c_long) Function completion status. interface public  function mkl_dfti_create_desc(precision, domain, dim, length, desc) result(status) bind(C) Allocates the descriptor data structure and initializes it with default configuration values. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: precision Precision of the transform: DFTI_SINGLE or DFTI_DOUBLE. integer(kind=c_int), intent(in), value :: domain Forward domain of the transform: DFTI_COMPLEX or DFTI_REAL. integer(kind=c_long), intent(in), value :: dim Dimension of the transform. integer(kind=c_long), intent(in) :: length (*) Length of the transform for a one-dimensional transform.\nLengths of each dimension for a multi-dimensional transform. type(c_ptr) :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status. interface public  function mkl_dfti_commit_desc(desc) result(status) bind(C) Performs all initialization for the actual FFT computation. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status. interface public  function mkl_dfti_execute(desc, in, out, sign) result(status) bind(C) Computes FFT. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. type(c_ptr), value :: in Data to be transformed type(c_ptr), value :: out The transformed data integer(kind=c_int), intent(in), value :: sign Sign of transform Return Value integer(kind=c_long) Function completion status. interface public  function mkl_dfti_free_desc(desc) result(status) bind(C) Frees the memory allocated for a descriptor. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: desc FFT descriptor. Return Value integer(kind=c_long) Function completion status. interface public  function mkl_dfti_mem_alloc(alloc_bytes, ptr) result(status) bind(C) Allocates pointer via mkl_malloc Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), value :: alloc_bytes Number of bytes to allocate. type(c_ptr) :: ptr Pointer to allocated memory. Return Value integer(kind=c_long) Function completion status. interface public  function mkl_dfti_mem_free(ptr) result(status) bind(C) Frees pointer via mkl_free Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Pointer to allocated memory. Return Value integer(kind=c_long) Function completion status. interface private  function DftiErrorMessage_c(error_code) result(message) bind(C, name=\"DftiErrorMessage\") Generates an error message. Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in), value :: error_code Completion status of a function. Return Value type(c_ptr) Pointer to message Functions public  function DftiErrorMessage (error_code) result(string) Generates an error message. Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in) :: error_code Completion status of a function. Return Value character(len=:), allocatable Error message","tags":"","loc":"module/dtfft_interface_mkl_m.html"},{"title":"dtfft_abstract_transpose_handle – dtFFT","text":"This module defines abstract_transpose_handle type and its type bound procedures. This handle is used to perform data transpositions between distributed pencils.\nThe actual implementation of the handle is deferred to the create_private , execute , execute_end , destroy and get_async_active procedures. Uses dtfft_parameters dtfft_pencil iso_fortran_env dtfft_abstract_backend mpi_f08 module~~dtfft_abstract_transpose_handle~~UsesGraph module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle iso_fortran_env iso_fortran_env module~dtfft_abstract_transpose_handle->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_parameters dtfft_parameters module~dtfft_abstract_transpose_handle->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_abstract_transpose_handle->module~dtfft_pencil mpi_f08 mpi_f08 module~dtfft_abstract_transpose_handle->mpi_f08 module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->mpi_f08 iso_c_binding iso_c_binding module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_abstract_backend->module~dtfft_config module~dtfft_errors dtfft_errors module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_utils dtfft_utils module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_utils module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->mpi_f08 module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_parameters module~dtfft_config->mpi_f08 module~dtfft_config->iso_c_binding module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_utils module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->module~dtfft_errors module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_abstract_transpose_handle~~UsedByGraph module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface private elemental function get_async_active_interface(self) Returns if async transpose is active Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(in) :: self Abstract Transpose Handle Return Value logical abstract interface private  subroutine create_interface(self, comm, send, recv, transpose_type, base_storage, kwargs) Creates transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract transpose handle type(MPI_Comm), intent(in) :: comm MPI Communicator type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil type( dtfft_transpose_t ), intent(in) :: transpose_type Type of transpose to create integer(kind=int64), intent(in) :: base_storage Base storage type( create_args ), intent(in) :: kwargs Additional arguments abstract interface private  subroutine execute_interface(self, in, out, kwargs, error_code) Executes transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract Transpose Handle real(kind=real32), intent(inout) :: in (:) Send pointer real(kind=real32), intent(inout) :: out (:) Recv pointer type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code abstract interface private  subroutine execute_end_interface(self, kwargs, error_code) Finishes async transpose Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract Transpose Handle type( execute_args ), intent(inout) :: kwargs Additional arguments integer(kind=int32), intent(out) :: error_code Error code abstract interface private  subroutine destroy_interface(self) Destroys transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract Transpose Handle Derived Types type, public :: create_args Arguments for creating transpose handle Components Type Visibility Attributes Name Initial type( dtfft_platform_t ), public :: platform Platform type type( backend_helper ), public :: helper Backend helper type( dtfft_effort_t ), public :: effort Effort level for generating transpose kernels type( dtfft_backend_t ), public :: backend Backend type logical, public :: force_effort Should effort be forced or not type(MPI_Datatype), public :: base_type Base MPI Datatype integer(kind=int8), public :: datatype_id Type of datatype to use integer(kind=int8), public :: comm_id ID of communicator to use type, public :: execute_args Arguments for executing transpose handle Components Type Visibility Attributes Name Initial type( dtfft_stream_t ), public :: stream Stream to execute on type( async_exec_t ), public :: exec_type Async execution type real(kind=real32), public, pointer :: p1 (:) aux pointer for pipelined operations, in pointer for execute_end real(kind=real32), public, pointer :: p2 (:) out pointer for execute_end type, public, abstract :: abstract_transpose_handle Abstract transpose handle type Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates transpose handle procedure, public, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure( create_interface ), public, deferred :: create_private ../../ Creates transpose handle procedure( execute_interface ), public, deferred :: execute ../../ Executes transpose handle procedure( execute_end_interface ), public, deferred :: execute_end ../../ Finishes async transpose procedure( destroy_interface ), public, deferred :: destroy ../../ Destroys transpose handle procedure( get_async_active_interface ), public, deferred :: get_async_active ../../ Returns if async transpose is active Functions private pure function get_aux_size (self) Returns number of bytes required by aux buffer Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(in) :: self Abstract Transpose Handle Return Value integer(kind=int64) Subroutines private  subroutine create (self, send, recv, base_storage, kwargs) Creates transpose handle Arguments Type Intent Optional Attributes Name class( abstract_transpose_handle ), intent(inout) :: self Abstract transpose handle type( pencil ), intent(in) :: send Send pencil type( pencil ), intent(in) :: recv Recv pencil integer(kind=int64), intent(in) :: base_storage Base storage size type( create_args ), intent(inout) :: kwargs Additional arguments","tags":"","loc":"module/dtfft_abstract_transpose_handle.html"},{"title":"dtfft_backend_cufftmp_m – dtFFT","text":"cuFFTMp GPU Backend backend_cufftmp Uses dtfft_interface_nvshmem dtfft_parameters dtfft_errors iso_fortran_env dtfft_interface_cufft dtfft_pencil dtfft_abstract_backend dtfft_utils dtfft_interface_cuda_runtime iso_c_binding mpi_f08 module~~dtfft_backend_cufftmp_m~~UsesGraph module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m iso_c_binding iso_c_binding module~dtfft_backend_cufftmp_m->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_backend_cufftmp_m->iso_fortran_env module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_errors dtfft_errors module~dtfft_backend_cufftmp_m->module~dtfft_errors module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_parameters dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_pencil dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_backend_cufftmp_m->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_backend_cufftmp_m->mpi_f08 module~dtfft_abstract_backend->iso_c_binding module~dtfft_abstract_backend->iso_fortran_env module~dtfft_abstract_backend->module~dtfft_errors module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_backend->mpi_f08 module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_config dtfft_config module~dtfft_abstract_backend->module~dtfft_config module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_errors->iso_fortran_env module~dtfft_interface_cuda_runtime->iso_c_binding module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->iso_c_binding module~dtfft_interface_cufft->iso_fortran_env module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_nvshmem->iso_c_binding module~dtfft_interface_nvshmem->iso_fortran_env module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_nvshmem->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_pencil->iso_c_binding module~dtfft_pencil->iso_fortran_env module~dtfft_pencil->module~dtfft_errors module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_utils module~dtfft_pencil->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_errors module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->mpi_f08 module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_config->iso_c_binding module~dtfft_config->iso_fortran_env module~dtfft_config->module~dtfft_errors module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_utils module~dtfft_config->mpi_f08 module~dtfft_interface_nccl->iso_c_binding module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvtx->iso_c_binding module~dtfft_interface_nvtx->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_backend_cufftmp_m~~UsedByGraph module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( abstract_backend ) :: backend_cufftmp cuFFTMp GPU Backend Components Type Visibility Attributes Name Initial type( dtfft_backend_t ), public :: backend Backend type type( dtfft_platform_t ), public :: platform Platform to use logical, public :: is_selfcopy If backend is self-copying logical, public :: is_pipelined If backend is pipelined integer(kind=int64), public :: aux_size Number of bytes required by aux buffer integer(kind=int64), public :: send_recv_buffer_size Number of float elements used in c_f_pointer type(MPI_Comm), public :: comm MPI Communicator integer(kind=int32), public, allocatable :: comm_mapping (:) Mapping of 1d comm ranks to global comm integer(kind=int32), public :: comm_size Size of MPI Comm integer(kind=int32), public :: comm_rank Rank in MPI Comm integer(kind=int64), public, allocatable :: send_displs (:) Send data displacements, in float elements integer(kind=int64), public, allocatable :: send_floats (:) Send data elements, in float elements integer(kind=int64), public, allocatable :: recv_displs (:) Recv data displacements, in float elements integer(kind=int64), public, allocatable :: recv_floats (:) Recv data elements, in float elements type( cudaEvent ), public :: execution_event Event for main execution stream type( cudaEvent ), public :: copy_event Event for copy stream type( dtfft_stream_t ), public :: copy_stream Stream for copy operations integer(kind=int64), public :: self_copy_bytes Number of bytes to copy it itself integer(kind=int64), public :: self_send_displ Displacement for send buffer integer(kind=int64), public :: self_recv_displ Displacement for recv buffer class( abstract_kernel ), public, pointer :: unpack_kernel Kernel for unpacking data type( cufftReshapeHandle ), private :: plan Type-Bound Procedures procedure, public, non_overridable, pass(self) :: create ../../ Creates Abstract Backend procedure, public, non_overridable, pass(self) :: execute ../../ Executes Backend procedure, public, non_overridable, pass(self) :: destroy ../../ Destroys Abstract Backend procedure, public, non_overridable, pass(self) :: get_aux_size ../../ Returns number of bytes required by aux buffer procedure, public, non_overridable, pass(self) :: set_unpack_kernel ../../ Sets unpack kernel for pipelined backend procedure, public, pass(self) :: execute_end ../../ Ends execution of Backend procedure, public, pass(self) :: get_async_active ../../ Returns if async execution is active procedure, public :: create_private => create procedure, public :: execute_private => execute procedure, public :: destroy_private => destroy type, private :: Box3D cuFFTMp Box Components Type Visibility Attributes Name Initial integer(kind=c_long_long), public :: lower (3) Lower box boundaries integer(kind=c_long_long), public :: upper (3) Upper box boundaries integer(kind=c_long_long), public :: strides (3) Strides in memory Subroutines private  subroutine create (self, helper, base_storage) Creates cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend type( backend_helper ), intent(in) :: helper Backend helper integer(kind=int64), intent(in) :: base_storage Number of bytes to store single element private  subroutine execute (self, in, out, stream, aux, exec_type, error_code) Executes cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend real(kind=real32), intent(inout), target :: in (:) Send pointer real(kind=real32), intent(inout), target :: out (:) Recv pointer type( dtfft_stream_t ), intent(in) :: stream Main execution CUDA stream real(kind=real32), intent(inout), target :: aux (:) Aux pointer type( async_exec_t ), intent(in) :: exec_type Type of async execution integer(kind=int32), intent(out) :: error_code Error code private  subroutine destroy (self) Destroys cuFFTMp GPU Backend Arguments Type Intent Optional Attributes Name class( backend_cufftmp ), intent(inout) :: self cuFFTMp GPU Backend","tags":"","loc":"module/dtfft_backend_cufftmp_m.html"},{"title":"dtfft_interface_fftw_m – dtFFT","text":"This module creates interface with fftw3 library Uses dtfft_interface_fftw_native_m iso_c_binding module~~dtfft_interface_fftw_m~~UsesGraph module~dtfft_interface_fftw_m dtfft_interface_fftw_m dtfft_interface_fftw_native_m dtfft_interface_fftw_native_m module~dtfft_interface_fftw_m->dtfft_interface_fftw_native_m iso_c_binding iso_c_binding module~dtfft_interface_fftw_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_interface_fftw_m~~UsedByGraph module~dtfft_interface_fftw_m dtfft_interface_fftw_m module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_interface_fftw_m module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface public  function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Creates C2C plan, double precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C) Creates C2C plan, single precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_INT), value :: sign integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates R2C plan, double precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates R2C plan, single precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates C2R plan, double precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C) Creates C2R plan, single precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C) Creates R2R plan, double precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kind (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C) Creates R2R plan, single precision. Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: rank integer(kind=c_int) :: n (*) integer(kind=c_int), value :: howmany type(c_ptr), value :: in integer(kind=c_int) :: inembed (*) integer(kind=c_int), value :: istride integer(kind=c_int), value :: idist type(c_ptr), value :: out integer(kind=c_int) :: onembed (*) integer(kind=c_int), value :: ostride integer(kind=c_int), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in) :: kind (*) integer(kind=c_int), value :: flags Return Value type(c_ptr) interface public  subroutine fftw_execute_dft(plan, in, out) bind(C) Executes C2C plan, double precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftwf_execute_dft(plan, in, out) bind(C) Executes C2C plan, single precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftw_execute_dft_r2c(plan, in, out) bind(C) Executes R2C plan, double precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftwf_execute_dft_r2c(plan, in, out) bind(C) Executes R2C plan, single precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftw_execute_dft_c2r(plan, in, out) bind(C) Executes C2R plan, double precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftwf_execute_dft_c2r(plan, in, out) bind(C) Executes C2R plan, single precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftw_execute_r2r(plan, in, out) bind(C) Executes R2R plan, double precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out interface public  subroutine fftwf_execute_r2r(plan, in, out) bind(C) Executes R2R plan, single precision. Arguments Type Intent Optional Attributes Name type(c_ptr), value :: plan type(c_ptr), value :: in type(c_ptr), value :: out","tags":"","loc":"module/dtfft_interface_fftw_m.html"},{"title":"dtfft_parameters – dtFFT","text":"This module defines common dtFFT parameters Uses iso_fortran_env iso_c_binding mpi_f08 module~~dtfft_parameters~~UsesGraph module~dtfft_parameters dtfft_parameters iso_c_binding iso_c_binding module~dtfft_parameters->iso_c_binding iso_fortran_env iso_fortran_env module~dtfft_parameters->iso_fortran_env mpi_f08 mpi_f08 module~dtfft_parameters->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_parameters~~UsedByGraph module~dtfft_parameters dtfft_parameters module~dtfft dtfft module~dtfft->module~dtfft_parameters module~dtfft_config dtfft_config module~dtfft->module~dtfft_config module~dtfft_pencil dtfft_pencil module~dtfft->module~dtfft_pencil module~dtfft_plan dtfft_plan module~dtfft->module~dtfft_plan module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_parameters module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_abstract_backend->module~dtfft_config module~dtfft_interface_cuda_runtime dtfft_interface_cuda_runtime module~dtfft_abstract_backend->module~dtfft_interface_cuda_runtime module~dtfft_interface_nccl dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_interface_nccl module~dtfft_abstract_backend->module~dtfft_pencil module~dtfft_utils dtfft_utils module~dtfft_abstract_backend->module~dtfft_utils module~dtfft_abstract_executor dtfft_abstract_executor module~dtfft_abstract_executor->module~dtfft_parameters module~dtfft_abstract_executor->module~dtfft_pencil module~dtfft_abstract_executor->module~dtfft_utils module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_executor->module~dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_utils module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_abstract_transpose_handle->module~dtfft_parameters module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_abstract_transpose_handle->module~dtfft_pencil module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_parameters module~dtfft_api->module~dtfft_config module~dtfft_api->module~dtfft_pencil module~dtfft_api->module~dtfft_plan module~dtfft_api->module~dtfft_utils module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_backend_cufftmp_m->module~dtfft_parameters module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_interface_cuda_runtime module~dtfft_interface_cufft dtfft_interface_cufft module~dtfft_backend_cufftmp_m->module~dtfft_interface_cufft module~dtfft_interface_nvshmem dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_interface_nvshmem module~dtfft_backend_cufftmp_m->module~dtfft_pencil module~dtfft_backend_cufftmp_m->module~dtfft_utils module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_backend_mpi->module~dtfft_parameters module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_interface_cuda_runtime module~dtfft_backend_mpi->module~dtfft_utils module~dtfft_backend_mpi->module~dtfft_interface_nvtx module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_backend_nccl_m->module~dtfft_parameters module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_interface_cuda_runtime module~dtfft_backend_nccl_m->module~dtfft_interface_nccl module~dtfft_backend_nccl_m->module~dtfft_utils module~dtfft_config->module~dtfft_parameters module~dtfft_config->module~dtfft_interface_cuda_runtime module~dtfft_config->module~dtfft_utils module~dtfft_executor_cufft_m dtfft_executor_cufft_m module~dtfft_executor_cufft_m->module~dtfft_parameters module~dtfft_executor_cufft_m->module~dtfft_abstract_executor module~dtfft_executor_cufft_m->module~dtfft_config module~dtfft_executor_cufft_m->module~dtfft_interface_cuda_runtime module~dtfft_executor_cufft_m->module~dtfft_interface_cufft module~dtfft_executor_cufft_m->module~dtfft_utils module~dtfft_executor_fftw_m dtfft_executor_fftw_m module~dtfft_executor_fftw_m->module~dtfft_parameters module~dtfft_executor_fftw_m->module~dtfft_abstract_executor module~dtfft_executor_fftw_m->module~dtfft_pencil module~dtfft_executor_fftw_m->module~dtfft_utils module~dtfft_executor_mkl_m dtfft_executor_mkl_m module~dtfft_executor_mkl_m->module~dtfft_parameters module~dtfft_executor_mkl_m->module~dtfft_abstract_executor module~dtfft_executor_mkl_m->module~dtfft_utils module~dtfft_interface_mkl_m dtfft_interface_mkl_m module~dtfft_executor_mkl_m->module~dtfft_interface_mkl_m module~dtfft_executor_vkfft_m dtfft_executor_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_parameters module~dtfft_executor_vkfft_m->module~dtfft_abstract_executor module~dtfft_executor_vkfft_m->module~dtfft_config module~dtfft_interface_vkfft_m dtfft_interface_vkfft_m module~dtfft_executor_vkfft_m->module~dtfft_interface_vkfft_m module~dtfft_interface_cuda dtfft_interface_cuda module~dtfft_interface_cuda->module~dtfft_parameters module~dtfft_interface_cuda->module~dtfft_utils module~dtfft_interface_cuda_runtime->module~dtfft_parameters module~dtfft_interface_cuda_runtime->module~dtfft_utils module~dtfft_interface_cufft->module~dtfft_parameters module~dtfft_interface_cufft->module~dtfft_utils module~dtfft_interface_nccl->module~dtfft_parameters module~dtfft_interface_nccl->module~dtfft_utils module~dtfft_interface_nvshmem->module~dtfft_parameters module~dtfft_interface_nvshmem->module~dtfft_utils module~dtfft_interface_vkfft_m->module~dtfft_parameters module~dtfft_interface_vkfft_m->module~dtfft_utils module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_parameters module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_kernel_device->module~dtfft_config module~dtfft_kernel_device->module~dtfft_interface_cuda module~dtfft_kernel_device->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_utils module~dtfft_kernel_device->module~dtfft_interface_nvtx module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_kernel_host dtfft_kernel_host module~dtfft_kernel_host->module~dtfft_parameters module~dtfft_kernel_host->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_parameters module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_config module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda module~dtfft_nvrtc_block_optimizer->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_block_optimizer->module~dtfft_utils module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_parameters module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_config module~dtfft_nvrtc_module->module~dtfft_interface_cuda module~dtfft_nvrtc_module->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module->module~dtfft_utils module~dtfft_interface_nvrtc dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_interface_nvrtc module~dtfft_nvrtc_module->module~dtfft_interface_nvtx module~dtfft_pencil->module~dtfft_parameters module~dtfft_pencil->module~dtfft_interface_cuda_runtime module~dtfft_pencil->module~dtfft_utils module~dtfft_plan->module~dtfft_parameters module~dtfft_plan->module~dtfft_abstract_executor module~dtfft_plan->module~dtfft_config module~dtfft_plan->module~dtfft_executor_cufft_m module~dtfft_plan->module~dtfft_executor_fftw_m module~dtfft_plan->module~dtfft_executor_mkl_m module~dtfft_plan->module~dtfft_executor_vkfft_m module~dtfft_plan->module~dtfft_interface_cuda_runtime module~dtfft_plan->module~dtfft_interface_nvshmem module~dtfft_plan->module~dtfft_pencil module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_plan->module~dtfft_utils module~dtfft_plan->module~dtfft_interface_nvtx module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_handle_datatype->module~dtfft_parameters module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype->module~dtfft_pencil module~dtfft_transpose_handle_datatype->module~dtfft_utils module~dtfft_transpose_handle_datatype->module~dtfft_interface_nvtx module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_parameters module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_transpose_handle_generic->module~dtfft_pencil module~dtfft_transpose_handle_generic->module~dtfft_utils module~dtfft_transpose_plan->module~dtfft_parameters module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_transpose_plan->module~dtfft_config module~dtfft_transpose_plan->module~dtfft_interface_cuda module~dtfft_transpose_plan->module~dtfft_interface_cuda_runtime module~dtfft_transpose_plan->module~dtfft_interface_nccl module~dtfft_transpose_plan->module~dtfft_interface_nvshmem module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_pencil module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_utils module~dtfft_transpose_plan->module~dtfft_interface_nvrtc module~dtfft_transpose_plan->module~dtfft_interface_nvtx module~dtfft_utils->module~dtfft_parameters module~dtfft_interface_mkl_m->module~dtfft_utils module~dtfft_interface_nvrtc->module~dtfft_utils module~dtfft_interface_nvtx->module~dtfft_utils module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_config module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda module~dtfft_nvrtc_module_cache->module~dtfft_interface_cuda_runtime module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_nvrtc_module_cache->module~dtfft_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DTFFT_VERSION_MAJOR = 2 dtFFT Major Version integer(kind=int32), public, parameter :: DTFFT_VERSION_MINOR = 3 dtFFT Minor Version integer(kind=int32), public, parameter :: DTFFT_VERSION_PATCH = 0 dtFFT Patch Version integer(kind=int32), public, parameter :: DTFFT_VERSION_CODE = 203000 dtFFT Version Code. Can be used in Version comparison real(kind=real32), public, parameter :: MAX_REAL32 = huge(1._real32) Maximum value of real32 integer(kind=int32), public, parameter :: MAX_INT32 = huge(1_int32) Maximum value of int32 type( dtfft_execute_t ), public, parameter :: DTFFT_EXECUTE_FORWARD = dtfft_execute_t(11) Perform XYZ –> YZX –> ZXY plan execution (Forward) type( dtfft_execute_t ), public, parameter :: DTFFT_EXECUTE_BACKWARD = dtfft_execute_t(12) Perform ZXY –> YZX –> XYZ plan execution (Backward) type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_X_TO_Y = dtfft_transpose_t(+1) Perform single transposition, from X aligned to Y aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_Y_TO_X = dtfft_transpose_t((-1)) Perform single transposition, from Y aligned to X aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_X_TO_Z = dtfft_transpose_t(+3) Perform single transposition, from X aligned to Z aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_Y_TO_Z = dtfft_transpose_t(+2) Perform single transposition, from Y aligned to Z aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_Z_TO_Y = dtfft_transpose_t((-2)) Perform single transposition, from Z aligned to Y aligned type( dtfft_transpose_t ), public, parameter :: DTFFT_TRANSPOSE_Z_TO_X = dtfft_transpose_t((-3)) Perform single transposition, from Z aligned to X aligned character(len=*), public, parameter :: TRANSPOSE_NAMES (-3:3) = [\"Z_TO_X\", \"Z_TO_Y\", \"Y_TO_X\", \" NULL \", \"X_TO_Y\", \"Y_TO_Z\", \"X_TO_Z\"] String representation of dtfft_transpose_t type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_NONE = dtfft_executor_t(0) Do not setup any executor. If this type is provided, then execute method should not be called.\nUse transpose method instead type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_FFTW3 = dtfft_executor_t(1) FFTW3 executor type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_MKL = dtfft_executor_t(2) MKL executor type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_CUFFT = dtfft_executor_t(3) cuFFT GPU executor type( dtfft_executor_t ), public, parameter :: DTFFT_EXECUTOR_VKFFT = dtfft_executor_t(4) VkFFT GPU executor integer(kind=int8), public, parameter :: FFT_FORWARD = (-1) Forward c2c transform integer(kind=int8), public, parameter :: FFT_BACKWARD = (+1) Backward c2c transform type( dtfft_effort_t ), public, parameter :: DTFFT_ESTIMATE = dtfft_effort_t(0) Estimate flag. dtFFT will use default decomposition provided by MPI_Dims_create type( dtfft_effort_t ), public, parameter :: DTFFT_MEASURE = dtfft_effort_t(+1) Measure flag. dtFFT will run transpose routines to find the best grid decomposition.\nPassing this flag and MPI Communicator with Cartesian topology to plan%create makes dtFFT do nothing. type( dtfft_effort_t ), public, parameter :: DTFFT_PATIENT = dtfft_effort_t(+2) Patient flag. Same as DTFFT_MEASURE , but different MPI datatypes will also be tested type( dtfft_precision_t ), public, parameter :: DTFFT_SINGLE = dtfft_precision_t(0) Use single precision type( dtfft_precision_t ), public, parameter :: DTFFT_DOUBLE = dtfft_precision_t(+1) Use double precision type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DCT_1 = dtfft_r2r_kind_t(+3) DCT-I (Logical N=2*(n-1), inverse is DTFFT_DCT_1 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DCT_2 = dtfft_r2r_kind_t(+5) DCT-II (Logical N=2*n, inverse is DTFFT_DCT_3 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DCT_3 = dtfft_r2r_kind_t(+4) DCT-III (Logical N=2*n, inverse is DTFFT_DCT_2 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DCT_4 = dtfft_r2r_kind_t(+6) DCT-IV (Logical N=2*n, inverse is DTFFT_DCT_4 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DST_1 = dtfft_r2r_kind_t(+7) DST-I (Logical N=2*(n+1), inverse is DTFFT_DST_1 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DST_2 = dtfft_r2r_kind_t(+9) DST-II (Logical N=2*n, inverse is DTFFT_DST_3 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DST_3 = dtfft_r2r_kind_t(+8) DST-III (Logical N=2*n, inverse is DTFFT_DST_2 ) type( dtfft_r2r_kind_t ), public, parameter :: DTFFT_DST_4 = dtfft_r2r_kind_t(+10) DST-IV (Logical N=2*n, inverse is DTFFT_DST_4 ) integer(kind=int64), public, parameter :: DOUBLE_COMPLEX_STORAGE_SIZE = storage_size((1._real64, 1._real64))/8_int64 Number of bytes to store single double precision complex element integer(kind=int64), public, parameter :: COMPLEX_STORAGE_SIZE = storage_size((1._real32, 1._real32))/8_int64 Number of bytes to store single float precision complex element integer(kind=int64), public, parameter :: DOUBLE_STORAGE_SIZE = storage_size(1._real64)/8_int64 Number of bytes to store single double precision real element integer(kind=int64), public, parameter :: FLOAT_STORAGE_SIZE = storage_size(1._real32)/8_int64 Number of bytes to store single single precision real element integer(kind=int32), public, parameter :: COLOR_CREATE = int(Z'00FAB53C') Color for plan.create integer(kind=int32), public, parameter :: COLOR_EXECUTE = int(Z'00E25DFC') Color for plan.execute integer(kind=int32), public, parameter :: COLOR_TRANSPOSE = int(Z'00B175BD') Color for plan.transpose integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_XY = int(Z'005DFCCA') Color for DTFFT_TRANSPOSE_X_TO_Y integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_YX = int(Z'0076A797') Color for DTFFT_TRANSPOSE_Y_TO_X integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_YZ = int(Z'00E3CF9F') Color for DTFFT_TRANSPOSE_Y_TO_Z integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_ZY = int(Z'008C826A') Color for DTFFT_TRANSPOSE_Z_TO_Y integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_XZ = int(Z'00546F66') Color for DTFFT_TRANSPOSE_X_TO_Z integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_ZX = int(Z'007A6D7D') Color for DTFFT_TRANSPOSE_Z_TO_X integer(kind=int32), public, parameter :: COLOR_FFT = int(Z'00FCD05D') Color for FFT integer(kind=int32), public, parameter :: COLOR_AUTOTUNE = int(Z'006075FF') Color for Autotune integer(kind=int32), public, parameter :: COLOR_AUTOTUNE2 = int(Z'0056E874') Color for Autotune2 integer(kind=int32), public, parameter :: COLOR_DESTROY = int(Z'00000000') Color for plan.destroy integer(kind=int32), public, parameter :: COLOR_TRANSPOSE_PALLETTE (-3:3) = [COLOR_TRANSPOSE_ZX, COLOR_TRANSPOSE_ZY, COLOR_TRANSPOSE_YX, 0, COLOR_TRANSPOSE_XY, COLOR_TRANSPOSE_YZ, COLOR_TRANSPOSE_XZ] Color pallete for plan.transpose integer(kind=int32), public, parameter :: VARIABLE_NOT_SET = -111 Default value when environ is not set type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_DATATYPE = dtfft_backend_t(21) Backend that uses MPI datatypes\nThis is default backend for Host build.\nNot really recommended to use for GPU usage, since it is a ‘million’ times slower than other backends. type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_P2P = dtfft_backend_t(22) MPI peer-to-peer algorithm type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_A2A = dtfft_backend_t(23) MPI backend using MPI_Alltoallv type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_RMA = dtfft_backend_t(29) MPI RMA backend type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_RMA_PIPELINED = dtfft_backend_t(30) MPI Pipelined RMA backend type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_NCCL = dtfft_backend_t(24) NCCL backend type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_MPI_P2P_PIPELINED = dtfft_backend_t(26) MPI peer-to-peer algorithm with overlapping data copying and unpacking type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_NCCL_PIPELINED = dtfft_backend_t(27) NCCL backend with overlapping data copying and unpacking type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_CUFFTMP = dtfft_backend_t(25) cuFFTMp backend type( dtfft_backend_t ), public, parameter :: DTFFT_BACKEND_CUFFTMP_PIPELINED = dtfft_backend_t(28) cuFFTMp backend that uses extra buffer to gain performance type( dtfft_backend_t ), public, parameter :: BACKEND_NOT_SET = dtfft_backend_t(VARIABLE_NOT_SET) Backend is not used type( dtfft_backend_t ), public, parameter :: VALID_BACKENDS (*) = [DTFFT_BACKEND_MPI_DATATYPE, DTFFT_BACKEND_MPI_P2P, DTFFT_BACKEND_MPI_A2A, DTFFT_BACKEND_MPI_P2P_PIPELINED, DTFFT_BACKEND_NCCL_PIPELINED, DTFFT_BACKEND_NCCL, DTFFT_BACKEND_CUFFTMP, DTFFT_BACKEND_CUFFTMP_PIPELINED] List of valid GPU backends that dtFFT was compiled for type( dtfft_stream_t ), public, parameter :: NULL_STREAM = dtfft_stream_t(c_null_ptr) type( dtfft_platform_t ), public, parameter :: DTFFT_PLATFORM_HOST = dtfft_platform_t(1) Host platform type( dtfft_platform_t ), public, parameter :: DTFFT_PLATFORM_CUDA = dtfft_platform_t(2) CUDA platform type( dtfft_platform_t ), public, parameter :: PLATFORM_NOT_SET = dtfft_platform_t(VARIABLE_NOT_SET) type( async_exec_t ), public, parameter :: EXEC_BLOCKING = async_exec_t(1) Blocking execution type( async_exec_t ), public, parameter :: EXEC_NONBLOCKING = async_exec_t(2) Non-blocking execution type( dtfft_execute_t ), private, parameter :: VALID_EXECUTE_TYPES (*) = [DTFFT_EXECUTE_FORWARD, DTFFT_EXECUTE_BACKWARD] Valid execute types type( dtfft_transpose_t ), private, parameter :: VALID_TRANSPOSE_TYPES (*) = [DTFFT_TRANSPOSE_X_TO_Y, DTFFT_TRANSPOSE_Y_TO_X, DTFFT_TRANSPOSE_Y_TO_Z, DTFFT_TRANSPOSE_Z_TO_Y, DTFFT_TRANSPOSE_X_TO_Z, DTFFT_TRANSPOSE_Z_TO_X] Types of transpose that are valid to pass to transpose method type( dtfft_executor_t ), private, parameter :: VALID_EXECUTORS (*) = [DTFFT_EXECUTOR_NONE, DTFFT_EXECUTOR_FFTW3, DTFFT_EXECUTOR_MKL, DTFFT_EXECUTOR_CUFFT, DTFFT_EXECUTOR_VKFFT] List of valid executors type( dtfft_executor_t ), private, parameter :: HOST_EXECUTORS (*) = [DTFFT_EXECUTOR_NONE, DTFFT_EXECUTOR_FFTW3, DTFFT_EXECUTOR_MKL] List of host executors type( dtfft_executor_t ), private, parameter :: CUDA_EXECUTORS (*) = [DTFFT_EXECUTOR_NONE, DTFFT_EXECUTOR_CUFFT, DTFFT_EXECUTOR_VKFFT] List of CUDA executors type( dtfft_effort_t ), private, parameter :: VALID_EFFORTS (*) = [DTFFT_ESTIMATE, DTFFT_MEASURE, DTFFT_PATIENT] Valid effort flags type( dtfft_precision_t ), private, parameter :: VALID_PRECISIONS (*) = [DTFFT_SINGLE, DTFFT_DOUBLE] Valid precision flags type( dtfft_r2r_kind_t ), private, parameter :: VALID_R2R_KINDS (*) = [DTFFT_DCT_1, DTFFT_DCT_2, DTFFT_DCT_3, DTFFT_DCT_4, DTFFT_DST_1, DTFFT_DST_2, DTFFT_DST_3, DTFFT_DST_4] Array of valid R2R kinds integer(kind=int8), private, parameter :: VALID_DIMENSIONS (*) = [2_int8, 3_int8] Valid dimensions for plan.create integer(kind=int32), private, parameter :: VALID_COMM_TYPES (*) = [MPI_UNDEFINED, MPI_CART] Valid communicator types for plan.create type( dtfft_backend_t ), private, parameter :: PIPELINED_BACKENDS (*) = [DTFFT_BACKEND_MPI_P2P_PIPELINED, DTFFT_BACKEND_NCCL_PIPELINED, DTFFT_BACKEND_CUFFTMP_PIPELINED, DTFFT_BACKEND_MPI_RMA_PIPELINED] List of pipelined backends type( dtfft_backend_t ), private, parameter :: MPI_BACKENDS (*) = [DTFFT_BACKEND_MPI_P2P, DTFFT_BACKEND_MPI_A2A, DTFFT_BACKEND_MPI_P2P_PIPELINED, DTFFT_BACKEND_MPI_RMA, DTFFT_BACKEND_MPI_RMA_PIPELINED] List of MPI backends type( dtfft_backend_t ), private, parameter :: NCCL_BACKENDS (*) = [DTFFT_BACKEND_NCCL, DTFFT_BACKEND_NCCL_PIPELINED] List of NCCL backends type( dtfft_backend_t ), private, parameter :: CUFFTMP_BACKENDS (*) = [DTFFT_BACKEND_CUFFTMP, DTFFT_BACKEND_CUFFTMP_PIPELINED] List of cuFFTMp backends type( dtfft_backend_t ), private, parameter :: NVSHMEM_BACKENDS (*) = [DTFFT_BACKEND_CUFFTMP, DTFFT_BACKEND_CUFFTMP_PIPELINED] List of NVSHMEM-based backends type( dtfft_platform_t ), private, parameter :: VALID_PLATFORMS (*) = [DTFFT_PLATFORM_HOST, DTFFT_PLATFORM_CUDA] Valid platforms Interfaces public        interface dtfft_get_version Get dtFFT version private  function dtfft_get_version_current () bind(C) Returns the current version code Arguments None Return Value integer(kind=c_int32_t) private  function dtfft_get_version_required (major, minor, patch) Returns the version code required by the user Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: major Major version integer(kind=int32), intent(in) :: minor Minor version integer(kind=int32), intent(in) :: patch Patch version Return Value integer(kind=int32) public        interface operator(==) private pure elemental function execute_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function exec_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( async_exec_t ), intent(in) :: left type( async_exec_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical public        interface operator(/=) private pure elemental function execute_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical public        interface dtfft_stream_t Creates dtfft_stream_t from integer(cuda_stream_kind) private  function stream_from_int64 (cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream Derived Types type, public, bind(C) :: dtfft_execute_t Type that is used during call to execute method Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_transpose_t Type that is used during call to transpose method Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_executor_t Type that specifies external FFT executor Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_effort_t Type that specifies effort that dtFFT should use when creating plan Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_precision_t Type that specifies precision of dtFFT plan Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_r2r_kind_t Type that specifies various kinds of R2R FFTs Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_backend_t Type that specifies various backends present in dtFFT Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_stream_t dtFFT stream representation. Components Type Visibility Attributes Name Initial type(c_ptr), public :: stream Actual stream Constructor Creates dtfft_stream_t from integer(cuda_stream_kind) private\n\n                    \n                    function stream_from_int64 (cuda_stream) Creates dtfft_stream_t from integer(cuda_stream_kind) type, public, bind(C) :: dtfft_platform_t Type that specifies runtime platform, e.g. Host, CUDA, HIP Components Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: val Internal value type, public, bind(C) :: dtfft_request_t Components Type Visibility Attributes Name Initial type(c_ptr), public :: val = c_null_ptr type, public :: async_exec_t Components Type Visibility Attributes Name Initial integer(kind=int32), public :: val Functions public pure elemental function is_valid_execute_type (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_transpose_type (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_executor (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_effort (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_precision (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_r2r_kind (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_dimension (param) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: param Return Value logical public pure elemental function is_valid_comm_type (param) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: param Return Value logical public  function dtfft_get_precision_string (precision) result(string) Gets the string description of a precision Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: precision Precision type Return Value character(len=:), allocatable Precision string public  function dtfft_get_executor_string (executor) result(string) Gets the string description of an executor Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: executor Executor type Return Value character(len=:), allocatable Executor string public  function dtfft_get_backend_string (backend) result(string) Gets the string description of a GPU backend Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: backend GPU backend Return Value character(len=:), allocatable Backend string public pure elemental function is_backend_pipelined (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_backend_mpi (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_backend (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_backend_nccl (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_backend_cufftmp (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_backend_nvshmem (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: param Return Value logical public pure elemental function is_host_executor (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical public pure elemental function is_cuda_executor (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: param Return Value logical public pure elemental function is_valid_platform (param) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: param Return Value logical public  function dtfft_get_cuda_stream (stream) result(cuda_stream) Returns the CUDA stream from dtfft_stream_t Arguments Type Intent Optional Attributes Name type( dtfft_stream_t ), intent(in) :: stream dtfft stream Return Value integer(kind=int64) CUDA stream private pure elemental function execute_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private pure elemental function exec_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( async_exec_t ), intent(in) :: left type( async_exec_t ), intent(in) :: right Return Value logical private pure elemental function execute_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_execute_t ), intent(in) :: left type( dtfft_execute_t ), intent(in) :: right Return Value logical private pure elemental function transpose_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_transpose_t ), intent(in) :: left type( dtfft_transpose_t ), intent(in) :: right Return Value logical private pure elemental function executor_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_executor_t ), intent(in) :: left type( dtfft_executor_t ), intent(in) :: right Return Value logical private pure elemental function effort_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_effort_t ), intent(in) :: left type( dtfft_effort_t ), intent(in) :: right Return Value logical private pure elemental function precision_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_precision_t ), intent(in) :: left type( dtfft_precision_t ), intent(in) :: right Return Value logical private pure elemental function r2r_kind_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_r2r_kind_t ), intent(in) :: left type( dtfft_r2r_kind_t ), intent(in) :: right Return Value logical private pure elemental function platform_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_platform_t ), intent(in) :: left type( dtfft_platform_t ), intent(in) :: right Return Value logical private  function dtfft_get_version_current () bind(C) Returns the current version code Arguments None Return Value integer(kind=c_int32_t) private  function dtfft_get_version_required (major, minor, patch) Returns the version code required by the user Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: major Major version integer(kind=int32), intent(in) :: minor Minor version integer(kind=int32), intent(in) :: patch Patch version Return Value integer(kind=int32) private pure elemental function gpu_backend_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical private pure elemental function gpu_backend_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( dtfft_backend_t ), intent(in) :: left type( dtfft_backend_t ), intent(in) :: right Return Value logical private  function stream_from_int64 (cuda_stream) result(stream) Creates dtfft_stream_t from integer(cuda_stream_kind) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: cuda_stream CUDA stream Return Value type( dtfft_stream_t ) dtfft Stream","tags":"","loc":"module/dtfft_parameters.html"},{"title":"dtfft_abstract_kernel – dtFFT","text":"This module defines abstract_kernel type and its type bound procedures. The abstract kernel is used in transpose_handle_generic type and\nis resposible for packing/unpacking/permute operations.\nThe actual implementation of the kernel is deferred to the create_private , execute_private and destroy_private procedures. Uses dtfft_interface_nvtx dtfft_parameters dtfft_utils iso_fortran_env mpi_f08 module~~dtfft_abstract_kernel~~UsesGraph module~dtfft_abstract_kernel dtfft_abstract_kernel iso_fortran_env iso_fortran_env module~dtfft_abstract_kernel->iso_fortran_env module~dtfft_interface_nvtx dtfft_interface_nvtx module~dtfft_abstract_kernel->module~dtfft_interface_nvtx module~dtfft_parameters dtfft_parameters module~dtfft_abstract_kernel->module~dtfft_parameters module~dtfft_utils dtfft_utils module~dtfft_abstract_kernel->module~dtfft_utils mpi_f08 mpi_f08 module~dtfft_abstract_kernel->mpi_f08 module~dtfft_interface_nvtx->module~dtfft_utils iso_c_binding iso_c_binding module~dtfft_interface_nvtx->iso_c_binding module~dtfft_parameters->iso_fortran_env module~dtfft_parameters->mpi_f08 module~dtfft_parameters->iso_c_binding module~dtfft_utils->iso_fortran_env module~dtfft_utils->module~dtfft_parameters module~dtfft_utils->mpi_f08 module~dtfft_utils->iso_c_binding module~dtfft_errors dtfft_errors module~dtfft_utils->module~dtfft_errors module~dtfft_errors->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dtfft_abstract_kernel~~UsedByGraph module~dtfft_abstract_kernel dtfft_abstract_kernel module~dtfft_abstract_backend dtfft_abstract_backend module~dtfft_abstract_backend->module~dtfft_abstract_kernel module~dtfft_kernel_device dtfft_kernel_device module~dtfft_kernel_device->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer dtfft_nvrtc_block_optimizer module~dtfft_kernel_device->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache dtfft_nvrtc_module_cache module~dtfft_kernel_device->module~dtfft_nvrtc_module_cache module~dtfft_kernel_host dtfft_kernel_host module~dtfft_kernel_host->module~dtfft_abstract_kernel module~dtfft_nvrtc_block_optimizer->module~dtfft_abstract_kernel module~dtfft_nvrtc_module dtfft_nvrtc_module module~dtfft_nvrtc_module->module~dtfft_abstract_kernel module~dtfft_nvrtc_module->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_abstract_kernel module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_block_optimizer module~dtfft_nvrtc_module_cache->module~dtfft_nvrtc_module module~dtfft_transpose_handle_generic dtfft_transpose_handle_generic module~dtfft_transpose_handle_generic->module~dtfft_abstract_kernel module~dtfft_transpose_handle_generic->module~dtfft_abstract_backend module~dtfft_transpose_handle_generic->module~dtfft_kernel_device module~dtfft_transpose_handle_generic->module~dtfft_kernel_host module~dtfft_abstract_transpose_handle dtfft_abstract_transpose_handle module~dtfft_transpose_handle_generic->module~dtfft_abstract_transpose_handle module~dtfft_backend_cufftmp_m dtfft_backend_cufftmp_m module~dtfft_transpose_handle_generic->module~dtfft_backend_cufftmp_m module~dtfft_backend_mpi dtfft_backend_mpi module~dtfft_transpose_handle_generic->module~dtfft_backend_mpi module~dtfft_backend_nccl_m dtfft_backend_nccl_m module~dtfft_transpose_handle_generic->module~dtfft_backend_nccl_m module~dtfft_abstract_transpose_handle->module~dtfft_abstract_backend module~dtfft_backend_cufftmp_m->module~dtfft_abstract_backend module~dtfft_backend_mpi->module~dtfft_abstract_backend module~dtfft_backend_nccl_m->module~dtfft_abstract_backend module~dtfft_transpose_plan dtfft_transpose_plan module~dtfft_transpose_plan->module~dtfft_abstract_backend module~dtfft_transpose_plan->module~dtfft_kernel_device module~dtfft_transpose_plan->module~dtfft_transpose_handle_generic module~dtfft_transpose_plan->module~dtfft_abstract_transpose_handle module~dtfft_transpose_handle_datatype dtfft_transpose_handle_datatype module~dtfft_transpose_plan->module~dtfft_transpose_handle_datatype module~dtfft_plan dtfft_plan module~dtfft_plan->module~dtfft_transpose_plan module~dtfft_transpose_handle_datatype->module~dtfft_abstract_transpose_handle module~dtfft dtfft module~dtfft->module~dtfft_plan module~dtfft_api dtfft_api module~dtfft_api->module~dtfft_plan Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( kernel_type_t ), public, parameter :: KERNEL_DUMMY = kernel_type_t(-1) Dummy kernel, does nothing type( kernel_type_t ), public, parameter :: KERNEL_UNPACK = kernel_type_t(3) Unpacks contiguous buffer. type( kernel_type_t ), public, parameter :: KERNEL_UNPACK_SIMPLE_COPY = kernel_type_t(4) Doesn’t actually unpacks anything. Performs cudaMemcpyAsync call.\nShould be used only when backend is DTFFT_BACKEND_CUFFTMP . type( kernel_type_t ), public, parameter :: KERNEL_UNPACK_PIPELINED = kernel_type_t(5) Unpacks pack of contiguous buffer recieved from rank. Unpacks contiguous buffer recieved from everyone except myself.\nShould be used only when backend is DTFFT_BACKEND_NCCL_PIPELINED . type( kernel_type_t ), public, parameter :: KERNEL_PERMUTE_FORWARD = kernel_type_t(7) type( kernel_type_t ), public, parameter :: KERNEL_PERMUTE_BACKWARD = kernel_type_t(8) type( kernel_type_t ), public, parameter :: KERNEL_PERMUTE_BACKWARD_START = kernel_type_t(9) type( kernel_type_t ), public, parameter :: KERNEL_PERMUTE_BACKWARD_END = kernel_type_t(10) type( kernel_type_t ), public, parameter :: KERNEL_PERMUTE_BACKWARD_END_PIPELINED = kernel_type_t(11) Unpacks contiguous buffer recieved from everyone except myself.\nShould be used only when backend is DTFFT_BACKEND_NCCL_PIPELINED . type( kernel_type_t ), private, parameter :: TRANSPOSE_KERNELS (*) = [KERNEL_PERMUTE_FORWARD, KERNEL_PERMUTE_BACKWARD, KERNEL_PERMUTE_BACKWARD_START] List of all transpose kernel types type( kernel_type_t ), private, parameter :: UNPACK_KERNELS (*) = [KERNEL_PERMUTE_BACKWARD_END_PIPELINED, KERNEL_UNPACK_PIPELINED] List of all unpack kernel types Interfaces public        interface operator(==) private pure elemental function kernel_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: left type( kernel_type_t ), intent(in) :: right Return Value logical public        interface operator(/=) private pure elemental function kernel_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: left type( kernel_type_t ), intent(in) :: right Return Value logical Abstract Interfaces abstract interface private  subroutine create_interface(self, effort, base_storage, force_effort) Creates underlying kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element logical, intent(in), optional :: force_effort Should effort be forced or not abstract interface private  subroutine execute_interface(self, in, out, stream, neighbor) Executes underlying kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel real(kind=real32), intent(in), target :: in (:) Source buffer, can be device or host pointer real(kind=real32), intent(inout), target :: out (:) Target buffer, can be device or host pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, used only for device pointers integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking abstract interface private  subroutine destroy_interface(self) Destroys underlying kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel Derived Types type, public :: kernel_type_t nvRTC Kernel type Components Type Visibility Attributes Name Initial integer(kind=int32), public :: val type, public, abstract :: abstract_kernel Abstract kernel type Read more… Components Type Visibility Attributes Name Initial logical, public :: is_created = .false. Kernel is created flag. logical, public :: is_dummy = .false. If kernel should do anything or not. type( kernel_type_t ), public :: kernel_type Type of the kernel character(len=:), public, allocatable :: kernel_string integer(kind=int32), public, allocatable :: neighbor_data (:,:) Neighbor data for pipelined unpacking integer(kind=int32), public, allocatable :: dims (:) Local dimensions to process Type-Bound Procedures procedure, public, pass(self) :: create ../../ Creates kernel procedure, public, pass(self) :: execute ../../ Executes kernel procedure, public, pass(self) :: destroy ../../ Destroys kernel procedure( create_interface ), public, deferred :: create_private ../../ Creates underlying kernel procedure( execute_interface ), public, deferred :: execute_private ../../ Executes underlying kernel procedure( destroy_interface ), public, deferred :: destroy_private ../../ Destroys underlying kernel Functions public  function get_kernel_string (kernel) result(string) Gets the string description of a kernel Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: kernel kernel type Return Value character(len=:), allocatable kernel string public pure elemental function is_transpose_kernel (param) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: param Return Value logical public pure elemental function is_unpack_kernel (param) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: param Return Value logical private pure elemental function kernel_type_eq (left, right) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: left type( kernel_type_t ), intent(in) :: right Return Value logical private pure elemental function kernel_type_ne (left, right) result(res) Arguments Type Intent Optional Attributes Name type( kernel_type_t ), intent(in) :: left type( kernel_type_t ), intent(in) :: right Return Value logical Subroutines private  subroutine create (self, dims, effort, base_storage, kernel_type, neighbor_data, force_effort) Creates kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel integer(kind=int32), intent(in) :: dims (:) Local dimensions to process type( dtfft_effort_t ), intent(in) :: effort Effort level for generating transpose kernels integer(kind=int64), intent(in) :: base_storage Number of bytes needed to store single element type( kernel_type_t ), intent(in) :: kernel_type Type of kernel to build integer(kind=int32), intent(in), optional :: neighbor_data (:,:) Optional pointers for unpack kernels logical, intent(in), optional :: force_effort Should effort be forced or not private  subroutine execute (self, in, out, stream, neighbor) Executes kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel real(kind=real32), intent(in) :: in (:) Source buffer, can be device or host pointer real(kind=real32), intent(inout) :: out (:) Target buffer, can be device or host pointer type( dtfft_stream_t ), intent(in) :: stream Stream to execute on, used only for device pointers integer(kind=int32), intent(in), optional :: neighbor Source rank for pipelined unpacking private  subroutine destroy (self) Destroys kernel Arguments Type Intent Optional Attributes Name class( abstract_kernel ), intent(inout) :: self Abstract kernel","tags":"","loc":"module/dtfft_abstract_kernel.html"},{"title":"dtfft_abstract_backend.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_abstract_backend.f90~~EfferentGraph sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_abstract_backend.f90~~AfferentGraph sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_abstract_backend !! This module describes Abstraction for all Backends: [[abstract_backend]] use iso_c_binding use iso_fortran_env use dtfft_abstract_kernel , only : abstract_kernel use dtfft_config , only : get_env use dtfft_errors #ifdef DTFFT_WITH_CUDA use dtfft_interface_cuda_runtime #endif #ifdef DTFFT_WITH_NCCL use dtfft_interface_nccl #endif use dtfft_parameters use dtfft_pencil , only : pencil use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_cuda.h\" #include \"_dtfft_private.h\" implicit none private public :: abstract_backend , backend_helper #ifdef NCCL_HAVE_COMMREGISTER integer ( int32 ), parameter , public :: NCCL_REGISTER_PREALLOC_SIZE = 8 !! Number of register elements to preallocate #endif type :: backend_helper !! Helper with nccl, mpi and nvshmem communicators logical :: is_nccl_created = . false . !! Flag is `nccl_comm` has been created #ifdef DTFFT_WITH_NCCL type ( ncclComm ) :: nccl_comm !! NCCL communicator #endif #ifdef NCCL_HAVE_COMMREGISTER logical :: should_register !! If NCCL buffer should be registered type ( c_ptr ), allocatable :: nccl_register (:, :) !! NCCL register cache integer ( int32 ) :: nccl_register_size !! Number of elements in `nccl_register` #endif TYPE_MPI_COMM , allocatable :: comms (:) !! MPI communicators integer ( int32 ), allocatable :: comm_mappings (:, :) !! Mapping of 1d comm ranks to global comm type ( dtfft_transpose_t ) :: tranpose_type !! Type of transpose to create type ( pencil ), pointer :: pencils (:) !! Pencils contains procedure , pass ( self ) :: create => create_helper !! Creates helper procedure , pass ( self ) :: destroy => destroy_helper !! Destroys helper end type backend_helper type , abstract :: abstract_backend !! The most Abstract Backend type ( dtfft_backend_t ) :: backend !! Backend type type ( dtfft_platform_t ) :: platform !! Platform to use logical :: is_selfcopy !! If backend is self-copying logical :: is_pipelined !! If backend is pipelined integer ( int64 ) :: aux_size !! Number of bytes required by aux buffer integer ( int64 ) :: send_recv_buffer_size !! Number of float elements used in ``c_f_pointer`` TYPE_MPI_COMM :: comm !! MPI Communicator integer ( int32 ), allocatable :: comm_mapping (:) !! Mapping of 1d comm ranks to global comm integer ( int32 ) :: comm_size !! Size of MPI Comm integer ( int32 ) :: comm_rank !! Rank in MPI Comm integer ( int64 ), allocatable :: send_displs (:) !! Send data displacements, in float elements integer ( int64 ), allocatable :: send_floats (:) !! Send data elements, in float elements integer ( int64 ), allocatable :: recv_displs (:) !! Recv data displacements, in float elements integer ( int64 ), allocatable :: recv_floats (:) !! Recv data elements, in float elements ! Self copy params #ifdef DTFFT_WITH_CUDA type ( cudaEvent ) :: execution_event !! Event for main execution stream type ( cudaEvent ) :: copy_event !! Event for copy stream #endif type ( dtfft_stream_t ) :: copy_stream !! Stream for copy operations integer ( int64 ) :: self_copy_bytes !! Number of bytes to copy it itself integer ( int64 ) :: self_send_displ !! Displacement for send buffer integer ( int64 ) :: self_recv_displ !! Displacement for recv buffer class ( abstract_kernel ), pointer :: unpack_kernel !! Kernel for unpacking data contains procedure , non_overridable , pass ( self ) :: create !! Creates Abstract Backend procedure , non_overridable , pass ( self ) :: execute !! Executes Backend procedure , non_overridable , pass ( self ) :: destroy !! Destroys Abstract Backend procedure , non_overridable , pass ( self ) :: get_aux_size !! Returns number of bytes required by aux buffer procedure , non_overridable , pass ( self ) :: set_unpack_kernel !! Sets unpack kernel for pipelined backend procedure , pass ( self ) :: execute_end !! Ends execution of Backend procedure , pass ( self ) :: get_async_active !! Returns if async execution is active procedure ( create_interface ), deferred , pass ( self ) :: create_private !! Creates overriding class procedure ( execute_interface ), deferred , pass ( self ) :: execute_private !! Executes Backend procedure ( destroy_interface ), deferred , pass ( self ) :: destroy_private !! Destroys overriding class end type abstract_backend abstract interface subroutine create_interface ( self , helper , base_storage ) !! Creates overriding class import class ( abstract_backend ), intent ( inout ) :: self !! Abstract Backend type ( backend_helper ), intent ( in ) :: helper !! Backend helper integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element end subroutine create_interface subroutine execute_interface ( self , in , out , stream , aux , exec_type , error_code ) !! Executes Backend import class ( abstract_backend ), intent ( inout ) :: self !! Abstract Backend real ( real32 ), target , intent ( inout ) :: in (:) !! Send pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Main execution CUDA stream real ( real32 ), target , intent ( inout ) :: aux (:) !! Aux pointer type ( async_exec_t ), intent ( in ) :: exec_type !! Type of async execution integer ( int32 ), intent ( out ) :: error_code !! Error code end subroutine execute_interface subroutine destroy_interface ( self ) !! Destroys overriding class import class ( abstract_backend ), intent ( inout ) :: self !! Abstract Backend end subroutine destroy_interface end interface contains subroutine create ( self , backend , helper , platform , comm_id , send_displs , send_counts , recv_displs , recv_counts , base_storage ) !! Creates Abstract Backend class ( abstract_backend ), intent ( inout ) :: self !! Abstract Backend type ( dtfft_backend_t ), intent ( in ) :: backend !! Backend type type ( backend_helper ), intent ( in ) :: helper !! Backend helper type ( dtfft_platform_t ), intent ( in ) :: platform !! Platform to use integer ( int8 ), intent ( in ) :: comm_id !! Id of communicator to use integer ( int32 ), intent ( in ) :: send_displs (:) !! Send data displacements, in original elements integer ( int32 ), intent ( in ) :: send_counts (:) !! Send data elements, in float elements integer ( int32 ), intent ( in ) :: recv_displs (:) !! Recv data displacements, in float elements integer ( int32 ), intent ( in ) :: recv_counts (:) !! Recv data elements, in float elements integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element integer ( int64 ) :: send_size !! Total number of floats to send integer ( int64 ) :: recv_size !! Total number of floats to recv integer ( int32 ) :: ierr !! MPI Error code integer ( int64 ) :: scaler !! Scaling data amount to float size scaler = base_storage / FLOAT_STORAGE_SIZE self % platform = platform send_size = sum ( send_counts ) * scaler recv_size = sum ( recv_counts ) * scaler self % send_recv_buffer_size = max ( send_size , recv_size ) self % comm = helper % comms ( comm_id ) call MPI_Comm_size ( self % comm , self % comm_size , ierr ) call MPI_Comm_rank ( self % comm , self % comm_rank , ierr ) if ( allocated ( helper % comm_mappings )) then allocate ( self % comm_mapping ( 0 : self % comm_size - 1 ), source = helper % comm_mappings ( 0 : self % comm_size - 1 , comm_id )) end if allocate ( self % send_displs ( 0 : self % comm_size - 1 )) allocate ( self % send_floats ( 0 : self % comm_size - 1 )) self % send_displs (:) = int ( send_displs (:), int64 ) * scaler self % send_displs (:) = self % send_displs (:) + 1 self % send_floats (:) = int ( send_counts (:), int64 ) * scaler allocate ( self % recv_displs ( 0 : self % comm_size - 1 )) allocate ( self % recv_floats ( 0 : self % comm_size - 1 )) self % recv_displs (:) = int ( recv_displs (:), int64 ) * scaler self % recv_displs (:) = self % recv_displs (:) + 1 self % recv_floats (:) = int ( recv_counts (:), int64 ) * scaler self % backend = backend self % is_pipelined = is_backend_pipelined ( backend ) self % is_selfcopy = self % is_pipelined . or . is_backend_mpi ( backend ) self % aux_size = 0_int64 if ( self % is_pipelined ) then self % aux_size = self % send_recv_buffer_size * FLOAT_STORAGE_SIZE end if self % self_copy_bytes = 0_int64 if ( self % is_selfcopy ) then self % self_send_displ = self % send_displs ( self % comm_rank ) self % self_recv_displ = self % recv_displs ( self % comm_rank ) self % self_copy_bytes = self % send_floats ( self % comm_rank ) * FLOAT_STORAGE_SIZE self % send_floats ( self % comm_rank ) = 0 self % recv_floats ( self % comm_rank ) = 0 #ifdef DTFFT_WITH_CUDA if ( platform == DTFFT_PLATFORM_CUDA ) then CUDA_CALL ( cudaEventCreateWithFlags ( self % execution_event , cudaEventDisableTiming ) ) CUDA_CALL ( cudaEventCreateWithFlags ( self % copy_event , cudaEventDisableTiming ) ) CUDA_CALL ( cudaStreamCreate ( self % copy_stream ) ) end if #endif end if call self % create_private ( helper , base_storage ) end subroutine create subroutine execute ( self , in , out , stream , aux , exec_type , error_code ) !! Executes Backend class ( abstract_backend ), intent ( inout ) :: self !! Self-copying backend real ( real32 ), intent ( inout ) :: in (:) !! Send pointer real ( real32 ), intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! CUDA stream real ( real32 ), intent ( inout ) :: aux (:) !! Aux pointer type ( async_exec_t ), intent ( in ) :: exec_type !! Type of async execution integer ( int32 ), intent ( out ) :: error_code !! Error code integer ( int32 ) :: i , upper_bound if (. not . self % is_selfcopy ) then call self % execute_private ( in , out , stream , aux , exec_type , error_code ) #if defined(DTFFT_DEBUG) && defined(DTFFT_WITH_CUDA) if ( self % platform == DTFFT_PLATFORM_CUDA ) then CUDA_CALL ( cudaStreamSynchronize ( stream ) ) end if #endif return end if if ( self % platform == DTFFT_PLATFORM_HOST ) then if ( self % self_copy_bytes > 0 ) then upper_bound = int ( self % self_copy_bytes / FLOAT_STORAGE_SIZE - 1 , int32 ) if ( self % is_pipelined ) then !$omp simd do i = 0 , upper_bound aux ( self % self_recv_displ + i ) = in ( self % self_send_displ + i ) end do !$omp end simd call self % unpack_kernel % execute ( aux , out , stream , self % comm_rank + 1 ) else !$omp simd do i = 0 , upper_bound out ( self % self_recv_displ + i ) = in ( self % self_send_displ + i ) end do !$omp end simd end if end if #ifdef DTFFT_WITH_CUDA else CUDA_CALL ( cudaEventRecord ( self % execution_event , stream ) ) ! Waiting for transpose kernel to finish execution on stream `stream` CUDA_CALL ( cudaStreamWaitEvent ( self % copy_stream , self % execution_event , 0 ) ) if ( self % self_copy_bytes > 0 ) then if ( self % is_pipelined ) then ! Tranposed data is actually located in aux buffer for pipelined algorithm CUDA_CALL ( cudaMemcpyAsync ( aux ( self % self_recv_displ ), in ( self % self_send_displ ), self % self_copy_bytes , cudaMemcpyDeviceToDevice , self % copy_stream ) ) ! Data can be unpacked in same stream as `cudaMemcpyAsync` call self % unpack_kernel % execute ( aux , out , self % copy_stream , self % comm_rank + 1 ) else CUDA_CALL ( cudaMemcpyAsync ( out ( self % self_recv_displ ), in ( self % self_send_displ ), self % self_copy_bytes , cudaMemcpyDeviceToDevice , self % copy_stream ) ) end if end if #endif end if call self % execute_private ( in , out , stream , aux , exec_type , error_code ) if ( exec_type == EXEC_BLOCKING . or . self % platform == DTFFT_PLATFORM_CUDA ) then call self % execute_end ( error_code ) endif #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_CUDA ) then ! Making future events, like FFT, on `stream` to wait for `copy_event` CUDA_CALL ( cudaEventRecord ( self % copy_event , self % copy_stream ) ) CUDA_CALL ( cudaStreamWaitEvent ( stream , self % copy_event , 0 ) ) end if #endif #if defined(DTFFT_DEBUG) && defined(DTFFT_WITH_CUDA) if ( self % platform == DTFFT_PLATFORM_CUDA ) then CUDA_CALL ( cudaStreamSynchronize ( stream ) ) end if #endif end subroutine execute subroutine execute_end ( self , error_code ) !! Ends execution of Backend class ( abstract_backend ), intent ( inout ) :: self !! Abstract backend integer ( int32 ), intent ( out ) :: error_code !! Error code error_code = DTFFT_SUCCESS if ( self % platform == DTFFT_PLATFORM_HOST ) return end subroutine execute_end elemental logical function get_async_active ( self ) !! Returns if async execution is active class ( abstract_backend ), intent ( in ) :: self !! Abstract backend get_async_active = . false . end function get_async_active subroutine destroy ( self ) !! Destroys Abstract Backend class ( abstract_backend ), intent ( inout ) :: self !! Abstract backend if ( allocated ( self % send_displs )) deallocate ( self % send_displs ) if ( allocated ( self % send_floats )) deallocate ( self % send_floats ) if ( allocated ( self % recv_displs )) deallocate ( self % recv_displs ) if ( allocated ( self % recv_floats )) deallocate ( self % recv_floats ) if ( allocated ( self % comm_mapping )) deallocate ( self % comm_mapping ) self % comm = MPI_COMM_NULL #ifdef DTFFT_WITH_CUDA if ( self % is_selfcopy . and . self % platform == DTFFT_PLATFORM_CUDA ) then CUDA_CALL ( cudaEventDestroy ( self % execution_event ) ) CUDA_CALL ( cudaEventDestroy ( self % copy_event ) ) CUDA_CALL ( cudaStreamDestroy ( self % copy_stream ) ) end if #endif nullify ( self % unpack_kernel ) self % is_pipelined = . false . self % is_selfcopy = . false . call self % destroy_private () end subroutine destroy pure integer ( int64 ) function get_aux_size ( self ) !! Returns number of bytes required by aux buffer class ( abstract_backend ), intent ( in ) :: self !! Abstract backend get_aux_size = self % aux_size end function get_aux_size subroutine set_unpack_kernel ( self , unpack_kernel ) !! Sets unpack kernel for pipelined backend class ( abstract_backend ), intent ( inout ) :: self !! Pipelined backend class ( abstract_kernel ), target , intent ( in ) :: unpack_kernel !! Kernel for unpacking data self % unpack_kernel => unpack_kernel end subroutine set_unpack_kernel subroutine create_helper ( self , platform , base_comm , comms , is_nccl_needed , pencils ) !! Creates helper class ( backend_helper ), intent ( inout ) :: self !! Backend helper type ( dtfft_platform_t ), intent ( in ) :: platform !! Platform to use TYPE_MPI_COMM , intent ( in ) :: base_comm !! MPI communicator TYPE_MPI_COMM , intent ( in ) :: comms (:) !! 1D Communicators logical , intent ( in ) :: is_nccl_needed !! If nccl communicator will be needed type ( pencil ), target , intent ( in ) :: pencils (:) !! Pencils integer ( int32 ) :: i , n_comms call self % destroy () self % pencils => pencils (:) n_comms = size ( comms ) allocate ( self % comms ( n_comms )) self % comms ( 1 ) = base_comm do i = 2 , n_comms self % comms ( i ) = comms ( i ) end do self % is_nccl_created = . false . if (. not . is_nccl_needed ) return if ( platform == DTFFT_PLATFORM_HOST ) return #ifdef DTFFT_WITH_NCCL block type ( ncclUniqueId ) :: id ! NCCL unique id integer ( int32 ) :: max_size , comm_size , comm_rank , ierr max_size = - 1 do i = 1 , n_comms call MPI_Comm_size ( self % comms ( i ), comm_size , ierr ) max_size = max ( max_size , comm_size ) end do call MPI_Comm_rank ( base_comm , comm_rank , ierr ) allocate ( self % comm_mappings ( 0 : max_size - 1 , n_comms ), source =- 1 ) do i = 1 , n_comms call MPI_Allgather ( comm_rank , 1 , MPI_INTEGER , self % comm_mappings (:, i ), 1 , MPI_INTEGER , self % comms ( i ), ierr ) end do if ( comm_rank == 0 ) then NCCL_CALL ( ncclGetUniqueId ( id ) ) end if call MPI_Bcast ( id , int ( c_sizeof ( id )), MPI_BYTE , 0 , base_comm , ierr ) NCCL_CALL ( ncclCommInitRank ( self % nccl_comm , max_size , id , comm_rank ) ) self % is_nccl_created = . true . end block # ifdef NCCL_HAVE_COMMREGISTER self % should_register = get_env ( \"NCCL_BUFFER_REGISTER\" , . true .) if ( self % should_register ) then self % nccl_register_size = 0 allocate ( self % nccl_register ( 2 , NCCL_REGISTER_PREALLOC_SIZE )) do i = 1 , NCCL_REGISTER_PREALLOC_SIZE self % nccl_register ( 1 , i ) = c_null_ptr self % nccl_register ( 2 , i ) = c_null_ptr end do end if # endif #endif end subroutine create_helper subroutine destroy_helper ( self ) !! Destroys helper class ( backend_helper ), intent ( inout ) :: self !! Backend helper if ( allocated ( self % comms )) deallocate ( self % comms ) if ( allocated ( self % comm_mappings )) deallocate ( self % comm_mappings ) nullify ( self % pencils ) #ifdef DTFFT_WITH_NCCL if ( self % is_nccl_created ) then NCCL_CALL ( ncclCommDestroy ( self % nccl_comm ) ) end if self % is_nccl_created = . false . #endif #ifdef NCCL_HAVE_COMMREGISTER if ( self % nccl_register_size > 0 ) then WRITE_ERROR ( \"NCCL register is not empty\" ) end if if ( allocated ( self % nccl_register )) deallocate ( self % nccl_register ) self % nccl_register_size = 0 #endif end subroutine destroy_helper end module dtfft_abstract_backend","tags":"","loc":"sourcefile/dtfft_abstract_backend.f90.html"},{"title":"dtfft_executor_fftw_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_executor_fftw_m.f90~~EfferentGraph sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_executor_fftw_m.f90~~AfferentGraph sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_executor_fftw_m !! This module describes FFTW3 based FFT Executor: [[fftw_executor]] !! !! http://www.fftw.org use iso_c_binding , only : c_ptr , c_loc , c_null_ptr , c_int use iso_fortran_env , only : int8 , int32 , int64 , real32 use dtfft_abstract_executor , only : abstract_executor , FFT_C2C , FFT_R2C , FFT_R2R use dtfft_errors use dtfft_pencil , only : pencil use dtfft_interface_fftw_m use dtfft_parameters use dtfft_utils , only : get_inverse_kind , is_null_ptr implicit none private public :: fftw_executor integer ( int32 ), parameter :: FFTW3_FLAGS = FFTW_MEASURE + FFTW_DESTROY_INPUT !! FFTW3 planner flags type , extends ( abstract_executor ) :: fftw_executor !! FFTW3 FFT Executor private procedure ( apply_interface ), nopass , pointer :: apply => NULL () !! Pointer to FFTW3 function that executes FFT plan procedure ( free_interface ), nopass , pointer :: free => NULL () !! Pointer to FFTW3 function that destroys FFT plan procedure ( apply_interface ), nopass , pointer :: apply_inverse => NULL () !! Pointer to FFTW3 function that executes inverse FFT plan !! Used in R2C only contains procedure :: create_private => create !! Creates FFT plan via FFTW3 Interface procedure :: execute_private => execute !! Executes FFTW3 plan procedure :: destroy_private => destroy !! Destroys FFTW3 plan procedure , nopass :: mem_alloc !! Allocates FFTW3 memory procedure , nopass :: mem_free !! Frees FFTW3 aligned memory end type fftw_executor abstract interface subroutine apply_interface ( plan , in , out ) bind ( C ) !! Executes FFTW3 Plan #include \"args_execute.i90\" end subroutine apply_interface subroutine free_interface ( plan ) bind ( C ) !! Destroys FFTW3 Plan import type ( c_ptr ), value :: plan end subroutine free_interface type ( c_ptr ) function create_c2c_plan ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , sign , flags ) bind ( C ) !! Creates C2C FFTW3 Plan #include \"args_create.i90\" integer ( C_INT ), value :: sign end function create_c2c_plan type ( c_ptr ) function create_r2c_plan ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates R2C FFTW3 Plan #include \"args_create.i90\" end function create_r2c_plan type ( c_ptr ) function create_r2r_plan ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , kinds , flags ) bind ( C ) !! Creates R2R FFTW3 Plan #include \"args_create.i90\" integer ( C_FFTW_R2R_KIND ), intent ( in ) :: kinds ( * ) end function create_r2r_plan end interface contains subroutine create ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan via FFTW3 Interface class ( fftw_executor ), intent ( inout ) :: self !! FFTW FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform integer ( int32 ) :: n_elements !! Number of elements in `buf` type ( c_ptr ) :: ptr !! C pointer to `buf` error_code = DTFFT_SUCCESS n_elements = product ( fft_sizes ) * how_many if ( fft_type == FFT_C2C . or . fft_type == FFT_R2C ) then n_elements = n_elements * 2 endif if ( precision == DTFFT_DOUBLE ) then n_elements = n_elements * 2 endif call self % mem_alloc ( FLOAT_STORAGE_SIZE * n_elements , ptr ) if ( precision == DTFFT_SINGLE ) then self % free => fftwf_destroy_plan else self % free => fftw_destroy_plan endif select case ( fft_type ) case ( FFT_C2C ) block procedure ( create_c2c_plan ), pointer :: constructor if ( precision == DTFFT_SINGLE ) then constructor => fftwf_plan_many_dft self % apply => fftwf_execute_dft else constructor => fftw_plan_many_dft self % apply => fftw_execute_dft endif self % apply_inverse => NULL () self % plan_forward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , int ( FFT_FORWARD , int32 ), FFTW3_FLAGS ) self % plan_backward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , int ( FFT_BACKWARD , int32 ), FFTW3_FLAGS ) nullify ( constructor ) endblock case ( FFT_R2C ) block procedure ( create_r2c_plan ), pointer :: constructor , constructor_inverse if ( precision == DTFFT_SINGLE ) then constructor => fftwf_plan_many_dft_r2c self % apply => fftwf_execute_dft_r2c constructor_inverse => fftwf_plan_many_dft_c2r self % apply_inverse => fftwf_execute_dft_c2r else constructor => fftw_plan_many_dft_r2c self % apply => fftw_execute_dft_r2c constructor_inverse => fftw_plan_many_dft_c2r self % apply_inverse => fftw_execute_dft_c2r endif self % plan_forward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , FFTW3_FLAGS ) self % plan_backward = constructor_inverse ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , onembed , 1 , odist , ptr , inembed , 1 , idist , FFTW3_FLAGS ) nullify ( constructor , constructor_inverse ) endblock case ( FFT_R2R ) block procedure ( create_r2r_plan ), pointer :: constructor type ( dtfft_r2r_kind_t ), allocatable :: inverse_kinds (:) integer ( C_FFTW_R2R_KIND ), allocatable :: knds (:) if ( precision == DTFFT_SINGLE ) then constructor => fftwf_plan_many_r2r self % apply => fftwf_execute_r2r else constructor => fftw_plan_many_r2r self % apply => fftw_execute_r2r endif self % apply_inverse => NULL () allocate ( knds ( size ( r2r_kinds )) ) knds (:) = int ( r2r_kinds (:)% val , C_FFTW_R2R_KIND ) self % plan_forward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , knds , FFTW3_FLAGS ) allocate ( inverse_kinds ( size ( r2r_kinds ) ) ) inverse_kinds (:) = get_inverse_kind ( r2r_kinds ) if ( all ( inverse_kinds == r2r_kinds ) ) then self % plan_backward = self % plan_forward self % is_inverse_copied = . true . else knds (:) = int ( inverse_kinds (:)% val , C_FFTW_R2R_KIND ) self % plan_backward = constructor ( int ( fft_rank , int32 ), fft_sizes , how_many , ptr , inembed , 1 , idist , ptr , onembed , 1 , odist , knds , FFTW3_FLAGS ) endif deallocate ( inverse_kinds , knds ) nullify ( constructor ) endblock endselect call self % mem_free ( ptr ) end subroutine create subroutine execute ( self , a , b , sign ) !! Executes FFTW3 plan class ( fftw_executor ), intent ( in ) :: self !! FFTW FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform if ( sign == FFT_FORWARD ) then call self % apply ( self % plan_forward , a , b ) else if ( associated ( self % apply_inverse ) ) then call self % apply_inverse ( self % plan_backward , a , b ) else call self % apply ( self % plan_backward , a , b ) endif endif end subroutine execute subroutine destroy ( self ) !! Destroys FFTW3 plan class ( fftw_executor ), intent ( inout ) :: self !! FFTW FFT Executor call self % free ( self % plan_forward ) if ( . not . self % is_inverse_copied ) call self % free ( self % plan_backward ) self % apply => NULL () self % apply_inverse => NULL () self % free => NULL () end subroutine destroy subroutine mem_alloc ( alloc_bytes , ptr ) !! Allocates FFTW3 memory integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer ptr = fftw_malloc ( alloc_bytes ) end subroutine mem_alloc subroutine mem_free ( ptr ) !! Frees FFTW3 aligned memory type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free call fftw_free ( ptr ) end subroutine mem_free end module dtfft_executor_fftw_m","tags":"","loc":"sourcefile/dtfft_executor_fftw_m.f90.html"},{"title":"dtfft_nvrtc_module.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_nvrtc_module.f90~~EfferentGraph sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_nvrtc_module.f90~~AfferentGraph sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_nvrtc_module !! Module for managing nvRTC compiled CUDA kernels !! Each module has only one templated kernel that can be instantiated with different parameters use iso_fortran_env use iso_c_binding use dtfft_abstract_kernel use dtfft_config use dtfft_nvrtc_block_optimizer , only : kernel_config use dtfft_interface_cuda use dtfft_interface_cuda_runtime use dtfft_interface_nvrtc use dtfft_parameters use dtfft_utils #include \"_dtfft_cuda.h\" #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" #include \"_dtfft_profile.h\" implicit none private public :: nvrtc_module type , extends ( string ) :: codegen_t !! Class for generating CUDA code contains procedure , pass ( self ) :: add => add_line !! Adds new line to CUDA code end type codegen_t character ( len =* ), parameter :: DEFAULT_KERNEL_NAME = \"dtfft_kernel\" !! Basic kernel name type :: nvrtc_module !! Class for managing nvRTC compiled CUDA kernels private logical :: is_created = . false . !! Is module created character ( len = :), allocatable :: basic_name !! Basic kernel name integer ( int32 ) :: ndims !! Number of dimensions, used only for forward permutation type ( CUmodule ) :: cumod !! CUDA module type ( nvrtcProgram ) :: prog !! nvRTC program type ( kernel_type_t ) :: kernel_type !! Type of kernel integer ( int64 ) :: base_storage !! Number of bytes needed to store single element type ( kernel_config ), allocatable :: configs (:) !! Kernel configurations that this module was compiled for contains private procedure , pass ( self ), public :: create !! Creates module with given parameters procedure , pass ( self ), public :: destroy !! Destroys module and frees resources procedure , pass ( self ), public :: get !! Returns kernel ready to be executed generic , public :: check => & check_instance , & check_module !! Checks if kernel is with given parameters is available in this module procedure , pass ( self ) :: check_instance !! Checks if kernel with given parameters is available in this module procedure , pass ( self ) :: check_module !! Basic check that this module provides kernels of given type end type nvrtc_module contains subroutine add_line ( self , line ) !! Adds new line to CUDA code class ( codegen_t ), intent ( inout ) :: self !! Kernel code character ( len =* ), intent ( in ) :: line !! Line to add if (. not . allocated ( self % raw )) allocate ( self % raw , source = \"\" ) self % raw = self % raw // line // c_new_line end subroutine add_line function get ( self , ndims , kernel_type , base_storage , tile_size , block_rows ) result ( fun ) !! Returns kernel ready to be executed class ( nvrtc_module ), intent ( in ) :: self !! This module integer ( int32 ), intent ( in ) :: ndims !! Number of dimensions, used only for forward permutation type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ), intent ( in ) :: tile_size !! Size of shared memory tile, template parameter integer ( int32 ), intent ( in ) :: block_rows !! Number of rows processed by single thread, template parameter type ( CUfunction ) :: fun !! Resulting kernel integer ( int32 ) :: i !! Loop variable integer ( int32 ) :: config_id !! Configuration ID type ( c_ptr ) :: mangled !! Mangled kernel name type ( kernel_config ) :: config !! Found configuration fun = CUfunction ( c_null_ptr ) if ( . not . self % check ( ndims , kernel_type , base_storage , tile_size , block_rows ) ) return config_id = - 1 do i = 1 , size ( self % configs , dim = 1 ) if ( tile_size == self % configs ( i )% tile_size . and . block_rows == self % configs ( i )% block_rows ) then config_id = i exit end if end do #ifdef DTFFT_DEBUG if ( config_id < 0 ) INTERNAL_ERROR ( \"nvrtc_module.get: config_id < 0\" ) #endif config = self % configs ( config_id ) mangled = get_mangled_name ( self % basic_name , self % prog , config % tile_size , config % block_rows , config % padding ) CUDA_CALL ( cuModuleGetFunction ( fun , self % cumod , mangled ) ) end function get logical function check_instance ( self , ndims , kernel_type , base_storage , tile_size , block_rows ) !! Checks if kernel with given parameters is available in this module class ( nvrtc_module ), intent ( in ) :: self !! This module integer ( int32 ), intent ( in ) :: ndims !! Number of dimensions type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ), intent ( in ) :: tile_size !! Size of shared memory tile, template parameter integer ( int32 ), intent ( in ) :: block_rows !! Number of rows processed by single thread, template parameter integer ( int32 ) :: i !! Loop variable check_instance = . false . if ( . not . self % check ( ndims , kernel_type , base_storage ) ) return do i = 1 , size ( self % configs , dim = 1 ) if ( tile_size == self % configs ( i )% tile_size . and . block_rows == self % configs ( i )% block_rows ) then check_instance = . true . return end if end do end function check_instance logical function check_module ( self , ndims , kernel_type , base_storage ) !! Basic check that this module provides kernels of given type class ( nvrtc_module ), intent ( in ) :: self !! This module integer ( int32 ), intent ( in ) :: ndims !! Number of dimensions type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element check_module = . false . if (. not . self % is_created ) return if ( kernel_type /= self % kernel_type ) return if ( base_storage /= self % base_storage ) return if ( ndims /= self % ndims . and . kernel_type == KERNEL_PERMUTE_FORWARD ) return check_module = . true . end function check_module subroutine create ( self , ndims , kernel_type , base_storage , configs , props ) !! Creates module with given parameters, compiles nvRTC program and loads it as CUDA module class ( nvrtc_module ), intent ( inout ) :: self !! This module integer ( int32 ), intent ( in ) :: ndims !! Number of dimensions, used only for forward permutation type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( kernel_config ), intent ( in ) :: configs (:) !! Kernel configurations that this module should be compiled for type ( device_props ), intent ( in ) :: props !! GPU architecture properties type ( codegen_t ) :: code !! Generated code character ( len = :), allocatable :: region_name !! Phase name for profiling integer ( int32 ) :: i !! Loop variable integer ( c_size_t ) :: cubinSizeRet !! Size of cubin type ( c_ptr ) :: cubin !! Cubin data call self % destroy () self % base_storage = base_storage self % kernel_type = kernel_type self % ndims = ndims self % cumod = CUmodule ( c_null_ptr ) allocate ( self % configs ( size ( configs ) )) do i = 1 , size ( configs ) self % configs ( i )% tile_size = configs ( i )% tile_size self % configs ( i )% block_rows = configs ( i )% block_rows self % configs ( i )% padding = configs ( i )% padding enddo self % basic_name = DEFAULT_KERNEL_NAME // \"_\" select case ( kernel_type % val ) case ( KERNEL_PERMUTE_FORWARD % val ) self % basic_name = self % basic_name // \"forward\" case ( KERNEL_PERMUTE_BACKWARD % val ) self % basic_name = self % basic_name // \"backward\" case ( KERNEL_PERMUTE_BACKWARD_START % val ) self % basic_name = self % basic_name // \"backward_start\" case ( KERNEL_PERMUTE_BACKWARD_END_PIPELINED % val ) self % basic_name = self % basic_name // \"backward_end\" case ( KERNEL_UNPACK_PIPELINED % val ) self % basic_name = self % basic_name // \"unpack\" case default INTERNAL_ERROR ( \"nvrtc_module.create: Unknown kernel type\" ) end select region_name = \"Compiling nvRTC program: \" // self % basic_name REGION_BEGIN ( region_name , COLOR_FFT ) WRITE_DEBUG ( region_name ) code = get_code ( self % basic_name , ndims , base_storage , kernel_type ) self % prog = compile_program ( code , self % basic_name , configs , props ) call code % destroy () NVRTC_CALL ( nvrtcGetCUBINSize ( self % prog , cubinSizeRet ) ) cubin = mem_alloc_host ( cubinSizeRet ) NVRTC_CALL ( nvrtcGetCUBIN ( self % prog , cubin ) ) CUDA_CALL ( cuModuleLoadData ( self % cumod , cubin ) ) call mem_free_host ( cubin ) REGION_END ( region_name ) self % is_created = . true . deallocate ( region_name ) end subroutine create subroutine destroy ( self ) !! Destroys module and frees resources class ( nvrtc_module ), intent ( inout ) :: self if ( . not . self % is_created ) return if ( is_null_ptr ( self % cumod % ptr ) . or . is_null_ptr ( self % prog % cptr ) ) INTERNAL_ERROR ( \"nvrtc_module.destroy: is_null_ptr(self%cumod%ptr)\" ) NVRTC_CALL ( nvrtcDestroyProgram ( self % prog ) ) CUDA_CALL ( cuModuleUnload ( self % cumod ) ) self % cumod = CUmodule ( c_null_ptr ) self % prog = nvrtcProgram ( c_null_ptr ) if ( allocated ( self % configs ) ) deallocate ( self % configs ) if ( allocated ( self % basic_name ) ) deallocate ( self % basic_name ) end subroutine destroy function compile_program ( code , prog_name , configs , props ) result ( prog ) !! Compiles nvRTC program with given configurations type ( codegen_t ), intent ( in ) :: code !! CUDA code to compile character ( len =* ), intent ( in ) :: prog_name !! Basic kernel name type ( kernel_config ), intent ( in ) :: configs (:) !! Kernel configurations that this module should be compiled for type ( device_props ), intent ( in ) :: props !! GPU architecture properties type ( nvrtcProgram ) :: prog !! Resulting nvRTC program integer ( int32 ) :: num_options !! Number of compilation options type ( string ), target , allocatable :: options (:) !! Compilation options type ( c_ptr ), allocatable :: c_options (:) !! C style, null-string terminated options character ( c_char ), allocatable :: c_code (:) !! CUDA C Code to compile integer ( int32 ) :: i !! Loop variable integer ( int32 ) :: compile_result !! Result of compilation character ( len = :), allocatable :: prog_name_ #ifdef DTFFT_DEBUG num_options = 3 #else num_options = 1 #endif allocate ( c_options ( num_options ), options ( num_options ) ) options ( 1 ) = string ( \"--gpu-architecture=sm_\" // to_str ( props % compute_capability_major ) // to_str ( props % compute_capability_minor ) // c_null_char ) #ifdef DTFFT_DEBUG options ( 2 ) = string ( \"--device-debug\" // c_null_char ) options ( 3 ) = string ( \"--generate-line-info\" // c_null_char ) #endif do i = 1 , num_options c_options ( i ) = c_loc ( options ( i )% raw ) enddo call astring_f2c ( code % raw , c_code ) prog_name_ = prog_name // \".cu\" // c_null_char NVRTC_CALL ( nvrtcCreateProgram ( prog , c_code , prog_name_ , 0 , c_null_ptr , c_null_ptr ) ) deallocate ( c_code , prog_name_ ) do i = 1 , size ( configs ) call set_name_expression ( prog , prog_name , configs ( i )% tile_size , configs ( i )% block_rows , configs ( i )% padding ) enddo compile_result = nvrtcCompileProgram ( prog , num_options , c_options ) if ( compile_result /= 0 ) then block type ( c_ptr ) :: c_log integer ( c_size_t ) :: log_size character ( len = :), allocatable :: f_log NVRTC_CALL ( nvrtcGetProgramLogSize ( prog , log_size ) ) c_log = mem_alloc_host ( log_size ) NVRTC_CALL ( nvrtcGetProgramLog ( prog , c_log ) ) call string_c2f ( c_log , f_log ) write ( error_unit , \"(a)\" ) \"dtFFT Internal Error: failed to compile kernel\" write ( error_unit , \"(a)\" ) \"CUDA Code:\" write ( error_unit , \"(a)\" ) code % raw write ( error_unit , \"(a)\" ) \"Compilation log:\" write ( error_unit , \"(a)\" ) f_log INTERNAL_ERROR ( \"compile_program: Compilation failed\" ) endblock endif call destroy_strings ( options ) deallocate ( c_options ) end function compile_program function get_name_expression ( basic_name , tile_dim , block_rows , padding ) result ( expression ) !! Generates name expression for given template parameters character ( len =* ), intent ( in ) :: basic_name !! Basic kernel name integer ( int32 ), intent ( in ) :: tile_dim !! Size of shared memory tile, template parameter integer ( int32 ), intent ( in ) :: block_rows !! Number of rows processed by single thread, template parameter integer ( int32 ), intent ( in ) :: padding !! Padding to avoid shared memory bank conflicts, template parameter character ( c_char ), allocatable :: expression (:) !! Resulting name expression character ( len = :), allocatable :: str !! Temporary string allocate ( str , source = basic_name ) str = str // \"<\" // to_str ( tile_dim ) str = str // \",\" // to_str ( block_rows ) str = str // \",\" // to_str ( padding ) str = str // \">\" // c_null_char call astring_f2c ( str , expression ) deallocate ( str ) end function get_name_expression subroutine set_name_expression ( prog , basic_name , tile_dim , block_rows , padding ) !! Sets name expression for given template parameters to nvRTC program type ( nvrtcProgram ), intent ( in ) :: prog !! nvRTC program character ( len =* ), intent ( in ) :: basic_name !! Basic kernel name integer ( int32 ), intent ( in ) :: tile_dim !! Size of shared memory tile, template parameter integer ( int32 ), intent ( in ) :: block_rows !! Number of rows processed by single thread, template parameter integer ( int32 ), intent ( in ) :: padding !! Padding to avoid shared memory bank conflicts, template parameter character ( c_char ), allocatable :: expression (:) !! Name expression expression = get_name_expression ( basic_name , tile_dim , block_rows , padding ) NVRTC_CALL ( nvrtcAddNameExpression ( prog , expression ) ) deallocate ( expression ) end subroutine set_name_expression function get_mangled_name ( basic_name , prog , tile_dim , block_rows , padding ) result ( mangled ) !! Gets mangled name for given template parameters from nvRTC program character ( len =* ), intent ( in ) :: basic_name !! Basic kernel name type ( nvrtcProgram ), intent ( in ) :: prog !! nvRTC program integer ( int32 ), intent ( in ) :: tile_dim !! Size of shared memory tile, template parameter integer ( int32 ), intent ( in ) :: block_rows !! Number of rows processed by single thread, template parameter integer ( int32 ), intent ( in ) :: padding !! Padding to avoid shared memory bank conflicts, template parameter type ( c_ptr ) :: mangled !! Mangled kernel name character ( c_char ), allocatable :: expression (:) !! Name expression expression = get_name_expression ( basic_name , tile_dim , block_rows , padding ) NVRTC_CALL ( nvrtcGetLoweredName ( prog , expression , mangled ) ) deallocate ( expression ) end function get_mangled_name function get_code ( kernel_name , ndims , base_storage , kernel_type ) result ( code ) !! Generates code that will be used to locally tranpose data and prepares to send it to other processes character ( len =* ), intent ( in ) :: kernel_name !! Name of CUDA kernel integer ( int32 ), intent ( in ) :: ndims !! Number of dimensions integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel to generate code for type ( codegen_t ) :: code !! Resulting code character ( len = :), allocatable :: buffer_type !! Type of buffer that should be used character ( len = 2 ) :: temp !! Temporary string logical :: is_unpack !! Is this unpack kernel select case ( base_storage ) case ( FLOAT_STORAGE_SIZE ) allocate ( buffer_type , source = \"float\" ) case ( DOUBLE_STORAGE_SIZE ) allocate ( buffer_type , source = \"double\" ) case ( DOUBLE_COMPLEX_STORAGE_SIZE ) allocate ( buffer_type , source = \"double2\" ) case default INTERNAL_ERROR ( \"get_code: unknown `base_storage`\" ) end select is_unpack = is_unpack_kernel ( kernel_type ) if ( kernel_type == KERNEL_PERMUTE_FORWARD ) then temp = \"ny\" else temp = \"nz\" end if call code % add ( \"template <int TILE_DIM, int BLOCK_ROWS, int PADDING>\" ) call code % add ( '__global__ void' ) call code % add ( kernel_name ) call code % add ( \"(\" ) call code % add ( \"   \" // buffer_type // \" * __restrict__ out\" ) call code % add ( \"    ,const \" // buffer_type // \" * __restrict__ in\" ) call code % add ( \"    ,const int nx\" ) call code % add ( \"    ,const int ny\" ) if ( ndims == 3 . and . . not . is_unpack ) call code % add ( \"    ,const int nz\" ) if ( is_unpack ) then call code % add ( \"   ,const int nxx\" ) call code % add ( \"   ,const int nyy\" ) if ( kernel_type == KERNEL_PERMUTE_BACKWARD_END_PIPELINED ) call code % add ( \"   ,const int nzz\" ) call code % add ( \"   ,const int din\" ) call code % add ( \"   ,const int dout\" ) end if call code % add ( \")\" ) call code % add ( \"{\" ) call code % add ( \"    __shared__ \" // buffer_type // \" tile[TILE_DIM][TILE_DIM + PADDING];\" ) call code % add ( \"    const int x_in = threadIdx.x + TILE_DIM * blockIdx.x;\" ) call code % add ( \"    const int y_in = threadIdx.y + TILE_DIM * blockIdx.y;\" ) call code % add ( \"    const int z = blockIdx.z;\" ) if (. not . is_unpack ) then call code % add ( \"    const int x_out = threadIdx.y + TILE_DIM * blockIdx.x;\" ) call code % add ( \"    const int y_out = threadIdx.x + TILE_DIM * blockIdx.y;\" ) end if if ( ndims == 2 . and . . not . is_unpack ) then call code % add ( \"    const int ibase = x_in;\" ) call code % add ( \"    const int obase = y_out;\" ) else select case ( kernel_type % val ) case ( KERNEL_PERMUTE_FORWARD % val ) call code % add ( \"    const int ibase = x_in + z * ny * nx;\" ) call code % add ( \"    const int obase = y_out + z * ny;\" ) case ( KERNEL_PERMUTE_BACKWARD % val ) call code % add ( \"    const int ibase = x_in + z * nx;\" ) call code % add ( \"    const int obase = y_out + z * nx * nz;\" ) case ( KERNEL_PERMUTE_BACKWARD_START % val ) call code % add ( \"    const int ibase = x_in + z * nx;\" ) call code % add ( \"    const int obase = y_out + z * nz;\" ) case ( KERNEL_PERMUTE_BACKWARD_END_PIPELINED % val ) call code % add ( \"    const int ibase = din + x_in + z * nxx;\" ) call code % add ( \"    const int obase = dout + x_in + z * nx * ny;\" ) case ( KERNEL_UNPACK_PIPELINED % val ) call code % add ( \"    const int ibase = din + x_in + z * nxx * nyy;\" ) call code % add ( \"    const int obase = dout + x_in + z * nx * ny;\" ) end select end if call code % add ( \"    #pragma unroll\" ) call code % add ( \"    for(int offset = 0; offset < TILE_DIM; offset+=BLOCK_ROWS) {\" ) call code % add ( \"        int y = y_in + offset;\" ) if ( is_unpack ) then call code % add ( \"        if( x_in < nxx && y < nyy) {\" ) else call code % add ( \"        if( x_in < nx && y < \" // temp // \") {\" ) end if select case ( kernel_type % val ) case ( KERNEL_PERMUTE_FORWARD % val ) call code % add ( \"            int iidx = ibase + y * nx;\" ) case ( KERNEL_PERMUTE_BACKWARD_END_PIPELINED % val ) call code % add ( \"            int iidx = ibase + y * nxx * nzz;\" ) case ( KERNEL_UNPACK_PIPELINED % val ) call code % add ( \"            int iidx = ibase + y * nxx;\" ) case default call code % add ( \"            int iidx = ibase + y * nx * ny;\" ) end select call code % add ( \"            tile[threadIdx.x][threadIdx.y + offset] = in[iidx];\" ) call code % add ( \"        }\" ) call code % add ( \"    }\" ) call code % add ( \"    __syncthreads();\" ) call code % add ( \"    #pragma unroll\" ) call code % add ( \"    for(int offset = 0; offset < TILE_DIM; offset+=BLOCK_ROWS) {\" ) if ( is_unpack_kernel ( kernel_type )) then call code % add ( \"      int y = y_in + offset;\" ) call code % add ( \"      if( x_in < nxx && y < nyy ) {\" ) else call code % add ( \"      int x = x_out + offset;\" ) call code % add ( \"      if( x < nx && y_out < \" // temp // \" ) {\" ) end if if ( ndims == 2 . and . . not . is_unpack ) then call code % add ( \"        int oidx = obase + x * ny;\" ) else if ( any ( kernel_type == [ KERNEL_PERMUTE_FORWARD , KERNEL_PERMUTE_BACKWARD_START ])) then call code % add ( \"        int oidx = obase + x * ny * nz;\" ) else if ( is_unpack_kernel ( kernel_type )) then call code % add ( \"        int oidx = obase + y * nx;\" ) else call code % add ( \"        int oidx = obase + x * nz;\" ) end if end if if ( is_unpack_kernel ( kernel_type )) then call code % add ( \"        out[oidx] = tile[threadIdx.x][threadIdx.y + offset];\" ) else call code % add ( \"        out[oidx] = tile[threadIdx.y + offset][threadIdx.x];\" ) end if call code % add ( \"        }\" ) call code % add ( \"    }\" ) call code % add ( \"}\" ) deallocate ( buffer_type ) end function get_code end module dtfft_nvrtc_module","tags":"","loc":"sourcefile/dtfft_nvrtc_module.f90.html"},{"title":"dtfft_executor_mkl_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_executor_mkl_m.f90~~EfferentGraph sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_executor_mkl_m.f90~~AfferentGraph sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_executor_mkl_m !! This module describes MKL based FFT Executor: [[mkl_executor]] !! !! https://software.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/fourier-transform-functions/fft-functions.html use iso_fortran_env , only : int8 , int32 , int64 , error_unit use iso_c_binding , only : c_int , c_long , c_ptr use dtfft_abstract_executor , only : abstract_executor , FFT_C2C , FFT_R2C , FFT_R2R use dtfft_errors use dtfft_interface_mkl_m use dtfft_interface_mkl_native_m use dtfft_parameters use dtfft_utils , only : to_str #include \"_dtfft_mpi.h\" implicit none private public :: mkl_executor #define MKL_DFTI_CALL(name, func)                                                                                                                                     \\ block ; \\ integer ( c_long ) :: ierr ; \\ integer ( int32 ) :: mpi_err ; \\ ierr = func ; \\ if ( ierr /= DFTI_NO_ERROR ) then ; \\ write ( error_unit , '(a)' ) \"Error occured during call to MKL DFTI function '\" // name // \"': \" // DftiErrorMessage ( ierr ) // \" at \" // __ FILE__ // \":\" // to_str ( __ LINE__ ); \\ call MPI_Abort ( MPI_COMM_WORLD , int ( ierr , c_int ), mpi_err ); \\ endif ; \\ endblock type , extends ( abstract_executor ) :: mkl_executor !! MKL FFT Executor private logical :: need_reconfigure !! Needed for R2C plans integer ( c_long ), allocatable :: istrides (:) !! Input strides. Needed for R2C plans to reconfigure plan integer ( c_long ), allocatable :: ostrides (:) !! Output strides. Needed for R2C plans to reconfigure plan integer ( int32 ) :: idist !! Input distance between the first data elements of consecutive data sets integer ( int32 ) :: odist !! Output distance between the first data elements of consecutive data sets contains procedure :: create_private => create !! Creates FFT plan via MKL DFTI Interface procedure :: execute_private => execute !! Executes MKL plan procedure :: destroy_private => destroy !! Destroys MKL plan procedure , nopass :: mem_alloc !! Allocates MKL memory procedure , nopass :: mem_free !! Frees MKL aligned memory endtype mkl_executor contains subroutine make_plan ( fft_rank , fft_sizes , mkl_precision , forward_domain , how_many , idist , odist , plan ) !! Creates general MKL plan integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( c_long ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: mkl_precision !! MKL Precision integer ( int32 ), intent ( in ) :: forward_domain !! C2C or R2C flag integer ( int32 ), intent ( in ) :: how_many !! Sets DFTI_NUMBER_OF_TRANSFORMS integer ( int32 ), intent ( in ) :: idist !! Sets DFTI_INPUT_DISTANCE integer ( int32 ), intent ( in ) :: odist !! Sets DFTI_OUTPUT_DISTANCE type ( c_ptr ), intent ( inout ) :: plan !! Resulting plan MKL_DFTI_CALL ( \"DftiCreateDescriptor\" , mkl_dfti_create_desc ( mkl_precision , forward_domain , int ( fft_rank , c_long ), fft_sizes , plan ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_NUMBER_OF_TRANSFORMS , how_many ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_PLACEMENT , DFTI_NOT_INPLACE ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_INPUT_DISTANCE , idist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_OUTPUT_DISTANCE , odist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( plan , DFTI_CONJUGATE_EVEN_STORAGE , DFTI_COMPLEX_COMPLEX ) ) MKL_DFTI_CALL ( \"DftiCommitDescriptor\" , mkl_dfti_commit_desc ( plan ) ) end subroutine make_plan subroutine create ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan via MKL DFTI Interface class ( mkl_executor ), intent ( inout ) :: self !! MKL FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform integer ( int32 ) :: forward_domain !! Forward domain integer ( int32 ) :: mkl_precision !! MKL Precision integer ( int32 ) :: i !! Loop counter integer ( int32 ) :: idx !! Index integer ( c_long ) :: iprod !! Input product integer ( c_long ) :: oprod !! Output product integer ( c_long ) :: sizes ( fft_rank ) !! Sizes of FFT if ( present ( r2r_kinds ) ) then endif error_code = DTFFT_SUCCESS self % is_inverse_copied = . true . self % need_reconfigure = . false . select case ( fft_type ) case ( FFT_C2C ) forward_domain = DFTI_COMPLEX case ( FFT_R2C ) forward_domain = DFTI_REAL self % need_reconfigure = . true . self % idist = idist self % odist = odist allocate ( self % istrides ( size ( inembed ) + 1 ), source = 0_c_long ) allocate ( self % ostrides ( size ( onembed ) + 1 ), source = 0_c_long ) iprod = 1 ; oprod = 1 self % istrides ( size ( inembed ) + 1 ) = iprod self % ostrides ( size ( onembed ) + 1 ) = oprod do i = 1 , size ( inembed ) - 1 idx = size ( inembed ) + 1 - i iprod = iprod * inembed ( idx ) oprod = oprod * onembed ( idx ) self % istrides ( idx ) = iprod self % ostrides ( idx ) = oprod enddo case ( FFT_R2R ) error_code = DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED return endselect if ( precision == DTFFT_DOUBLE ) then mkl_precision = DFTI_DOUBLE else mkl_precision = DFTI_SINGLE endif sizes (:) = fft_sizes (:) call make_plan ( fft_rank , sizes , mkl_precision , forward_domain , how_many , idist , odist , self % plan_forward ) self % plan_backward = self % plan_forward end subroutine create subroutine execute ( self , a , b , sign ) !! Executes MKL plan class ( mkl_executor ), intent ( in ) :: self !! MKL FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform if ( self % need_reconfigure ) then if ( sign == FFT_FORWARD ) then MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_INPUT_DISTANCE , self % idist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_OUTPUT_DISTANCE , self % odist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_INPUT_STRIDES , self % istrides ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_OUTPUT_STRIDES , self % ostrides ) ) else MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_INPUT_DISTANCE , self % odist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_OUTPUT_DISTANCE , self % idist ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_INPUT_STRIDES , self % ostrides ) ) MKL_DFTI_CALL ( \"DftiSetValue\" , mkl_dfti_set_value ( self % plan_forward , DFTI_OUTPUT_STRIDES , self % istrides ) ) endif MKL_DFTI_CALL ( \"DftiCommitDescriptor\" , mkl_dfti_commit_desc ( self % plan_forward ) ) endif MKL_DFTI_CALL ( \"DftiCompute\" , mkl_dfti_execute ( self % plan_forward , a , b , int ( sign , c_int )) ) end subroutine execute subroutine destroy ( self ) !! Destroys MKL plan class ( mkl_executor ), intent ( inout ) :: self !! MKL FFT Executor MKL_DFTI_CALL ( \"DftiFreeDescriptor\" , mkl_dfti_free_desc ( self % plan_forward ) ) end subroutine destroy subroutine mem_alloc ( alloc_bytes , ptr ) !! Allocates MKL memory integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer MKL_DFTI_CALL ( \"mkl_malloc\" , mkl_dfti_mem_alloc ( alloc_bytes , ptr ) ) end subroutine mem_alloc subroutine mem_free ( ptr ) !! Frees MKL aligned memory type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free MKL_DFTI_CALL ( \"mkl_free\" , mkl_dfti_mem_free ( ptr ) ) end subroutine mem_free end module dtfft_executor_mkl_m","tags":"","loc":"sourcefile/dtfft_executor_mkl_m.f90.html"},{"title":"dtfft_pencil.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_pencil.f90~~EfferentGraph sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_pencil.f90~~AfferentGraph sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_pencil !! This module describes private [[pencil]] and public [[dtfft_pencil_t]] classes use iso_fortran_env use iso_c_binding use dtfft_errors use dtfft_parameters use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" #ifdef DTFFT_WITH_CUDA use dtfft_interface_cuda_runtime #include \"_dtfft_cuda.h\" #endif implicit none private public :: pencil , pencil_init public :: dtfft_pencil_t , dtfft_pencil_c public :: get_local_sizes public :: get_transpose_type public :: pencil_c2f , pencil_f2c type :: dtfft_pencil_t !! Structure to hold pencil decomposition info integer ( int8 ) :: dim !! Aligned dimension id integer ( int8 ) :: ndims = 0 !! Number of dimensions integer ( int32 ), allocatable :: starts (:) !! Local starts, starting from 0 for both C and Fortran integer ( int32 ), allocatable :: counts (:) !! Local counts of data, in elements integer ( int64 ) :: size !! Total number of elements in a pencil logical , private :: is_created = . false . !! Is pencil created contains ! final :: destroy_pencil_t !! Finalizer procedure , pass ( self ), private :: destroy => destroy_pencil_t_private !! Destroys pencil end type dtfft_pencil_t interface dtfft_pencil_t !! Type bound constuctor for dtfft_pencil_t module procedure create_pencil_t !! Creates pencil object, that can be used to create dtFFT plans end interface dtfft_pencil_t type , bind ( C ) :: dtfft_pencil_c !! Structure to hold pencil decomposition info integer ( c_int8_t ) :: dim !! Aligned dimension id integer ( c_int8_t ) :: ndims !! Number of dimensions integer ( c_int32_t ) :: starts ( 3 ) !! Local starts, starting from 0 for both C and Fortran integer ( c_int32_t ) :: counts ( 3 ) !! Local counts of data, in elements integer ( c_size_t ) :: size !! Total number of elements in a pencil end type dtfft_pencil_c type :: pencil !! Class that describes information about data layout integer ( int8 ) :: aligned_dim !! Position of aligned dimension. For example: X pencil aligned_dim = 1, Z pencil aligned_dim = 3 integer ( int8 ) :: rank !! Rank of buffer: 2 or 3 integer ( int32 ), allocatable :: starts (:) !! Local starts, starting from 0 for both C and Fortran integer ( int32 ), allocatable :: counts (:) !! Local counts of data, in elements logical :: is_even !! Is data evenly distributed across processes contains private procedure , pass ( self ), public :: create !! Creates pencil procedure , pass ( self ), public :: destroy !! Destroys pencil ! procedure, pass(self),  public  :: output         !! Writes pencil data to stdout !                                                   !! Used only for debugging purposes procedure , pass ( self ), public :: make_public !! Creates public object that users can use to create own FFT backends end type pencil type :: pencil_init !! Class that describes information about data layout !! !! It is an extension of dtfft_pencil_t with additional fields TYPE_MPI_COMM , allocatable :: comms (:) !! 1D communicators for each dimension integer ( int32 ), allocatable :: starts (:) !! Local starts integer ( int32 ), allocatable :: counts (:) !! Local counts integer ( int32 ), allocatable :: dims (:) !! Global dimensions of entire region contains private procedure , pass ( self ), public :: create => create_pencil_init !! Creates and validates pencil passed by user to plan constructors procedure , pass ( self ), public :: destroy => destroy_pencil_init !! Destroys pencil_init end type pencil_init contains subroutine create ( self , rank , aligned_dim , counts , comms , lstarts , lcounts , order ) !! Creates pencil class ( pencil ), intent ( inout ) :: self !! Pencil integer ( int8 ), intent ( in ) :: rank !! Rank of buffer integer ( int8 ), intent ( in ) :: aligned_dim !! Position of aligned dimension integer ( int32 ), intent ( in ) :: counts (:) !! Global counts TYPE_MPI_COMM , intent ( in ) :: comms (:) !! Grid communicators integer ( int32 ), optional , intent ( in ) :: lstarts (:) !! Local starts integer ( int32 ), optional , intent ( in ) :: lcounts (:) !! Local counts integer ( int8 ), optional , intent ( in ) :: order (:) !! Order of dimensions integer ( int8 ) :: d !! Counter logical , allocatable :: is_even (:) !! Even distribution flag integer ( int8 ) :: order_ integer ( int32 ), allocatable :: starts (:), sizes (:) call self % destroy () allocate ( sizes ( rank )) allocate ( starts ( rank )) allocate ( is_even ( rank )) self % aligned_dim = aligned_dim self % rank = rank if ( present ( lstarts ) . and . present ( lcounts ) ) then if ( aligned_dim == 1 ) then starts (:) = lstarts (:) sizes (:) = lcounts (:) else do d = 1 , rank if ( aligned_dim == 2 . and . rank == 3 . and . d == 3 ) then call get_local_size ( counts ( d ), comms ( d ), starts ( d ), sizes ( d ), lstarts ( 3 ), lcounts ( 3 )) else if ( aligned_dim == 3 . and . rank == 3 . and . d == 2 ) then call get_local_size ( counts ( d ), comms ( d ), starts ( d ), sizes ( d ), lstarts ( 3 ), lcounts ( 3 )) else call get_local_size ( counts ( d ), comms ( d ), starts ( d ), sizes ( d )) endif enddo endif else do d = 1 , rank call get_local_size ( counts ( d ), comms ( d ), starts ( d ), sizes ( d )) enddo endif do d = 1 , rank is_even ( d ) = check_if_even ( sizes ( d ), comms ( d )) enddo allocate ( self % counts ( rank )) allocate ( self % starts ( rank )) do d = 1 , rank order_ = d if ( present ( order ) ) order_ = order ( d ) self % counts ( d ) = sizes ( order_ ) self % starts ( d ) = starts ( order_ ) enddo self % is_even = all ( is_even ) deallocate ( is_even ) end subroutine create subroutine destroy ( self ) !! Destroys pencil class ( pencil ), intent ( inout ) :: self !! Pencil if ( allocated ( self % counts ) ) deallocate ( self % counts ) if ( allocated ( self % starts ) ) deallocate ( self % starts ) end subroutine destroy subroutine get_local_size ( n_global , comm , start , count , start_to_keep , size_to_keep ) !! Computes local portions of data based on global count and position inside grid communicator integer ( int32 ), intent ( in ) :: n_global !! Global number of points TYPE_MPI_COMM , intent ( in ) :: comm !! Grid communicator integer ( int32 ), intent ( out ) :: start !! Local start integer ( int32 ), intent ( out ) :: count !! Local count integer ( int32 ), optional , intent ( in ) :: start_to_keep !! Start to keep in case of user defined decomposition integer ( int32 ), optional , intent ( in ) :: size_to_keep !! Size to keep in case of user defined decomposition integer ( int32 ), allocatable :: shift (:) !! Work buffer integer ( int32 ) :: comm_dim !! Number of MPI processes along n_global integer ( int32 ) :: comm_rank !! Rank of current MPI process integer ( int32 ) :: res !! Residual from n_global / comm_dim integer ( int32 ) :: i !! Counter integer ( int32 ) :: ierr !! Error code call MPI_Comm_size ( comm , comm_dim , ierr ) call MPI_Comm_rank ( comm , comm_rank , ierr ) res = mod ( n_global , comm_dim ) start = 0 if ( comm_dim == 1 ) then count = n_global return elseif ( present ( size_to_keep ) ) then count = size_to_keep elseif ( comm_rank >= comm_dim - res ) then count = int ( n_global / comm_dim , int32 ) + 1 else count = int ( n_global / comm_dim , int32 ) endif if ( present ( start_to_keep ) ) then start = start_to_keep else allocate ( shift ( comm_dim ) ) call MPI_Allgather ( count , 1 , MPI_INTEGER , shift , 1 , MPI_INTEGER , comm , ierr ) do i = 0 , comm_rank - 1 start = start + shift ( i + 1 ) end do deallocate ( shift ) endif end subroutine get_local_size logical function check_if_even ( count , comm ) !! Checks if data is evenly distributed across processes integer ( int32 ), intent ( in ) :: count !! Local count TYPE_MPI_COMM , intent ( in ) :: comm !! Grid communicator integer ( int32 ) :: comm_size !! Number of MPI processes integer ( int32 ), allocatable :: shift (:) !! Work buffer integer ( int32 ) :: ierr !! Error code call MPI_Comm_size ( comm , comm_size , ierr ) if ( comm_size == 1 ) then check_if_even = . true . return end if allocate ( shift ( comm_size ) ) call MPI_Allgather ( count , 1 , MPI_INTEGER , shift , 1 , MPI_INTEGER , comm , ierr ) check_if_even = all ( shift == shift ( 1 )) deallocate ( shift ) end function check_if_even !   subroutine output(self, name, vec) !   !! Writes pencil data to stdout !     class(pencil),                intent(in)  :: self                 !! Pencil !     character(len=*),             intent(in)  :: name                 !! Name of pencil !     real(real32),    target,      intent(in)  :: vec(:)               !! Device pointer to data !     integer(int32)                            :: iter                 !! Iteration counter !     integer(int32)                            :: i,j,k,ijk            !! Counters !     integer(int32)                            :: comm_size            !! Number of MPI processes !     integer(int32)                            :: comm_rank            !! Rank of current MPI process !     integer(int32)                            :: ierr                 !! Error code ! #ifdef DTFFT_WITH_CUDA !     real(real32),    target,      allocatable :: buf(:)               !! Host buffer ! #endif !     call MPI_Comm_rank(MPI_COMM_WORLD, comm_rank, ierr) !     call MPI_Comm_size(MPI_COMM_WORLD, comm_size, ierr) ! #ifdef DTFFT_WITH_CUDA !     allocate( buf( product(self%counts) ) ) !     if ( is_device_ptr(c_loc(vec)) ) then !       CUDA_CALL( cudaDeviceSynchronize()) !       CUDA_CALL( cudaMemcpy(c_loc(buf), c_loc(vec), int(real32, int64) * product(self%counts), cudaMemcpyDeviceToHost) ) !     endif ! #endif !     do iter = 0, comm_size - 1 !       call MPI_Barrier(MPI_COMM_WORLD, ierr) !       if ( iter == comm_rank ) then !         write(output_unit,'(a)') name !         do k = 0, self%counts(3) - 1 !           do j = 0, self%counts(2) - 1 !             ijk = k * self%counts(2) * self%counts(1) + j * self%counts(1) ! #ifdef DTFFT_WITH_CUDA !             write(output_unit,'(2i5, *(f9.2))') j, k, (buf(ijk + i + 1), i=0,self%counts(1) - 1) ! #else !             write(output_unit,'(2i5, *(f9.2))') j, k, (vec(ijk + i + 1), i=0,self%counts(1) - 1) ! #endif !           enddo !           write(output_unit, '(a)') ' ' !           flush(output_unit) !         enddo !         write(output_unit, '(a)') ' ' !         write(output_unit, '(a)') ' ' !         flush(output_unit) !       endif !       call MPI_Barrier(MPI_COMM_WORLD, ierr) !     enddo ! #ifdef DTFFT_WITH_CUDA !     deallocate(buf) ! #endif !   end subroutine output type ( dtfft_pencil_t ) function make_public ( self ) !! Creates public object that users can use to create own FFT backends class ( pencil ), intent ( in ) :: self !! Pencil integer ( int8 ) :: i !! Counter make_public % dim = self % aligned_dim make_public % ndims = self % rank if ( allocated ( make_public % counts ) ) deallocate ( make_public % counts ) if ( allocated ( make_public % starts ) ) deallocate ( make_public % starts ) allocate ( make_public % counts ( 1 : self % rank ), source = self % counts ) allocate ( make_public % starts ( 1 : self % rank ), source = self % starts ) make_public % size = 1_int64 do i = 1 , make_public % ndims make_public % size = make_public % size * int ( make_public % counts ( i ), int64 ) enddo end function make_public type ( dtfft_pencil_t ) function create_pencil_t ( starts , counts ) !! Creates pencil object, that can be used to create dtFFT plans integer ( int32 ), intent ( in ) :: starts (:) !! Local starts, starting from 0 for both C and Fortran integer ( int32 ), intent ( in ) :: counts (:) !! Local counts of data, in elements call create_pencil_t % destroy () create_pencil_t % ndims = size ( starts , kind = int8 ) allocate ( create_pencil_t % starts , source = starts ) allocate ( create_pencil_t % counts , source = counts ) create_pencil_t % is_created = . true . end function create_pencil_t subroutine destroy_pencil_t_private ( self ) !! Destroys pencil class ( dtfft_pencil_t ), intent ( inout ) :: self !! Public pencil if ( allocated ( self % counts ) ) deallocate ( self % counts ) if ( allocated ( self % starts ) ) deallocate ( self % starts ) self % dim = - 1 self % ndims = - 1 self % size = - 1 self % is_created = . false . end subroutine destroy_pencil_t_private subroutine destroy_pencil_t ( self ) !! Destroys pencil type ( dtfft_pencil_t ), intent ( inout ) :: self !! Public pencil call self % destroy () end subroutine destroy_pencil_t subroutine pencil_f2c ( pencil , c_pencil ) !! Converts Fortran pencil to C pencil type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Fortran pencil type ( dtfft_pencil_c ), intent ( out ) :: c_pencil !! C pencil c_pencil % dim = pencil % dim c_pencil % ndims = pencil % ndims c_pencil % size = pencil % size c_pencil % starts ( 1 : pencil % ndims ) = pencil % starts (:) c_pencil % counts ( 1 : pencil % ndims ) = pencil % counts (:) end subroutine pencil_f2c subroutine pencil_c2f ( c_pencil , pencil , error_code ) !! Converts C pencil to Fortran pencil type ( dtfft_pencil_c ), intent ( in ) :: c_pencil !! C pencil type ( dtfft_pencil_t ), intent ( out ) :: pencil !! Fortran pencil integer ( int32 ), intent ( out ) :: error_code !! Error code error_code = DTFFT_SUCCESS if ( . not . any ( c_pencil % ndims == [ 2 , 3 ]) ) then error_code = DTFFT_ERROR_PENCIL_NOT_INITIALIZED return endif pencil = dtfft_pencil_t ( c_pencil % starts ( 1 : c_pencil % ndims ), c_pencil % counts ( 1 : c_pencil % ndims )) end subroutine pencil_c2f subroutine get_local_sizes ( pencils , in_starts , in_counts , out_starts , out_counts , alloc_size , is_y_slab ) !! Obtain local starts and counts in `real` and `fourier` spaces type ( pencil ), intent ( in ) :: pencils (:) !! Array of pencils integer ( int32 ), optional , intent ( out ) :: in_starts (:) !! Start indexes in `real` space (0-based) integer ( int32 ), optional , intent ( out ) :: in_counts (:) !! Number of elements in `real` space integer ( int32 ), optional , intent ( out ) :: out_starts (:) !! Start indexes in `fourier` space (0-based) integer ( int32 ), optional , intent ( out ) :: out_counts (:) !! Number of elements in `fourier` space integer ( int64 ), optional , intent ( out ) :: alloc_size !! Minimal number of elements required to execute plan logical , optional , intent ( in ) :: is_y_slab !! Is Y-slab optimization used integer ( int8 ) :: d !! Counter integer ( int8 ) :: ndims !! Number of dimensions logical :: is_y_slab_ !! Is Y-slab optimization used integer ( int8 ) :: out_dim !! Aligned dimension of output pencil ndims = size ( pencils , kind = int8 ) is_y_slab_ = . false .; if ( present ( is_y_slab ) ) is_y_slab_ = is_y_slab out_dim = ndims ; if ( is_y_slab_ . and . ndims == 3 ) out_dim = 2 if ( present ( in_starts ) ) in_starts ( 1 : ndims ) = pencils ( 1 )% starts ( 1 : ndims ) if ( present ( in_counts ) ) in_counts ( 1 : ndims ) = pencils ( 1 )% counts ( 1 : ndims ) if ( present ( out_starts ) ) out_starts ( 1 : ndims ) = pencils ( out_dim )% starts ( 1 : ndims ) if ( present ( out_counts ) ) out_counts ( 1 : ndims ) = pencils ( out_dim )% counts ( 1 : ndims ) if ( present ( alloc_size ) ) alloc_size = maxval ([( product ( pencils ( d )% counts ), d = 1 , ndims )]) end subroutine get_local_sizes pure function get_transpose_type ( send , recv ) result ( transpose_type ) !! Determines transpose ID based on pencils type ( pencil ), intent ( in ) :: send !! Send pencil type ( pencil ), intent ( in ) :: recv !! Receive pencil type ( dtfft_transpose_t ) :: transpose_type !! Transpose ID transpose_type = dtfft_transpose_t ( 0 ) if ( send % aligned_dim == 1 . and . recv % aligned_dim == 2 ) then transpose_type = DTFFT_TRANSPOSE_X_TO_Y else if ( recv % aligned_dim == 1 . and . send % aligned_dim == 2 ) then transpose_type = DTFFT_TRANSPOSE_Y_TO_X else if ( send % aligned_dim == 1 . and . recv % aligned_dim == 3 ) then transpose_type = DTFFT_TRANSPOSE_X_TO_Z else if ( recv % aligned_dim == 1 . and . send % aligned_dim == 3 ) then transpose_type = DTFFT_TRANSPOSE_Z_TO_X else if ( send % aligned_dim == 2 . and . recv % aligned_dim == 3 ) then transpose_type = DTFFT_TRANSPOSE_Y_TO_Z else if ( recv % aligned_dim == 2 . and . send % aligned_dim == 3 ) then transpose_type = DTFFT_TRANSPOSE_Z_TO_Y endif end function get_transpose_type function create_pencil_init ( self , pencil , comm ) result ( error_code ) !! Creates and validates pencil passed by user to plan constructors class ( pencil_init ), intent ( inout ) :: self !! Internal pencil representation based on dtfft_pencil_t type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Pencil passed by user to plan constructors TYPE_MPI_COMM , intent ( in ) :: comm !! MPI Communicator passed to plan constructors integer ( int32 ) :: error_code !! Error code integer ( int32 ) :: comm_rank !! Rank of current MPI process integer ( int32 ) :: comm_size !! Size of communicator integer ( int32 ) :: ndims !! Number of dimensions integer ( int32 ) :: ierr !! Error code from MPI calls integer ( int32 ), allocatable :: all_starts (:,:) !! All starts gathered from all processes integer ( int32 ), allocatable :: all_counts (:,:) !! All counts gathered from all processes integer ( int32 ), allocatable :: fixed_dims (:) !! Fixed dimensions for 1D communicators integer ( int32 ) :: i , j , d !! Counters integer ( int32 ) :: p1 , p2 , d1 , d2 !! Counters error_code = DTFFT_SUCCESS if (. not . pencil % is_created ) then error_code = DTFFT_ERROR_PENCIL_NOT_INITIALIZED end if CHECK_ERROR_AND_RETURN_AGG ( comm ) ndims = size ( pencil % starts ) if ( ndims /= size ( pencil % counts )) then error_code = DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH end if CHECK_ERROR_AND_RETURN_AGG ( comm ) if ( ndims < 2 . or . ndims > 3 ) then error_code = DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES end if CHECK_ERROR_AND_RETURN_AGG ( comm ) if ( any ( pencil % starts < 0 )) then error_code = DTFFT_ERROR_PENCIL_INVALID_STARTS end if CHECK_ERROR_AND_RETURN_AGG ( comm ) if ( any ( pencil % counts < 0 )) then error_code = DTFFT_ERROR_PENCIL_INVALID_COUNTS end if CHECK_ERROR_AND_RETURN_AGG ( comm ) call MPI_Comm_rank ( comm , comm_rank , ierr ) call MPI_Comm_size ( comm , comm_size , ierr ) allocate ( self % dims ( ndims )) allocate ( all_starts ( ndims , comm_size )) allocate ( all_counts ( ndims , comm_size )) call MPI_Allgather ( pencil % starts , ndims , MPI_INTEGER , all_starts , ndims , MPI_INTEGER , comm , ierr ) call MPI_Allgather ( pencil % counts , ndims , MPI_INTEGER , all_counts , ndims , MPI_INTEGER , comm , ierr ) ! Computing global dimensions do d = 1 , ndims self % dims ( d ) = maxval ( all_starts ( d ,:) + all_counts ( d ,:)) enddo do p1 = 1 , comm_size do p2 = p1 + 1 , comm_size do d1 = 1 , ndims do d2 = d1 + 1 , ndims ! If two processes have the same start on two different axes, ! then their blocks must have the same size on these axes. if ( all_starts ( d1 , p1 ) == all_starts ( d1 , p2 ) . and . & all_starts ( d2 , p1 ) == all_starts ( d2 , p2 )) then if ( all_counts ( d1 , p1 ) /= all_counts ( d1 , p2 ) . or . & all_counts ( d2 , p1 ) /= all_counts ( d2 , p2 )) then error_code = DTFFT_ERROR_PENCIL_SHAPE_MISMATCH endif endif enddo enddo enddo enddo CHECK_ERROR_AND_RETURN_AGG ( comm ) ! Check intersection of pencils do i = 1 , comm_size do j = i + 1 , comm_size if ( check_overlap ( all_starts (:, i ), all_counts (:, i ), all_starts (:, j ), all_counts (:, j ), ndims )) then error_code = DTFFT_ERROR_PENCIL_OVERLAP endif enddo enddo CHECK_ERROR_AND_RETURN_AGG ( comm ) ! Check continuity of pencils if (. not . check_continuity ( all_starts , all_counts , self % dims , comm_size )) then error_code = DTFFT_ERROR_PENCIL_NOT_CONTINUOUS endif CHECK_ERROR_AND_RETURN_AGG ( comm ) allocate ( self % starts , source = pencil % starts ) allocate ( self % counts , source = pencil % counts ) allocate ( self % comms ( ndims )) allocate ( fixed_dims ( ndims - 1 )) ! Create 1D communicators for each dimension do d = 1 , ndims j = 1 do i = 1 , ndims if ( i /= d ) then fixed_dims ( j ) = i j = j + 1 endif enddo call create_1d_comm ( self % starts , all_starts , fixed_dims , comm , self % comms ( d )) enddo deallocate ( fixed_dims ) deallocate ( all_starts ) deallocate ( all_counts ) end function create_pencil_init subroutine destroy_pencil_init ( self ) !! Destroys pencil_init class ( pencil_init ), intent ( inout ) :: self !!  Internal pencil representation based on dtfft_pencil_t if ( allocated ( self % starts )) deallocate ( self % starts ) if ( allocated ( self % counts )) deallocate ( self % counts ) if ( allocated ( self % comms )) then block integer ( int32 ) :: ierr , i do i = 1 , size ( self % comms ) call MPI_Comm_free ( self % comms ( i ), ierr ) enddo end block deallocate ( self % comms ) end if if ( allocated ( self % dims )) deallocate ( self % dims ) end subroutine destroy_pencil_init pure logical function check_overlap ( lbounds1 , sizes1 , lbounds2 , sizes2 , ndims ) !! Check if two pencols overlap in ndims-dimensional space integer ( int32 ), intent ( in ) :: lbounds1 (:) !! Lower bounds of first pencil integer ( int32 ), intent ( in ) :: sizes1 (:) !! Sizes of first pencil integer ( int32 ), intent ( in ) :: lbounds2 (:) !! Lower bounds of second pencil integer ( int32 ), intent ( in ) :: sizes2 (:) !! Sizes of second pencil integer ( int32 ), intent ( in ) :: ndims !! Number of dimensions integer :: d check_overlap = . true . do d = 1 , ndims ! If there is no intersection in one of the dimensions, then there is no intersection in the whole space if ( lbounds1 ( d ) + sizes1 ( d ) <= lbounds2 ( d ) . or . lbounds2 ( d ) + sizes2 ( d ) <= lbounds1 ( d )) then check_overlap = . false . return endif enddo end function check_overlap logical function check_continuity ( all_lbounds , all_sizes , global_dims , comm_size ) !! Check if the local pencils cover the global space without gaps integer ( int32 ), intent ( in ) :: all_lbounds (:,:) !! Lower bounds of local pencils for each process integer ( int32 ), intent ( in ) :: all_sizes (:,:) !! Sizes of local pencils for each process integer ( int32 ), intent ( in ) :: global_dims (:) !! Global dimensions of the problem integer ( int32 ), intent ( in ) :: comm_size !! Number of processes in the communicator integer ( int64 ) :: total_local_volume , global_volume integer :: i ! 1. Check that local pencils do not exceed global grid limits do i = 1 , comm_size if ( any ( all_lbounds (:, i ) < 0 ) . or . & any ( all_lbounds (:, i ) + all_sizes (:, i ) > global_dims )) then check_continuity = . false . return endif enddo ! 2. Compare the sum of the local block volumes with the volume of the global grid total_local_volume = 0 do i = 1 , comm_size total_local_volume = total_local_volume + product ( int ( all_sizes (:, i ), int64 )) enddo global_volume = product ( int ( global_dims , int64 )) if ( total_local_volume == global_volume ) then check_continuity = . true . else check_continuity = . false . end if end function check_continuity function get_varying_dim ( fixed_dims , total_dims ) result ( varying_dim ) integer ( int32 ), intent ( in ) :: fixed_dims (:) integer ( int32 ), intent ( in ) :: total_dims integer ( int32 ) :: varying_dim do varying_dim = 1 , total_dims if (. not . any ( fixed_dims == varying_dim )) exit enddo end function get_varying_dim subroutine sort_by_varying_dim ( ranks , coords ) integer ( int32 ), intent ( inout ) :: ranks (:) integer ( int32 ), intent ( in ) :: coords (:) integer ( int32 ) :: i , j , tmp_rank , tmp_coord , n n = size ( ranks ) if ( n <= 1 ) return do i = 2 , n tmp_rank = ranks ( i ) tmp_coord = coords ( i ) j = i - 1 do while ( j >= 1 ) if ( coords ( j ) <= tmp_coord ) exit ranks ( j + 1 ) = ranks ( j ) j = j - 1 end do ranks ( j + 1 ) = tmp_rank end do end subroutine sort_by_varying_dim subroutine create_1d_comm ( lbounds , all_lbounds , fixed_dims , comm , new_comm ) !! Creates a new 1D communicator based on the fixed dimensions of the current pencil integer ( int32 ), intent ( in ) :: lbounds (:) !! Local starts of the current pencil integer ( int32 ), intent ( in ) :: all_lbounds (:,:) !! Local starts of all processes integer ( int32 ), intent ( in ) :: fixed_dims (:) !! Indices of fixed coordinates TYPE_MPI_COMM , intent ( in ) :: comm !! Original MPI communicator TYPE_MPI_COMM , intent ( out ) :: new_comm !! New 1D MPI communicator integer ( int32 ) :: comm_size !! Size of `comm` integer ( int32 ) :: ierr !! Error codes for mpi calls integer ( int32 ), allocatable :: neighbors (:) !! Array to neighbors ranks integer ( int32 ), allocatable :: varying_dim (:) !! Coordinates along the non-fixed dimension integer ( int32 ) :: i , j !! Counters integer ( int32 ) :: neighbor_count !! Number of neighboring processes call MPI_Comm_size ( comm , comm_size , ierr ) allocate ( neighbors ( comm_size ), varying_dim ( comm_size )) neighbor_count = 0 ! Find processes with matching fixed dimensions do i = 1 , comm_size do j = 1 , size ( fixed_dims ) if ( all_lbounds ( fixed_dims ( j ), i ) /= lbounds ( fixed_dims ( j ))) exit enddo if ( j > size ( fixed_dims )) then neighbor_count = neighbor_count + 1 neighbors ( neighbor_count ) = i - 1 ! MPI ranks are 0-based ! Store the coordinate along the first non-fixed dimension for sorting varying_dim ( neighbor_count ) = all_lbounds ( get_varying_dim ( fixed_dims , size ( lbounds )), i ) endif enddo ! Sort neighbors by their coordinate along the varying dimension call sort_by_varying_dim ( neighbors ( 1 : neighbor_count ), varying_dim ( 1 : neighbor_count )) call create_subcomm ( comm , neighbors ( 1 : neighbor_count ), new_comm ) deallocate ( neighbors , varying_dim ) end subroutine create_1d_comm end module dtfft_pencil","tags":"","loc":"sourcefile/dtfft_pencil.f90.html"},{"title":"dtfft_interface_mkl_native_m.F90 – dtFFT","text":"Files dependent on this one sourcefile~~dtfft_interface_mkl_native_m.f90~~AfferentGraph sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"mkl_dfti.f90\" module dtfft_interface_mkl_native_m !! This module creates native interface with MKL library use MKL_DFTI implicit none private public :: DFTI_NO_ERROR , & DFTI_DOUBLE , DFTI_SINGLE , & DFTI_NUMBER_OF_TRANSFORMS , & DFTI_PLACEMENT , & DFTI_INPUT_DISTANCE , & DFTI_OUTPUT_DISTANCE , & DFTI_CONJUGATE_EVEN_STORAGE , & DFTI_COMPLEX_COMPLEX , & DFTI_COMPLEX , & DFTI_REAL , & DFTI_INPLACE , & DFTI_NOT_INPLACE , & DFTI_INPUT_STRIDES , & DFTI_OUTPUT_STRIDES end module dtfft_interface_mkl_native_m","tags":"","loc":"sourcefile/dtfft_interface_mkl_native_m.f90.html"},{"title":"dtfft_plan.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_plan.f90~~EfferentGraph sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_plan.f90~~AfferentGraph sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. #include \"dtfft_config.h\" #include \"dtfft.f03\" !------------------------------------------------------------------------------------------------ module dtfft_plan !! This module describes [[dtfft_plan_t]], [[dtfft_plan_c2c_t]], [[dtfft_plan_r2c_t]] and [[dtfft_plan_r2r_t]] types use iso_c_binding , only : c_loc , c_f_pointer , c_ptr , c_bool , c_null_ptr use iso_fortran_env , only : int8 , int32 , int64 , real32 , real64 , output_unit , error_unit use dtfft_abstract_executor , only : abstract_executor , FFT_1D , FFT_2D , FFT_C2C , FFT_R2C , FFT_R2R #ifdef DTFFT_WITH_FFTW use dtfft_executor_fftw_m , only : fftw_executor #endif #ifdef DTFFT_WITH_MKL use dtfft_executor_mkl_m , only : mkl_executor #endif #ifdef DTFFT_WITH_CUFFT use dtfft_executor_cufft_m , only : cufft_executor #endif #ifdef DTFFT_WITH_VKFFT use dtfft_executor_vkfft_m , only : vkfft_executor #endif use dtfft_config use dtfft_errors use dtfft_pencil , only : pencil , pencil_init , get_local_sizes_private => get_local_sizes , dtfft_pencil_t use dtfft_parameters use dtfft_transpose_plan , only : transpose_plan use dtfft_utils #ifdef DTFFT_WITH_CUDA use dtfft_interface_cuda_runtime #endif #ifdef DTFFT_WITH_NVSHMEM use dtfft_interface_nvshmem , only : is_nvshmem_ptr #endif #include \"_dtfft_cuda.h\" #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" #include \"_dtfft_profile.h\" implicit none private public :: dtfft_plan_t public :: dtfft_plan_c2c_t public :: dtfft_plan_r2c_t public :: dtfft_plan_r2r_t type :: transpose_request !! Handle for async transpose operation type ( dtfft_transpose_t ) :: transpose_type !! Type of transposition requested logical :: is_started = . false . !! Flag that indicates if transpose was started type ( c_ptr ) :: in !! Input pointer type ( c_ptr ) :: out !! Output pointer end type transpose_request type :: fft_executor !! FFT handle class ( abstract_executor ), allocatable :: fft !! Executor end type fft_executor type , abstract :: dtfft_plan_t !! Abstract class for all ``dtFFT`` plans private integer ( int8 ) :: ndims !! Number of global dimensions integer ( int32 ), allocatable :: dims (:) !! Global dimensions integer ( int32 ), allocatable :: grid_dims (:) !! Grid decomposition dimensions type ( dtfft_precision_t ) :: precision !! Precision of transform logical :: is_created = . false . !! Plan creation flag logical :: is_transpose_plan = . false . !! Plan is transpose only logical :: is_aux_alloc = . false . !! Auxiliary buffer is allocated internally logical :: is_z_slab = . false . !! Using Z-slab optimization !! !! Only 3D plan. !! !! When .true., then data is distributed only Z direction and it creates a possibility for optimization: !! !! - 2 dimensional FFT plan is created for both X and Y dimensions !! - Single call to MPI_Alltoall is required to transpose data from X-align to Z-align !! !! For CUDA build this optimization means single CUDA kernel that tranposes data directly from X to Z logical :: is_y_slab = . false . !! Using Y-slab optimization !! !! Only 3D plan. !! !! When .true., then data is distributed only Y direction and it creates a possibility for optimization: !! !! - 2 dimensional FFT plan is created for both Y and Z dimensions !! - Transpose from Y-align to Z-align is skipped type ( dtfft_effort_t ) :: effort !! User defined type of effort integer ( int64 ) :: storage_size !! Single element size in bytes type ( dtfft_executor_t ) :: executor !! FFT executor type TYPE_MPI_COMM :: comm !! Grid communicator TYPE_MPI_COMM , allocatable :: comms (:) !! Local 1d communicators type ( transpose_plan ) :: plan !! Transpose plan handle type ( pencil ), allocatable :: pencils (:) !! Information about data aligment and datatypes type ( dtfft_platform_t ) :: platform !! Execution platform #ifdef DTFFT_WITH_CUDA type ( dtfft_stream_t ) :: stream !! CUDA Stream associated with current plan #endif type ( c_ptr ) :: aux_ptr !! Auxiliary pointer type ( fft_executor ), allocatable :: fft (:) !! Internal fft runners integer ( int32 ), allocatable :: fft_mapping (:) !! Memory and plan creation optimization. !! In case same FFTs needs to be run in different dimensions !! only single FFT plan needs to be created contains private procedure , pass ( self ), non_overridable , public :: transpose !! Performs single transposition procedure , pass ( self ), non_overridable , public :: transpose_ptr !! Performs single transposition using type(c_ptr) pointers instead of buffers procedure , pass ( self ), non_overridable , public :: transpose_start !! Starts an asynchronous transpose operation procedure , pass ( self ), non_overridable , public :: transpose_start_ptr !! Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers procedure , pass ( self ), non_overridable , public :: transpose_end !! Ends previously started transposition procedure , pass ( self ), non_overridable , public :: execute !! Executes plan procedure , pass ( self ), non_overridable , public :: execute_ptr !! Executes plan using type(c_ptr) pointers instead of buffers procedure , pass ( self ), non_overridable , public :: destroy !! Destroys plan procedure , pass ( self ), non_overridable , public :: get_local_sizes !! Returns local starts and counts in `real` and `fourier` spaces procedure , pass ( self ), non_overridable , public :: get_alloc_size !! Wrapper around ``get_local_sizes`` to obtain number of elements only procedure , pass ( self ), non_overridable , public :: get_z_slab_enabled !! Returns logical value is Z-slab optimization is enabled procedure , pass ( self ), non_overridable , public :: get_y_slab_enabled !! Returns logical value is Y-slab optimization is enabled procedure , pass ( self ), non_overridable , public :: get_pencil !! Returns pencil decomposition procedure , pass ( self ), non_overridable , public :: get_element_size !! Returns number of bytes required to store single element. procedure , pass ( self ), non_overridable , public :: get_alloc_bytes !! Returns minimum number of bytes required to execute plan procedure , pass ( self ), non_overridable , public :: get_executor !! Returns FFT Executor associated with plan procedure , pass ( self ), non_overridable , public :: get_dims !! Returns global dimensions procedure , pass ( self ), non_overridable , public :: get_grid_dims !! Returns grid decomposition dimensions procedure , pass ( self ), non_overridable , public :: get_precision !! Returns precision of plan procedure , pass ( self ), non_overridable , public :: report !! Prints plan details procedure , pass ( self ), non_overridable , public :: mem_alloc_ptr !! Allocates memory for type(c_ptr) generic , public :: mem_alloc => & mem_alloc_r32_1d , & mem_alloc_r64_1d , & mem_alloc_r32_2d , & mem_alloc_r64_2d , & mem_alloc_r32_3d , & mem_alloc_r64_3d , & mem_alloc_c32_1d , & mem_alloc_c64_1d , & mem_alloc_c32_2d , & mem_alloc_c64_2d , & mem_alloc_c32_3d , & mem_alloc_c64_3d !! Allocates memory specific for this plan procedure , pass ( self ), non_overridable , public :: mem_free_ptr !! Frees previously allocated memory for type(c_ptr) generic , public :: mem_free => & mem_free_r32_1d , & mem_free_r32_2d , & mem_free_r32_3d , & mem_free_r64_1d , & mem_free_r64_2d , & mem_free_r64_3d , & mem_free_c32_1d , & mem_free_c32_2d , & mem_free_c32_3d , & mem_free_c64_1d , & mem_free_c64_2d , & mem_free_c64_3d !! Frees previously allocated memory specific for this plan procedure , pass ( self ), non_overridable , public :: get_backend !! Returns selected backend during autotuning #ifdef DTFFT_WITH_CUDA procedure , pass ( self ), non_overridable , public :: get_platform !! Returns plan execution platform generic , public :: get_stream & !! Returns CUDA stream associated with plan => get_stream_ptr , & get_stream_int64 procedure , pass ( self ), non_overridable :: get_stream_ptr !! Returns CUDA stream associated with plan procedure , pass ( self ), non_overridable :: get_stream_int64 !! Returns CUDA stream associated with plan #endif procedure , pass ( self ), non_overridable :: execute_private !! Executes plan procedure , pass ( self ), non_overridable :: execute_2d !! Executes 2d plan procedure , pass ( self ), non_overridable :: execute_z_slab !! Executes Z slab plan procedure , pass ( self ), non_overridable :: execute_generic !! Executes plan with specified auxiliary buffer procedure , pass ( self ), non_overridable :: transpose_private !! Performs single transposition using type(c_ptr) pointers instead of buffers procedure , pass ( self ), non_overridable :: check_create_args !! Check arguments provided to `create` subroutines procedure , pass ( self ), non_overridable :: create_private !! Creates core procedure , pass ( self ), non_overridable :: alloc_fft_plans !! Allocates `fft_executor` classes procedure , pass ( self ), non_overridable :: check_aux !! Checks if aux buffer was passed !! and if not will allocate one internally procedure , pass ( self ), non_overridable :: mem_alloc_r32_1d !! Allocates memory for 1d real32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r64_1d !! Allocates memory for 1d real64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r32_2d !! Allocates memory for 2d real32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r64_2d !! Allocates memory for 2d real64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r32_3d !! Allocates memory for 2d real32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_r64_3d !! Allocates memory for 2d real64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c32_1d !! Allocates memory for 1d complex32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c64_1d !! Allocates memory for 1d complex64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c32_2d !! Allocates memory for 2d complex32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c64_2d !! Allocates memory for 2d complex64 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c32_3d !! Allocates memory for 3d complex32 pointer procedure , pass ( self ), non_overridable :: mem_alloc_c64_3d !! Allocates memory for 3d complex64 pointer procedure , pass ( self ), non_overridable :: mem_free_r32_1d !! Frees real32 1d pointer procedure , pass ( self ), non_overridable :: mem_free_r64_1d !! Frees real64 1d pointer procedure , pass ( self ), non_overridable :: mem_free_r32_2d !! Frees real32 2d pointer procedure , pass ( self ), non_overridable :: mem_free_r64_2d !! Frees real64 2d pointer procedure , pass ( self ), non_overridable :: mem_free_r32_3d !! Frees real32 3d pointer procedure , pass ( self ), non_overridable :: mem_free_r64_3d !! Frees real64 3d pointer procedure , pass ( self ), non_overridable :: mem_free_c32_1d !! Frees complex32 1d pointer procedure , pass ( self ), non_overridable :: mem_free_c64_1d !! Frees complex64 1d pointer procedure , pass ( self ), non_overridable :: mem_free_c32_2d !! Frees complex32 2d pointer procedure , pass ( self ), non_overridable :: mem_free_c64_2d !! Frees complex64 2d pointer procedure , pass ( self ), non_overridable :: mem_free_c32_3d !! Frees complex32 3d pointer procedure , pass ( self ), non_overridable :: mem_free_c64_3d !! Frees complex64 3d pointer end type dtfft_plan_t type , abstract , extends ( dtfft_plan_t ) :: dtfft_core_c2c !! Abstract C2C Plan private contains private procedure , pass ( self ), non_overridable :: create_c2c_core !! Creates plan for both C2C and R2C end type dtfft_core_c2c type , extends ( dtfft_core_c2c ) :: dtfft_plan_c2c_t !! C2C Plan private contains private generic , public :: create => create_c2c , & create_c2c_pencil !! Creates C2C plan procedure , pass ( self ) :: create_c2c !! Creates C2C plan using global dimensions procedure , pass ( self ) :: create_c2c_pencil !! Creates C2C plan using Pencil of local data procedure , pass ( self ) :: create_c2c_internal !! Private method that combines common logic for C2C plan creation end type dtfft_plan_c2c_t type , extends ( dtfft_core_c2c ) :: dtfft_plan_r2c_t !! R2C Plan private type ( pencil ) :: real_pencil !! \"Real\" pencil decomposition info contains private generic , public :: create => create_r2c , & create_r2c_pencil !! Creates R2C plan procedure , pass ( self ) :: create_r2c !! Creates R2C plan using global dimensions procedure , pass ( self ) :: create_r2c_pencil !! Creates R2C plan using Pencil of local data procedure , pass ( self ) :: create_r2c_internal !! Private method that combines common logic for R2C plan creation end type dtfft_plan_r2c_t type , extends ( dtfft_plan_t ) :: dtfft_plan_r2r_t !! R2R Plan private contains private generic , public :: create => create_r2r , & create_r2r_pencil !! Creates R2R plan procedure , pass ( self ) :: create_r2r !! Creates R2R plan using global dimensions procedure , pass ( self ) :: create_r2r_pencil !! Creates R2R plan using Pencil of local data procedure , pass ( self ) :: create_r2r_internal !! Private method that combines common logic for R2R plan creation end type dtfft_plan_r2r_t contains subroutine transpose ( self , in , out , transpose_type , error_code ) !! Performs single transposition !! !! @note !! Buffers `in` and `out` cannot be the same !! @endnote class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( * ), target , intent ( inout ) :: in (..) !! Incoming buffer of any rank and kind. Note that this buffer !! will be modified in GPU build type ( * ), target , intent ( inout ) :: out (..) !! Resulting buffer of any rank and kind type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user call self % transpose_ptr ( c_loc ( in ), c_loc ( out ), transpose_type , error_code ) end subroutine transpose subroutine transpose_ptr ( self , in , out , transpose_type , error_code ) !! Performs single transposition using type(c_ptr) pointers instead of buffers !! !! @note !! Buffers `in` and `out` cannot be the same !! @endnote class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Incoming pointer. Note that values of this pointer !! will be modified in GPU build type ( c_ptr ), intent ( in ) :: out !! Resulting pointer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user PHASE_BEGIN ( \"dtfft_transpose\" , COLOR_TRANSPOSE ) call self % transpose_private ( in , out , transpose_type , EXEC_BLOCKING , error_code ) PHASE_END ( \"dtfft_transpose\" ) end subroutine transpose_ptr function transpose_start ( self , in , out , transpose_type , error_code ) result ( request ) !! Starts an asynchronous transpose operation !! !! @note !! Buffers `in` and `out` cannot be the same !! @endnote class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( * ), target , intent ( inout ) :: in (..) !! Incoming buffer of any rank and kind. Note that this buffer !! will be modified in GPU build type ( * ), target , intent ( inout ) :: out (..) !! Resulting buffer of any rank and kind type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user type ( dtfft_request_t ) :: request !! Asynchronous handle describing started transpose operation request = self % transpose_start_ptr ( c_loc ( in ), c_loc ( out ), transpose_type , error_code ) end function transpose_start function transpose_start_ptr ( self , in , out , transpose_type , error_code ) result ( request ) !! Starts an asynchronous transpose operation using type(c_ptr) pointers instead of buffers !! !! @note !! Buffers `in` and `out` cannot be the same !! @endnote class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Incoming pointer. Note that values of this pointer !! will be modified in GPU build type ( c_ptr ), intent ( in ) :: out !! Resulting pointer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user type ( dtfft_request_t ) :: request !! Asynchronous handle describing started transpose operation integer ( int32 ) :: ierr !! Error code type ( transpose_request ), pointer :: internal_handle !! Handle to internal transpose structure PHASE_BEGIN ( \"dtfft_transpose_start\" , COLOR_TRANSPOSE ) request = dtfft_request_t ( c_null_ptr ) call self % transpose_private ( in , out , transpose_type , EXEC_NONBLOCKING , ierr ) if ( ierr == DTFFT_SUCCESS ) then allocate ( internal_handle ) internal_handle % transpose_type = transpose_type internal_handle % is_started = . true . internal_handle % in = in internal_handle % out = out request % val = c_loc ( internal_handle ) endif if ( present ( error_code ) ) error_code = ierr PHASE_END ( \"dtfft_transpose_start\" ) end function transpose_start_ptr subroutine transpose_end ( self , request , error_code ) !! Ends previously started transposition class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( dtfft_request_t ), intent ( inout ) :: request !! Handle obtained from [[dtfft_plan_t(type):transpose_start]] or [[dtfft_plan_t(type):transpose_start_ptr]] integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user type ( transpose_request ), pointer :: internal_handle !! Handle to internal transpose structure integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS #ifdef ENABLE_INPUT_CHECK if ( is_null_ptr ( request % val ) ) ierr = DTFFT_ERROR_INVALID_REQUEST CHECK_ERROR_AND_RETURN #endif call c_f_pointer ( request % val , internal_handle ) #ifdef ENABLE_INPUT_CHECK if ( . not . internal_handle % is_started & . or . . not . is_valid_transpose_type ( internal_handle % transpose_type ) & . or . is_null_ptr ( internal_handle % in ) & . or . is_null_ptr ( internal_handle % out )) ierr = DTFFT_ERROR_INVALID_REQUEST CHECK_ERROR_AND_RETURN #endif PHASE_BEGIN ( \"dtfft_transpose_end\" , COLOR_TRANSPOSE ) call self % plan % execute_end ( internal_handle % in , internal_handle % out , internal_handle % transpose_type , ierr ) PHASE_END ( \"dtfft_transpose_end\" ) #ifdef ENABLE_INPUT_CHECK CHECK_ERROR_AND_RETURN #endif deallocate ( internal_handle ) request = dtfft_request_t ( c_null_ptr ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine transpose_end subroutine transpose_private ( self , in , out , transpose_type , exec_type , error_code ) !! Performs single transposition using type(c_ptr) pointers instead of buffers !! !! @note !! Buffers `in` and `out` cannot be the same !! @endnote class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Incoming pointer. Note that values of this pointer !! will be modified in GPU build type ( c_ptr ), intent ( in ) :: out !! Resulting pointer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. type ( async_exec_t ), intent ( in ) :: exec_type !! Type of asynchronous execution. integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS #ifdef ENABLE_INPUT_CHECK if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( . not . is_valid_transpose_type ( transpose_type ) & . or . ( self % ndims == 2 . and . abs ( transpose_type % val ) > 1 ) & . or . ( abs ( transpose_type % val ) == DTFFT_TRANSPOSE_X_TO_Z % val . and .. not . self % is_z_slab )) & ierr = DTFFT_ERROR_INVALID_TRANSPOSE_TYPE CHECK_ERROR_AND_RETURN if ( is_same_ptr ( in , out ) ) & ierr = DTFFT_ERROR_INPLACE_TRANSPOSE CHECK_ERROR_AND_RETURN select type ( self ) class is ( dtfft_plan_r2c_t ) ierr = DTFFT_ERROR_R2C_TRANSPOSE_CALLED CHECK_ERROR_AND_RETURN endselect # ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_CUDA ) then ierr = check_device_pointers ( in , out , self % plan % get_backend (), c_null_ptr ) CHECK_ERROR_AND_RETURN endif # endif #endif call self % plan % execute ( in , out , transpose_type , exec_type , ierr ) #ifdef ENABLE_INPUT_CHECK CHECK_ERROR_AND_RETURN #endif if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine transpose_private subroutine execute ( self , in , out , execute_type , aux , error_code ) !! Executes plan class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( * ), target , intent ( inout ) :: in (..) !! Incoming buffer of any rank and kind type ( * ), target , intent ( inout ) :: out (..) !! Resulting buffer of any rank and kind type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution. type ( * ), target , optional , intent ( inout ) :: aux (..) !! Optional auxiliary buffer. !! Size of buffer must be greater than value !! returned by `alloc_size` parameter of [[dtfft_plan_t(type):get_local_sizes]] subroutine integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user type ( c_ptr ) :: aux_ptr aux_ptr = c_null_ptr ; if ( present ( aux ) ) aux_ptr = c_loc ( aux ) call self % execute_ptr ( c_loc ( in ), c_loc ( out ), execute_type , aux_ptr , error_code ) end subroutine execute subroutine execute_ptr ( self , in , out , execute_type , aux , error_code ) !! Executes plan using type(c_ptr) pointers instead of buffers class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Incoming pointer. Note that values of this pointer !! will be modified in GPU build type ( c_ptr ), intent ( in ) :: out !! Resulting pointer type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution. type ( c_ptr ), intent ( in ) :: aux !! Auxiliary buffer. Not optional. If not required, c_null_ptr must be passed. !! Size of buffer must be greater than value !! returned by `alloc_size` parameter of [[dtfft_plan_t(type):get_local_sizes]] subroutine integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code logical :: inplace !! Inplace execution flag inplace = is_same_ptr ( in , out ) ierr = DTFFT_SUCCESS #ifdef ENABLE_INPUT_CHECK if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( . not . is_valid_execute_type ( execute_type ) ) ierr = DTFFT_ERROR_INVALID_TRANSPOSE_TYPE CHECK_ERROR_AND_RETURN if ( self % is_transpose_plan . and . ( self % ndims == 2 . or . self % is_y_slab ) . and . inplace ) ierr = DTFFT_ERROR_INPLACE_TRANSPOSE CHECK_ERROR_AND_RETURN if ( is_same_ptr ( in , aux ) . or . is_same_ptr ( out , aux ) ) ierr = DTFFT_ERROR_INVALID_AUX CHECK_ERROR_AND_RETURN if ( self % plan % get_async_active () ) ierr = DTFFT_ERROR_TRANSPOSE_ACTIVE CHECK_ERROR_AND_RETURN # ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_CUDA ) then ierr = check_device_pointers ( in , out , self % plan % get_backend (), aux ) CHECK_ERROR_AND_RETURN endif # endif #endif PHASE_BEGIN ( \"dtfft_execute\" , COLOR_EXECUTE ) call self % check_aux ( aux ) if ( . not . is_null_ptr ( aux ) ) then call self % execute_private ( in , out , execute_type , aux , inplace ) else call self % execute_private ( in , out , execute_type , self % aux_ptr , inplace ) endif PHASE_END ( \"dtfft_execute\" ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine execute_ptr subroutine execute_private ( self , in , out , execute_type , aux , inplace ) !! Executes plan with specified auxiliary buffer class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Source pointer type ( c_ptr ), intent ( in ) :: out !! Target pointer type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution. type ( c_ptr ), intent ( in ) :: aux !! Auxiliary pointer. logical , intent ( in ) :: inplace !! Inplace execution flag if ( self % ndims == 2 . or . self % is_y_slab ) then call self % execute_2d ( in , out , execute_type , aux ) else if ( self % is_z_slab ) then call self % execute_z_slab ( in , out , execute_type , aux , inplace ) else call self % execute_generic ( in , out , execute_type , aux ) endif end subroutine execute_private subroutine execute_2d ( self , in , out , execute_type , aux ) !! Executes plan with specified auxiliary buffer class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Source pointer type ( c_ptr ), intent ( in ) :: out !! Target pointer type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution. type ( c_ptr ), intent ( in ) :: aux !! Auxiliary pointer. if ( self % is_transpose_plan ) then if ( execute_type == DTFFT_EXECUTE_FORWARD ) then call self % plan % execute ( in , out , DTFFT_TRANSPOSE_X_TO_Y , EXEC_BLOCKING ) else call self % plan % execute ( in , out , DTFFT_TRANSPOSE_Y_TO_X , EXEC_BLOCKING ) endif return endif if ( execute_type == DTFFT_EXECUTE_FORWARD ) then ! 1d direct FFT X direction call self % fft ( 1 )% fft % execute ( in , aux , FFT_FORWARD ) ! Transpose X -> Y call self % plan % execute ( aux , out , DTFFT_TRANSPOSE_X_TO_Y , EXEC_BLOCKING ) ! 1d FFT Y direction call self % fft ( self % fft_mapping ( 2 ))% fft % execute ( out , out , FFT_FORWARD ) else ! 1d inverse FFT Y direction call self % fft ( self % fft_mapping ( 2 ))% fft % execute ( in , in , FFT_BACKWARD ) ! Transpose Y -> X call self % plan % execute ( in , aux , DTFFT_TRANSPOSE_Y_TO_X , EXEC_BLOCKING ) ! 1d inverse FFT X direction call self % fft ( 1 )% fft % execute ( aux , out , FFT_BACKWARD ) endif end subroutine execute_2d subroutine execute_z_slab ( self , in , out , execute_type , aux , inplace ) !! Executes plan with specified auxiliary buffer class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Source pointer type ( c_ptr ), intent ( in ) :: out !! Target pointer type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution. type ( c_ptr ), intent ( in ) :: aux !! Auxiliary pointer. logical , intent ( in ) :: inplace !! Inplace execution flag if ( self % is_transpose_plan ) then if ( inplace ) then call self % execute_generic ( in , out , execute_type , aux ) return endif if ( execute_type == DTFFT_EXECUTE_FORWARD ) then call self % plan % execute ( in , out , DTFFT_TRANSPOSE_X_TO_Z , EXEC_BLOCKING ) else call self % plan % execute ( in , out , DTFFT_TRANSPOSE_Z_TO_X , EXEC_BLOCKING ) endif return endif if ( execute_type == DTFFT_EXECUTE_FORWARD ) then ! 2d direct FFT X-Y directions call self % fft ( 1 )% fft % execute ( in , aux , FFT_FORWARD ) ! Transpose X -> Z call self % plan % execute ( aux , out , DTFFT_TRANSPOSE_X_TO_Z , EXEC_BLOCKING ) ! 1d direct FFT Z direction call self % fft ( 3 )% fft % execute ( out , out , FFT_FORWARD ) else ! 1d inverse FFT Z direction call self % fft ( 3 )% fft % execute ( in , in , FFT_BACKWARD ) ! Transpose Z -> X call self % plan % execute ( in , aux , DTFFT_TRANSPOSE_Z_TO_X , EXEC_BLOCKING ) ! 2d inverse FFT X-Y direction call self % fft ( 1 )% fft % execute ( aux , out , FFT_BACKWARD ) endif end subroutine execute_z_slab subroutine execute_generic ( self , in , out , execute_type , aux ) !! Executes plan with specified auxiliary buffer class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: in !! Source pointer type ( c_ptr ), intent ( in ) :: out !! Target pointer type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution. type ( c_ptr ), intent ( in ) :: aux !! Auxiliary pointer. if ( self % is_transpose_plan ) then if ( execute_type == DTFFT_EXECUTE_FORWARD ) then call self % plan % execute ( in , aux , DTFFT_TRANSPOSE_X_TO_Y , EXEC_BLOCKING ) call self % plan % execute ( aux , out , DTFFT_TRANSPOSE_Y_TO_Z , EXEC_BLOCKING ) else call self % plan % execute ( in , aux , DTFFT_TRANSPOSE_Z_TO_Y , EXEC_BLOCKING ) call self % plan % execute ( aux , out , DTFFT_TRANSPOSE_Y_TO_X , EXEC_BLOCKING ) endif return endif if ( execute_type == DTFFT_EXECUTE_FORWARD ) then ! 1d direct FFT X direction call self % fft ( 1 )% fft % execute ( in , aux , FFT_FORWARD ) ! Transpose X -> Y call self % plan % execute ( aux , out , DTFFT_TRANSPOSE_X_TO_Y , EXEC_BLOCKING ) ! 1d FFT Y direction call self % fft ( self % fft_mapping ( 2 ))% fft % execute ( out , out , FFT_FORWARD ) ! Transpose Y -> Z call self % plan % execute ( out , aux , DTFFT_TRANSPOSE_Y_TO_Z , EXEC_BLOCKING ) ! 1d direct FFT Z direction call self % fft ( self % fft_mapping ( 3 ))% fft % execute ( aux , out , FFT_FORWARD ) else ! 1d inverse FFT Z direction call self % fft ( self % fft_mapping ( 3 ))% fft % execute ( in , aux , FFT_BACKWARD ) ! Transpose Z -> Y call self % plan % execute ( aux , in , DTFFT_TRANSPOSE_Z_TO_Y , EXEC_BLOCKING ) ! 1d inverse FFT Y direction call self % fft ( self % fft_mapping ( 2 ))% fft % execute ( in , in , FFT_BACKWARD ) ! Transpose Y -> X call self % plan % execute ( in , aux , DTFFT_TRANSPOSE_Y_TO_X , EXEC_BLOCKING ) ! 1d inverse FFT X direction call self % fft ( 1 )% fft % execute ( aux , out , FFT_BACKWARD ) endif end subroutine execute_generic subroutine destroy ( self , error_code ) !! Destroys plan, frees all memory class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: d !! Counter integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN PHASE_BEGIN ( \"dtfft_destroy\" , COLOR_DESTROY ) if ( allocated ( self % dims ) ) deallocate ( self % dims ) if ( allocated ( self % grid_dims ) ) deallocate ( self % grid_dims ) select type ( self ) class is ( dtfft_plan_r2c_t ) call self % real_pencil % destroy () endselect if ( allocated ( self % pencils ) ) then do d = 1 , self % ndims call self % pencils ( d )% destroy () enddo deallocate ( self % pencils ) endif if ( self % is_aux_alloc ) then call self % mem_free_ptr ( self % aux_ptr ) self % is_aux_alloc = . false . endif if ( allocated ( self % fft ) ) then do d = 1 , self % ndims call self % fft ( d )% fft % destroy () if ( allocated ( self % fft ( d )% fft ) ) deallocate ( self % fft ( d )% fft ) enddo deallocate ( self % fft ) endif self % is_created = . false . self % is_aux_alloc = . false . #ifdef DTFFT_WITH_CUDA call destroy_stream () #endif block logical :: is_finalized ! Following calls may contain calls to MPI ! Must make sure that MPI is still enabled call MPI_Finalized ( is_finalized , ierr ) if ( is_finalized ) ierr = DTFFT_ERROR_MPI_FINALIZED CHECK_ERROR_AND_RETURN end block call self % plan % destroy () if ( allocated ( self % comms ) ) then do d = 1 , self % ndims call MPI_Comm_free ( self % comms ( d ), ierr ) enddo deallocate ( self % comms ) endif call MPI_Comm_free ( self % comm , ierr ) self % ndims = - 1 if ( present ( error_code ) ) error_code = DTFFT_SUCCESS PHASE_END ( \"dtfft_destroy\" ) ! call cali_flush(0) end subroutine destroy logical function get_z_slab_enabled ( self , error_code ) !! Returns logical value is Z-slab optimization enabled internally class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_z_slab_enabled = . false . if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN get_z_slab_enabled = self % is_z_slab if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_z_slab_enabled logical function get_y_slab_enabled ( self , error_code ) !! Returns logical value is Y-slab optimization enabled internally class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_y_slab_enabled = . false . if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN get_y_slab_enabled = self % is_y_slab if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_y_slab_enabled type ( dtfft_pencil_t ) function get_pencil ( self , layout , error_code ) !! Returns pencil decomposition class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), intent ( in ) :: layout !! Required layout: !! !!  - 0 for XYZ layout (real space, R2C only) !!  - 1 for XYZ layout !!  - 2 for YZX layout !!  - 3 for ZXY layout !! !! [//]: # (ListBreak) integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code integer ( int32 ) :: min_layout ierr = DTFFT_SUCCESS ! get_pencil = dtfft_pencil_t(-1,-1,-1,-1) if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN select type ( self ) class is ( dtfft_plan_r2c_t ) min_layout = 0 class default min_layout = 1 endselect if ( layout < min_layout . or . layout > self % ndims ) ierr = DTFFT_ERROR_INVALID_DIM CHECK_ERROR_AND_RETURN if ( layout == 0 ) then select type ( self ) class is ( dtfft_plan_r2c_t ) get_pencil = self % real_pencil % make_public () endselect else get_pencil = self % pencils ( layout )% make_public () endif if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_pencil integer ( int64 ) function get_element_size ( self , error_code ) !! Returns number of bytes required to store single element. class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_element_size = 0 if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN select type ( self ) class is ( dtfft_plan_r2c_t ) get_element_size = self % storage_size / 2 class default get_element_size = self % storage_size endselect if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_element_size integer ( int64 ) function get_alloc_bytes ( self , error_code ) !! Returns minimum number of bytes required to execute plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code integer ( int64 ) :: alloc_size !! Number of elements required integer ( int64 ) :: element_size !! Size of each element ierr = DTFFT_SUCCESS get_alloc_bytes = 0 if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN alloc_size = self % get_alloc_size () element_size = self % get_element_size () get_alloc_bytes = alloc_size * element_size if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_alloc_bytes type ( dtfft_executor_t ) function get_executor ( self , error_code ) !! Returns FFT Executor associated with plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_executor = dtfft_executor_t ( VARIABLE_NOT_SET ) if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN get_executor = self % executor if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_executor subroutine get_dims ( self , dims , error_code ) !! Returns global dimensions class ( dtfft_plan_t ), target , intent ( in ) :: self !! Abstract plan integer ( int32 ), pointer , intent ( out ) :: dims (:) !! Global dimensions integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN dims => self % dims if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine get_dims subroutine get_grid_dims ( self , grid_dims , error_code ) !! Returns grid decomposition dimensions class ( dtfft_plan_t ), target , intent ( in ) :: self !! Abstract plan integer ( int32 ), pointer , intent ( out ) :: grid_dims (:) !! Grid dimensions integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN grid_dims => self % grid_dims if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine get_grid_dims type ( dtfft_precision_t ) function get_precision ( self , error_code ) !! Returns precision of the plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_precision = dtfft_precision_t ( VARIABLE_NOT_SET ) if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN get_precision = self % precision if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function get_precision subroutine report ( self , error_code ) !! Prints plan-related information to stdout class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code integer ( int32 ) :: comm_dims ( self % ndims ) !! Communicator dimensions integer ( int32 ) :: d !! Counter ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN WRITE_REPORT ( \"**Plan report**\" ) WRITE_REPORT ( \"  dtFFT Version        :  \" // to_str ( DTFFT_VERSION_MAJOR ) // \".\" // to_str ( DTFFT_VERSION_MINOR ) // \".\" // to_str ( DTFFT_VERSION_PATCH )) WRITE_REPORT ( \"  Number of dimensions :  \" // to_str ( self % ndims )) do d = 2 , self % ndims call MPI_Comm_size ( self % comms ( d ), comm_dims ( d ), ierr ) enddo if ( self % ndims == 2 ) then WRITE_REPORT ( \"  Global dimensions    :  \" // to_str ( self % dims ( 1 )) // \"x\" // to_str ( self % dims ( 2 ))) WRITE_REPORT ( \"  Grid decomposition   :  1x\" // to_str ( comm_dims ( 2 ))) else WRITE_REPORT ( \"  Global dimensions    :  \" // to_str ( self % dims ( 1 )) // \"x\" // to_str ( self % dims ( 2 )) // \"x\" // to_str ( self % dims ( 3 ))) WRITE_REPORT ( \"  Grid decomposition   :  1x\" // to_str ( comm_dims ( 2 )) // \"x\" // to_str ( comm_dims ( 3 ))) endif #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_HOST ) then WRITE_REPORT ( \"  Execution platform   :  HOST\" ) else WRITE_REPORT ( \"  Execution platform   :  CUDA\" ) endif #endif select type ( self ) class is ( dtfft_plan_c2c_t ) WRITE_REPORT ( \"  Plan type            :  Complex-to-Complex\" ) class is ( dtfft_plan_r2r_t ) WRITE_REPORT ( \"  Plan type            :  Real-to-Real\" ) class is ( dtfft_plan_r2c_t ) WRITE_REPORT ( \"  Plan type            :  Real-to-Complex\" ) endselect WRITE_REPORT ( \"  Plan precision       :  \" // dtfft_get_precision_string ( self % precision )) WRITE_REPORT ( \"  FFT Executor type    :  \" // dtfft_get_executor_string ( self % executor )) if ( self % ndims == 3 ) then if ( self % is_z_slab ) then WRITE_REPORT ( \"  Z-slab enabled       :  True\" ) else WRITE_REPORT ( \"  Z-slab enabled       :  False\" ) endif if ( self % is_y_slab ) then WRITE_REPORT ( \"  Y-slab enabled       :  True\" ) else WRITE_REPORT ( \"  Y-slab enabled       :  False\" ) endif endif WRITE_REPORT ( \"  Backend              :  \" // dtfft_get_backend_string ( self % plan % get_backend ())) WRITE_REPORT ( \"**End of report**\" ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine report type ( dtfft_backend_t ) function get_backend ( self , error_code ) !! Returns selected GPU backend during autotuning class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_backend = BACKEND_NOT_SET if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN get_backend = self % plan % get_backend () if ( present ( error_code ) ) error_code = ierr end function get_backend #ifdef DTFFT_WITH_CUDA type ( dtfft_platform_t ) function get_platform ( self , error_code ) !! Returns execution platform of the plan (HOST or CUDA) class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS get_platform = PLATFORM_NOT_SET if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN get_platform = self % platform if ( present ( error_code ) ) error_code = ierr end function get_platform subroutine get_stream_ptr ( self , stream , error_code ) !! Returns CUDA stream associated with plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan type ( dtfft_stream_t ), intent ( out ) :: stream !! dtFFT Stream integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS stream = NULL_STREAM if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( self % platform == DTFFT_PLATFORM_HOST ) ierr = DTFFT_ERROR_INVALID_USAGE CHECK_ERROR_AND_RETURN stream = self % stream if ( present ( error_code ) ) error_code = ierr end subroutine get_stream_ptr subroutine get_stream_int64 ( self , stream , error_code ) !! Returns CUDA stream associated with plan class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int64 ), intent ( out ) :: stream !! CUDA-Fortran Stream integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code type ( dtfft_stream_t ) :: stream_ !! dtFFT Stream call self % get_stream ( stream_ , error_code = ierr ) if ( ierr == DTFFT_SUCCESS ) stream = dtfft_get_cuda_stream ( stream_ ) if ( present ( error_code ) ) error_code = ierr end subroutine get_stream_int64 integer ( int32 ) function check_device_pointers ( in , out , backend , aux ) result ( error_code ) !! Checks if device pointers are provided by user type ( c_ptr ), intent ( in ) :: in !! First pointer type ( c_ptr ), intent ( in ) :: out !! Second pointer type ( dtfft_backend_t ), intent ( in ) :: backend !! Backend. Required to check for `nvshmem` pointer type ( c_ptr ), intent ( in ) :: aux !! Optional auxiliary pointer. logical ( c_bool ) :: is_devptr !! Are pointers device pointers? error_code = DTFFT_SUCCESS if ( is_backend_nvshmem ( backend ) ) then #ifdef DTFFT_WITH_NVSHMEM is_devptr = is_nvshmem_ptr ( in ) . and . is_nvshmem_ptr ( out ) if ( . not . is_null_ptr ( aux ) ) is_devptr = is_devptr . and . is_nvshmem_ptr ( aux ) if ( . not . is_devptr ) error_code = DTFFT_ERROR_NOT_NVSHMEM_PTR #endif else is_devptr = is_device_ptr ( in ) . and . is_device_ptr ( out ) if ( . not . is_null_ptr ( aux ) ) is_devptr = is_devptr . and . is_device_ptr ( aux ) if ( . not . is_devptr ) error_code = DTFFT_ERROR_NOT_DEVICE_PTR endif end function check_device_pointers #endif subroutine get_local_sizes ( self , in_starts , in_counts , out_starts , out_counts , alloc_size , error_code ) !! Obtain local starts and counts in ``real`` and ``fourier`` spaces class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: in_starts (:) !! Starts of local portion of data in ``real`` space (0-based) integer ( int32 ), optional , intent ( out ) :: in_counts (:) !! Number of elements of local portion of data in 'real' space integer ( int32 ), optional , intent ( out ) :: out_starts (:) !! Starts of local portion of data in ``fourier`` space (0-based) integer ( int32 ), optional , intent ( out ) :: out_counts (:) !! Number of elements of local portion of data in ``fourier`` space integer ( int64 ), optional , intent ( out ) :: alloc_size !! Minimal number of elements required to execute plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( . not . present ( in_starts ) & . and .. not . present ( in_counts ) & . and .. not . present ( out_starts ) & . and .. not . present ( out_counts ) & . and .. not . present ( alloc_size )) ierr = DTFFT_ERROR_INVALID_USAGE CHECK_ERROR_AND_RETURN select type ( self ) class is ( dtfft_plan_r2c_t ) if ( present ( in_starts ) ) in_starts ( 1 : self % ndims ) = self % real_pencil % starts ( 1 : self % ndims ) if ( present ( in_counts ) ) in_counts ( 1 : self % ndims ) = self % real_pencil % counts ( 1 : self % ndims ) call get_local_sizes_private ( self % pencils , out_starts = out_starts , out_counts = out_counts , alloc_size = alloc_size , is_y_slab = self % is_y_slab ) if ( present ( alloc_size ) ) alloc_size = max ( int ( product ( self % real_pencil % counts ), int64 ), 2 * alloc_size ) class default call get_local_sizes_private ( self % pencils , in_starts , in_counts , out_starts , out_counts , alloc_size , is_y_slab = self % is_y_slab ) endselect #ifdef DTFFT_WITH_CUDA if ( is_backend_nvshmem ( self % plan % get_backend () ) . and . present ( alloc_size ) ) then block integer ( int64 ) :: aux_size ! cufftMp pipelined may require aux buffer that is larger than ! required by dtfft. in such case we must make sure that ! buffer allocated by user is large enough aux_size = self % plan % get_aux_size () alloc_size = max ( alloc_size , aux_size / self % storage_size ) ALL_REDUCE ( alloc_size , MPI_INTEGER8 , MPI_MAX , self % comm , ierr ) endblock endif #endif if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine get_local_sizes function get_alloc_size ( self , error_code ) result ( alloc_size ) !! Wrapper around ``get_local_sizes`` to obtain number of elements only class ( dtfft_plan_t ), intent ( in ) :: self !! Abstract plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int64 ) :: alloc_size !! Minimal number of elements required to execute plan call self % get_local_sizes ( alloc_size = alloc_size , error_code = error_code ) end function get_alloc_size integer ( int32 ) function create_private ( self , sngl_type , sngl_storage_size , dbl_type , dbl_storage_size , dims , pencil , comm , precision , effort , executor , kinds ) #define __FUNC__ create_private !! Creates core class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan TYPE_MPI_DATATYPE , intent ( in ) :: sngl_type !! MPI_Datatype for single precision plan integer ( int64 ), intent ( in ) :: sngl_storage_size !! Number of bytes needed to store single element (single precision) TYPE_MPI_DATATYPE , intent ( in ) :: dbl_type !! MPI_Datatype for double precision plan integer ( int64 ), intent ( in ) :: dbl_storage_size !! Number of bytes needed to store single element (double precision) integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of local portion of data TYPE_MPI_COMM , optional , intent ( in ) :: comm !! User-defined communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Precision of transform: `DTFFT_SINGLE` or `DTFFT_DOUBLE` type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform TYPE_MPI_DATATYPE :: base_dtype !! MPI_Datatype for current precision integer ( int64 ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_COMM :: comm_ !! MPI Communicator integer ( int8 ) :: d !! Counter integer ( int32 ) :: ierr create_private = DTFFT_SUCCESS CHECK_INTERNAL_CALL ( self % check_create_args ( dims , pencil , comm , precision , effort , executor , kinds ) ) select case ( self % precision % val ) case ( DTFFT_SINGLE % val ) base_storage = sngl_storage_size base_dtype = sngl_type case ( DTFFT_DOUBLE % val ) base_storage = dbl_storage_size base_dtype = dbl_type case default INTERNAL_ERROR ( \"unknown precision\" ) endselect self % storage_size = base_storage if ( allocated ( self % pencils ) ) then do d = 1 , size ( self % pencils , kind = int8 ) call self % pencils ( d )% destroy () enddo deallocate ( self % pencils ) endif if ( allocated ( self % comms ) ) then ! Can potentially leak some memory deallocate ( self % comms ) endif call self % plan % destroy () allocate ( self % pencils ( self % ndims )) allocate ( self % comms ( self % ndims )) comm_ = MPI_COMM_WORLD ; if ( present ( comm ) ) comm_ = comm #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_CUDA ) then block TYPE_MPI_COMM :: local_comm integer ( int32 ) :: n_devices , current_device , local_rank , local_size integer ( int32 ), allocatable :: local_devices (:) call MPI_Comm_split_Type ( comm_ , MPI_COMM_TYPE_SHARED , 0 , MPI_INFO_NULL , local_comm , ierr ) call MPI_Comm_size ( local_comm , local_size , ierr ) call MPI_Comm_rank ( local_comm , local_rank , ierr ) allocate ( local_devices ( local_size ) ) CUDA_CALL ( cudaGetDeviceCount ( n_devices ) ) CUDA_CALL ( cudaGetDevice ( current_device ) ) call MPI_Allgather ( current_device , 1 , MPI_INTEGER4 , local_devices , 1 , MPI_INTEGER4 , local_comm , ierr ) call MPI_Comm_free ( local_comm , ierr ) if ( count_unique ( local_devices ) /= local_size ) then create_private = DTFFT_ERROR_GPU_NOT_SET return endif deallocate ( local_devices ) self % stream = get_conf_stream () endblock endif #endif if ( present ( pencil ) ) then block integer ( int32 ), allocatable :: fixed_dims (:) type ( pencil_init ) :: ipencil CHECK_INTERNAL_CALL ( ipencil % create ( pencil , comm_ ) ) ! After creating internal pencil and validating user passed pencil ! We finally know global dimensions `dims` allocate ( self % dims , source = ipencil % dims ) allocate ( fixed_dims , source = self % dims ) select type ( self ) class is ( dtfft_plan_r2c_t ) fixed_dims ( 1 ) = fixed_dims ( 1 ) / 2 + 1 ipencil % counts ( 1 ) = ipencil % counts ( 1 ) / 2 + 1 endselect CHECK_INTERNAL_CALL ( self % plan % create ( self % platform , fixed_dims , comm_ , self % effort , base_dtype , base_storage , self % comm , self % comms , self % pencils , ipencil ) ) select type ( self ) class is ( dtfft_plan_r2c_t ) ipencil % counts ( 1 ) = ( ipencil % counts ( 1 ) - 1 ) * 2 call self % real_pencil % create ( self % ndims , 1_int8 , self % dims , self % comms , ipencil % starts , ipencil % counts ) endselect deallocate ( fixed_dims ) call ipencil % destroy () endblock else CHECK_INTERNAL_CALL ( self % plan % create ( self % platform , dims , comm_ , self % effort , base_dtype , base_storage , self % comm , self % comms , self % pencils ) ) endif self % is_z_slab = self % plan % get_z_slab () if ( allocated ( self % grid_dims ) ) deallocate ( self % grid_dims ) allocate ( self % grid_dims ( self % ndims ) ) do d = 1 , self % ndims call MPI_Comm_size ( self % comms ( d ), self % grid_dims ( d ), ierr ) enddo self % is_y_slab = . false . if ( self % ndims == 3 . and . . not . self % is_z_slab . and . self % grid_dims ( self % ndims ) == 1 . and . get_conf_y_slab_enabled () ) then self % is_y_slab = . true . endif call self % alloc_fft_plans ( kinds ) self % is_aux_alloc = . false . #undef __FUNC__ end function create_private integer ( int32 ) function check_create_args ( self , dims , pencil , comm , precision , effort , executor , kinds ) #define __FUNC__ check_create_args !! Check arguments provided by user and sets private variables class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of local portion of data TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Optional MPI Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Precision of transform: `DTFFT_SINGLE` or `DTFFT_DOUBLE` type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform integer ( int32 ) :: ierr !! Error code integer ( int32 ) :: top_type !! MPI Comm topology type integer ( int32 ) :: dim !! Counter check_create_args = DTFFT_SUCCESS CHECK_INTERNAL_CALL ( init_internal () ) self % platform = get_conf_platform () #ifdef DTFFT_DEBUG if ( . not . present ( dims ) . and . . not . present ( pencil ) ) INTERNAL_ERROR ( \".not.present(dims) .and. .not.present(pencil)\" ) if ( present ( dims ) . and . present ( pencil ) ) INTERNAL_ERROR ( \"present(dims) .and. present(pencil)\" ) #endif if ( allocated ( self % dims ) ) deallocate ( self % dims ) if ( present ( dims ) ) then self % ndims = size ( dims , kind = int8 ) CHECK_INPUT_PARAMETER ( self % ndims , is_valid_dimension , DTFFT_ERROR_INVALID_N_DIMENSIONS ) if ( any ( dims <= 0 ) ) then check_create_args = DTFFT_ERROR_INVALID_DIMENSION_SIZE return endif allocate ( self % dims , source = dims ) else self % ndims = pencil % ndims if ( self % ndims == 0 ) then check_create_args = DTFFT_ERROR_PENCIL_NOT_INITIALIZED return endif endif if ( present ( comm ) ) then call MPI_Topo_test ( comm , top_type , ierr ) CHECK_INPUT_PARAMETER ( top_type , is_valid_comm_type , DTFFT_ERROR_INVALID_COMM_TYPE ) endif self % precision = DTFFT_DOUBLE if ( present ( precision ) ) then CHECK_INPUT_PARAMETER ( precision , is_valid_precision , DTFFT_ERROR_INVALID_PRECISION ) self % precision = precision endif self % effort = DTFFT_ESTIMATE if ( present ( effort ) ) then CHECK_INPUT_PARAMETER ( effort , is_valid_effort , DTFFT_ERROR_INVALID_EFFORT ) self % effort = effort endif self % is_transpose_plan = . false . self % executor = DTFFT_EXECUTOR_NONE if ( present ( executor ) ) then CHECK_INPUT_PARAMETER ( executor , is_valid_executor , DTFFT_ERROR_INVALID_EXECUTOR ) #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_HOST ) then CHECK_INPUT_PARAMETER ( executor , is_host_executor , DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR ) else if ( self % platform == DTFFT_PLATFORM_CUDA ) then CHECK_INPUT_PARAMETER ( executor , is_cuda_executor , DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR ) endif #endif self % executor = executor endif if ( self % executor == DTFFT_EXECUTOR_NONE ) self % is_transpose_plan = . true . #ifdef DTFFT_WITH_CUDA ! Platform is used to check correctness of both executor and backend ! DTFFT_PATIENT ignores backend set by user: if ( self % effort % val < DTFFT_PATIENT % val ) then block type ( dtfft_backend_t ) :: backend backend = get_conf_backend () if ( self % platform == DTFFT_PLATFORM_HOST ) then if ( is_backend_nccl ( backend ) . or . is_backend_nvshmem ( backend ) ) then __ FUNC__ = DTFFT_ERROR_INVALID_PLATFORM_BACKEND return endif endif endblock endif #endif if ( present ( kinds ) . and . . not . self % is_transpose_plan ) then do dim = 1 , self % ndims CHECK_INPUT_PARAMETER ( kinds ( dim ), is_valid_r2r_kind , DTFFT_ERROR_INVALID_R2R_KINDS ) enddo endif #undef __FUNC__ end function check_create_args subroutine alloc_fft_plans ( self , kinds ) !! Allocates [[abstract_executor]] with required FFT class !! and populates [[dtfft_plan_t(type):fft_mapping]] with similar FFT ids class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform integer ( int8 ) :: dim , dim2 !! Counters type ( dtfft_r2r_kind_t ), allocatable :: kinds_ (:) !! Dummy kinds if ( self % is_transpose_plan ) return allocate ( self % fft ( self % ndims )) allocate ( self % fft_mapping ( self % ndims )) do dim = 1 , self % ndims self % fft_mapping ( dim ) = dim select case ( self % executor % val ) #ifdef DTFFT_WITH_FFTW case ( DTFFT_EXECUTOR_FFTW3 % val ) allocate ( fftw_executor :: self % fft ( dim )% fft ) #endif #ifdef DTFFT_WITH_MKL case ( DTFFT_EXECUTOR_MKL % val ) allocate ( mkl_executor :: self % fft ( dim )% fft ) #endif #ifdef DTFFT_WITH_CUFFT case ( DTFFT_EXECUTOR_CUFFT % val ) allocate ( cufft_executor :: self % fft ( dim )% fft ) #endif #ifdef DTFFT_WITH_VKFFT case ( DTFFT_EXECUTOR_VKFFT % val ) allocate ( vkfft_executor :: self % fft ( dim )% fft ) #endif case default INTERNAL_ERROR ( \"Executor type unrecognized\" ) endselect enddo if ( self % is_z_slab . or . self % is_y_slab ) return allocate ( kinds_ ( self % ndims )) kinds_ (:) = dtfft_r2r_kind_t ( - 1 ); if ( present ( kinds ) ) kinds_ (:) = kinds (:) ! Searching for similar FFT transforms in order to reduce time of plan creation ! and reduce memory usage ! Most profitable in GPU build do dim = 1_int8 , self % ndims do dim2 = 1_int8 , dim - 1_int8 if ( dim == dim2 ) cycle select type ( self ) class is ( dtfft_plan_r2c_t ) if ( dim == 1 ) cycle endselect if ( self % pencils ( dim )% counts ( 1 ) == self % pencils ( dim2 )% counts ( 1 ) & . and . product ( self % pencils ( dim )% counts ) == product ( self % pencils ( dim2 )% counts ) & . and . kinds_ ( dim ) == kinds_ ( dim2 ) ) then self % fft_mapping ( dim ) = dim2 endif enddo enddo deallocate ( kinds_ ) end subroutine alloc_fft_plans subroutine check_aux ( self , aux ) !! Checks if aux buffer was passed by user and if not will allocate one internally class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: aux !! Optional auxiliary buffer. integer ( int64 ) :: alloc_size !! Number of elements to be allocated integer ( int32 ) :: ierr if ( self % is_aux_alloc . or . . not . is_null_ptr ( aux ) ) return alloc_size = self % get_alloc_size () * self % get_element_size () WRITE_DEBUG ( \"Allocating auxiliary buffer of \" // to_str ( alloc_size ) // \" bytes\" ) self % aux_ptr = self % mem_alloc_ptr ( alloc_size , ierr ); DTFFT_CHECK ( ierr ) self % is_aux_alloc = . true . end subroutine check_aux subroutine create_r2r ( self , dims , kinds , comm , precision , effort , executor , error_code ) !! R2R Plan Constructor class ( dtfft_plan_r2r_t ), intent ( inout ) :: self !! R2R Plan integer ( int32 ), intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_r2r_internal ( dims = dims , kinds = kinds , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_r2r subroutine create_r2r_pencil ( self , pencil , kinds , comm , precision , effort , executor , error_code ) !! R2R Plan Constructor class ( dtfft_plan_r2r_t ), intent ( inout ) :: self !! R2R Plan type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Local pencil of data to be transformed type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_r2r_internal ( pencil = pencil , kinds = kinds , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_r2r_pencil integer ( int32 ) function create_r2r_internal ( self , dims , pencil , kinds , comm , precision , effort , executor ) !! Creates plan for R2R plans #define __FUNC__ create_r2r_internal class ( dtfft_plan_r2r_t ), intent ( inout ) :: self !! R2R Plan integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of data to be transformed type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: kinds (:) !! Kinds of R2R transform TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int8 ) :: fft_rank !! Rank of FFT transform integer ( int32 ) :: dim !! Counter type ( dtfft_r2r_kind_t ) :: r2r_kinds ( 2 ) !! Transposed Kinds of R2R transform create_r2r_internal = DTFFT_SUCCESS if ( self % is_created ) then create_r2r_internal = DTFFT_ERROR_PLAN_IS_CREATED return endif PHASE_BEGIN ( \"dtfft_create_r2r\" , COLOR_CREATE ) CHECK_INTERNAL_CALL ( self % create_private ( MPI_REAL , FLOAT_STORAGE_SIZE , MPI_REAL8 , DOUBLE_STORAGE_SIZE , dims = dims , pencil = pencil , comm = comm , precision = precision , effort = effort , executor = executor , kinds = kinds ) ) if ( . not . self % is_transpose_plan ) then if ( . not . present ( kinds ) ) then create_r2r_internal = DTFFT_ERROR_MISSING_R2R_KINDS return endif do dim = 1 , self % ndims r2r_kinds ( 1 ) = kinds ( dim ) fft_rank = FFT_1D if ( self % is_z_slab . and . dim == 1 ) then r2r_kinds ( 1 ) = kinds ( 2 ) r2r_kinds ( 2 ) = kinds ( 1 ) fft_rank = FFT_2D else if ( self % is_y_slab . and . dim == 2 ) then r2r_kinds ( 1 ) = kinds ( 3 ) r2r_kinds ( 2 ) = kinds ( 2 ) fft_rank = FFT_2D endif if ( self % is_z_slab . and . dim == 2 ) cycle if ( self % is_y_slab . and . dim == 3 ) cycle CHECK_INTERNAL_CALL ( self % fft ( self % fft_mapping ( dim ))% fft % create ( fft_rank , FFT_R2R , self % precision , real_pencil = self % pencils ( dim ), r2r_kinds = r2r_kinds ) ) enddo endif self % is_created = . true . PHASE_END ( \"dtfft_create_r2r\" ) #undef __FUNC__ end function create_r2r_internal subroutine create_c2c ( self , dims , comm , precision , effort , executor , error_code ) !! C2C Plan Constructor class ( dtfft_plan_c2c_t ), intent ( inout ) :: self !! C2C Plan integer ( int32 ), intent ( in ) :: dims (:) !! Global dimensions of transform TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_c2c_internal ( dims = dims , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_c2c subroutine create_c2c_pencil ( self , pencil , comm , precision , effort , executor , error_code ) !! C2C Plan Constructor class ( dtfft_plan_c2c_t ), intent ( inout ) :: self !! C2C Plan type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Local pencil of data to be transformed TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_c2c_internal ( pencil = pencil , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_c2c_pencil integer ( int32 ) function create_c2c_internal ( self , dims , pencil , comm , precision , effort , executor ) !! Private method that combines common logic for C2C plan creation #define __FUNC__ create_c2c_internal class ( dtfft_plan_c2c_t ), intent ( inout ) :: self !! C2C Plan integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of data to be transformed TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor create_c2c_internal = DTFFT_SUCCESS if ( self % is_created ) then create_c2c_internal = DTFFT_ERROR_PLAN_IS_CREATED return endif PHASE_BEGIN ( \"dtfft_create_c2c\" , COLOR_CREATE ) CHECK_INTERNAL_CALL ( self % create_c2c_core ( dims , pencil , comm , precision , effort , executor ) ) self % is_created = . true . PHASE_END ( \"dtfft_create_c2c\" ) #undef __FUNC__ end function create_c2c_internal integer ( int32 ) function create_c2c_core ( self , dims , pencil , comm , precision , effort , executor ) !! Creates plan for both C2C and R2C #define __FUNC__ create_c2c_core class ( dtfft_core_c2c ), intent ( inout ) :: self !! C2C Plan integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Pencil of data to be transformed TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan type ( dtfft_executor_t ), optional , intent ( in ) :: executor !! Type of External FFT Executor integer ( int8 ) :: dim !! Counter integer ( int8 ) :: fft_start !! 1 for c2c, 2 for r2c integer ( int8 ) :: fft_rank !! Rank of FFT transform CHECK_INTERNAL_CALL ( self % create_private ( MPI_COMPLEX , COMPLEX_STORAGE_SIZE , MPI_DOUBLE_COMPLEX , DOUBLE_COMPLEX_STORAGE_SIZE , dims = dims , pencil = pencil , comm = comm , precision = precision , effort = effort , executor = executor ) ) if ( self % is_transpose_plan ) return fft_start = 1 select type ( self ) class is ( dtfft_plan_r2c_t ) fft_start = 2 endselect do dim = fft_start , self % ndims fft_rank = FFT_1D if ( ( self % is_z_slab . and . dim == 1 ) . or . ( self % is_y_slab . and . dim == 2 ) ) fft_rank = FFT_2D if ( ( self % is_z_slab . and . dim == 2 ) . or . ( self % is_y_slab . and . dim == 3 ) ) cycle CHECK_INTERNAL_CALL ( self % fft ( self % fft_mapping ( dim ))% fft % create ( fft_rank , FFT_C2C , self % precision , complex_pencil = self % pencils ( dim )) ) enddo #undef __FUNC__ end function create_c2c_core subroutine create_r2c ( self , dims , executor , comm , precision , effort , error_code ) !! R2C Generic Plan Constructor class ( dtfft_plan_r2c_t ), intent ( inout ) :: self !! C2C Plan integer ( int32 ), intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_r2c_internal ( executor , dims = dims , comm = comm , precision = precision , effort = effort ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_r2c subroutine create_r2c_pencil ( self , pencil , executor , comm , precision , effort , error_code ) !! R2C Plan Constructor with pencil class ( dtfft_plan_r2c_t ), intent ( inout ) :: self !! R2C Plan type ( dtfft_pencil_t ), intent ( in ) :: pencil !! Local pencil of data to be transformed type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan integer ( int32 ), optional , intent ( out ) :: error_code !! Optional Error Code returned to user integer ( int32 ) :: ierr !! Error code CHECK_OPTIONAL_CALL ( self % create_r2c_internal ( executor , pencil = pencil , comm = comm , precision = precision , effort = effort ) ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine create_r2c_pencil integer ( int32 ) function create_r2c_internal ( self , executor , dims , pencil , comm , precision , effort ) !! Private method that combines common logic for R2C plan creation #define __FUNC__ create_r2c_internal class ( dtfft_plan_r2c_t ), intent ( inout ) :: self !! R2C Plan type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor integer ( int32 ), optional , intent ( in ) :: dims (:) !! Global dimensions of transform type ( dtfft_pencil_t ), optional , intent ( in ) :: pencil !! Local pencil of data to be transformed TYPE_MPI_COMM , optional , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), optional , intent ( in ) :: precision !! Presicion of Transform type ( dtfft_effort_t ), optional , intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan integer ( int32 ), allocatable :: fixed_dims (:) !! Fixed dimensions for R2C integer ( int8 ) :: fft_rank !! Rank of FFT transform create_r2c_internal = DTFFT_SUCCESS if ( self % is_created ) then create_r2c_internal = DTFFT_ERROR_PLAN_IS_CREATED return endif PHASE_BEGIN ( \"dtfft_create_r2c\" , COLOR_CREATE ) if ( present ( dims ) ) then allocate ( fixed_dims , source = dims ) fixed_dims ( 1 ) = int ( dims ( 1 ) / 2 , int32 ) + 1 CHECK_INTERNAL_CALL ( self % create_c2c_core ( dims = fixed_dims , comm = comm , precision = precision , effort = effort , executor = executor ) ) deallocate ( fixed_dims ) call self % real_pencil % create ( self % ndims , 1_int8 , dims , self % comms ) else ! Do not know global dimensions ! They are computed when private pencil is created CHECK_INTERNAL_CALL ( self % create_c2c_core ( pencil = pencil , comm = comm , precision = precision , effort = effort , executor = executor ) ) endif if ( self % is_transpose_plan ) then create_r2c_internal = DTFFT_ERROR_R2C_TRANSPOSE_PLAN return endif fft_rank = FFT_1D ; if ( self % is_z_slab ) fft_rank = FFT_2D CHECK_INTERNAL_CALL ( self % fft ( 1 )% fft % create ( fft_rank , FFT_R2C , self % precision , real_pencil = self % real_pencil , complex_pencil = self % pencils ( 1 )) ) PHASE_END ( \"dtfft_create_r2c\" ) self % is_created = . true . #undef __FUNC__ end function create_r2c_internal function mem_alloc_ptr ( self , alloc_bytes , error_code ) result ( ptr ) !! Allocates memory specific for this plan class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ) :: ptr !! Allocated pointer integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS ptr = c_null_ptr if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( alloc_bytes < FLOAT_STORAGE_SIZE ) ierr = DTFFT_ERROR_INVALID_ALLOC_BYTES CHECK_ERROR_AND_RETURN if ( self % platform == DTFFT_PLATFORM_HOST ) then if ( self % is_transpose_plan ) then ptr = mem_alloc_host ( alloc_bytes ) else call self % fft ( 1 )% fft % mem_alloc ( alloc_bytes , ptr ) endif if ( is_null_ptr ( ptr ) ) ierr = DTFFT_ERROR_ALLOC_FAILED #ifdef DTFFT_WITH_CUDA else call self % plan % mem_alloc ( self % comm , alloc_bytes , ptr , ierr ) #endif endif CHECK_ERROR_AND_RETURN if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end function mem_alloc_ptr subroutine mem_free_ptr ( self , ptr , error_code ) !! Frees previously allocated memory specific for this plan class ( dtfft_plan_t ), intent ( inout ) :: self !! Abstract plan type ( c_ptr ), intent ( in ) :: ptr !! Pointer allocated with [[dtfft_plan_t(type):mem_alloc]] integer ( int32 ), optional , intent ( out ) :: error_code !! Optional error code returned to user integer ( int32 ) :: ierr !! Error code ierr = DTFFT_SUCCESS if ( . not . self % is_created ) ierr = DTFFT_ERROR_PLAN_NOT_CREATED CHECK_ERROR_AND_RETURN if ( self % platform == DTFFT_PLATFORM_HOST ) then if ( self % is_transpose_plan ) then call mem_free_host ( ptr ) else call self % fft ( 1 )% fft % mem_free ( ptr ) endif #ifdef DTFFT_WITH_CUDA else call self % plan % mem_free ( ptr , ierr ) #endif endif CHECK_ERROR_AND_RETURN if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine mem_free_ptr #define STORAGE_BYTES FLOAT_STORAGE_SIZE #define BUFFER_TYPE real(real32) #define ALLOC_1D mem_alloc_r32_1d #define ALLOC_2D mem_alloc_r32_2d #define ALLOC_3D mem_alloc_r32_3d #define FREE_1D mem_free_r32_1d #define FREE_2D mem_free_r32_2d #define FREE_3D mem_free_r32_3d #include \"_dtfft_mem_alloc_free.inc\" #define STORAGE_BYTES DOUBLE_STORAGE_SIZE #define BUFFER_TYPE real(real64) #define ALLOC_1D mem_alloc_r64_1d #define ALLOC_2D mem_alloc_r64_2d #define ALLOC_3D mem_alloc_r64_3d #define FREE_1D mem_free_r64_1d #define FREE_2D mem_free_r64_2d #define FREE_3D mem_free_r64_3d #include \"_dtfft_mem_alloc_free.inc\" #define STORAGE_BYTES COMPLEX_STORAGE_SIZE #define BUFFER_TYPE complex(real32) #define ALLOC_1D mem_alloc_c32_1d #define ALLOC_2D mem_alloc_c32_2d #define ALLOC_3D mem_alloc_c32_3d #define FREE_1D mem_free_c32_1d #define FREE_2D mem_free_c32_2d #define FREE_3D mem_free_c32_3d #include \"_dtfft_mem_alloc_free.inc\" #define STORAGE_BYTES DOUBLE_COMPLEX_STORAGE_SIZE #define BUFFER_TYPE complex(real64) #define ALLOC_1D mem_alloc_c64_1d #define ALLOC_2D mem_alloc_c64_2d #define ALLOC_3D mem_alloc_c64_3d #define FREE_1D mem_free_c64_1d #define FREE_2D mem_free_c64_2d #define FREE_3D mem_free_c64_3d #include \"_dtfft_mem_alloc_free.inc\" end module dtfft_plan","tags":"","loc":"sourcefile/dtfft_plan.f90.html"},{"title":"dtfft_interface_vkfft_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_vkfft_m.f90~~EfferentGraph sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_vkfft_m.f90~~AfferentGraph sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_vkfft_m !! This module creates interface with VkFFT library !! !! VkFFT is loaded at runtime via dynamic loading. use iso_c_binding use iso_fortran_env use dtfft_errors use dtfft_parameters use dtfft_utils implicit none private #include \"_dtfft_private.h\" public :: load_vkfft abstract interface subroutine vkfft_create_interface ( rank , dims , double_precision , how_many , r2c , c2r , dct , dst , stream , app_handle ) bind ( C ) !! Creates FFT plan via vkFFT Interface import integer ( c_int8_t ), value :: rank !! Rank of fft: 1 or 2 integer ( c_int ) :: dims ( * ) !! Dimensions of transform integer ( c_int ), value :: double_precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( c_int ), value :: how_many !! Number of transforms to create integer ( c_int8_t ), value :: r2c !! Is R2C transform required integer ( c_int8_t ), value :: c2r !! Is C2R transform required integer ( c_int8_t ), value :: dct !! Is DCT transform required integer ( c_int8_t ), value :: dst !! Is DST transform required type ( dtfft_stream_t ), value :: stream !! CUDA stream type ( c_ptr ) :: app_handle !! vkFFT application handle end subroutine vkfft_create_interface subroutine vkfft_execute_interface ( app_handle , in , out , sign ) bind ( C ) !! Executes vkFFT plan import type ( c_ptr ), value :: app_handle !! vkFFT application handle type ( c_ptr ), value :: in !! Input data type ( c_ptr ), value :: out !! Output data integer ( c_int8_t ), value :: sign !! Sign of FFT end subroutine vkfft_execute_interface subroutine vkfft_destroy_interface ( app_handle ) bind ( C ) !! Destroys vkFFT plan import type ( c_ptr ), value :: app_handle !! vkFFT application handle end subroutine vkfft_destroy_interface end interface public :: vkfft_wrapper type :: vkfft_wrapper !! VkFFT Wrapper private logical :: is_loaded = . false . !! Is VkFFT library loaded type ( c_ptr ) :: lib_handle !! Handle to the loaded library type ( c_funptr ) :: vkfft_functions ( 3 ) !! Array of VkFFT functions procedure ( vkfft_create_interface ), pointer , public , nopass :: create !! Fortran Pointer to vkFFT create function procedure ( vkfft_execute_interface ), pointer , public , nopass :: execute !! Fortran Pointer to vkFFT execute function procedure ( vkfft_destroy_interface ), pointer , public , nopass :: destroy !! Fortran Pointer to vkFFT destroy function end type vkfft_wrapper type ( vkfft_wrapper ), public , save , target :: cuda_wrapper !! VkFFT Wrapper for CUDA platform contains integer ( int32 ) function load_vkfft ( platform ) !! Loads VkFFT library based on the platform type ( dtfft_platform_t ), intent ( in ) :: platform !! Platform to load VkFFT library for if ( platform == DTFFT_PLATFORM_CUDA ) then load_vkfft = load ( cuda_wrapper , \"cuda\" ) endif end function load_vkfft function load ( wrapper , suffix ) result ( error_code ) !! Loads VkFFT library class ( vkfft_wrapper ), intent ( inout ) :: wrapper !! VkFFT Wrapper character ( len =* ), intent ( in ) :: suffix !! Suffix for the library name type ( string ), allocatable :: func_names (:) !! Names of functions to load from VkFFT module integer ( int32 ) :: error_code !! Error code error_code = DTFFT_SUCCESS if ( wrapper % is_loaded ) return allocate ( func_names ( 3 )) func_names ( 1 ) = string ( \"vkfft_create\" ) func_names ( 2 ) = string ( \"vkfft_execute\" ) func_names ( 3 ) = string ( \"vkfft_destroy\" ) error_code = dynamic_load ( \"libdtfft_vkfft_\" // suffix // \".so\" , func_names , wrapper % lib_handle , wrapper % vkfft_functions ) call destroy_strings ( func_names ) if ( error_code /= DTFFT_SUCCESS ) return call c_f_procpointer ( wrapper % vkfft_functions ( 1 ), wrapper % create ) call c_f_procpointer ( wrapper % vkfft_functions ( 2 ), wrapper % execute ) call c_f_procpointer ( wrapper % vkfft_functions ( 3 ), wrapper % destroy ) wrapper % is_loaded = . true . end function load end module dtfft_interface_vkfft_m","tags":"","loc":"sourcefile/dtfft_interface_vkfft_m.f90.html"},{"title":"dtfft_transpose_plan.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_transpose_plan.f90~~EfferentGraph sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_transpose_plan.f90~~AfferentGraph sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" #include \"dtfft.f03\" module dtfft_transpose_plan !! This module describes [[transpose_plan]] class use iso_fortran_env use iso_c_binding use dtfft_abstract_backend , only : backend_helper use dtfft_abstract_transpose_handle , only : abstract_transpose_handle , create_args , execute_args use dtfft_config use dtfft_errors #ifdef DTFFT_WITH_CUDA use dtfft_interface_cuda_runtime use dtfft_kernel_device , only : DEF_TILE_SIZE use dtfft_interface_cuda , only : load_cuda use dtfft_interface_nvrtc , only : load_nvrtc # ifdef NCCL_HAVE_COMMREGISTER use dtfft_abstract_backend , only : NCCL_REGISTER_PREALLOC_SIZE # endif # ifdef DTFFT_WITH_NVSHMEM use dtfft_interface_nvshmem # endif # ifdef DTFFT_WITH_NCCL use dtfft_interface_nccl # endif #endif use dtfft_parameters use dtfft_pencil , only : pencil , pencil_init , get_local_sizes use dtfft_transpose_handle_generic , only : transpose_handle_generic use dtfft_transpose_handle_datatype , only : transpose_handle_datatype use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_profile.h\" #include \"_dtfft_cuda.h\" #include \"_dtfft_private.h\" implicit none private public :: transpose_plan type :: plan_t !! This type is a container for allocatable transpose handles class ( abstract_transpose_handle ), allocatable :: p !! Transpose handle end type plan_t integer ( int8 ), save :: FORWARD_PLAN_IDS ( 3 ) !! Default data types for forward transpositions integer ( int8 ), save :: BACKWARD_PLAN_IDS ( 3 ) !! Default data types for backward transpositions logical , save :: ARE_DATATYPES_SET = . false . !! Are default data types set type :: transpose_plan !! Transpose Plan class !! This class is a container for transposition plans private type ( dtfft_backend_t ) :: backend !! Backend type ( backend_helper ) :: helper !! Backend helper logical :: is_z_slab !! Z-slab optimization flag (for 3D transforms) integer ( int64 ) :: min_buffer_size !! Minimal buffer size for transposition type ( dtfft_platform_t ) :: platform !! Platform used for transposition type ( dtfft_stream_t ) :: stream !! CUDA stream type ( c_ptr ) :: aux !! Auxiliary memory real ( real32 ), pointer :: paux (:) !! Pointer to auxiliary memory logical :: is_aux_alloc = . false . !! Is auxiliary memory allocated type ( plan_t ), allocatable :: plans (:) !! Plans for each transposition contains private procedure , non_overridable , pass ( self ), public :: create !! Creates transpose plan procedure , non_overridable , pass ( self ), public :: execute !! Executes transposition procedure , non_overridable , pass ( self ), public :: execute_end !! Finishes asynchronous transposition procedure , non_overridable , pass ( self ), public :: get_async_active !! Returns .true. if any of the plans is running asynchronously procedure , non_overridable , pass ( self ), public :: destroy !! Destroys transpose plan procedure , non_overridable , pass ( self ), public :: get_aux_size !! Returns auxiliary buffer size procedure , non_overridable , pass ( self ), public :: get_backend !! Returns backend id procedure , non_overridable , pass ( self ), public :: get_z_slab !! Returns .true. if Z-slab optimization is enabled procedure , non_overridable , pass ( self ), public :: mem_alloc !! Allocates memory based on selected backend procedure , non_overridable , pass ( self ), public :: mem_free !! Frees memory allocated with mem_alloc end type transpose_plan contains function create ( self , platform , dims , base_comm , effort , base_dtype , base_storage , cart_comm , comms , pencils , ipencil ) result ( error_code ) !! Creates transposition plan class ( transpose_plan ), intent ( inout ) :: self !! Transposition class type ( dtfft_platform_t ), intent ( in ) :: platform !! Platform to create plan for integer ( int32 ), intent ( in ) :: dims (:) !! Global sizes of the transform requested TYPE_MPI_COMM , intent ( in ) :: base_comm !! Base communicator type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner type of effort TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_COMM , intent ( out ) :: cart_comm !! Cartesian communicator TYPE_MPI_COMM , intent ( out ) :: comms (:) !! Array of 1d communicators type ( pencil ), intent ( out ) :: pencils (:) !! Data distributing meta type ( pencil_init ), optional , intent ( in ) :: ipencil !! Pencil passed by user integer ( int32 ) :: error_code !! Error code integer ( int32 ), allocatable :: transposed_dims (:,:) !! Global counts in transposed coordinates logical :: cond1 !! First condition for Z-slab optimization logical :: cond2 !! Second condition for Z-slab optimization integer ( int32 ), allocatable :: comm_dims (:) !! Dims in cartesian communicator integer ( int8 ) :: ndims !! Number of dimensions integer ( int32 ) :: comm_size !! Number of MPI processes integer ( int32 ) :: top_type !! Topology type integer ( int32 ) :: ierr !! Error code logical :: is_custom_cart_comm !! Custom cartesian communicator provided by user integer ( int8 ) :: d TYPE_MPI_COMM :: base_comm_ integer ( int8 ) :: n_transpose_plans integer ( int32 ), allocatable :: best_decomposition (:) logical :: pencils_created real ( real64 ) :: ts , te integer ( int8 ) :: best_forward_ids ( 3 ), best_backward_ids ( 3 ) logical :: invalid_grid_selected call MPI_Comm_size ( base_comm , comm_size , ierr ) call MPI_Topo_test ( base_comm , top_type , ierr ) base_comm_ = base_comm ndims = size ( dims , kind = int8 ) allocate ( comm_dims ( ndims ) ) comm_dims (:) = 0 is_custom_cart_comm = . false . self % is_z_slab = . false . invalid_grid_selected = . false . if ( present ( ipencil ) ) then is_custom_cart_comm = . true . do d = 1 , ndims call MPI_Comm_size ( ipencil % comms ( d ), comm_dims ( d ), ierr ) enddo if ( comm_dims ( 1 ) /= 1 ) then error_code = DTFFT_ERROR_INVALID_COMM_FAST_DIM return endif if ( ndims == 3 . and . comm_dims ( 2 ) == 1 . and . get_conf_z_slab_enabled () ) then self % is_z_slab = . true . base_comm_ = ipencil % comms ( 3 ) endif else ! ipencil not present if ( top_type == MPI_CART ) then is_custom_cart_comm = . true . block integer ( int32 ) :: grid_ndims ! Number of dims in user defined cartesian communicator integer ( int32 ), allocatable :: temp_dims (:) ! Temporary dims needed by MPI_Cart_get integer ( int32 ), allocatable :: temp_coords (:) ! Temporary coordinates needed by MPI_Cart_get logical , allocatable :: temp_periods (:) ! Temporary periods needed by MPI_Cart_get call MPI_Cartdim_get ( base_comm_ , grid_ndims , ierr ) if ( grid_ndims > ndims ) then error_code = DTFFT_ERROR_INVALID_COMM_DIMS return endif comm_dims (:) = 1 allocate ( temp_dims ( grid_ndims ), temp_periods ( grid_ndims ), temp_coords ( grid_ndims )) call MPI_Cart_get ( base_comm_ , grid_ndims , temp_dims , temp_periods , temp_coords , ierr ) if ( grid_ndims == ndims ) then if ( temp_dims ( 1 ) /= 1 ) then error_code = DTFFT_ERROR_INVALID_COMM_FAST_DIM return endif comm_dims (:) = temp_dims elseif ( grid_ndims == ndims - 1 ) then comm_dims ( 2 :) = temp_dims elseif ( grid_ndims == ndims - 2 ) then comm_dims ( 3 ) = temp_dims ( 1 ) endif deallocate ( temp_dims , temp_periods , temp_coords ) do d = 2 , ndims if ( comm_dims ( d ) > dims ( d ) ) then WRITE_WARN ( \"Number of MPI processes in direction \" // to_str ( d ) // \" greater then number of physical points: \" // to_str ( comm_dims ( d )) // \" > \" // to_str ( dims ( d ))) endif enddo if ( ndims == 3 . and . comm_dims ( 2 ) == 1 . and . get_conf_z_slab_enabled () ) then self % is_z_slab = . true . endif endblock else !  top_type /= MPI_CART comm_dims (:) = 0 comm_dims ( 1 ) = 1 cond1 = comm_size <= dims ( ndims ) cond2 = comm_size <= dims ( 1 ) . and . comm_size <= dims ( 2 ) #ifdef DTFFT_WITH_CUDA if ( platform == DTFFT_PLATFORM_CUDA ) then cond1 = DEF_TILE_SIZE <= dims ( ndims ) / comm_size cond2 = DEF_TILE_SIZE <= dims ( 1 ) / comm_size . and . DEF_TILE_SIZE <= dims ( 2 ) / comm_size endif #endif if ( ndims == 3 . and . cond1 ) then comm_dims ( 2 ) = 1 comm_dims ( 3 ) = comm_size self % is_z_slab = get_conf_z_slab_enabled () else if ( ndims == 3 . and . cond2 ) then comm_dims ( 2 ) = comm_size comm_dims ( 3 ) = 1 endif call MPI_Dims_create ( comm_size , int ( ndims , int32 ), comm_dims , ierr ) if ( dims ( ndims - 1 ) < comm_dims ( ndims - 1 ) . or . dims ( ndims ) < comm_dims ( ndims ) ) then WRITE_WARN ( \"Unable to create correct grid decomposition.\" ) invalid_grid_selected = . true . ! WRITE_WARN(\"Fallback to Z slab is used\") ! comm_dims(ndims - 1) = 1 ! comm_dims(ndims) = comm_size endif endif endif allocate ( transposed_dims ( ndims , ndims )) if ( ndims == 2 ) then ! Nx x Ny transposed_dims (:, 1 ) = dims (:) ! Ny x Nx transposed_dims ( 1 , 2 ) = dims ( 2 ) transposed_dims ( 2 , 2 ) = dims ( 1 ) else ! Nx x Ny x Nz transposed_dims (:, 1 ) = dims (:) ! Ny x Nx x Nz transposed_dims ( 1 , 2 ) = dims ( 2 ) transposed_dims ( 2 , 2 ) = dims ( 1 ) transposed_dims ( 3 , 2 ) = dims ( 3 ) ! Nz x Nx x Ny transposed_dims ( 1 , 3 ) = dims ( 3 ) transposed_dims ( 2 , 3 ) = dims ( 1 ) transposed_dims ( 3 , 3 ) = dims ( 2 ) endif error_code = DTFFT_SUCCESS if ( . not . ARE_DATATYPES_SET ) then FORWARD_PLAN_IDS ( 1 ) = get_datatype_from_env ( \"DTYPE_X_Y\" ); BACKWARD_PLAN_IDS ( 1 ) = get_datatype_from_env ( \"DTYPE_Y_X\" ) FORWARD_PLAN_IDS ( 2 ) = get_datatype_from_env ( \"DTYPE_Y_Z\" ); BACKWARD_PLAN_IDS ( 2 ) = get_datatype_from_env ( \"DTYPE_Z_Y\" ) FORWARD_PLAN_IDS ( 3 ) = get_datatype_from_env ( \"DTYPE_X_Z\" ); BACKWARD_PLAN_IDS ( 3 ) = get_datatype_from_env ( \"DTYPE_Z_X\" ) ARE_DATATYPES_SET = . true . endif best_forward_ids (:) = FORWARD_PLAN_IDS (:) best_backward_ids (:) = BACKWARD_PLAN_IDS (:) self % platform = platform self % backend = get_conf_backend () if ( platform == DTFFT_PLATFORM_HOST ) then if ( . not . get_conf_datatype_enabled () . and . . not . get_conf_mpi_enabled () . and . effort == DTFFT_PATIENT ) then error_code = DTFFT_ERROR_BACKENDS_DISABLED return endif #ifdef DTFFT_WITH_CUDA else if ( . not . get_conf_mpi_enabled () . and . . not . get_conf_nccl_enabled () . and . . not . get_conf_nvshmem_enabled () . and . effort == DTFFT_PATIENT ) then error_code = DTFFT_ERROR_BACKENDS_DISABLED return endif CHECK_CALL ( load_cuda (), error_code ) CHECK_CALL ( load_nvrtc (), error_code ) self % stream = get_conf_stream () ! # ifdef DTFFT_WITH_NVSHMEM !       if ( is_backend_nvshmem(self%backend) .or. (get_conf_nvshmem_enabled() .and. effort == DTFFT_PATIENT) ) then !         call nvshmem_init(base_comm_) !       endif ! # endif #endif endif ! if ( platform == DTFFT_PLATFORM_HOST .and. (is_backend_nccl(self%backend) .or. is_backend_nvshmem(self%backend)) ) then ! ! Do not raise error here, just fallback to MPI_P2P !   self%backend = DTFFT_BACKEND_MPI_DATATYPE ! endif allocate ( best_decomposition ( ndims ) ) best_decomposition (:) = comm_dims (:) call MPI_Comm_size ( base_comm_ , comm_size , ierr ) if ( comm_size == 1 . and . self % backend /= DTFFT_BACKEND_MPI_DATATYPE ) self % backend = BACKEND_NOT_SET pencils_created = . false . if ( ndims == 2 . or . is_custom_cart_comm . or . self % is_z_slab ) then pencils_created = . true . call create_pencils_and_comm ( transposed_dims , base_comm_ , comm_dims , cart_comm , comms , pencils , ipencil = ipencil ) endif ts = MPI_Wtime () if ( effort == DTFFT_PATIENT . and . comm_size > 1 . and . . not . invalid_grid_selected ) then if ( pencils_created ) then call run_autotune_backend ( & platform , comms , cart_comm , effort , base_dtype , pencils , base_storage , self % stream , self % is_z_slab , & best_forward_ids , best_backward_ids , best_backend = self % backend ) else call autotune_grid_decomposition ( & platform , dims , transposed_dims , base_comm_ , effort , base_dtype , base_storage , & self % stream , best_forward_ids , best_backward_ids , best_decomposition , best_backend = self % backend ) endif else if ( ndims == 3 & . and . . not . is_custom_cart_comm & . and . . not . self % is_z_slab & . and . effort == DTFFT_MEASURE & . and . comm_size > 1 ) then call autotune_grid_decomposition ( & platform , dims , transposed_dims , base_comm_ , effort , base_dtype , base_storage , & self % stream , best_forward_ids , best_backward_ids , best_decomposition , backend = self % backend ) endif te = MPI_Wtime () if ( effort % val >= DTFFT_MEASURE % val . and . ndims > 2 . and . comm_size > 1 ) then WRITE_INFO ( repeat ( \"*\" , 50 )) if ( self % is_z_slab ) then WRITE_INFO ( \"Skipped search of MPI processor grid due to Z-slab optimization enabled\" ) else if ( is_custom_cart_comm ) then WRITE_INFO ( \"Skipped search of MPI processor grid due to custom grid provided\" ) else if ( invalid_grid_selected ) then WRITE_INFO ( \"Skipped search of MPI processor grid due to lack of work per process\" ) else WRITE_INFO ( \"DTFFT_MEASURE: Selected MPI processor grid 1x\" // to_str ( best_decomposition ( 2 )) // \"x\" // to_str ( best_decomposition ( 3 ))) endif endif if ( effort == DTFFT_PATIENT . and . comm_size > 1 ) then WRITE_INFO ( \"DTFFT_PATIENT: Selected backend is \" // dtfft_get_backend_string ( self % backend )) endif n_transpose_plans = ndims - 1_int8 ; if ( self % is_z_slab ) n_transpose_plans = n_transpose_plans + 1_int8 if ( effort == DTFFT_PATIENT . and . self % backend == DTFFT_BACKEND_MPI_DATATYPE ) then WRITE_INFO ( \"DTFFT_PATIENT: Selected transpose ids:\" ) do d = 1 , n_transpose_plans WRITE_INFO ( \"    \" // TRANSPOSE_NAMES ( d ) // \": \" // to_str ( best_forward_ids ( d ) )) WRITE_INFO ( \"    \" // TRANSPOSE_NAMES ( - d ) // \": \" // to_str ( best_backward_ids ( d ) )) enddo WRITE_INFO ( repeat ( \"*\" , 50 )) endif if ( effort % val >= DTFFT_MEASURE % val . and . comm_size > 1 ) then WRITE_INFO ( \"Time spent on autotune: \" // to_str ( te - ts ) // \" [s]\" ) endif if ( . not . pencils_created ) then call create_pencils_and_comm ( transposed_dims , base_comm_ , best_decomposition , cart_comm , comms , pencils ) endif ts = MPI_Wtime () allocate ( self % plans ( - 1 * n_transpose_plans : n_transpose_plans ) ) call allocate_plans ( self % plans , self % backend ) call self % helper % create ( platform , cart_comm , comms , is_backend_nccl ( self % backend ), pencils ) block type ( create_args ) :: args args % platform = platform args % helper = self % helper args % effort = effort args % backend = self % backend args % force_effort = . false . args % base_type = base_dtype do d = 1_int8 , ndims - 1_int8 args % datatype_id = best_forward_ids ( d ) call self % plans ( d )% p % create ( pencils ( d ), pencils ( d + 1 ), base_storage , args ) args % datatype_id = best_backward_ids ( d ) call self % plans ( - d )% p % create ( pencils ( d + 1 ), pencils ( d ), base_storage , args ) enddo if ( self % is_z_slab ) then args % datatype_id = best_forward_ids ( 3 ) call self % plans ( 3 )% p % create ( pencils ( 1 ), pencils ( 3 ), base_storage , args ) args % datatype_id = best_backward_ids ( 3 ) call self % plans ( - 3 )% p % create ( pencils ( 3 ), pencils ( 1 ), base_storage , args ) endif endblock te = MPI_Wtime () WRITE_INFO ( \"Time spent creating final plans: \" // to_str ( te - ts ) // \" [s]\" ) call get_local_sizes ( pencils , alloc_size = self % min_buffer_size ) self % min_buffer_size = self % min_buffer_size * ( base_storage / FLOAT_STORAGE_SIZE ) call alloc_and_set_aux ( platform , self % helper , self % backend , cart_comm , self % aux , self % paux , self % plans , self % is_aux_alloc ) deallocate ( best_decomposition , comm_dims , transposed_dims ) error_code = DTFFT_SUCCESS end function create logical function get_async_active ( self ) !! Returns .true. if any of the plans is running asynchronously class ( transpose_plan ), intent ( in ) :: self !! Transposition class integer ( int32 ) :: i get_async_active = . false . do i = lbound ( self % plans , dim = 1 ), ubound ( self % plans , dim = 1 ) if ( allocated ( self % plans ( i )% p ) ) then get_async_active = get_async_active . or . self % plans ( i )% p % get_async_active () endif enddo end function get_async_active subroutine execute ( self , in , out , transpose_type , exec_type , error_code ) !! Executes transposition class ( transpose_plan ), intent ( inout ) :: self !! Transposition class type ( c_ptr ), intent ( in ) :: in !! Incoming buffer type ( c_ptr ), intent ( in ) :: out !! Resulting buffer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transpose to execute type ( async_exec_t ), intent ( in ) :: exec_type !! Type of execution (sync/async) integer ( int32 ), optional , intent ( out ) :: error_code !! Error code real ( real32 ), pointer :: pin (:) !! Source buffer real ( real32 ), pointer :: pout (:) !! Destination buffer type ( execute_args ) :: kwargs !! Additional arguments for execution integer ( int32 ) :: ierr !! Error code REGION_BEGIN ( 'Transpose ' // TRANSPOSE_NAMES ( transpose_type % val ), COLOR_TRANSPOSE_PALLETTE ( transpose_type % val )) call c_f_pointer ( in , pin , [ self % min_buffer_size ]) call c_f_pointer ( out , pout , [ self % min_buffer_size ]) kwargs % exec_type = exec_type kwargs % stream = self % stream if ( self % is_aux_alloc ) then kwargs % p1 => self % paux else ! Pointer is unused. Pointing to something in order to avoid runtime null pointer errors kwargs % p1 => pin endif call self % plans ( transpose_type % val )% p % execute ( pin , pout , kwargs , ierr ) if ( present ( error_code ) ) error_code = ierr REGION_END ( 'Transpose ' // TRANSPOSE_NAMES ( transpose_type % val )) end subroutine execute subroutine execute_end ( self , in , out , transpose_type , error_code ) !! Finishes asynchronous transposition class ( transpose_plan ), intent ( inout ) :: self !! Transposition class type ( c_ptr ), intent ( in ) :: in !! Incoming buffer type ( c_ptr ), intent ( in ) :: out !! Resulting buffer type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transpose integer ( int32 ), intent ( out ) :: error_code !! Error code real ( real32 ), pointer :: pin (:) !! Source buffer real ( real32 ), pointer :: pout (:) !! Destination buffer type ( execute_args ) :: kwargs !! Additional arguments for execution call c_f_pointer ( in , pin , [ self % min_buffer_size ]) call c_f_pointer ( out , pout , [ self % min_buffer_size ]) kwargs % p1 => pin kwargs % p2 => pout kwargs % stream = self % stream call self % plans ( transpose_type % val )% p % execute_end ( kwargs , error_code ) end subroutine execute_end subroutine destroy ( self ) !! Destroys transposition plans class ( transpose_plan ), intent ( inout ) :: self !! Transposition class integer ( int32 ) :: ierr if ( self % is_aux_alloc ) then call self % mem_free ( self % aux , ierr ) self % paux => null () self % is_aux_alloc = . false . endif if ( allocated ( self % plans ) ) then call destroy_plans ( self % plans ) deallocate ( self % plans ) endif call self % helper % destroy () ! # ifdef DTFFT_WITH_NVSHMEM !       if ( is_backend_nvshmem(self%backend) ) then !         call nvshmem_finalize() !       endif ! # endif ! #ifdef DTFFT_WITH_CUDA !     if ( self%platform == DTFFT_PLATFORM_CUDA  ) then !       call cache%cleanup() !     endif ! #endif end subroutine destroy logical function get_z_slab ( self ) !! Returns .true. if Z-slab optimization is enabled class ( transpose_plan ), intent ( in ) :: self !! Transposition class get_z_slab = self % is_z_slab end function get_z_slab subroutine allocate_plans ( plans , backend ) !! Allocates array of plans type ( plan_t ), intent ( inout ) :: plans (:) !! Plans to allocate type ( dtfft_backend_t ), intent ( in ) :: backend !! Backend to use integer ( int32 ) :: i do i = 1 , size ( plans ) if ( backend == DTFFT_BACKEND_MPI_DATATYPE ) then allocate ( transpose_handle_datatype :: plans ( i )% p ) else allocate ( transpose_handle_generic :: plans ( i )% p ) endif enddo end subroutine allocate_plans subroutine destroy_plans ( plans ) !! Destroys array of plans type ( plan_t ), intent ( inout ) :: plans (:) !! Plans to destroy integer ( int32 ) :: i do i = 1 , size ( plans ) if ( allocated ( plans ( i )% p ) ) then call plans ( i )% p % destroy () deallocate ( plans ( i )% p ) endif enddo end subroutine destroy_plans subroutine autotune_grid_decomposition ( & platform , dims , transposed_dims , base_comm , effort , base_dtype , base_storage , stream , & best_forward_ids , best_backward_ids , best_decomposition , backend , min_execution_time , best_backend ) !! Runs through all possible grid decompositions and selects the best one based on the lowest average execution time type ( dtfft_platform_t ), intent ( in ) :: platform !! Platform to use integer ( int32 ), intent ( in ) :: dims (:) !! Global sizes of the transform requested integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Transposed dimensions TYPE_MPI_COMM , intent ( in ) :: base_comm !! 3D comm type ( dtfft_effort_t ), intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to use integer ( int8 ), intent ( inout ) :: best_forward_ids (:) !! Best Datatype ids for forward plan integer ( int8 ), intent ( inout ) :: best_backward_ids (:) !! Best Datatype ids for backward plan integer ( int32 ), intent ( out ) :: best_decomposition (:) !! Best decomposition found type ( dtfft_backend_t ), optional , intent ( in ) :: backend !! GPU Backend to test. Should be passed only when effort is `DTFFT_ESTIMATE` or `DTFFT_MEASURE` real ( real32 ), optional , intent ( out ) :: min_execution_time !! Elapsed time for best plan selected type ( dtfft_backend_t ), optional , intent ( out ) :: best_backend !! Best backend selected integer ( int8 ) :: ndims type ( dtfft_backend_t ) :: best_backend_ integer ( int32 ) :: comm_size , square_root , i , current_timer , k , ierr real ( real32 ) :: current_time , elapsed_time real ( real32 ), allocatable :: timers (:) integer ( int32 ), allocatable :: decomps (:,:) type ( dtfft_backend_t ), allocatable :: backends (:) integer ( int8 ), allocatable :: forw_ids (:,:) !! Best Forward ids are stored in forw_ids(:, latest_timer_id) integer ( int8 ), allocatable :: back_ids (:,:) !! Best Backward ids are stored in back_ids(:, latest_timer_id) integer ( int8 ) :: forw ( 3 ), back ( 3 ) call MPI_Comm_size ( base_comm , comm_size , ierr ) ndims = size ( dims , kind = int8 ) square_root = int ( sqrt ( real ( comm_size , real64 ))) + 1 allocate ( timers ( 2 * square_root )) allocate ( decomps ( 2 , 2 * square_root )) allocate ( backends ( 2 * square_root )) allocate ( forw_ids ( 3 , 2 * square_root )) allocate ( back_ids ( 3 , 2 * square_root )) current_timer = 0 do i = 1 , square_root - 1 if ( mod ( comm_size , i ) /= 0 ) cycle forw (:) = best_forward_ids (:) back (:) = best_backward_ids (:) call autotune_grid ( & platform , dims , transposed_dims , base_comm , effort , base_dtype , & [ 1 , i , comm_size / i ], base_storage , stream , . false ., forw , back , & backend = backend , best_time = current_time , best_backend = best_backend_ ) if ( current_time > 0.0 ) then current_timer = current_timer + 1 timers ( current_timer ) = current_time decomps ( 1 , current_timer ) = i decomps ( 2 , current_timer ) = comm_size / i forw_ids (:, current_timer ) = forw (:) back_ids (:, current_timer ) = back (:) backends ( current_timer ) = best_backend_ endif if ( i /= comm_size / i ) then forw (:) = best_forward_ids (:) back (:) = best_backward_ids (:) call autotune_grid ( & platform , dims , transposed_dims , base_comm , effort , base_dtype , & [ 1 , comm_size / i , i ], base_storage , stream , . false ., forw , back , & backend = backend , best_time = current_time , best_backend = best_backend_ ) if ( current_time > 0.0 ) then current_timer = current_timer + 1 timers ( current_timer ) = current_time decomps ( 1 , current_timer ) = comm_size / i decomps ( 2 , current_timer ) = i forw_ids (:, current_timer ) = forw (:) back_ids (:, current_timer ) = back (:) backends ( current_timer ) = best_backend_ endif endif enddo elapsed_time = MAX_REAL32 k = 1 do i = 1 , current_timer if ( timers ( i ) < elapsed_time ) then elapsed_time = timers ( i ) k = i endif enddo best_decomposition ( 1 ) = 1 best_decomposition ( 2 ) = decomps ( 1 , k ) best_decomposition ( 3 ) = decomps ( 2 , k ) best_forward_ids (:) = forw_ids (:, k ) best_backward_ids (:) = back_ids (:, k ) if ( present ( best_backend ) ) best_backend = backends ( k ) if ( present ( min_execution_time ) ) min_execution_time = elapsed_time deallocate ( timers , decomps , backends , forw_ids , back_ids ) end subroutine autotune_grid_decomposition subroutine autotune_grid ( & platform , dims , transposed_dims , base_comm , effort , base_dtype , comm_dims , base_storage , stream , is_z_slab , & best_forward_ids , best_backward_ids , backend , best_time , best_backend ) !! Creates cartesian grid and runs various backends on it. Returns best backend and execution time type ( dtfft_platform_t ), intent ( in ) :: platform !! Platform to create plan for integer ( int32 ), intent ( in ) :: dims (:) !! Global sizes of the transform requested integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Transposed dimensions TYPE_MPI_COMM , intent ( in ) :: base_comm !! Basic communicator to create 3d grid from type ( dtfft_effort_t ), intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal plan TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype integer ( int32 ), intent ( in ) :: comm_dims (:) !! Number of processors in each dimension integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to use logical , intent ( in ) :: is_z_slab !! Is Z-slab optimization enabled integer ( int8 ), intent ( inout ) :: best_forward_ids (:) !! Best Datatype ids for forward plan integer ( int8 ), intent ( inout ) :: best_backward_ids (:) !! Best Datatype ids for backward plan type ( dtfft_backend_t ), optional , intent ( in ) :: backend !! GPU Backend to test. Should be passed only when effort is `DTFFT_ESTIMATE` or `DTFFT_MEASURE` type ( dtfft_backend_t ), optional , intent ( out ) :: best_backend !! Best backend selected for the grid real ( real32 ), optional , intent ( out ) :: best_time !! Elapsed time for best plan selected type ( pencil ), allocatable :: pencils (:) character ( len = :), allocatable :: phase_name !! Caliper phase name integer ( int8 ) :: d , ndims TYPE_MPI_COMM , allocatable :: comms (:) TYPE_MPI_COMM :: cart_comm integer ( int32 ) :: mpi_ierr best_time = - 1.0 ndims = size ( dims , kind = int8 ) if ( ndims == 3 ) then if ( comm_dims ( 2 ) > dims ( 2 ) . or . comm_dims ( 3 ) > dims ( 3 ) ) return allocate ( phase_name , source = \"Testing grid 1x\" // to_str ( comm_dims ( 2 )) // \"x\" // to_str ( comm_dims ( 3 )) ) else allocate ( phase_name , source = \"Testing grid 1x\" // to_str ( comm_dims ( 2 )) ) endif WRITE_INFO ( \"\" ) WRITE_INFO ( phase_name ) REGION_BEGIN ( phase_name , COLOR_AUTOTUNE ) allocate ( comms ( ndims ), pencils ( ndims ) ) call create_pencils_and_comm ( transposed_dims , base_comm , comm_dims , cart_comm , comms , pencils ) call run_autotune_backend ( & platform , comms , cart_comm , effort , base_dtype , pencils , base_storage , stream , is_z_slab , & best_forward_ids , best_backward_ids , backend = backend , best_time = best_time , best_backend = best_backend ) do d = 1 , ndims call pencils ( d )% destroy () call MPI_Comm_free ( comms ( d ), mpi_ierr ) enddo call MPI_Comm_free ( cart_comm , mpi_ierr ) deallocate ( comms , pencils ) REGION_END ( phase_name ) end subroutine autotune_grid subroutine run_autotune_backend ( & platform , comms , cart_comm , effort , base_dtype , pencils , base_storage , stream , is_z_slab , & best_forward_ids , best_backward_ids , backend , best_time , best_backend ) !! Runs autotune for all backends type ( dtfft_platform_t ), intent ( in ) :: platform !! Platform to create plan for TYPE_MPI_COMM , intent ( in ) :: comms (:) !! 1D comms TYPE_MPI_COMM , intent ( in ) :: cart_comm !! 3D Cartesian comm type ( dtfft_effort_t ), intent ( in ) :: effort !! TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype type ( pencil ), intent ( in ) :: pencils (:) !! Source meta integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to use logical , intent ( in ) :: is_z_slab !! Is Z-slab optimization enabled integer ( int8 ), intent ( inout ) :: best_forward_ids (:) !! Best Datatype ids for forward plan integer ( int8 ), intent ( inout ) :: best_backward_ids (:) !! Best Datatype ids for backward plan type ( dtfft_backend_t ), optional , intent ( in ) :: backend !! GPU Backend to test. Should be passed only when effort is `DTFFT_ESTIMATE` or `DTFFT_MEASURE` real ( real32 ), optional , intent ( out ) :: best_time !! Elapsed time for best backend type ( dtfft_backend_t ), optional , intent ( out ) :: best_backend !! Best backend selected type ( dtfft_backend_t ), allocatable :: backends_to_run (:) type ( dtfft_backend_t ) :: current_backend_id , best_backend_ logical :: is_udb !! Used defined backend real ( real32 ) :: execution_time , avg_execution_time , best_time_ integer ( int32 ) :: iter , comm_size , mpi_ierr , b , ierr ! type(transpose_handle_generic),  allocatable   :: plans(:) type ( plan_t ), allocatable :: plans (:) integer ( int8 ) :: i , n_transpose_plans type ( c_ptr ) :: in , out , aux real ( real32 ), pointer :: pin (:), pout (:), paux (:) logical :: is_aux_alloc real ( real64 ) :: ts , te ! , need_aux integer ( int64 ) :: alloc_size #ifdef DTFFT_WITH_CUDA type ( cudaEvent ) :: timer_start , timer_stop #endif character ( len = :), allocatable :: testing_phase type ( backend_helper ) :: helper integer ( int32 ) :: n_warmup_iters , n_iters integer ( int64 ) :: min_buffer_size type ( create_args ) :: create_kwargs type ( execute_args ) :: execute_kwargs integer ( int32 ) :: first logical :: pipe_enabled , mpi_enabled , dtype_enabled if ( present ( backend ) ) then allocate ( backends_to_run ( 1 ) ) backends_to_run ( 1 ) = backend is_udb = . true . else if ( platform == DTFFT_PLATFORM_HOST ) then first = 1 else first = 2 endif allocate ( backends_to_run ( size ( VALID_BACKENDS ( first :)))) do b = 1 , size ( backends_to_run ) backends_to_run ( b ) = VALID_BACKENDS ( first - 1 + b ) enddo is_udb = . false . endif best_backend_ = backends_to_run ( 1 ) if ( is_z_slab ) then n_transpose_plans = 1 else n_transpose_plans = size ( pencils , kind = int8 ) - 1_int8 endif allocate ( plans ( 2 * n_transpose_plans ) ) call MPI_Comm_size ( cart_comm , comm_size , mpi_ierr ) call helper % create ( platform , cart_comm , comms , any ( is_backend_nccl ( backends_to_run )), pencils ) call get_local_sizes ( pencils , alloc_size = alloc_size ) alloc_size = alloc_size * base_storage min_buffer_size = alloc_size / FLOAT_STORAGE_SIZE create_kwargs % effort = DTFFT_ESTIMATE create_kwargs % force_effort = . true . create_kwargs % platform = platform create_kwargs % helper = helper create_kwargs % base_type = base_dtype execute_kwargs % exec_type = EXEC_BLOCKING execute_kwargs % stream = stream #ifdef DTFFT_WITH_CUDA if ( platform == DTFFT_PLATFORM_CUDA ) then CUDA_CALL ( cudaEventCreate ( timer_start ) ) CUDA_CALL ( cudaEventCreate ( timer_stop ) ) endif #endif n_warmup_iters = get_conf_measure_warmup_iters () n_iters = get_conf_measure_iters () pipe_enabled = get_conf_pipelined_enabled () dtype_enabled = get_conf_datatype_enabled () mpi_enabled = get_conf_mpi_enabled () best_time_ = MAX_REAL32 do b = 1 , size ( backends_to_run ) current_backend_id = backends_to_run ( b ) if ( (( is_backend_pipelined ( current_backend_id ) . and . . not . pipe_enabled ) & . or .( is_backend_mpi ( current_backend_id ) . and . . not . mpi_enabled ) & . or .( current_backend_id == DTFFT_BACKEND_MPI_DATATYPE . and . . not . dtype_enabled )) & . and . . not . is_udb ) cycle #ifdef DTFFT_WITH_CUDA if ( platform == DTFFT_PLATFORM_CUDA ) then if ( ( is_backend_nvshmem ( current_backend_id ) . and . . not . get_conf_nvshmem_enabled ()) & . and . . not . is_udb ) cycle else if ( is_backend_nccl ( current_backend_id ) . or . is_backend_nvshmem ( current_backend_id ) ) cycle endif #endif call allocate_plans ( plans , current_backend_id ) if ( . not . is_backend_nvshmem ( current_backend_id ) ) then call alloc_mem ( platform , helper , current_backend_id , cart_comm , alloc_size , in , ierr ); DTFFT_CHECK ( ierr ) call alloc_mem ( platform , helper , current_backend_id , cart_comm , alloc_size , out , ierr ); DTFFT_CHECK ( ierr ) call c_f_pointer ( in , pin , [ min_buffer_size ]) call c_f_pointer ( out , pout , [ min_buffer_size ]) endif testing_phase = \"Testing backend \" // dtfft_get_backend_string ( current_backend_id ) REGION_BEGIN ( testing_phase , COLOR_AUTOTUNE2 ) WRITE_INFO ( testing_phase ) is_aux_alloc = . false . if ( current_backend_id == DTFFT_BACKEND_MPI_DATATYPE . and . effort == DTFFT_PATIENT ) then call run_autotune_datatypes ( helper , base_dtype , pencils , base_storage , is_z_slab , best_forward_ids , best_backward_ids , pin , pout , avg_execution_time ) else create_kwargs % backend = current_backend_id if ( is_z_slab ) then create_kwargs % datatype_id = best_forward_ids ( 3 ) call plans ( 1 )% p % create ( pencils ( 1 ), pencils ( 3 ), base_storage , create_kwargs ) create_kwargs % datatype_id = best_backward_ids ( 3 ) call plans ( 2 )% p % create ( pencils ( 3 ), pencils ( 1 ), base_storage , create_kwargs ) else do i = 1 , n_transpose_plans create_kwargs % datatype_id = best_forward_ids ( i ) call plans ( i )% p % create ( pencils ( i ), pencils ( i + 1 ), base_storage , create_kwargs ) create_kwargs % datatype_id = best_backward_ids ( i ) call plans ( i + n_transpose_plans )% p % create ( pencils ( i + 1 ), pencils ( i ), base_storage , create_kwargs ) enddo endif if ( is_backend_nvshmem ( current_backend_id ) ) then !! Symmetric heap can be allocated after nvshmem_init, which is done during plan creation call alloc_mem ( platform , helper , current_backend_id , cart_comm , alloc_size , in , ierr ); DTFFT_CHECK ( ierr ) call alloc_mem ( platform , helper , current_backend_id , cart_comm , alloc_size , out , ierr ); DTFFT_CHECK ( ierr ) call c_f_pointer ( in , pin , [ min_buffer_size ]) call c_f_pointer ( out , pout , [ min_buffer_size ]) endif call alloc_and_set_aux ( platform , helper , current_backend_id , cart_comm , aux , paux , plans , is_aux_alloc ) if ( is_aux_alloc ) then execute_kwargs % p1 => paux else execute_kwargs % p1 => pout endif REGION_BEGIN ( \"Warmup\" , COLOR_TRANSPOSE ) do iter = 1 , n_warmup_iters do i = 1 , 2_int8 * n_transpose_plans call plans ( i )% p % execute ( pin , pout , execute_kwargs , ierr ) enddo enddo #ifdef DTFFT_WITH_CUDA if ( platform == DTFFT_PLATFORM_CUDA ) then CUDA_CALL ( cudaStreamSynchronize ( stream ) ) endif #endif REGION_END ( \"Warmup\" ) call MPI_Barrier ( cart_comm , mpi_ierr ) REGION_BEGIN ( \"Measure\" , COLOR_EXECUTE ) if ( platform == DTFFT_PLATFORM_HOST ) then ts = MPI_Wtime () #ifdef DTFFT_WITH_CUDA else CUDA_CALL ( cudaEventRecord ( timer_start , stream ) ) #endif endif do iter = 1 , n_iters do i = 1 , 2_int8 * n_transpose_plans call plans ( i )% p % execute ( pin , pout , execute_kwargs , ierr ) enddo enddo if ( platform == DTFFT_PLATFORM_HOST ) then te = MPI_Wtime () execution_time = real ( te - ts , real32 ) * 100 0._real32 #ifdef DTFFT_WITH_CUDA else CUDA_CALL ( cudaEventRecord ( timer_stop , stream ) ) CUDA_CALL ( cudaEventSynchronize ( timer_stop ) ) CUDA_CALL ( cudaEventElapsedTime ( execution_time , timer_start , timer_stop ) ) #endif endif REGION_END ( \"Measure\" ) avg_execution_time = report_timings ( cart_comm , execution_time , n_iters ) endif ! execution_time = execution_time / real(n_iters, real32) ! call MPI_Allreduce(execution_time, min_execution_time, 1, MPI_REAL4, MPI_MIN, cart_comm, mpi_ierr) ! call MPI_Allreduce(execution_time, max_execution_time, 1, MPI_REAL4, MPI_MAX, cart_comm, mpi_ierr) ! call MPI_Allreduce(execution_time, avg_execution_time, 1, MPI_REAL4, MPI_SUM, cart_comm, mpi_ierr) ! avg_execution_time = avg_execution_time / real(comm_size, real32) ! WRITE_INFO(\"  max: \"//to_str(real(max_execution_time, real64))//\" [ms]\") ! WRITE_INFO(\"  min: \"//to_str(real(min_execution_time, real64))//\" [ms]\") ! WRITE_INFO(\"  avg: \"//to_str(real(avg_execution_time, real64))//\" [ms]\") if ( avg_execution_time < best_time_ ) then best_time_ = avg_execution_time best_backend_ = current_backend_id endif call free_mem ( platform , helper , current_backend_id , in , ierr ) call free_mem ( platform , helper , current_backend_id , out , ierr ) if ( is_aux_alloc ) then call free_mem ( platform , helper , current_backend_id , aux , ierr ) is_aux_alloc = . false . endif call destroy_plans ( plans ) REGION_END ( \"Testing backend \" // dtfft_get_backend_string ( current_backend_id )) enddo deallocate ( plans ) #ifdef DTFFT_WITH_CUDA if ( platform == DTFFT_PLATFORM_CUDA ) then CUDA_CALL ( cudaEventDestroy ( timer_start ) ) CUDA_CALL ( cudaEventDestroy ( timer_stop ) ) endif #endif call helper % destroy () if ( present ( best_time )) best_time = best_time_ if ( present ( best_backend ) ) best_backend = best_backend_ end subroutine run_autotune_backend subroutine run_autotune_datatypes ( & helper , base_dtype , pencils , base_storage , & is_z_slab , best_forward_ids , best_backward_ids , a , b , elapsed_time ) type ( backend_helper ), intent ( inout ) :: helper TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Base MPI_Datatype type ( pencil ), intent ( in ) :: pencils (:) !! Source meta integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element logical , intent ( in ) :: is_z_slab !! Is Z-slab optimization enabled integer ( int8 ), intent ( out ) :: best_forward_ids (:) !! Best Datatype ids for forward plan integer ( int8 ), intent ( out ) :: best_backward_ids (:) !! Best Datatype ids for backward plan real ( real32 ), intent ( inout ) :: a (:) !! Source buffer real ( real32 ), intent ( inout ) :: b (:) !! Target buffer real ( real32 ), intent ( out ) :: elapsed_time !! Elapsed time for best plans selected in [ms] integer ( int8 ) :: dim !! Counter integer ( int8 ) :: ndims !! Number of dimensions ndims = size ( pencils , kind = int8 ) elapsed_time = 0._real32 if ( is_z_slab ) then elapsed_time = autotune_transpose_id ( helper , pencils ( 1 ), pencils ( 3 ), & base_dtype , base_storage , 3_int8 , a , b , best_forward_ids ( 3 ), best_backward_ids ( 3 )) else do dim = 1_int8 , ndims - 1_int8 elapsed_time = elapsed_time & + autotune_transpose_id ( helper , pencils ( dim ), pencils ( dim + 1 ), & base_dtype , base_storage , dim , a , b , best_forward_ids ( dim ), best_backward_ids ( dim )) enddo endif WRITE_INFO ( \"  Execution time on a grid using fastest transpositions: \" // to_str ( real ( elapsed_time , real64 )) // \" [ms]\" ) end subroutine run_autotune_datatypes function autotune_transpose_id ( helper , from , to , base_dtype , base_storage , transpose_name_id , a , b , forward_id , backward_id ) result ( elapsed_time ) !! Creates forward and backward transpose plans for backend `DTFFT_BACKEND_MPI_DATATYPE` based on source and target data distributions and, !! executes them `DTFFT_MEASURE_ITERS` times ( 4 * `DTFFT_MEASURE_ITERS` iterations total ) + 4 * `DTFFT_MEASURE_WARMUP_ITERS` warmup iterations !! !! Returns elapsed time for best plans selected type ( backend_helper ), intent ( inout ) :: helper !! Backend helper type ( pencil ), intent ( in ) :: from !! Source meta type ( pencil ), intent ( in ) :: to !! Target meta TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Basic MPI Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store Basic MPI Datatype integer ( int8 ), intent ( in ) :: transpose_name_id !! ID of transpose name (from -3 to 3, except 0) real ( real32 ), intent ( inout ) :: a (:) !! Source buffer real ( real32 ), intent ( inout ) :: b (:) !! Target buffer integer ( int8 ), intent ( out ) :: forward_id !! Best forward plan ID integer ( int8 ), intent ( out ) :: backward_id !! Best backward plan ID real ( real32 ) :: elapsed_time !! Elapsed time for best plans selected real ( real32 ) :: forward_time !! Forward plan execution time real ( real32 ) :: backward_time !! Backward plan execution time real ( real32 ) :: time !! Timer integer ( int8 ) :: datatype_id !! Counter forward_time = huge ( 1._real32 ) backward_time = huge ( 1._real32 ) do datatype_id = 1 , 2 time = get_plan_execution_time ( helper , from , to , base_dtype , base_storage , datatype_id , transpose_name_id , a , b ) if ( time < forward_time ) then forward_time = time forward_id = datatype_id endif time = get_plan_execution_time ( helper , to , from , base_dtype , base_storage , datatype_id , - 1_int8 * transpose_name_id , a , b ) if ( time < backward_time ) then backward_time = time backward_id = datatype_id endif enddo elapsed_time = forward_time + backward_time end function autotune_transpose_id function get_plan_execution_time ( helper , from , to , base_dtype , base_storage , datatype_id , transpose_name_id , a , b ) result ( elapsed_time ) !! Creates transpose plan for backend `DTFFT_BACKEND_MPI_DATATYPE` and executes it `DTFFT_MEASURE_WARMUP_ITERS` + `DTFFT_MEASURE_ITERS` times !! !! Returns elapsed time type ( backend_helper ), intent ( inout ) :: helper !! Backend helper type ( pencil ), intent ( in ) :: from !! Source meta type ( pencil ), intent ( in ) :: to !! Target meta TYPE_MPI_DATATYPE , intent ( in ) :: base_dtype !! Basic MPI Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store Basic MPI Datatype integer ( int8 ), intent ( in ) :: datatype_id !! ID of transpose (1 or 2) integer ( int8 ), intent ( in ) :: transpose_name_id !! ID of transpose name (from -3 to 3, except 0) real ( real32 ), intent ( inout ) :: a (:) !! Source buffer real ( real32 ), intent ( inout ) :: b (:) !! Target buffer real ( real32 ) :: elapsed_time !! Execution time [ms] real ( real32 ) :: time !! Timer character ( len = :), allocatable :: phase_name !! Caliper phase name type ( transpose_handle_datatype ) :: plan !! Transpose plan real ( real64 ) :: ts , te !! Timers integer ( int32 ) :: iter !! Counter integer ( int32 ) :: ierr !! Error code type ( create_args ) :: create_kwargs type ( execute_args ) :: exec_kwargs integer ( int32 ) :: n_iters allocate ( phase_name , source = \"  Testing plan \" // TRANSPOSE_NAMES ( transpose_name_id ) // \", datatype_id = \" // to_str ( datatype_id ) ) REGION_BEGIN ( phase_name , 0 ) WRITE_INFO ( phase_name ) create_kwargs % base_type = base_dtype create_kwargs % datatype_id = datatype_id create_kwargs % helper = helper call plan % create ( from , to , base_storage , create_kwargs ) exec_kwargs % exec_type = EXEC_BLOCKING do iter = 1 , get_conf_measure_warmup_iters () call plan % execute ( a , b , exec_kwargs , ierr ) enddo call MPI_Barrier ( helper % comms ( 1 ), ierr ) n_iters = get_conf_measure_iters () ts = MPI_Wtime () do iter = 1 , n_iters call plan % execute ( a , b , exec_kwargs , ierr ) enddo te = MPI_Wtime () time = real ( te - ts , real32 ) * 100 0._real32 elapsed_time = report_timings ( helper % comms ( 1 ), time , n_iters , 4 ) call plan % destroy () REGION_END ( phase_name ) deallocate ( phase_name ) end function get_plan_execution_time function report_timings ( comm , elapsed_time , n_iters , space_count ) result ( max_time ) TYPE_MPI_COMM , intent ( in ) :: comm real ( real32 ), intent ( in ) :: elapsed_time integer ( int32 ), intent ( in ) :: n_iters integer ( int32 ), optional , intent ( in ) :: space_count real ( real32 ) :: max_time real ( real32 ) :: execution_time , min_time , avg_time integer ( int32 ) :: ierr , comm_size , space_count_ execution_time = elapsed_time / real ( n_iters , real32 ) space_count_ = 2 ; if ( present ( space_count ) ) space_count_ = space_count call MPI_Allreduce ( execution_time , min_time , 1 , MPI_REAL4 , MPI_MIN , comm , ierr ) call MPI_Allreduce ( execution_time , max_time , 1 , MPI_REAL4 , MPI_MAX , comm , ierr ) call MPI_Allreduce ( execution_time , avg_time , 1 , MPI_REAL4 , MPI_SUM , comm , ierr ) call MPI_Comm_size ( comm , comm_size , ierr ) avg_time = avg_time / real ( comm_size , real32 ) WRITE_INFO ( repeat ( \" \" , space_count_ ) // \"max: \" // to_str ( real ( max_time , real64 )) // \" [ms]\" ) WRITE_INFO ( repeat ( \" \" , space_count_ ) // \"min: \" // to_str ( real ( min_time , real64 )) // \" [ms]\" ) WRITE_INFO ( repeat ( \" \" , space_count_ ) // \"avg: \" // to_str ( real ( avg_time , real64 )) // \" [ms]\" ) end function report_timings function get_aux_size ( self ) result ( aux_size ) !! Returns maximum auxiliary memory size needed by transpose plan class ( transpose_plan ), intent ( in ) :: self !! Transposition class integer ( int64 ) :: aux_size aux_size = get_aux_size_generic ( self % plans ) end function get_aux_size function get_aux_size_generic ( plans ) result ( aux_size ) !! Returns maximum auxiliary memory size needed by plans type ( plan_t ), intent ( in ) :: plans (:) !! Transpose plans integer ( int64 ) :: aux_size !! Maximum auxiliary memory size needed integer ( int64 ), allocatable :: worksizes (:) !! Auxiliary memory sizes needed by each plan integer ( int32 ) :: n_transpose_plans , i n_transpose_plans = size ( plans ) allocate ( worksizes ( n_transpose_plans ), source = 0_int64 ) do i = 1 , n_transpose_plans if ( allocated ( plans ( i )% p ) ) then worksizes ( i ) = plans ( i )% p % get_aux_size () endif enddo aux_size = maxval ( worksizes ) deallocate ( worksizes ) end function get_aux_size_generic subroutine alloc_and_set_aux ( platform , helper , backend , cart_comm , aux , paux , plans , is_aux_alloc ) !! Allocates auxiliary memory according to the backend and sets it to the plans type ( dtfft_platform_t ), intent ( in ) :: platform type ( backend_helper ), intent ( inout ) :: helper !! Backend helper type ( dtfft_backend_t ), intent ( in ) :: backend !! GPU backend TYPE_MPI_COMM , intent ( in ) :: cart_comm !! Cartesian communicator type ( c_ptr ), intent ( inout ) :: aux !! Allocatable auxiliary memory real ( real32 ), pointer , intent ( inout ) :: paux (:) !! Pointer to auxiliary memory type ( plan_t ), intent ( in ) :: plans (:) logical :: is_aux_alloc !! Is auxiliary memory allocated integer ( int64 ) :: max_work_size_local , max_work_size_global integer ( int32 ) :: mpi_ierr integer ( int32 ) :: alloc_ierr max_work_size_local = get_aux_size_generic ( plans ) call MPI_Allreduce ( max_work_size_local , max_work_size_global , 1 , MPI_INTEGER8 , MPI_MAX , cart_comm , mpi_ierr ) is_aux_alloc = . false . paux => null () if ( max_work_size_global > 0 ) then call alloc_mem ( platform , helper , backend , cart_comm , max_work_size_global , aux , alloc_ierr ) DTFFT_CHECK ( alloc_ierr ) call c_f_pointer ( aux , paux , [ max_work_size_global / 4_int64 ]) is_aux_alloc = . true . endif end subroutine alloc_and_set_aux subroutine create_pencils_and_comm ( transposed_dims , old_comm , comm_dims , comm , local_comms , pencils , ipencil ) !! Creates cartesian communicator integer ( int32 ), intent ( in ) :: transposed_dims (:,:) !! Global counts in transposed coordinates TYPE_MPI_COMM , intent ( in ) :: old_comm !! Communicator to create cartesian from integer ( int32 ), intent ( in ) :: comm_dims (:) !! Dims in cartesian communicator TYPE_MPI_COMM , intent ( out ) :: comm !! Cartesian communicator TYPE_MPI_COMM , intent ( out ) :: local_comms (:) !! 1d communicators in cartesian communicator type ( pencil ), intent ( out ) :: pencils (:) !! Data distributing meta type ( pencil_init ), intent ( in ), optional :: ipencil !! Pencil passed by user integer ( int8 ) :: ndims !! Number of dimensions integer ( int8 ) :: d !! Counter integer ( int8 ) :: order ( 3 ) ndims = size ( comm_dims , kind = int8 ) order = [ 1_int8 , 3_int8 , 2_int8 ] call create_cart_comm ( old_comm , comm_dims , comm , local_comms , ipencil = ipencil ) if ( present ( ipencil ) ) then block integer ( int32 ), allocatable :: lstarts (:), lcounts (:) allocate ( lstarts , source = ipencil % starts ) allocate ( lcounts , source = ipencil % counts ) do d = 1 , ndims if ( ndims == 3 . and . d == 2 ) then call pencils ( d )% create ( ndims , d , transposed_dims (:, d ), local_comms , lstarts = lstarts , lcounts = lcounts , order = order ) else call pencils ( d )% create ( ndims , d , transposed_dims (:, d ), local_comms , lstarts = lstarts , lcounts = lcounts ) endif lcounts (:) = pencils ( d )% counts (:) lstarts (:) = pencils ( d )% starts (:) enddo deallocate ( lstarts , lcounts ) endblock else do d = 1 , ndims if ( ndims == 3 . and . d == 2 ) then call pencils ( d )% create ( ndims , d , transposed_dims (:, d ), local_comms , order = order ) else call pencils ( d )% create ( ndims , d , transposed_dims (:, d ), local_comms ) endif enddo endif end subroutine create_pencils_and_comm subroutine create_cart_comm ( old_comm , comm_dims , comm , local_comms , ipencil ) !! Creates cartesian communicator TYPE_MPI_COMM , intent ( in ) :: old_comm !! Communicator to create cartesian from integer ( int32 ), intent ( in ) :: comm_dims (:) !! Dims in cartesian communicator TYPE_MPI_COMM , intent ( out ) :: comm !! Cartesian communicator TYPE_MPI_COMM , intent ( out ) :: local_comms (:) !! 1d communicators in cartesian communicator type ( pencil_init ), intent ( in ), optional :: ipencil !! Pencil passed by user logical , allocatable :: periods (:) !! Grid is not periodic logical , allocatable :: remain_dims (:) !! Needed by MPI_Cart_sub integer ( int8 ) :: dim !! Counter integer ( int32 ) :: ierr !! Error code integer ( int8 ) :: ndims TYPE_MPI_COMM :: temp_cart_comm TYPE_MPI_COMM , allocatable :: temp_comms (:) ndims = size ( comm_dims , kind = int8 ) if ( present ( ipencil ) ) then call MPI_Comm_dup ( old_comm , comm , ierr ) do dim = 1 , ndims call MPI_Comm_dup ( ipencil % comms ( dim ), local_comms ( dim ), ierr ) enddo return endif allocate ( periods ( ndims ), source = . false .) call MPI_Cart_create ( old_comm , int ( ndims , int32 ), comm_dims , periods , . true ., temp_cart_comm , ierr ) call create_subcomm_include_all ( temp_cart_comm , comm ) if ( GET_MPI_VALUE ( comm ) == GET_MPI_VALUE ( MPI_COMM_NULL ) ) INTERNAL_ERROR ( \"comm == MPI_COMM_NULL\" ) allocate ( temp_comms ( ndims )) allocate ( remain_dims ( ndims ), source = . false . ) do dim = 1 , ndims remain_dims ( dim ) = . true . call MPI_Cart_sub ( temp_cart_comm , remain_dims , temp_comms ( dim ), ierr ) call create_subcomm_include_all ( temp_comms ( dim ), local_comms ( dim )) if ( GET_MPI_VALUE ( local_comms ( dim )) == GET_MPI_VALUE ( MPI_COMM_NULL ) ) INTERNAL_ERROR ( \"local_comms(dim) == MPI_COMM_NULL: dim = \" // to_str ( dim )) remain_dims ( dim ) = . false . enddo call MPI_Comm_free ( temp_cart_comm , ierr ) do dim = 1 , ndims call MPI_Comm_free ( temp_comms ( dim ), ierr ) enddo deallocate ( temp_comms ) deallocate ( remain_dims , periods ) end subroutine create_cart_comm type ( dtfft_backend_t ) function get_backend ( self ) !! Returns plan GPU backend class ( transpose_plan ), intent ( in ) :: self !! Transposition class get_backend = self % backend end function get_backend subroutine mem_alloc ( self , comm , alloc_bytes , ptr , error_code ) !! Allocates memory based on selected backend class ( transpose_plan ), intent ( inout ) :: self !! Transposition class TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Pointer to the allocated memory integer ( int32 ), intent ( out ) :: error_code !! Error code call alloc_mem ( self % platform , self % helper , self % backend , comm , alloc_bytes , ptr , error_code ) end subroutine mem_alloc subroutine mem_free ( self , ptr , error_code ) !! Frees memory allocated with mem_alloc class ( transpose_plan ), intent ( inout ) :: self !! Transposition class type ( c_ptr ), intent ( in ) :: ptr !! Pointer to the memory to free integer ( int32 ), intent ( out ) :: error_code !! Error code call free_mem ( self % platform , self % helper , self % backend , ptr , error_code ) end subroutine mem_free subroutine alloc_mem ( platform , helper , backend , comm , alloc_bytes , ptr , error_code ) !! Allocates memory based on ``backend`` type ( dtfft_platform_t ), intent ( in ) :: platform type ( backend_helper ), intent ( inout ) :: helper !! Backend helper type ( dtfft_backend_t ), intent ( in ) :: backend !! GPU backend TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Pointer to the allocated memory integer ( int32 ), intent ( out ) :: error_code !! Error code #ifdef DTFFT_WITH_CUDA integer ( int64 ) :: free_mem_avail , total_mem_avail #endif error_code = DTFFT_SUCCESS if ( platform == DTFFT_PLATFORM_HOST ) then ptr = mem_alloc_host ( alloc_bytes ) #ifdef DTFFT_WITH_CUDA else CUDA_CALL ( cudaMemGetInfo ( free_mem_avail , total_mem_avail ) ) # ifdef DTFFT_DEBUG block integer ( int64 ) :: min_mem , max_mem , min_free_mem , max_free_mem integer ( int32 ) :: mpi_err call MPI_Allreduce ( alloc_bytes , max_mem , 1 , MPI_INTEGER8 , MPI_MAX , comm , mpi_err ) call MPI_Allreduce ( alloc_bytes , min_mem , 1 , MPI_INTEGER8 , MPI_MIN , comm , mpi_err ) call MPI_Allreduce ( free_mem_avail , max_free_mem , 1 , MPI_INTEGER8 , MPI_MAX , comm , mpi_err ) call MPI_Allreduce ( free_mem_avail , min_free_mem , 1 , MPI_INTEGER8 , MPI_MIN , comm , mpi_err ) WRITE_DEBUG ( \"Trying to allocate \" // to_str ( min_mem ) // \"/\" // to_str ( max_mem ) // \" (min/max) bytes for backend: '\" // dtfft_get_backend_string ( backend ) // \"'\" ) WRITE_DEBUG ( \"Free memory available: \" // to_str ( min_free_mem ) // \"/\" // to_str ( max_free_mem ) // \" (min/max) bytes\" ) endblock # endif if ( alloc_bytes > free_mem_avail ) then error_code = DTFFT_ERROR_ALLOC_FAILED return endif if ( is_backend_nccl ( backend ) ) then # ifdef DTFFT_WITH_NCCL #   ifdef NCCL_HAVE_MEMALLOC error_code = ncclMemAlloc ( ptr , alloc_bytes ) #   else error_code = cudaMalloc ( ptr , alloc_bytes ) #   endif #   ifdef NCCL_HAVE_COMMREGISTER if ( error_code == cudaSuccess . and . helper % should_register ) then block type ( c_ptr ), allocatable :: temp (:,:) type ( c_ptr ) :: handle if ( size ( helper % nccl_register , dim = 2 ) == helper % nccl_register_size ) then allocate ( temp ( 2 , helper % nccl_register_size + NCCL_REGISTER_PREALLOC_SIZE ) ) temp ( 2 , 1 : helper % nccl_register_size ) = helper % nccl_register ( 2 , 1 : helper % nccl_register_size ) deallocate ( helper % nccl_register ) call move_alloc ( temp , helper % nccl_register ) endif helper % nccl_register_size = helper % nccl_register_size + 1 NCCL_CALL ( ncclCommRegister ( helper % nccl_comm , ptr , alloc_bytes , handle ) ) helper % nccl_register ( 1 , helper % nccl_register_size ) = ptr helper % nccl_register ( 2 , helper % nccl_register_size ) = handle WRITE_DEBUG ( \"Registered pointer \" // to_str ( transfer ( ptr , int64 ))) endblock endif #   endif # else INTERNAL_ERROR ( \"not DTFFT_WITH_NCCL\" ) # endif else if ( is_backend_nvshmem ( backend ) ) then # ifdef DTFFT_WITH_NVSHMEM block integer ( int64 ) :: max_alloc_bytes integer ( int32 ) :: mpi_err call MPI_Allreduce ( alloc_bytes , max_alloc_bytes , 1 , MPI_INTEGER8 , MPI_MAX , comm , mpi_err ) ptr = nvshmem_malloc ( max_alloc_bytes ) if ( is_null_ptr ( ptr ) ) error_code = DTFFT_ERROR_ALLOC_FAILED endblock # else INTERNAL_ERROR ( \"not DTFFT_WITH_NVSHMEM\" ) # endif else error_code = cudaMalloc ( ptr , alloc_bytes ) endif #endif endif if ( error_code /= DTFFT_SUCCESS ) error_code = DTFFT_ERROR_ALLOC_FAILED end subroutine alloc_mem subroutine free_mem ( platform , helper , backend , ptr , error_code ) !! Frees memory based on ``backend`` type ( dtfft_platform_t ), intent ( in ) :: platform type ( backend_helper ), intent ( inout ) :: helper !! Backend helper type ( dtfft_backend_t ), intent ( in ) :: backend !! GPU backend type ( c_ptr ), intent ( in ) :: ptr !! Pointer to the memory to free integer ( int32 ), intent ( out ) :: error_code !! Error code error_code = DTFFT_SUCCESS if ( platform == DTFFT_PLATFORM_HOST ) then call mem_free_host ( ptr ) #ifdef DTFFT_WITH_CUDA else if ( is_backend_nccl ( backend ) ) then # ifdef NCCL_HAVE_COMMREGISTER if ( helper % should_register ) then block integer ( int32 ) :: i do i = 1 , size ( helper % nccl_register , dim = 2 ) if ( . not . is_same_ptr ( ptr , helper % nccl_register ( 1 , i )) ) cycle NCCL_CALL ( ncclCommDeregister ( helper % nccl_comm , helper % nccl_register ( 2 , i )) ) helper % nccl_register ( 1 , i ) = c_null_ptr helper % nccl_register ( 2 , i ) = c_null_ptr helper % nccl_register_size = helper % nccl_register_size - 1 WRITE_DEBUG ( \"Pointer \" // to_str ( transfer ( ptr , int64 )) // \" has been removed from registry\" ) enddo endblock endif # endif # ifdef DTFFT_WITH_NCCL #   ifdef NCCL_HAVE_MEMALLOC error_code = ncclMemFree ( ptr ) #   else error_code = cudaFree ( ptr ) #   endif # else INTERNAL_ERROR ( \"not DTFFT_WITH_NCCL\" ) # endif else if ( is_backend_nvshmem ( backend ) ) then # ifdef DTFFT_WITH_NVSHMEM call nvshmem_free ( ptr ) # else INTERNAL_ERROR ( \"not DTFFT_WITH_NVSHMEM\" ) # endif else error_code = cudaFree ( ptr ) endif #endif endif if ( error_code /= DTFFT_SUCCESS ) error_code = DTFFT_ERROR_FREE_FAILED end subroutine free_mem end module dtfft_transpose_plan","tags":"","loc":"sourcefile/dtfft_transpose_plan.f90.html"},{"title":"dtfft_transpose_handle_generic.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_transpose_handle_generic.f90~~EfferentGraph sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_transpose_handle_generic.f90~~AfferentGraph sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_transpose_handle_generic !! This module describes [[transpose_handle_generic]] class !! It is responsible for managing both Host and CUDA-based transposition operations !! It executes transpose kernels, memory transfers between GPUs/Hosts, and data unpacking if required use iso_c_binding , only : c_ptr , c_f_pointer use iso_fortran_env , only : int8 , int32 , int64 , real32 use dtfft_abstract_backend , only : abstract_backend , backend_helper use dtfft_abstract_kernel use dtfft_abstract_transpose_handle , only : abstract_transpose_handle , create_args , execute_args #ifdef DTFFT_WITH_NVSHMEM use dtfft_backend_cufftmp_m , only : backend_cufftmp #endif #ifdef DTFFT_WITH_NCCL use dtfft_backend_nccl_m , only : backend_nccl #endif use dtfft_backend_mpi , only : backend_mpi use dtfft_errors #ifdef DTFFT_WITH_CUDA use dtfft_kernel_device , only : kernel_device #endif use dtfft_kernel_host , only : kernel_host use dtfft_pencil , only : pencil , get_transpose_type use dtfft_parameters use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" implicit none private public :: transpose_handle_generic type :: data_handle !! Helper class used to obtain displacements and !! counts needed to send to other processes integer ( int32 ), allocatable :: ls (:,:) !! Starts of my data that I should send or recv !! while communicating with other processes integer ( int32 ), allocatable :: ln (:,:) !! Counts of my data that I should send or recv !! while communicating with other processes integer ( int32 ), allocatable :: sizes (:,:) !! Counts of every rank in a comm integer ( int32 ), allocatable :: starts (:,:) !! Starts of every rank in a comm integer ( int32 ), allocatable :: displs (:) !! Local buffer displacement integer ( int32 ), allocatable :: counts (:) !! Number of elements to send or recv contains procedure , pass ( self ) :: create => create_data_handle !! Creates handle procedure , pass ( self ) :: destroy => destroy_data_handle !! Destroys handle end type data_handle type , extends ( abstract_transpose_handle ) :: transpose_handle_generic !! Generic Transpose Handle !! Executes transposition in 3 steps: !! !! - Transpose kernel execution !! - Data exchange between processes !! - Unpacking kernel execution private logical :: has_exchange = . false . !! If current handle has exchanges between GPUs logical :: is_pipelined = . false . !! If underlying exchanges are pipelined logical :: is_async_supported = . false . !! If underlying backend support async execution(execute/execute_end) class ( abstract_kernel ), allocatable :: transpose_kernel !! Kernel for data transposition class ( abstract_kernel ), allocatable :: unpack_kernel !! Kernel for unpacking data class ( abstract_backend ), allocatable :: comm_handle !! Communication handle contains procedure , pass ( self ) :: create_private => create !! Creates Generic Transpose Handle procedure , pass ( self ) :: execute !! Executes transpose - exchange - unpack procedure , pass ( self ) :: execute_end !! Finalizes async transpose procedure , pass ( self ) :: get_async_active !! Returns if async transpose is active procedure , pass ( self ) :: destroy !! Destroys Generic Transpose Handle procedure , pass ( self ) :: get_aux_size !! Returns number of bytes required by aux buffer end type transpose_handle_generic contains subroutine create_data_handle ( self , info , comm , comm_size ) !! Creates handle class ( data_handle ), intent ( inout ) :: self !! Helper class type ( pencil ), intent ( in ) :: info !! Pencil info TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator integer ( int32 ), intent ( in ) :: comm_size !! Size of ``comm`` integer ( int32 ) :: ierr !! MPI error flag allocate ( self % ls ( info % rank , 0 : comm_size - 1 ), source = 0_int32 ) allocate ( self % ln ( info % rank , 0 : comm_size - 1 ), source = 0_int32 ) allocate ( self % sizes ( info % rank , 0 : comm_size - 1 ) ) allocate ( self % starts ( info % rank , 0 : comm_size - 1 ) ) allocate ( self % displs ( 0 : comm_size - 1 ), source = 0_int32 ) allocate ( self % counts ( 0 : comm_size - 1 ), source = 0_int32 ) call MPI_Allgather ( info % counts , int ( info % rank , int32 ), MPI_INTEGER , self % sizes , int ( info % rank , int32 ), MPI_INTEGER , comm , ierr ) call MPI_Allgather ( info % starts , int ( info % rank , int32 ), MPI_INTEGER , self % starts , int ( info % rank , int32 ), MPI_INTEGER , comm , ierr ) end subroutine create_data_handle subroutine destroy_data_handle ( self ) !! Destroys handle class ( data_handle ), intent ( inout ) :: self !! Helper class if ( allocated ( self % ls )) deallocate ( self % ls ) if ( allocated ( self % ln )) deallocate ( self % ln ) if ( allocated ( self % sizes )) deallocate ( self % sizes ) if ( allocated ( self % starts )) deallocate ( self % starts ) if ( allocated ( self % displs )) deallocate ( self % displs ) if ( allocated ( self % counts )) deallocate ( self % counts ) end subroutine destroy_data_handle subroutine check_if_overflow ( sizes ) !! Checks if product of sizes fits into integer(int32) integer ( int32 ), intent ( in ) :: sizes (:) !! Sizes to check integer ( int64 ) :: sizes_prod !! Product of sizes integer ( int32 ) :: i !! Counter sizes_prod = 1_int64 do i = 1 , size ( sizes ) sizes_prod = sizes_prod * int ( sizes ( i ), int64 ) enddo if ( sizes_prod /= product ( sizes ) ) then INTERNAL_ERROR ( \"integer(int64) indexing currently not supported\" ) endif end subroutine check_if_overflow subroutine create ( self , comm , send , recv , transpose_type , base_storage , kwargs ) !! Creates Generic Transpose Handle class ( transpose_handle_generic ), intent ( inout ) :: self !! Generic Transpose Handle TYPE_MPI_COMM , intent ( in ) :: comm !! MPI Communicator type ( pencil ), intent ( in ) :: send !! Send pencil type ( pencil ), intent ( in ) :: recv !! Recv pencil type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transpose to create integer ( int64 ), intent ( in ) :: base_storage !! Base storage type ( create_args ), intent ( in ) :: kwargs !! Additional arguments integer ( int8 ) :: ndims !! Number of dimensions integer ( int32 ) :: comm_size !! Size of ``comm`` integer ( int32 ) :: comm_rank !! Rank in ``comm`` integer ( int32 ) :: ierr !! MPI error flag integer ( int32 ) :: sdispl !! Send displacement integer ( int32 ) :: rdispl !! Recv displacement integer ( int32 ) :: sendsize !! Number of elements to send integer ( int32 ) :: recvsize !! Number of elements to recieve integer ( int32 ) :: i !! Counter TYPE_MPI_REQUEST :: sr !! Send request TYPE_MPI_REQUEST :: rr !! Recv request type ( kernel_type_t ) :: kernel_type !! Type of kernel integer ( int32 ), allocatable :: neighbor_data (:,:) !! Aggregated neighbor data type ( data_handle ) :: in !! Send helper type ( data_handle ) :: out !! Recv helper logical :: is_two_step_permute !! If transpose is two-step permute call self % destroy () call check_if_overflow ( send % counts ) call check_if_overflow ( recv % counts ) if ( kwargs % platform == DTFFT_PLATFORM_HOST ) then allocate ( kernel_host :: self % transpose_kernel ) allocate ( kernel_host :: self % unpack_kernel ) #ifdef DTFFT_WITH_CUDA else allocate ( kernel_device :: self % transpose_kernel ) allocate ( kernel_device :: self % unpack_kernel ) #endif endif call MPI_Comm_size ( comm , comm_size , ierr ) call MPI_Comm_rank ( comm , comm_rank , ierr ) self % has_exchange = comm_size > 1 if ( any ( transpose_type == [ DTFFT_TRANSPOSE_X_TO_Y , DTFFT_TRANSPOSE_Y_TO_Z , DTFFT_TRANSPOSE_Z_TO_X ] ) ) then kernel_type = KERNEL_PERMUTE_FORWARD else kernel_type = KERNEL_PERMUTE_BACKWARD endif if ( . not . self % has_exchange ) then self % is_pipelined = . false . self % is_async_supported = . false . call self % transpose_kernel % create ( send % counts , kwargs % effort , base_storage , kernel_type , force_effort = kwargs % force_effort ) return endif allocate ( neighbor_data ( 5 , comm_size ), source = 0_int32 ) call in % create ( send , comm , comm_size ) call out % create ( recv , comm , comm_size ) ndims = send % rank sdispl = 0 do i = 0 , comm_size - 1 ! Finding amount of data to send to rank i if ( ndims == 2 ) then in % ln ( 1 , i ) = out % sizes ( 2 , i ) in % ln ( 2 , i ) = in % sizes ( 2 , comm_rank ) in % ls ( 1 , i ) = out % starts ( 2 , i ) in % ls ( 2 , i ) = in % starts ( 2 , comm_rank ) else if ( transpose_type == DTFFT_TRANSPOSE_X_TO_Z ) then in % ln ( 1 , i ) = in % sizes ( 1 , comm_rank ) in % ln ( 2 , i ) = out % sizes ( 3 , i ) in % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) in % ls ( 1 , i ) = in % starts ( 1 , comm_rank ) in % ls ( 2 , i ) = out % starts ( 3 , i ) in % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) else if ( transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then in % ln ( 1 , i ) = out % sizes ( 3 , i ) in % ln ( 2 , i ) = in % sizes ( 2 , comm_rank ) in % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) in % ls ( 1 , i ) = out % starts ( 3 , i ) in % ls ( 2 , i ) = in % starts ( 2 , comm_rank ) in % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) else if ( kernel_type == KERNEL_PERMUTE_FORWARD ) then in % ln ( 1 , i ) = out % sizes ( 3 , i ) in % ln ( 2 , i ) = in % sizes ( 2 , comm_rank ) in % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) in % ls ( 1 , i ) = out % starts ( 3 , i ) in % ls ( 2 , i ) = in % starts ( 2 , comm_rank ) in % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) else in % ln ( 1 , i ) = out % sizes ( 2 , i ) in % ln ( 2 , i ) = in % sizes ( 2 , comm_rank ) in % ln ( 3 , i ) = in % sizes ( 3 , comm_rank ) in % ls ( 1 , i ) = out % starts ( 2 , i ) in % ls ( 2 , i ) = in % starts ( 2 , comm_rank ) in % ls ( 3 , i ) = in % starts ( 3 , comm_rank ) endif endif sendsize = product ( in % ln (:, i ) ) in % counts ( i ) = sendsize in % displs ( i ) = sdispl sdispl = sdispl + sendsize ! Sending with tag = me to rank i call MPI_Isend ( sendsize , 1 , MPI_INTEGER4 , i , comm_rank , comm , sr , ierr ) call MPI_Wait ( sr , MPI_STATUS_IGNORE , ierr ) enddo rdispl = 0 do i = 0 , comm_size - 1 ! Recieving from i with tag i call MPI_Irecv ( recvsize , 1 , MPI_INTEGER4 , i , i , comm , rr , ierr ) call MPI_Wait ( rr , MPI_STATUS_IGNORE , ierr ) if ( recvsize > 0 ) then if ( ndims == 2 ) then out % ln ( 1 , i ) = in % sizes ( 2 , i ) out % ln ( 2 , i ) = out % sizes ( 2 , comm_rank ) out % ls ( 1 , i ) = in % starts ( 2 , i ) out % ls ( 2 , i ) = out % starts ( 2 , comm_rank ) else if ( transpose_type == DTFFT_TRANSPOSE_X_TO_Z ) then out % ln ( 1 , i ) = in % sizes ( 3 , i ) out % ln ( 2 , i ) = out % sizes ( 2 , comm_rank ) out % ln ( 3 , i ) = out % sizes ( 3 , comm_rank ) out % ls ( 1 , i ) = in % starts ( 3 , i ) out % ls ( 2 , i ) = out % starts ( 2 , comm_rank ) out % ls ( 3 , i ) = out % starts ( 3 , comm_rank ) else if ( transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then out % ln ( 1 , i ) = out % sizes ( 1 , comm_rank ) out % ln ( 2 , i ) = in % sizes ( 3 , i ) out % ln ( 3 , i ) = out % sizes ( 3 , comm_rank ) out % ls ( 1 , i ) = out % starts ( 1 , comm_rank ) out % ls ( 2 , i ) = in % starts ( 3 , i ) out % ls ( 3 , i ) = out % starts ( 3 , comm_rank ) else if ( kernel_type == KERNEL_PERMUTE_FORWARD ) then out % ln ( 1 , i ) = in % sizes ( 2 , i ) out % ln ( 2 , i ) = out % sizes ( 2 , comm_rank ) out % ln ( 3 , i ) = out % sizes ( 3 , comm_rank ) out % ls ( 1 , i ) = in % starts ( 2 , i ) out % ls ( 2 , i ) = in % starts ( 2 , comm_rank ) out % ls ( 3 , i ) = out % starts ( 3 , comm_rank ) else ! ZXY -> YZX ! YZX -> XYZ out % ln ( 1 , i ) = in % sizes ( 3 , i ) out % ln ( 2 , i ) = out % sizes ( 2 , comm_rank ) out % ln ( 3 , i ) = out % sizes ( 3 , comm_rank ) out % ls ( 1 , i ) = in % starts ( 3 , i ) out % ls ( 2 , i ) = in % starts ( 2 , comm_rank ) out % ls ( 3 , i ) = out % starts ( 3 , comm_rank ) endif endif endif neighbor_data ( 1 , i + 1 ) = out % ln ( 1 , i ) neighbor_data ( 2 , i + 1 ) = out % ln ( 2 , i ) if ( ndims == 3 ) then neighbor_data ( 3 , i + 1 ) = out % ln ( 3 , i ) else neighbor_data ( 3 , i + 1 ) = 1 endif neighbor_data ( 4 , i + 1 ) = rdispl if ( transpose_type == DTFFT_TRANSPOSE_Z_TO_X ) then neighbor_data ( 5 , i + 1 ) = out % ln ( 1 , i ) * out % ls ( 2 , i ) ! out%sizes(1, comm_rank) * out%sizes(2, comm_rank) else neighbor_data ( 5 , i + 1 ) = out % ls ( 1 , i ) endif out % counts ( i ) = recvsize out % displs ( i ) = rdispl rdispl = rdispl + recvsize enddo is_two_step_permute = any ( transpose_type == [ DTFFT_TRANSPOSE_Y_TO_X , DTFFT_TRANSPOSE_Z_TO_Y ]) & . and . ndims == 3 & . and . (. not . any ( kwargs % backend == [ DTFFT_BACKEND_CUFFTMP , DTFFT_BACKEND_CUFFTMP_PIPELINED ])) if ( is_two_step_permute ) kernel_type = KERNEL_PERMUTE_BACKWARD_START call self % transpose_kernel % create ( send % counts , kwargs % effort , base_storage , kernel_type , force_effort = kwargs % force_effort ) self % is_pipelined = is_backend_pipelined ( kwargs % backend ) kernel_type = KERNEL_UNPACK if ( self % is_pipelined ) kernel_type = KERNEL_UNPACK_PIPELINED if ( is_two_step_permute ) kernel_type = KERNEL_PERMUTE_BACKWARD_END if ( self % is_pipelined . and . is_two_step_permute ) kernel_type = KERNEL_PERMUTE_BACKWARD_END_PIPELINED if ( kwargs % backend == DTFFT_BACKEND_CUFFTMP ) kernel_type = KERNEL_UNPACK_SIMPLE_COPY if ( kwargs % backend == DTFFT_BACKEND_CUFFTMP_PIPELINED ) kernel_type = KERNEL_DUMMY call self % unpack_kernel % create ( recv % counts , kwargs % effort , base_storage , kernel_type , neighbor_data , kwargs % force_effort ) if ( is_backend_mpi ( kwargs % backend ) ) then allocate ( backend_mpi :: self % comm_handle ) #ifdef DTFFT_WITH_CUDA else if ( is_backend_nccl ( kwargs % backend ) ) then # ifdef DTFFT_WITH_NCCL allocate ( backend_nccl :: self % comm_handle ) # else INTERNAL_ERROR ( \"not DTFFT_WITH_NCCL\" ) # endif else if ( is_backend_cufftmp ( kwargs % backend ) ) then # ifdef DTFFT_WITH_NVSHMEM allocate ( backend_cufftmp :: self % comm_handle ) # else INTERNAL_ERROR ( \"not DTFFT_WITH_NVSHMEM\" ) # endif #endif else INTERNAL_ERROR ( \"Unknown backend\" ) endif self % is_async_supported = is_backend_mpi ( kwargs % backend ) & . and . . not . self % is_pipelined & . and . kwargs % platform == DTFFT_PLATFORM_HOST call self % comm_handle % create ( kwargs % backend , kwargs % helper , kwargs % platform , kwargs % comm_id , in % displs , in % counts , out % displs , out % counts , base_storage ) if ( self % is_pipelined ) then call self % comm_handle % set_unpack_kernel ( self % unpack_kernel ) endif call in % destroy () call out % destroy () deallocate ( neighbor_data ) end subroutine create subroutine execute ( self , in , out , kwargs , error_code ) !! Executes transpose - exchange - unpack class ( transpose_handle_generic ), intent ( inout ) :: self !! Generic Transpose Handle real ( real32 ), intent ( inout ) :: in (:) !! Send pointer real ( real32 ), intent ( inout ) :: out (:) !! Recv pointer type ( execute_args ), intent ( inout ) :: kwargs !! Additional arguments integer ( int32 ), intent ( out ) :: error_code !! Error code error_code = DTFFT_SUCCESS if ( self % is_pipelined ) then call self % transpose_kernel % execute ( in , kwargs % p1 , kwargs % stream ) call self % comm_handle % execute ( kwargs % p1 , out , kwargs % stream , in , kwargs % exec_type , error_code ) return endif call self % transpose_kernel % execute ( in , out , kwargs % stream ) if ( . not . self % has_exchange ) return call self % comm_handle % execute ( out , in , kwargs % stream , kwargs % p1 , kwargs % exec_type , error_code ) if ( error_code /= DTFFT_SUCCESS ) return if ( self % is_async_supported . and . kwargs % exec_type == EXEC_NONBLOCKING ) return call self % unpack_kernel % execute ( in , out , kwargs % stream ) end subroutine execute subroutine execute_end ( self , kwargs , error_code ) !! Ends execution of transposition class ( transpose_handle_generic ), intent ( inout ) :: self !! Generic Transpose Handle type ( execute_args ), intent ( inout ) :: kwargs !! Additional arguments integer ( int32 ), intent ( out ) :: error_code !! Error code error_code = DTFFT_SUCCESS if ( . not . self % is_async_supported ) return call self % comm_handle % execute_end ( error_code ) if ( error_code /= DTFFT_SUCCESS ) return call self % unpack_kernel % execute ( kwargs % p1 , kwargs % p2 , kwargs % stream ) end subroutine execute_end elemental logical function get_async_active ( self ) class ( transpose_handle_generic ), intent ( in ) :: self !! Generic Transpose Handle get_async_active = . false . if ( . not . self % is_async_supported ) return get_async_active = self % comm_handle % get_async_active () end function get_async_active subroutine destroy ( self ) !! Destroys Generic Transpose Handle class ( transpose_handle_generic ), intent ( inout ) :: self !! Generic Transpose Handle if ( allocated ( self % transpose_kernel ) ) then call self % transpose_kernel % destroy () deallocate ( self % transpose_kernel ) endif if ( allocated ( self % comm_handle ) ) then call self % comm_handle % destroy () deallocate ( self % comm_handle ) endif if ( allocated ( self % unpack_kernel ) ) then call self % unpack_kernel % destroy () deallocate ( self % unpack_kernel ) endif end subroutine destroy pure integer ( int64 ) function get_aux_size ( self ) !! Returns number of bytes required by aux buffer class ( transpose_handle_generic ), intent ( in ) :: self !! Generic Transpose Handle if ( . not . self % has_exchange ) then get_aux_size = 0 return endif get_aux_size = self % comm_handle % get_aux_size () end function get_aux_size end module dtfft_transpose_handle_generic","tags":"","loc":"sourcefile/dtfft_transpose_handle_generic.f90.html"},{"title":"dtfft_nvrtc_block_optimizer.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_nvrtc_block_optimizer.f90~~EfferentGraph sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_nvrtc_block_optimizer.f90~~AfferentGraph sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_nvrtc_block_optimizer !! Module that provides functionality to analytically optimize CUDA kernel configurations use iso_fortran_env use dtfft_abstract_kernel use dtfft_config , only : get_conf_log_enabled use dtfft_interface_cuda , only : dim3 use dtfft_interface_cuda_runtime use dtfft_parameters use dtfft_utils #include \"_dtfft_private.h\" implicit none private public :: generate_candidates public :: evaluate_analytical_performance public :: get_ampere_architecture , get_volta_architecture public :: count_bank_conflicts public :: sort_candidates_by_score integer ( int32 ), parameter :: NUM_BANKS = 32 !! Number of banks in shared memory integer ( int32 ), parameter :: WARP_SIZE = 32 !! Warp size in threads integer ( int32 ), parameter :: BANK_WIDTH_BYTES = 4 !! Bank width in bytes integer ( int32 ), parameter , public :: N_TILES_CANDIDATES = 5 !! Maximum number of tile candidates to generate integer ( int32 ), parameter , public :: N_BLOCKS_CANDIDATES = 5 !! Maximum number of block candidates to generate integer ( int32 ), parameter , public :: N_CANDIDATES = N_TILES_CANDIDATES * N_BLOCKS_CANDIDATES !! Maximum number of candidates to generate type , public :: kernel_config !! Configuration for the potential kernel ! type(dim3)      :: blocks     !! Number of blocks in the grid ! type(dim3)      :: threads    !! Number of threads per block integer ( int32 ) :: tile_size !! Tile size (number of columns) integer ( int32 ) :: block_rows !! Block rows integer ( int32 ) :: padding !! Padding added to the tile end type kernel_config contains function get_ampere_architecture () result ( props ) !! Ampere architecture (Compute Capability 8.0) type ( device_props ) :: props !! Ampere architecture properties props % sm_count = 108 props % max_threads_per_sm = 2048 props % max_blocks_per_sm = 32 props % shared_mem_per_sm = 164 * 1024 props % max_threads_per_block = 1024 props % shared_mem_per_block = 48 * 1024 props % l2_cache_size = 40960 * 1024 props % compute_capability_major = 8 props % compute_capability_minor = 0 end function get_ampere_architecture function get_volta_architecture () result ( props ) !! Volta architecture (Compute Capability 7.0) type ( device_props ) :: props !! Volta architecture properties props % sm_count = 80 props % max_threads_per_sm = 2048 props % max_blocks_per_sm = 32 props % shared_mem_per_sm = 96 * 1024 props % max_threads_per_block = 1024 props % shared_mem_per_block = 48 * 1024 props % l2_cache_size = 6144 * 1024 props % compute_capability_major = 7 props % compute_capability_minor = 0 end function get_volta_architecture pure function count_bank_conflicts ( tile_size , block_rows , base_storage , padding ) result ( total_conflicts ) !! Counts bank conflicts for a given tile size, padding, element size, and block rows. integer ( int32 ), intent ( in ) :: tile_size !! Size of the tile integer ( int32 ), intent ( in ) :: block_rows !! Number of rows in the block integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ), intent ( in ) :: padding !! Padding added to the tile integer ( int32 ) :: total_conflicts !! Total number of bank conflicts integer ( int32 ) :: stride !! Stride of the tile integer ( int32 ) :: thread_idx !! Thread index within the warp integer ( int32 ) :: bank !! Bank index integer ( int32 ) :: element_address !! Address of the element integer ( int32 ) :: address_in_bytes !! Address of the element in bytes integer ( int32 ) :: bank_accesses ( 0 : NUM_BANKS - 1 ) !! Array to count bank accesses integer ( int32 ) :: thread_x !! Thread index in the x dimension integer ( int32 ) :: thread_y !! Thread index in the y dimension integer ( int32 ) :: load_conflicts !! Number of load bank conflicts integer ( int32 ) :: store_conflicts !! Number of store bank conflicts integer ( int32 ) :: offset !! Offset for the tile ! Check for validity if ( block_rows > tile_size ) then total_conflicts = MAX_INT32 return end if ! Shared memory: T tile[TILE_DIM][TILE_DIM + padding] ! stride = tile_size + padding stride = tile_size + padding load_conflicts = 0 ! Computing write conflicts do offset = 0 , tile_size - 1 , block_rows bank_accesses (:) = 0 do thread_idx = 0 , WARP_SIZE - 1 thread_x = mod ( thread_idx , tile_size ) thread_y = thread_idx / tile_size if ( thread_y >= block_rows ) cycle if ( thread_y + offset >= tile_size ) cycle ! Load address: tile[threadIdx.x][threadIdx.y + y_offset] element_address = thread_x * stride + ( thread_y + offset ) address_in_bytes = element_address * int ( base_storage , int32 ) bank = mod ( address_in_bytes / BANK_WIDTH_BYTES , NUM_BANKS ) bank_accesses ( bank ) = bank_accesses ( bank ) + 1 end do do bank = 0 , NUM_BANKS - 1 if ( bank_accesses ( bank ) > 1 ) then load_conflicts = load_conflicts + ( bank_accesses ( bank ) - 1 ) end if end do end do ! Computing read conflicts store_conflicts = 0 do offset = 0 , tile_size - 1 , block_rows bank_accesses (:) = 0 do thread_idx = 0 , WARP_SIZE - 1 thread_x = mod ( thread_idx , tile_size ) thread_y = thread_idx / tile_size if ( thread_y >= block_rows ) cycle if ( thread_y + offset >= tile_size ) cycle ! Read address: tile[threadIdx.y + offset][threadIdx.x] element_address = ( thread_y + offset ) * stride + thread_x address_in_bytes = element_address * int ( base_storage , int32 ) bank = mod ( address_in_bytes / BANK_WIDTH_BYTES , NUM_BANKS ) bank_accesses ( bank ) = bank_accesses ( bank ) + 1 end do do bank = 0 , NUM_BANKS - 1 if ( bank_accesses ( bank ) > 1 ) then store_conflicts = store_conflicts + ( bank_accesses ( bank ) - 1 ) end if end do end do total_conflicts = load_conflicts + store_conflicts end function count_bank_conflicts pure function estimate_optimal_padding ( tile_size , block_rows , base_storage ) result ( padding ) !! Estimates the optimal padding for a given tile size and element size integer ( int32 ), intent ( in ) :: tile_size !! Size of the tile integer ( int32 ), intent ( in ) :: block_rows !! Number of rows in the block integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ) :: padding !! Optimal padding to reduce bank conflicts integer ( int32 ) :: best_padding !! Best padding found integer ( int32 ) :: min_conflicts !! Minimum conflicts found integer ( int32 ) :: n_conflicts !! Number of bank conflicts for the current padding best_padding = 1 ! This is default, works in most cases min_conflicts = MAX_INT32 ! Starting from 1. We do not consider zero padding do padding = 1 , 8 n_conflicts = count_bank_conflicts ( tile_size , block_rows , base_storage , padding ) if ( n_conflicts < min_conflicts ) then min_conflicts = n_conflicts best_padding = padding ! Early exit in case of best padding found if ( n_conflicts == 0 ) exit end if end do padding = best_padding end function estimate_optimal_padding pure function estimate_bank_conflict_ratio ( config , base_storage ) result ( ratio ) !! Estimates the bank conflict ratio for a given kernel configuration type ( kernel_config ), intent ( in ) :: config !! Kernel configuration integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element real ( real32 ) :: ratio !! Bank conflict estimation integer ( int32 ) :: actual_conflicts !! Actual number of bank conflicts for given configuration integer ( int32 ) :: worst_case_conflicts !! Worst-case number of bank conflicts for given configuration actual_conflicts = count_bank_conflicts ( config % tile_size , config % block_rows , base_storage , config % padding ) if ( actual_conflicts == MAX_INT32 ) then ! Invalid configuration, return immediately ratio = 1.0 return end if ! Worst case is using same configuration but without padding worst_case_conflicts = count_bank_conflicts ( config % tile_size , config % block_rows , base_storage , 0 ) ! Worst case can also have no conflicts if ( worst_case_conflicts > 0 ) then ratio = real ( actual_conflicts ) / real ( worst_case_conflicts ) ratio = max ( 0.0 , min ( 1.0 , ratio )) else ratio = 0.0 end if end function estimate_bank_conflict_ratio pure function estimate_occupancy ( config , props , base_storage ) result ( occupancy ) !! Calculates theoretical occupancy for a given kernel configuration type ( kernel_config ), intent ( in ) :: config !! Kernel configuration type ( device_props ), intent ( in ) :: props !! GPU architecture properties integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element real ( real32 ) :: occupancy !! Estimated occupancy integer ( int32 ) :: threads_per_block !! Number of threads per block integer ( int32 ) :: max_blocks_by_threads !! Maximum number of blocks by threads integer ( int32 ) :: max_blocks_by_shared_mem !! Maximum number of blocks by shared memory integer ( int32 ) :: max_active_blocks !! Maximum number of active blocks integer ( int64 ) :: shared_mem_per_block !! Shared memory per block ! Limits by number of threads in multiprocessor threads_per_block = config % tile_size * config % block_rows if ( threads_per_block > 0 ) then max_blocks_by_threads = props % max_threads_per_sm / threads_per_block else max_blocks_by_threads = 0 end if ! Limits by shared memory in multiprocessor shared_mem_per_block = config % tile_size * ( config % tile_size + config % padding ) * base_storage if ( shared_mem_per_block > 0 ) then max_blocks_by_shared_mem = int ( props % shared_mem_per_sm / shared_mem_per_block , int32 ) else max_blocks_by_shared_mem = props % max_blocks_per_sm end if max_active_blocks = min ( max_blocks_by_threads , max_blocks_by_shared_mem , props % max_blocks_per_sm ) if ( props % max_threads_per_sm > 0 ) then occupancy = real ( max_active_blocks * threads_per_block , real32 ) / real ( props % max_threads_per_sm , real32 ) else occupancy = 0.0 end if occupancy = max ( 0.0 , min ( 1.0 , occupancy )) end function estimate_occupancy function estimate_memory_pressure ( dims , tile_dim , other_dim , base_storage , props ) result ( pressure ) !! Analytical estimation of memory pressure based on GPU architecture integer ( int32 ), intent ( in ) :: dims (:) !! Size of the problem integer ( int32 ), intent ( in ) :: tile_dim !! Tile dimension integer ( int32 ), intent ( in ) :: other_dim !! Other dimension (not tiled) integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( device_props ), intent ( in ) :: props !! GPU architecture properties real ( real32 ) :: pressure !! Pressure metric integer ( int64 ) :: matrix_size_bytes !! Size of the matrix in bytes integer ( int64 ) :: shared_mem_total_bytes !! Total shared memory available for a GPU real ( real32 ) :: memory_utilization !! Memory utilization metric real ( real32 ) :: cache_efficiency !! Cache efficiency metric real ( real32 ) :: locality_factor !! Locality factor metric real ( real32 ) :: aspect_ratio !! Aspect ratio metric integer ( int32 ) :: nx !! Size of the matrix in the x dimension integer ( int32 ) :: ny !! Size of the matrix in the y dimension integer ( int32 ) :: nz !! Size of the matrix in the z dimension integer ( int32 ) :: min_dim !! Minimum dimension size nx = dims ( 1 ) ny = dims ( tile_dim ) nz = dims ( other_dim ) min_dim = min ( nx , ny ) matrix_size_bytes = product ( dims ) * base_storage shared_mem_total_bytes = props % shared_mem_per_sm * int ( props % sm_count , int64 ) ! 2D model of memory pressure: Shared Memory + L2 Cache vs Global Memory if ( matrix_size_bytes > props % l2_cache_size ) then ! Matrix does not fit in L2 - high pressure on global memory memory_utilization = 0.9 else if ( matrix_size_bytes > shared_mem_total_bytes ) then ! Matrix fits in L2 but not in shared memory - medium pressure memory_utilization = 0.6 else if ( matrix_size_bytes < 1024_int64 ) then ! No pressure memory_utilization = 0.1 else ! Matrix fits in shared memory - low pressure memory_utilization = 0.3 end if ! Analytical estimation of cache efficiency based on access pattern aspect_ratio = real ( max ( nx , ny )) / real ( min_dim ) if ( nz == 1 ) then ! 2D case if ( nx == ny ) then ! Square matrix - good spatial locality when transposed cache_efficiency = 0.8 else if ( min_dim < 32 ) then ! Narrow matrix - poor spatial locality cache_efficiency = 0.5 else ! Rectangular matrix - average locality cache_efficiency = 0.7 end if else ! 3D case - additional dimension affects cache efficiency if ( nx == ny . and . nz <= 16 ) then ! Square layers with small depth - good locality cache_efficiency = 0.7 else if ( min_dim < 32 . or . nz > 64 ) then ! Narrow layers or large depth - poor locality cache_efficiency = 0.4 else ! Average case for 3D cache_efficiency = 0.6 end if aspect_ratio = aspect_ratio * ( 1.0 + real ( nz ) / 3 2.0 ) ! Z-dimension affects locality end if if ( aspect_ratio > 1 6.0 ) then locality_factor = 0.3 ! Very asymmetric - poor locality else if ( aspect_ratio > 4.0 ) then locality_factor = 0.6 ! Moderately asymmetric else locality_factor = 0.9 ! Close to square - good locality end if ! Combined memory pressure estimation pressure = memory_utilization * ( 1.0 - cache_efficiency * locality_factor + 0.1 ) pressure = max ( 0.0 , min ( 1.0 , pressure )) end function estimate_memory_pressure function estimate_coalescing ( dims , tile_dim , other_dim , kernel_type , config , base_storage , neighbor_data ) result ( score ) !! Estimate memory coalescing efficiency for a given kernel configuration and transpose type integer ( int32 ), intent ( in ) :: dims (:) !! Local dimensions of the input data integer ( int32 ), intent ( in ) :: tile_dim !! Tile dimension integer ( int32 ), intent ( in ) :: other_dim !! Other dimension (not tiled) type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel type ( kernel_config ), intent ( in ) :: config !! Kernel configuration integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ), optional , intent ( in ) :: neighbor_data (:) !! Neighboring data dimensions for pipelined kernels real ( real32 ) :: score !! Coalescing score real ( real32 ) :: read_efficiency !! Read efficiency score real ( real32 ) :: write_efficiency !! Write efficiency score real ( real32 ) :: thread_utilization !! Thread utilization score real ( real32 ) :: dimension_penalty !! Penalty based on dimension sizes integer ( int32 ) :: tile_size !! Tile size (X dimension) integer ( int32 ) :: block_rows !! Number of rows in the block (Y dimension) integer ( int32 ) :: threads_per_block !! Number of threads per block integer ( int32 ) :: nx , ny , nz !! Problem dimensions integer ( int32 ) :: read_stride !! Stride for reading integer ( int32 ) :: write_stride !! Stride for writing real ( real32 ) :: cache_efficiency !! Cache line utilization efficiency tile_size = config % tile_size block_rows = config % block_rows threads_per_block = tile_size * block_rows nx = dims ( 1 ) ny = dims ( tile_dim ) nz = dims ( other_dim ) ! Analyze memory access patterns based on transpose type select case ( kernel_type % val ) case ( KERNEL_PERMUTE_FORWARD % val ) read_stride = nx write_stride = ny * nz case ( KERNEL_PERMUTE_BACKWARD % val ) read_stride = nx * ny write_stride = nz case ( KERNEL_PERMUTE_BACKWARD_START % val ) read_stride = nx * ny write_stride = ny * nz case ( KERNEL_PERMUTE_BACKWARD_END_PIPELINED % val ) read_stride = neighbor_data ( 1 ) * neighbor_data ( 3 ) write_stride = nx case ( KERNEL_UNPACK_PIPELINED % val ) read_stride = neighbor_data ( 1 ) write_stride = nx case default INTERNAL_ERROR ( \"estimate_coalescing: unknown kernel_type\" ) endselect ! Calculate read efficiency based on memory access pattern if ( tile_size >= WARP_SIZE ) then ! Full warp coalescing for reads read_efficiency = 1.0 else read_efficiency = real ( tile_size ) / real ( WARP_SIZE ) end if ! Apply stride penalty for reads if ( read_stride == 1 ) then ! Perfect coalescing read_efficiency = read_efficiency * 1.0 else if ( read_stride <= 4 ) then ! Good coalescing read_efficiency = read_efficiency * 0.95 else if ( read_stride <= 32 ) then ! Acceptable coalescing read_efficiency = read_efficiency * 0.85 else if ( read_stride <= 128 ) then ! Poor coalescing read_efficiency = read_efficiency * 0.70 else ! Very poor coalescing read_efficiency = read_efficiency * 0.50 end if ! Calculate write efficiency based on stride and dimension sizes if ( write_stride == 1 ) then write_efficiency = 1.0 else if ( write_stride <= 4 ) then write_efficiency = 0.95 else if ( write_stride <= 16 ) then write_efficiency = 0.85 else if ( write_stride <= 64 ) then write_efficiency = 0.70 else if ( write_stride <= 256 ) then write_efficiency = 0.55 else if ( write_stride <= 1024 ) then write_efficiency = 0.40 else write_efficiency = 0.25 end if ! Apply dimension-specific penalties select case ( kernel_type % val ) case ( KERNEL_PERMUTE_BACKWARD_START % val , KERNEL_PERMUTE_BACKWARD % val ) if ( min ( nx , nz ) < 16 ) then dimension_penalty = 0.75 else if ( min ( nx , nz ) < 32 ) then dimension_penalty = 0.85 else dimension_penalty = 0.92 end if case default if ( min ( ny , nz ) < 16 ) then dimension_penalty = 0.80 else if ( min ( ny , nz ) < 32 ) then dimension_penalty = 0.88 else dimension_penalty = 0.95 end if endselect write_efficiency = write_efficiency * dimension_penalty ! Cache line utilization based on element size if ( base_storage == DOUBLE_COMPLEX_STORAGE_SIZE ) then cache_efficiency = 0.85 else if ( base_storage == DOUBLE_STORAGE_SIZE ) then cache_efficiency = 0.92 else cache_efficiency = 1.0 end if read_efficiency = read_efficiency * cache_efficiency write_efficiency = write_efficiency * cache_efficiency ! Thread utilization based on block size if ( threads_per_block >= 512 ) then thread_utilization = 1.0 else if ( threads_per_block >= 256 ) then thread_utilization = 0.95 else if ( threads_per_block >= 128 ) then thread_utilization = 0.90 else if ( threads_per_block >= 64 ) then thread_utilization = 0.80 else thread_utilization = 0.60 end if ! Combined score - writing is more critical for transpose operations score = 0.20 * read_efficiency + 0.65 * write_efficiency + 0.15 * thread_utilization end function estimate_coalescing subroutine generate_candidates ( dims , tile_dim , other_dim , base_storage , props , candidates , num_candidates ) !! Generate kernel configuration candidates for given problem integer ( int32 ), intent ( in ) :: dims (:) !! Local dimensions of the input data, always 3D integer ( int32 ), intent ( in ) :: tile_dim !! Tile dimension integer ( int32 ), intent ( in ) :: other_dim !! Other dimension (not tiled) integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( device_props ), intent ( in ) :: props !! GPU architecture properties type ( kernel_config ), intent ( out ) :: candidates (:) !! Generated kernel configurations integer ( int32 ), intent ( out ) :: num_candidates !! Number of generated candidates integer ( int32 ) :: nx !! Local dimension X integer ( int32 ) :: ny !! Local dimension Y integer ( int32 ) :: tile_sizes ( N_TILES_CANDIDATES ) !! Tile sizes to consider integer ( int32 ) :: block_heights ( N_BLOCKS_CANDIDATES ) !! Block heights to consider integer ( int32 ) :: i !! Counter integer ( int32 ) :: j !! Counter integer ( int32 ) :: k !! Counter integer ( int32 ) :: tile_size !! Current tile size integer ( int32 ) :: block_rows !! Current number of block rows logical :: is_asymmetric !! Flag for asymmetric problem logical :: is_square !! Flag for square problem logical :: is_large !! Flag for large problem logical :: is_found !! Flag for found configuration real ( real32 ) :: aspect_ratio !! Aspect ratio of the problem real ( real32 ) :: memory_bandwidth !! Estimated memory bandwidth pressure integer ( int32 ) :: optimal_tile_size !! Optimal tile size integer ( int32 ) :: optimal_block_rows !! Optimal number of block rows integer ( int32 ) :: threads_per_block !! Number of threads per block integer ( int32 ) :: padding !! Padding size integer ( int64 ) :: shared_mem_usage !! Shared memory usage per block ! WRITE_DEBUG(\"Generating kernel configuration candidates..\") nx = dims ( 1 ) ny = dims ( tile_dim ) is_square = abs ( nx - ny ) <= max ( nx , ny ) / 10 is_large = 1_int64 * product ( dims ) > ( int ( props % l2_cache_size , int64 ) / base_storage ) is_asymmetric = ( nx > 4 * ny ) . or . ( ny > 4 * nx ) aspect_ratio = real ( max ( nx , ny )) / real ( min ( nx , ny )) memory_bandwidth = estimate_memory_pressure ( dims , tile_dim , other_dim , base_storage , props ) if ( is_asymmetric ) then if ( nx > ny ) then ! Prefer more rows optimal_tile_size = min ( 64 , max ( 16 , ny )) optimal_block_rows = min ( 16 , max ( 8 , ny / 4 )) else ! Prefer fewer rows optimal_tile_size = min ( 128 , max ( 32 , nx )) optimal_block_rows = min ( 8 , max ( 2 , nx / 16 )) end if call find_valid_combination ( optimal_tile_size , optimal_block_rows ) else if ( is_large . and . memory_bandwidth > 0.7 ) then ! Large matrix with high memory pressure - prefer larger blocks optimal_tile_size = 64 if ( base_storage >= DOUBLE_STORAGE_SIZE ) then optimal_block_rows = 8 else optimal_block_rows = 16 end if else if (. not . is_large ) then ! Small matrix with low pressure - prefer smaller blocks optimal_tile_size = 16 optimal_block_rows = 4 else ! Default case optimal_tile_size = 32 if ( base_storage >= DOUBLE_STORAGE_SIZE ) then optimal_block_rows = 4 else optimal_block_rows = 8 end if end if ! Forming 5 variants of tile sizes around the optimal tile_sizes ( 1 ) = max ( 8 , optimal_tile_size / 4 ) tile_sizes ( 2 ) = max ( 16 , optimal_tile_size / 2 ) tile_sizes ( 3 ) = optimal_tile_size tile_sizes ( 4 ) = min ( 128 , optimal_tile_size * 2 ) tile_sizes ( 5 ) = min ( 256 , optimal_tile_size * 4 ) ! Forming 5 variants of block heights around the optimal ! Avoiding too small configurations (minimum 2 rows for reasonable occupancy) block_heights ( 1 ) = max ( 2 , optimal_block_rows / 2 ) block_heights ( 2 ) = optimal_block_rows block_heights ( 3 ) = min ( 16 , optimal_block_rows * 2 ) block_heights ( 4 ) = min ( 32 , optimal_block_rows * 4 ) block_heights ( 5 ) = min ( 64 , optimal_block_rows * 8 ) num_candidates = 0 do i = 1 , size ( tile_sizes ) do j = 1 , size ( block_heights ) if ( num_candidates > size ( candidates )) exit tile_size = tile_sizes ( i ) block_rows = block_heights ( j ) threads_per_block = tile_size * block_rows if ( tile_size * block_rows > props % max_threads_per_block ) cycle if ( threads_per_block < 2 * WARP_SIZE ) cycle if ( tile_size < block_rows ) cycle if ( mod ( tile_size * block_rows , WARP_SIZE ) /= 0 ) cycle padding = estimate_optimal_padding ( tile_size , block_rows , base_storage ) shared_mem_usage = tile_size * ( tile_size + padding ) * base_storage ! Reserving 10% of shared memory if ( shared_mem_usage >= int ( props % shared_mem_per_block * 0.9_real64 , int64 )) cycle ! Checking if candidate was added before is_found = . false . do k = 1 , num_candidates if ( candidates ( k )% tile_size == tile_size . and . candidates ( k )% block_rows == block_rows ) is_found = . true . enddo if ( is_found ) cycle WRITE_DEBUG ( \"Adding candidate for consideration: \" // to_str ( tile_size ) // \"x\" // to_str ( block_rows ) // \", padding = \" // to_str ( padding )) num_candidates = num_candidates + 1 candidates ( num_candidates )% tile_size = tile_size candidates ( num_candidates )% block_rows = block_rows ! candidates(num_candidates)%threads%x = tile_size ! candidates(num_candidates)%threads%y = block_rows ! candidates(num_candidates)%threads%z = 1 ! candidates(num_candidates)%blocks%x = (nx + tile_size - 1) / tile_size ! candidates(num_candidates)%blocks%y = (ny + tile_size - 1) / tile_size ! candidates(num_candidates)%blocks%z = dims(other_dim) candidates ( num_candidates )% padding = padding end do if ( num_candidates > size ( candidates )) exit end do ! WRITE_DEBUG(\"Generated \"//to_str(num_candidates)//\" candidates\") end subroutine generate_candidates subroutine find_valid_combination ( base_tile , base_rows ) !! This subroutine optimizes the tile size and number of rows for narrow matrices !! by adjusting them to be compatible with the warp size. integer ( int32 ), intent ( inout ) :: base_tile !!< Tile size integer ( int32 ), intent ( inout ) :: base_rows !!< Number of rows integer ( int32 ) :: best_tile !! Optimized tile size integer ( int32 ) :: best_rows !! Optimized number of rows best_tile = ( base_tile + WARP_SIZE - 1 ) / WARP_SIZE * WARP_SIZE best_tile = min ( 256 , max ( 8 , best_tile )) best_rows = (( base_rows + best_tile - 1 ) / best_tile ) * best_tile best_rows = min ( 4 , max ( best_tile , best_rows )) if ( mod ( best_tile * best_rows , WARP_SIZE ) /= 0 ) then best_rows = best_rows + best_tile best_rows = min ( 4 , best_rows ) end if base_tile = best_tile base_rows = best_rows end subroutine function evaluate_analytical_performance ( dims , tile_dim , other_dim , kernel_type , config , props , base_storage , neighbor_data ) result ( score ) !! This function evaluates the performance of a kernel configuration !! based on various architectural and problem-specific parameters. integer ( int32 ), intent ( in ) :: dims (:) !! Problem dimensions integer ( int32 ), intent ( in ) :: tile_dim !! Tile dimension integer ( int32 ), intent ( in ) :: other_dim !! Other dimension (not tiled) type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel_type to evaluate type ( kernel_config ), intent ( in ) :: config !! Kernel configuration type ( device_props ), intent ( in ) :: props !! GPU architecture properties integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ), optional , intent ( in ) :: neighbor_data (:) !! Neighboring data dimensions for pipelined kernels real ( real32 ) :: score !! Performance score integer ( int32 ) :: n_bank_conflicts !! Number of bank conflicts integer ( int32 ) :: tile_size !! Tile size integer ( int32 ) :: block_rows !! Number of rows in a block real ( real32 ) :: occupancy_score !! Occupancy score real ( real32 ) :: memory_access_score !! Memory access score real ( real32 ) :: computation_efficiency_score !! Computation efficiency score real ( real32 ) :: occupancy !! Raw occupancy score real ( real32 ) :: coalescing_efficiency !! Coalescing efficiency score real ( real32 ) :: bank_conflict_ratio !! Bank conflict ratio ! real(real32)    :: x_waste                      !! X waste ! real(real32)    :: y_waste                      !! Y waste ! real(real32)    :: total_efficiency             !! Total efficiency tile_size = config % tile_size block_rows = config % block_rows occupancy = estimate_occupancy ( config , props , base_storage ) if ( occupancy >= 0.5 . and . occupancy <= 0.75 ) then occupancy_score = 1.0 else if ( occupancy >= 0.3 . and . occupancy < 0.5 ) then occupancy_score = 0.7 + 0.3 * ( occupancy - 0.3 ) / 0.2 else if ( occupancy > 0.75 . and . occupancy <= 1.0 ) then occupancy_score = 1.0 - 0.2 * ( occupancy - 0.75 ) / 0.25 else occupancy_score = 0.3 end if coalescing_efficiency = estimate_coalescing ( dims , tile_dim , other_dim , kernel_type , config , base_storage , neighbor_data ) bank_conflict_ratio = estimate_bank_conflict_ratio ( config , base_storage ) memory_access_score = 0.4 * coalescing_efficiency + 0.6 * ( 1.0 - bank_conflict_ratio ) if ( mod ( tile_size , WARP_SIZE ) == 0 ) then computation_efficiency_score = 1.0 else if ( mod ( tile_size , 16 ) == 0 ) then computation_efficiency_score = 0.9 else if ( mod ( tile_size , 8 ) == 0 ) then computation_efficiency_score = 0.8 else computation_efficiency_score = 0.7 end if ! x_waste = real(config%blocks%x * tile_size - dims(1)) / real(config%blocks%x * tile_size) ! y_waste = real(config%blocks%y * tile_size - dims(2)) / real(config%blocks%y * tile_size) ! total_efficiency = (1.0 - x_waste) * (1.0 - y_waste) ! if (total_efficiency >= 0.95) then !   workload_balance_score = 1.0 ! else if (total_efficiency >= 0.85) then !   workload_balance_score = 0.9 + 0.1 * (total_efficiency - 0.85) / 0.10 ! else if (total_efficiency >= 0.75) then !   workload_balance_score = 0.8 + 0.1 * (total_efficiency - 0.75) / 0.10 ! else if (total_efficiency >= 0.50) then !   workload_balance_score = 0.6 + 0.2 * (total_efficiency - 0.50) / 0.25 ! else !   workload_balance_score = 0.3 + 0.3 * total_efficiency / 0.50 ! end if score = 0.35 * occupancy_score & + 0.55 * memory_access_score & + 0.10 * computation_efficiency_score ! + 0.10 * workload_balance_score score = max ( 0.0 , min ( 1.0 , score )) n_bank_conflicts = count_bank_conflicts ( tile_size , block_rows , base_storage , config % padding ) ! WRITE_DEBUG(\"=== Performance Analysis for \"//to_str(tile_size)//\"x\"//to_str(block_rows)//\", padding = \"//to_str(config%padding)//\" ===\") ! WRITE_DEBUG(\"  Occupancy score:                \"//to_str(occupancy_score)//\" (occupancy: \"//to_str(occupancy)//\")\") ! WRITE_DEBUG(\"  Memory access score:            \"//to_str(memory_access_score)) ! WRITE_DEBUG(\"    - Coalescing:                 \"//to_str(coalescing_efficiency)) ! WRITE_DEBUG(\"    - Bank conflict ratio:        \"//to_str(bank_conflict_ratio)) ! WRITE_DEBUG(\"    - Number of bank conflicts:   \"//to_str(n_bank_conflicts)) ! WRITE_DEBUG(\"  Computational efficiency score: \"//to_str(computation_efficiency_score)) ! WRITE_DEBUG(\"  Workload balance score:         \"//to_str(workload_balance_score)//\" (efficiency: \"//to_str(total_efficiency)//\")\") ! WRITE_DEBUG(\"  Final score: \"//to_str(score)) end function evaluate_analytical_performance subroutine sort_candidates_by_score ( scores , num_candidates , sorted_indices ) !! Sorting candidates by their performance scores real ( real32 ), intent ( in ) :: scores (:) !! Performance scores of candidates generated by `evaluate_analytical_performance` integer ( int32 ), intent ( in ) :: num_candidates !! Number of candidates integer ( int32 ), intent ( out ) :: sorted_indices (:) !! Sorted indices of candidates integer ( int32 ) :: i !! Counter integer ( int32 ) :: j !! Counter integer ( int32 ) :: max_idx !! Index of the maximum element real ( real32 ) :: max_score !! Maximum score found logical :: used ( num_candidates ) !! Array to track used candidates used = . false . do i = 1 , num_candidates max_score = - 1.0 max_idx = 0 do j = 1 , num_candidates if (. not . used ( j ) . and . scores ( j ) > max_score ) then max_score = scores ( j ) max_idx = j end if end do if ( max_idx > 0 ) then sorted_indices ( i ) = max_idx used ( max_idx ) = . true . else sorted_indices ( i ) = i ! Fallback end if end do end subroutine sort_candidates_by_score end module dtfft_nvrtc_block_optimizer","tags":"","loc":"sourcefile/dtfft_nvrtc_block_optimizer.f90.html"},{"title":"dtfft_errors.F90 – dtFFT","text":"Files dependent on this one sourcefile~~dtfft_errors.f90~~AfferentGraph sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_errors !! Module that defines error codes and provides utility to get error string use iso_fortran_env , only : int32 implicit none private public :: dtfft_get_error_string integer ( int32 ), parameter , public :: DTFFT_SUCCESS = CONF_DTFFT_SUCCESS !! Successful execution integer ( int32 ), parameter , public :: DTFFT_ERROR_MPI_FINALIZED = CONF_DTFFT_ERROR_MPI_FINALIZED !! MPI_Init is not called or MPI_Finalize has already been called integer ( int32 ), parameter , public :: DTFFT_ERROR_PLAN_NOT_CREATED = CONF_DTFFT_ERROR_PLAN_NOT_CREATED !! Plan not created integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_TRANSPOSE_TYPE = CONF_DTFFT_ERROR_INVALID_TRANSPOSE_TYPE !! Invalid `transpose_type` provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_N_DIMENSIONS = CONF_DTFFT_ERROR_INVALID_N_DIMENSIONS !! Invalid Number of dimensions provided. Valid options are 2 and 3 integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_DIMENSION_SIZE = CONF_DTFFT_ERROR_INVALID_DIMENSION_SIZE !! One or more provided dimension sizes <= 0 integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_COMM_TYPE = CONF_DTFFT_ERROR_INVALID_COMM_TYPE !! Invalid communicator type provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_PRECISION = CONF_DTFFT_ERROR_INVALID_PRECISION !! Invalid `precision` parameter provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_EFFORT = CONF_DTFFT_ERROR_INVALID_EFFORT_FLAG !! Invalid `effort` parameter provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_EXECUTOR = CONF_DTFFT_ERROR_INVALID_EXECUTOR_TYPE !! Invalid `executor` parameter provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_COMM_DIMS = CONF_DTFFT_ERROR_INVALID_COMM_DIMS !! Number of dimensions in provided Cartesian communicator > Number of dimension passed to `create` subroutine integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_COMM_FAST_DIM = CONF_DTFFT_ERROR_INVALID_COMM_FAST_DIM !! Passed Cartesian communicator with number of processes in 1st (fastest varying) dimension > 1 integer ( int32 ), parameter , public :: DTFFT_ERROR_MISSING_R2R_KINDS = CONF_DTFFT_ERROR_MISSING_R2R_KINDS !! For R2R plan, `kinds` parameter must be passed if `executor` != `DTFFT_EXECUTOR_NONE` integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_R2R_KINDS = CONF_DTFFT_ERROR_INVALID_R2R_KINDS !! Invalid values detected in `kinds` parameter integer ( int32 ), parameter , public :: DTFFT_ERROR_R2C_TRANSPOSE_PLAN = CONF_DTFFT_ERROR_R2C_TRANSPOSE_PLAN !! Transpose plan is not supported in R2C, use R2R or C2C plan instead integer ( int32 ), parameter , public :: DTFFT_ERROR_INPLACE_TRANSPOSE = CONF_DTFFT_ERROR_INPLACE_TRANSPOSE !! Inplace transpose is not supported integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_AUX = CONF_DTFFT_ERROR_INVALID_AUX !! Invalid `aux` buffer provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_DIM = CONF_DTFFT_ERROR_INVALID_DIM !! Invalid `dim` passed to `plan.get_pencil` integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_USAGE = CONF_DTFFT_ERROR_INVALID_USAGE !! Invalid API Usage. integer ( int32 ), parameter , public :: DTFFT_ERROR_PLAN_IS_CREATED = CONF_DTFFT_ERROR_PLAN_IS_CREATED !! Trying to create already created plan integer ( int32 ), parameter , public :: DTFFT_ERROR_ALLOC_FAILED = CONF_DTFFT_ERROR_ALLOC_FAILED !! Internal allocation failed integer ( int32 ), parameter , public :: DTFFT_ERROR_FREE_FAILED = CONF_DTFFT_ERROR_FREE_FAILED !! Internal memory free failed integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_ALLOC_BYTES = CONF_DTFFT_ERROR_INVALID_ALLOC_BYTES !! Invalid `alloc_bytes` provided integer ( int32 ), parameter , public :: DTFFT_ERROR_DLOPEN_FAILED = CONF_DTFFT_ERROR_DLOPEN_FAILED !! dlopen failed integer ( int32 ), parameter , public :: DTFFT_ERROR_DLSYM_FAILED = CONF_DTFFT_ERROR_DLSYM_FAILED !! dlsym failed integer ( int32 ), parameter , public :: DTFFT_ERROR_R2C_TRANSPOSE_CALLED = CONF_DTFFT_ERROR_R2C_TRANSPOSE_CALLED !! Calling to `transpose` method for R2C plan is not allowed integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH = CONF_DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH !! Sizes of `starts` and `counts` arrays passed to `dtfft_pencil_t` constructor do not match integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES = CONF_DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES !! Sizes of `starts` and `counts` < 2 or > 3 provided to `dtfft_pencil_t` constructor integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_INVALID_COUNTS = CONF_DTFFT_ERROR_PENCIL_INVALID_COUNTS !! Invalid `counts` provided to `dtfft_pencil_t` constructor integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_INVALID_STARTS = CONF_DTFFT_ERROR_PENCIL_INVALID_STARTS !! Invalid `starts` provided to `dtfft_pencil_t` constructor integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_SHAPE_MISMATCH = CONF_DTFFT_ERROR_PENCIL_SHAPE_MISMATCH !! Processes have same lower bounds but different sizes in some dimensions integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_OVERLAP = CONF_DTFFT_ERROR_PENCIL_OVERLAP !! Pencil overlap detected, i.e. two processes share same part of global space integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_NOT_CONTINUOUS = CONF_DTFFT_ERROR_PENCIL_NOT_CONTINUOUS !! Local pencils do not cover the global space without gaps integer ( int32 ), parameter , public :: DTFFT_ERROR_PENCIL_NOT_INITIALIZED = CONF_DTFFT_ERROR_PENCIL_NOT_INITIALIZED !! Pencil is not initialized, i.e. `constructor` subroutine was not called integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_MEASURE_WARMUP_ITERS = CONF_DTFFT_ERROR_INVALID_MEASURE_WARMUP_ITERS !! Invalid `n_measure_warmup_iters` provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_MEASURE_ITERS = CONF_DTFFT_ERROR_INVALID_MEASURE_ITERS !! Invalid `n_measure_iters` provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_REQUEST = CONF_DTFFT_ERROR_INVALID_REQUEST !! Invalid `dtfft_request_t` provided integer ( int32 ), parameter , public :: DTFFT_ERROR_TRANSPOSE_ACTIVE = CONF_DTFFT_ERROR_TRANSPOSE_ACTIVE !! Attempting to execute already active transposition integer ( int32 ), parameter , public :: DTFFT_ERROR_TRANSPOSE_NOT_ACTIVE = CONF_DTFFT_ERROR_TRANSPOSE_NOT_ACTIVE !! Attempting to finalize non-active transposition integer ( int32 ), parameter , public :: DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED = CONF_DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED !! Selected `executor` do not support R2R FFTs integer ( int32 ), parameter , public :: DTFFT_ERROR_GPU_INVALID_STREAM = CONF_DTFFT_ERROR_GPU_INVALID_STREAM !! Invalid stream provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_BACKEND = CONF_DTFFT_ERROR_INVALID_BACKEND !! Invalid GPU backend provided integer ( int32 ), parameter , public :: DTFFT_ERROR_GPU_NOT_SET = CONF_DTFFT_ERROR_GPU_NOT_SET !! Multiple MPI Processes located on same host share same GPU which is not supported integer ( int32 ), parameter , public :: DTFFT_ERROR_VKFFT_R2R_2D_PLAN = CONF_DTFFT_ERROR_VKFFT_R2R_2D_PLAN !! When using R2R FFT and executor type is vkFFT and plan uses Z-slab optimization, it is required that types of R2R transform are same in X and Y directions integer ( int32 ), parameter , public :: DTFFT_ERROR_BACKENDS_DISABLED = CONF_DTFFT_ERROR_BACKENDS_DISABLED !! Passed `effort` ==  `DTFFT_PATIENT` but all GPU Backends has been disabled by `dtfft_config_t` */ integer ( int32 ), parameter , public :: DTFFT_ERROR_NOT_DEVICE_PTR = CONF_DTFFT_ERROR_NOT_DEVICE_PTR !! One of pointers passed to `plan.execute` or `plan.transpose` cannot be accessed from device integer ( int32 ), parameter , public :: DTFFT_ERROR_NOT_NVSHMEM_PTR = CONF_DTFFT_ERROR_NOT_NVSHMEM_PTR !! One of pointers passed to `plan.execute` or `plan.transpose` is not an `NVSHMEM` pointer integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_PLATFORM = CONF_DTFFT_ERROR_INVALID_PLATFORM !! Invalid platform provided integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR = CONF_DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR !! Invalid executor provided for selected platform integer ( int32 ), parameter , public :: DTFFT_ERROR_INVALID_PLATFORM_BACKEND = CONF_DTFFT_ERROR_INVALID_PLATFORM_BACKEND !! Invalid backend provided for selected platform contains pure function dtfft_get_error_string ( error_code ) result ( error_string ) !! Gets the string description of an error code integer ( int32 ), intent ( in ) :: error_code !! Error code character ( len = :), allocatable :: error_string !! Error string select case ( error_code ) case ( DTFFT_SUCCESS ) allocate ( error_string , source = \"DTFFT_SUCCESS\" ) case ( DTFFT_ERROR_MPI_FINALIZED ) allocate ( error_string , source = \"MPI_Init is not called or MPI_Finalize has already been called\" ) case ( DTFFT_ERROR_PLAN_NOT_CREATED ) allocate ( error_string , source = \"Plan not created\" ) case ( DTFFT_ERROR_INVALID_TRANSPOSE_TYPE ) allocate ( error_string , source = \"Invalid `transpose_type` provided\" ) case ( DTFFT_ERROR_INVALID_N_DIMENSIONS ) allocate ( error_string , source = \"Invalid Number of dimensions provided. Valid options are 2 and 3\" ) case ( DTFFT_ERROR_INVALID_DIMENSION_SIZE ) allocate ( error_string , source = \"One or more provided dimension sizes <= 0\" ) case ( DTFFT_ERROR_INVALID_COMM_TYPE ) allocate ( error_string , source = \"Invalid communicator type provided\" ) case ( DTFFT_ERROR_INVALID_PRECISION ) allocate ( error_string , source = \"Invalid `precision` parameter provided\" ) case ( DTFFT_ERROR_INVALID_EFFORT ) allocate ( error_string , source = \"Invalid `effort` parameter provided\" ) case ( DTFFT_ERROR_INVALID_EXECUTOR ) allocate ( error_string , source = \"Invalid `executor` parameter provided\" ) case ( DTFFT_ERROR_INVALID_COMM_DIMS ) allocate ( error_string , source = \"Number of dimensions in provided Cartesian communicator > Number of dimension passed to `create` subroutine\" ) case ( DTFFT_ERROR_INVALID_COMM_FAST_DIM ) allocate ( error_string , source = \"Passed Cartesian communicator with number of processes in 1st (fastest varying) dimension > 1 OR provided dtfft_pencil_t with distribution over 1st dimension\" ) case ( DTFFT_ERROR_MISSING_R2R_KINDS ) allocate ( error_string , source = \"For R2R plan, `kinds` parameter must be passed if `executor` != `DTFFT_EXECUTOR_NONE`\" ) case ( DTFFT_ERROR_INVALID_R2R_KINDS ) allocate ( error_string , source = \"Invalid values detected in `kinds` parameter\" ) case ( DTFFT_ERROR_R2C_TRANSPOSE_PLAN ) allocate ( error_string , source = \"Transpose plan is not supported in R2C, use R2R or C2C plan instead\" ) case ( DTFFT_ERROR_INVALID_AUX ) allocate ( error_string , source = \"Invalid `aux` buffer provided\" ) case ( DTFFT_ERROR_INPLACE_TRANSPOSE ) allocate ( error_string , source = \"Inplace transpose is not supported\" ) case ( DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED ) allocate ( error_string , source = \"Selected `executor` do not support R2R FFTs\" ) case ( DTFFT_ERROR_INVALID_DIM ) allocate ( error_string , source = \"Invalid `dim` passed to `dtfft_get_pencil`\" ) case ( DTFFT_ERROR_INVALID_USAGE ) allocate ( error_string , source = \"Invalid API Usage.\" ) case ( DTFFT_ERROR_PLAN_IS_CREATED ) allocate ( error_string , source = \"Trying to create already created plan\" ) case ( DTFFT_ERROR_ALLOC_FAILED ) allocate ( error_string , source = \"Allocation failed\" ) case ( DTFFT_ERROR_FREE_FAILED ) allocate ( error_string , source = \"Memory free failed\" ) case ( DTFFT_ERROR_INVALID_ALLOC_BYTES ) allocate ( error_string , source = \"Invalid `alloc_bytes` provided\" ) case ( DTFFT_ERROR_DLOPEN_FAILED ) allocate ( error_string , source = \"Failed to open shared library. Set DTFFT_ENABLE_LOG=1 to see the error\" ) case ( DTFFT_ERROR_DLSYM_FAILED ) allocate ( error_string , source = \"Failed to find symbol in shared library. Set DTFFT_ENABLE_LOG=1 to see the error\" ) case ( DTFFT_ERROR_R2C_TRANSPOSE_CALLED ) allocate ( error_string , source = \"Calling to `transpose` method for R2C plan is not allowed\" ) case ( DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH ) allocate ( error_string , source = \"Sizes of `lbound` and `sizes` arrays passed to `dtfft_pencil_t` constructor do not match\" ) case ( DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES ) allocate ( error_string , source = \"Sizes of `lbound` and `sizes` < 2 or > 3 provided to `dtfft_pencil_t` constructor\" ) case ( DTFFT_ERROR_PENCIL_INVALID_COUNTS ) allocate ( error_string , source = \"Invalid `counts` provided to `dtfft_pencil_t` constructor\" ) case ( DTFFT_ERROR_PENCIL_INVALID_STARTS ) allocate ( error_string , source = \"Invalid `starts` provided to `dtfft_pencil_t` constructor\" ) case ( DTFFT_ERROR_PENCIL_SHAPE_MISMATCH ) allocate ( error_string , source = \"Processes have same `starts` but different `counts` in some dimensions\" ) case ( DTFFT_ERROR_PENCIL_OVERLAP ) allocate ( error_string , source = \"Pencil overlap detected, i.e. two processes share same part of global space\" ) case ( DTFFT_ERROR_PENCIL_NOT_CONTINUOUS ) allocate ( error_string , source = \"Local pencils do not cover the global space without gaps\" ) case ( DTFFT_ERROR_PENCIL_NOT_INITIALIZED ) allocate ( error_string , source = \"Pencil is not initialized, i.e. `constructor` subroutine was not called\" ) case ( DTFFT_ERROR_INVALID_MEASURE_WARMUP_ITERS ) allocate ( error_string , source = \"Invalid `n_measure_warmup_iters` provided\" ) case ( DTFFT_ERROR_INVALID_MEASURE_ITERS ) allocate ( error_string , source = \"Invalid `n_measure_iters` provided\" ) case ( DTFFT_ERROR_INVALID_REQUEST ) allocate ( error_string , source = \"Invalid `dtfft_request_t` provided\" ) case ( DTFFT_ERROR_TRANSPOSE_ACTIVE ) allocate ( error_string , source = \"Attempting to execute already active transposition\" ) case ( DTFFT_ERROR_TRANSPOSE_NOT_ACTIVE ) allocate ( error_string , source = \"Attempting to finalize non-active transposition\" ) case ( DTFFT_ERROR_GPU_INVALID_STREAM ) allocate ( error_string , source = \"Invalid stream provided\" ) case ( DTFFT_ERROR_INVALID_BACKEND ) allocate ( error_string , source = \"Invalid backend provided\" ) case ( DTFFT_ERROR_GPU_NOT_SET ) allocate ( error_string , source = \"Multiple MPI Processes located on same host share same GPU which is not supported\" ) case ( DTFFT_ERROR_VKFFT_R2R_2D_PLAN ) allocate ( error_string , source = \"When using R2R FFT and executor type is vkFFT and plan uses Z-slab optimization, it is required that types of R2R transform are same in X and Y directions\" ) case ( DTFFT_ERROR_BACKENDS_DISABLED ) allocate ( error_string , source = \"Passed `effort` ==  `DTFFT_PATIENT` but all backends has been disabled by `dtfft_config_t`\" ) case ( DTFFT_ERROR_NOT_DEVICE_PTR ) allocate ( error_string , source = \"One of pointers passed to `dtfft_execute` or `dtfft_transpose` cannot be accessed from device\" ) case ( DTFFT_ERROR_NOT_NVSHMEM_PTR ) allocate ( error_string , source = \"One of pointers passed to `dtfft_execute` or `dtfft_transpose` is not an `NVSHMEM` pointer\" ) case ( DTFFT_ERROR_INVALID_PLATFORM ) allocate ( error_string , source = \"Invalid platform provided\" ) case ( DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR ) allocate ( error_string , source = \"Invalid executor provided for selected platform\" ) case ( DTFFT_ERROR_INVALID_PLATFORM_BACKEND ) allocate ( error_string , source = \"Invalid backend provided for selected platform\" ) case default allocate ( error_string , source = \"Unknown error\" ) endselect end function dtfft_get_error_string end module dtfft_errors","tags":"","loc":"sourcefile/dtfft_errors.f90.html"},{"title":"dtfft_executor_cufft_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_executor_cufft_m.f90~~EfferentGraph sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_executor_cufft_m.f90~~AfferentGraph sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_executor_cufft_m !! This module describes cuFFT based FFT Executor: [[vkfft_executor]] !! !! https://docs.nvidia.com/cuda/cufft/index.html use iso_c_binding , only : c_ptr , c_int , c_null_ptr , c_loc use iso_fortran_env , only : int8 , int32 , int64 use dtfft_abstract_executor , only : abstract_executor , FFT_C2C , FFT_R2C use dtfft_config , only : get_conf_stream use dtfft_errors use dtfft_interface_cufft use dtfft_interface_cuda_runtime use dtfft_parameters use dtfft_utils , only : to_str #include \"_dtfft_mpi.h\" #include \"_dtfft_cuda.h\" #include \"_dtfft_private.h\" implicit none private public :: cufft_executor type , extends ( abstract_executor ) :: cufft_executor !! cuFFT FFT Executor private contains procedure :: create_private => create !! Creates FFT plan via cuFFT Interface procedure :: execute_private => execute !! Executes cuFFT plan procedure :: destroy_private => destroy !! Destroys cuFFT plan procedure , nopass :: mem_alloc !! Dummy method. Raises `error stop` procedure , nopass :: mem_free !! Dummy method. Raises `error stop` end type cufft_executor contains subroutine create ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan via cuFFT Interface class ( cufft_executor ), intent ( inout ) :: self !! cuFFT FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform integer ( c_int ) :: cufft_type , rnk ! CHECK_CALL( load_cufft(), error_code ) rnk = int ( fft_rank , c_int ) select case ( fft_type ) case ( FFT_C2C ) if ( precision == DTFFT_SINGLE ) then cufft_type = CUFFT_C2C else cufft_type = CUFFT_Z2Z endif CUFFT_CALL ( cufftPlanMany ( self % plan_forward , rnk , fft_sizes , inembed , 1 , idist , onembed , 1 , odist , cufft_type , how_many ) ) self % plan_backward = self % plan_forward self % is_inverse_copied = . true . case ( FFT_R2C ) if ( precision == DTFFT_SINGLE ) then cufft_type = CUFFT_R2C else cufft_type = CUFFT_D2Z endif CUFFT_CALL ( cufftPlanMany ( self % plan_forward , rnk , fft_sizes , inembed , 1 , idist , onembed , 1 , odist , cufft_type , how_many ) ) if ( precision == DTFFT_SINGLE ) then cufft_type = CUFFT_C2R else cufft_type = CUFFT_Z2D endif CUFFT_CALL ( cufftPlanMany ( self % plan_backward , rnk , fft_sizes , onembed , 1 , odist , inembed , 1 , idist , cufft_type , how_many ) ) case default error_code = DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED if ( present ( r2r_kinds )) then endif return endselect CUFFT_CALL ( cufftSetStream ( self % plan_forward , get_conf_stream ()) ) if ( . not . self % is_inverse_copied ) then CUFFT_CALL ( cufftSetStream ( self % plan_backward , get_conf_stream ()) ) endif end subroutine create subroutine execute ( self , a , b , sign ) !! Executes cuFFT plan class ( cufft_executor ), intent ( in ) :: self !! cuFFT FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform integer ( c_int ) :: sign_ sign_ = int ( sign , c_int ) if ( self % is_inverse_copied ) then CUFFT_CALL ( cufftXtExec ( self % plan_forward , a , b , sign_ ) ) return endif if ( sign == FFT_FORWARD ) then CUFFT_CALL ( cufftXtExec ( self % plan_forward , a , b , sign_ ) ) else CUFFT_CALL ( cufftXtExec ( self % plan_backward , a , b , sign_ ) ) endif end subroutine execute subroutine destroy ( self ) !! Destroys cuFFT plan class ( cufft_executor ), intent ( inout ) :: self !! cuFFT FFT Executor CUFFT_CALL ( cufftDestroy ( self % plan_forward ) ) if ( . not . self % is_inverse_copied ) then CUFFT_CALL ( cufftDestroy ( self % plan_backward ) ) endif end subroutine destroy subroutine mem_alloc ( alloc_bytes , ptr ) !! Dummy method. Raises `error stop` integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer INTERNAL_ERROR ( \"mem_alloc for cuFFT called\" ) end subroutine mem_alloc subroutine mem_free ( ptr ) !! Dummy method. Raises `error stop` type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free INTERNAL_ERROR ( \"mem_free for cuFFT called\" ) end subroutine mem_free end module dtfft_executor_cufft_m","tags":"","loc":"sourcefile/dtfft_executor_cufft_m.f90.html"},{"title":"dtfft_nvrtc_module_cache.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_nvrtc_module_cache.f90~~EfferentGraph sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_nvrtc_module_cache.f90~~AfferentGraph sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_nvrtc_module_cache !! Module that implements a cache for nvrtc modules !! Cache is used to avoid recompilation of kernels with the same parameters use iso_fortran_env use iso_c_binding , only : c_null_ptr use dtfft_abstract_kernel , only : kernel_type_t , get_kernel_string use dtfft_config use dtfft_interface_cuda , only : CUfunction use dtfft_interface_cuda_runtime , only : device_props use dtfft_nvrtc_block_optimizer , only : kernel_config use dtfft_nvrtc_module use dtfft_utils #include \"_dtfft_private.h\" implicit none private public :: create_nvrtc_module , get_kernel_instance integer ( int32 ), parameter :: CACHE_PREALLOC_SIZE = 10 !! Number of preallocated cache entries type :: nvrtc_module_cache !! Cache for nvrtc modules !! !! This type is used internally by the module and is not exposed to the user !! It maintains a list of compiled nvrtc modules and provides methods to add new modules !! and retrieve existing ones !! !! The cache automatically grows as needed private logical :: is_created = . false . !! Flag that indicates if cache is created type ( nvrtc_module ), allocatable :: cache (:) !! Array of cached modules integer ( int32 ) :: size !! Number of entries in cache contains private procedure , pass ( self ) :: create !! Creates cache procedure , pass ( self ) :: add !! Adds new entry to cache end type nvrtc_module_cache type ( nvrtc_module_cache ), save :: cache !! Cache instance contains subroutine create ( self ) !! Creates cache class ( nvrtc_module_cache ), intent ( inout ) :: self !! Cache instance if ( self % is_created ) return allocate ( self % cache ( CACHE_PREALLOC_SIZE )) self % size = 0 self % is_created = . true . end subroutine create subroutine add ( self , m ) !! Adds new entry to cache class ( nvrtc_module_cache ), intent ( inout ) :: self !! Cache instance type ( nvrtc_module ), intent ( in ) :: m !! Module to add type ( nvrtc_module ), allocatable :: temp (:) !! Temporary cache call cache % create () if ( self % size == size ( self % cache ) ) then allocate ( temp ( self % size + CACHE_PREALLOC_SIZE ) ) temp ( 1 : self % size ) = self % cache ( 1 : cache % size ) deallocate ( self % cache ) call move_alloc ( temp , self % cache ) endif self % size = self % size + 1 self % cache ( self % size ) = m WRITE_DEBUG ( 'Added to cache: size = ' // to_str ( self % size )) end subroutine add subroutine create_nvrtc_module ( ndims , kernel_type , base_storage , configs , props ) !! Creates and adds a new nvrtc module to the cache if it does not already exist integer ( int32 ), intent ( in ) :: ndims !! Number of dimensions (2 or 3) type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( kernel_config ), intent ( in ) :: configs (:) !! Array of kernel configurations to build type ( device_props ), intent ( in ) :: props !! GPU architecture properties integer ( int32 ) :: i !! Loop counter integer ( int32 ) :: j !! Loop counter integer ( int32 ) :: k !! Loop counter for number of new configs to add logical :: is_found !! Flag that indicates if module with required kernel_type was found logical :: is_instance_found !! Flag that indicates if specific kernel instance was found type ( nvrtc_module ) :: m !! New module to create type ( kernel_config ), allocatable :: configs_to_add (:) !! Configurations that need to be added is_found = . false . do i = 1 , cache % size is_found = cache % cache ( i )% check ( ndims , kernel_type , base_storage ) if ( is_found ) exit enddo k = 0 if ( is_found ) then ! Found at least one module with required kernel_type ! Now need to loop over all modules once again and check if required configs are present in any of them allocate ( configs_to_add ( size ( configs )) ) do j = 1 , size ( configs ) is_instance_found = . false . do i = 1 , cache % size is_instance_found = cache % cache ( i )% check ( ndims , kernel_type , base_storage , configs ( j )% tile_size , configs ( j )% block_rows ) if ( is_instance_found ) exit enddo if ( . not . is_instance_found ) then k = k + 1 configs_to_add ( k )% tile_size = configs ( j )% tile_size configs_to_add ( k )% block_rows = configs ( j )% block_rows configs_to_add ( k )% padding = configs ( j )% padding WRITE_DEBUG ( \"Adding new: \" // to_str ( configs ( j )% tile_size ) // \"x\" // to_str ( configs ( j )% block_rows ) // \": \" // to_str ( configs ( j )% padding )) endif enddo if ( k > 0 ) then WRITE_DEBUG ( \"Adding \" // to_str ( k ) // \" new kernel configurations for module '\" // get_kernel_string ( kernel_type ) // \"'\" ) call m % create ( ndims , kernel_type , base_storage , configs_to_add ( 1 : k ), props ) endif deallocate ( configs_to_add ) else WRITE_DEBUG ( \"Adding new module with following configs for '\" // get_kernel_string ( kernel_type ) // \"'\" ) do j = 1 , size ( configs ) WRITE_DEBUG ( to_str ( configs ( j )% tile_size ) // \"x\" // to_str ( configs ( j )% block_rows ) // \": \" // to_str ( configs ( j )% padding )) enddo call m % create ( ndims , kernel_type , base_storage , configs , props ) endif if ( k == 0 . and . is_found ) return call cache % add ( m ) end subroutine create_nvrtc_module function get_kernel_instance ( ndims , kernel_type , base_storage , tile_size , block_rows ) result ( fun ) !! Retrieves a kernel instance from the cache !! If the instance is not found, an error is raised integer ( int32 ), intent ( in ) :: ndims !! Number of dimensions (2 or 3) type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element integer ( int32 ), intent ( in ) :: tile_size !! Tile size (number of columns) integer ( int32 ), intent ( in ) :: block_rows !! Block rows type ( CUfunction ) :: fun !! Retrieved kernel instance logical :: is_found !! Flag that indicates if instance was found integer ( int32 ) :: i !! Loop counter fun = CUfunction ( c_null_ptr ) if ( . not . cache % is_created ) INTERNAL_ERROR ( \"get_kernel_instance: cache not created\" ) is_found = . false . do i = 1 , cache % size fun = cache % cache ( i )% get ( ndims , kernel_type , base_storage , tile_size , block_rows ) if ( . not . is_null_ptr ( fun % ptr ) ) return enddo WRITE_DEBUG ( \"Kernel = \" // get_kernel_string ( kernel_type ) // \": \" // to_str ( tile_size ) // \"x\" // to_str ( block_rows )) INTERNAL_ERROR ( \"get_kernel_instance: unable to retrive function from cache\" ) end function get_kernel_instance end module dtfft_nvrtc_module_cache","tags":"","loc":"sourcefile/dtfft_nvrtc_module_cache.f90.html"},{"title":"dtfft_config.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_config.f90~~EfferentGraph sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_config.f90~~AfferentGraph sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_config !! Configuration module for dtFFT. !! It handles both runtime (environment variables) and compile-time ([[dtfft_config_t]]) configurations. use iso_c_binding , only : c_bool , c_int32_t use iso_fortran_env use dtfft_errors use dtfft_parameters use dtfft_utils #ifdef DTFFT_WITH_CUDA use dtfft_interface_cuda_runtime #endif #include \"_dtfft_cuda.h\" #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" implicit none private public :: init_internal public :: dtfft_config_t public :: string public :: dtfft_create_config , dtfft_set_config public :: get_conf_log_enabled , get_conf_z_slab_enabled , get_conf_y_slab_enabled public :: get_conf_platform public :: get_conf_measure_warmup_iters , get_conf_measure_iters public :: get_env , get_datatype_from_env public :: get_conf_backend , get_conf_datatype_enabled public :: get_conf_mpi_enabled , get_conf_pipelined_enabled #ifdef DTFFT_WITH_CUDA public :: destroy_stream public :: get_conf_stream public :: get_conf_nvshmem_enabled , get_conf_nccl_enabled public :: get_conf_kernel_optimization_enabled , get_conf_configs_to_test public :: get_conf_forced_kernel_optimization #endif logical , save :: is_init_called = . false . !! Has [[init_internal]] already been called or not integer ( int32 ), save :: log_enabled_from_env = VARIABLE_NOT_SET !! Should we log messages to stdout or not type ( dtfft_platform_t ), save :: platform_from_env = PLATFORM_NOT_SET !! Platform obtained from environ integer ( int32 ), save :: z_slab_from_env = VARIABLE_NOT_SET !! Should Z-slab be used if possible integer ( int32 ), save :: y_slab_from_env = VARIABLE_NOT_SET !! Should Y-slab be used if possible integer ( int32 ), save :: n_measure_warmup_iters_from_env = VARIABLE_NOT_SET !! Number of warmup iterations for measurements integer ( int32 ), save :: n_measure_iters_from_env = VARIABLE_NOT_SET !! Number of measurement iterations logical , save :: is_log_enabled = . false . !! Should we print additional information during plan creation logical , save :: is_z_slab_enabled = . true . !! Should we use Z-slab optimization or not logical , save :: is_y_slab_enabled = . false . !! Should we use Y-slab optimization or not type ( dtfft_platform_t ), save :: platform = DTFFT_PLATFORM_HOST !! Default platform integer ( int32 ), save :: n_measure_warmup_iters = CONF_DTFFT_MEASURE_WARMUP_ITERS !! Number of warmup iterations for measurements integer ( int32 ), save :: n_measure_iters = CONF_DTFFT_MEASURE_ITERS !! Number of measurement iterations type ( dtfft_backend_t ), save :: backend_from_env = BACKEND_NOT_SET !! Backend obtained from environ integer ( int32 ), save :: datatype_enabled_from_env = VARIABLE_NOT_SET !! Should we use MPI Datatype backend during autotune or not integer ( int32 ), save :: mpi_enabled_from_env = VARIABLE_NOT_SET !! Should we use MPI backends during autotune or not integer ( int32 ), save :: pipelined_enabled_from_env = VARIABLE_NOT_SET !! Should we use pipelined backends during autotune or not #ifdef DTFFT_WITH_CUDA integer ( int32 ), save :: nccl_enabled_from_env = VARIABLE_NOT_SET !! Should we use NCCL backends during autotune or not integer ( int32 ), save :: nvshmem_enabled_from_env = VARIABLE_NOT_SET !! Should we use NVSHMEM backends during autotune or not integer ( int32 ), save :: kernel_optimization_enabled_from_env = VARIABLE_NOT_SET !! Should we enable kernel block optimization during autotune or not integer ( int32 ), save :: n_configs_to_test_from_env = VARIABLE_NOT_SET !! Number of blocks to test during nvrtc kernel autotune integer ( int32 ), save :: forced_kernel_optimization_from_env = VARIABLE_NOT_SET !! Should we force kernel optimization even when effort is not DTFFT_PATIENT type ( dtfft_backend_t ), parameter :: DEFAULT_BACKEND = BACKEND_NOT_SET !! Default backend when cuda is enabled type ( dtfft_stream_t ), save :: main_stream = NULL_STREAM !! Default dtFFT CUDA stream type ( dtfft_stream_t ), save :: custom_stream = NULL_STREAM !! CUDA stream set by the user logical , save :: is_stream_created = . false . !! Is the default stream created? logical , save :: is_custom_stream = . false . !! Is the custom stream provided by the user? #else type ( dtfft_backend_t ), parameter :: DEFAULT_BACKEND = DTFFT_BACKEND_MPI_DATATYPE !! Default host backend #endif logical , save :: is_datatype_enabled = . true . !! Should we use MPI Datatype backend or not logical , save :: is_pipelined_enabled = . true . !! Should we use pipelined backends or not logical , save :: is_mpi_enabled = . false . !! Should we use MPI backends or not #ifdef DTFFT_WITH_CUDA logical , save :: is_nccl_enabled = . true . !! Should we use NCCL backends or not logical , save :: is_nvshmem_enabled = . true . !! Should we use NCCL backends or not logical , save :: is_kernel_optimization_enabled = . true . !! Should we use kernel optimization or not integer ( int32 ), save :: n_configs_to_test = CONF_DTFFT_CONFIGS_TO_TEST !! Number of different NVRTC kernel configurations to try during autotune logical , save :: is_forced_kernel_optimization = . false . !! Should we use forced kernel optimization or not #endif type ( dtfft_backend_t ), save :: backend = DEFAULT_BACKEND !! Default backend character ( len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! Upper case alphabet. character ( len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !! Lower case alphabet. type , bind ( C ) :: dtfft_config_t !! Type that can be used to set additional configuration parameters to ``dtFFT`` logical ( c_bool ) :: enable_log !! Should dtFFT print additional information during plan creation or not. !! !! Default is false. logical ( c_bool ) :: enable_z_slab !! Should dtFFT use Z-slab optimization or not. !! !! Default is true. !! !! One should consider disabling Z-slab optimization in order to resolve `DTFFT_ERROR_VKFFT_R2R_2D_PLAN` error !! OR when underlying FFT implementation of 2D plan is too slow. !! In all other cases it is considered that Z-slab is always faster, since it reduces number of data transpositions. logical ( c_bool ) :: enable_y_slab !! Should dtFFT use Y-slab optimization or not. !! !! Default is false. !! !! One should consider disabling Y-slab optimization in order to resolve `DTFFT_ERROR_VKFFT_R2R_2D_PLAN` error !! OR when underlying FFT implementation of 2D plan is too slow. !! In all other cases it is considered that Y-slab is always faster, since it reduces number of data transpositions. integer ( c_int32_t ) :: n_measure_warmup_iters !! Number of warmup iterations to execute when effort level is higher or equal to `DTFFT_MEASURE` !! !! Default is 2. integer ( c_int32_t ) :: n_measure_iters !! Number of iterations to execute when effort level is higher or equal to `DTFFT_MEASURE` !! !! Default is 5. !! When `dtFFT` is built with CUDA support, this value also used to determine number !! of iterations when selecting block of threads for NVRTC transpose kernel #ifdef DTFFT_WITH_CUDA type ( dtfft_platform_t ) :: platform !! Selects platform to execute plan. !! !! Default is DTFFT_PLATFORM_HOST !! !! This option is only defined with device support build. !! Even when dtFFT is build with device support it does not nessasary means that all plans must be related to device. !! This enables single library installation to be compiled with both host, CUDA and HIP plans. type ( dtfft_stream_t ) :: stream !! Main CUDA stream that will be used in dtFFT. !! !! This parameter is a placeholder for user to set custom stream. !! !! Stream that is actually used by dtFFT plan is returned by `plan%get_stream` function. !! !! When user sets stream he is responsible of destroying it. !! !! Stream must not be destroyed before call to `plan%destroy`. #endif type ( dtfft_backend_t ) :: backend !! Backend that will be used by dtFFT when `effort` is `DTFFT_ESTIMATE` or `DTFFT_MEASURE`. !! !! Default is `DTFFT_BACKEND_NCCL` if NCCL is enabled, otherwise `DTFFT_BACKEND_MPI_P2P`. logical ( c_bool ) :: enable_datatype_backend !! Should `DTFFT_BACKEND_MPI_DATATYPE` be enabled when `effort` is `DTFFT_PATIENT` or not. !! !! Default is true. !! !! This option works when `platform` is `DTFFT_PLATFORM_HOST`. logical ( c_bool ) :: enable_mpi_backends !! Should MPI Backends be enabled when `effort` is `DTFFT_PATIENT` or not. !! !! Default is false. !! !! The following applies only to CUDA builds. !! MPI Backends are disabled by default during autotuning process due to OpenMPI Bug https://github.com/open-mpi/ompi/issues/12849 !! It was noticed that during plan autotuning GPU memory not being freed completely. !! For example: !! 1024x1024x512 C2C, double precision, single GPU, using Z-slab optimization, with MPI backends enabled, plan autotuning will leak 8Gb GPU memory. !! Without Z-slab optimization, running on 4 GPUs, will leak 24Gb on each of the GPUs. !! !! One of the workarounds is to disable MPI Backends by default, which is done here. !! !! Other is to pass \"--mca btl_smcuda_use_cuda_ipc 0\" to `mpiexec`, !! but it was noticed that disabling CUDA IPC seriously affects overall performance of MPI algorithms logical ( c_bool ) :: enable_pipelined_backends !! Should pipelined GPU backends be enabled when `effort` is `DTFFT_PATIENT` or not. !! !! Default is true. !! !! Pipelined backends require additional buffer that user has no control over. #ifdef DTFFT_WITH_CUDA logical ( c_bool ) :: enable_nccl_backends !! Should NCCL Backends be enabled when `effort` is `DTFFT_PATIENT` or not. !! !! Default is true. logical ( c_bool ) :: enable_nvshmem_backends !! Should NVSHMEM Backends be enabled when `effort` is `DTFFT_PATIENT` or not. !! !! Default is true. logical ( c_bool ) :: enable_kernel_optimization !! Should dtFFT try to optimize NVRTC kernel block size when `effort` is `DTFFT_PATIENT` or not. !! !! Default is true. !! !! This option is only defined when dtFFT is built with CUDA support. !! !! Enabling this option will make autotuning process longer, but may result in better performance for some problem sizes. !! It is recommended to keep this option enabled. integer ( c_int32_t ) :: n_configs_to_test !! Number of top theoretical best performing blocks of threads to test for transposition kernels !! when `effort` is `DTFFT_PATIENT`  or `force_kernel_optimization` set to `true`. !! !! Default is 5. !! !! This option is only defined when dtFFT is built with CUDA support. !! !! It is recommended to keep this value between 3 and 10. !! Maximum possible value is 25. !! Setting this value to zero or one will disable kernel optimization. logical ( c_bool ) :: force_kernel_optimization !! Whether to force kernel optimization when `effort` is not `DTFFT_PATIENT`. !! !! Default is false. !! !! This option is only defined when dtFFT is built with CUDA support. !! !! Enabling this option will make plan creation process longer, but may result in better performance for a long run. !! Since kernel optimization is performed without data transfers, the overall autotuning time increase should not be significant. #endif end type dtfft_config_t interface dtfft_config_t !! Interface to create a new configuration module procedure config_constructor !! Default constructor end interface dtfft_config_t interface get_conf_internal !! Returns value from configuration unless environment variable is set module procedure get_conf_internal_logical !! For logical values module procedure get_conf_internal_int32 !! For integer(int32) values end interface get_conf_internal interface get_env !! Obtains environment variable module procedure :: get_env_base !! Base procedure module procedure :: get_env_string !! For string values module procedure :: get_env_int32 !! For integer(int32) values module procedure :: get_env_int8 !! For integer(int8) values module procedure :: get_env_logical !! For logical values end interface get_env contains integer ( int32 ) function init_internal () !! Checks if MPI is initialized and loads environment variables integer ( int32 ) :: ierr !! Error code logical :: is_mpi_init !! Is MPI initialized? init_internal = DTFFT_SUCCESS call MPI_Initialized ( is_mpi_init , ierr ) if ( . not . is_mpi_init ) then init_internal = DTFFT_ERROR_MPI_FINALIZED return endif ! Processing environment variables once if ( is_init_called ) return call init_environment () is_init_called = . true . end function init_internal subroutine init_environment () log_enabled_from_env = get_env ( \"ENABLE_LOG\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) z_slab_from_env = get_env ( \"ENABLE_Z_SLAB\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) y_slab_from_env = get_env ( \"ENABLE_Y_SLAB\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) n_measure_warmup_iters_from_env = get_env ( \"MEASURE_WARMUP_ITERS\" , VARIABLE_NOT_SET , min_valid_value = 0 ) n_measure_iters_from_env = get_env ( \"MEASURE_ITERS\" , VARIABLE_NOT_SET , min_valid_value = 1 ) #ifdef DTFFT_WITH_CUDA block type ( string ), allocatable :: platforms (:) type ( string ) :: pltfrm_env allocate ( platforms ( 2 ) ) platforms ( 1 ) = string ( \"host\" ) platforms ( 2 ) = string ( \"cuda\" ) pltfrm_env = get_env ( \"PLATFORM\" , \"undefined\" , platforms ) if ( pltfrm_env % raw == \"undefined\" ) then platform_from_env = PLATFORM_NOT_SET else if ( pltfrm_env % raw == \"host\" ) then platform_from_env = DTFFT_PLATFORM_HOST else if ( pltfrm_env % raw == \"cuda\" ) then platform_from_env = DTFFT_PLATFORM_CUDA endif call pltfrm_env % destroy () call destroy_strings ( platforms ) endblock #endif block type ( string ), allocatable :: backends (:) type ( string ) :: bcknd_env allocate ( backends ( 10 ) ) backends ( 1 ) = string ( \"mpi_dt\" ) backends ( 2 ) = string ( \"mpi_p2p\" ) backends ( 3 ) = string ( \"mpi_a2a\" ) backends ( 4 ) = string ( \"mpi_p2p_pipe\" ) backends ( 5 ) = string ( \"nccl\" ) backends ( 6 ) = string ( \"nccl_pipe\" ) backends ( 7 ) = string ( \"cufftmp\" ) backends ( 8 ) = string ( \"cufftmp_pipe\" ) backends ( 9 ) = string ( \"mpi_rma\" ) backends ( 10 ) = string ( \"mpi_rma_pipe\" ) bcknd_env = get_env ( \"BACKEND\" , \"undefined\" , backends ) select case ( bcknd_env % raw ) case ( \"undefined\" ) backend_from_env = BACKEND_NOT_SET case ( \"mpi_dt\" ) backend_from_env = DTFFT_BACKEND_MPI_DATATYPE case ( \"mpi_p2p\" ) backend_from_env = DTFFT_BACKEND_MPI_P2P case ( \"mpi_a2a\" ) backend_from_env = DTFFT_BACKEND_MPI_A2A case ( \"mpi_p2p_pipe\" ) backend_from_env = DTFFT_BACKEND_MPI_P2P_PIPELINED case ( \"nccl\" ) backend_from_env = DTFFT_BACKEND_NCCL case ( \"nccl_pipe\" ) backend_from_env = DTFFT_BACKEND_NCCL_PIPELINED case ( \"cufftmp\" ) backend_from_env = DTFFT_BACKEND_CUFFTMP case ( \"cufftmp_pipe\" ) backend_from_env = DTFFT_BACKEND_CUFFTMP_PIPELINED case ( \"mpi_rma\" ) backend_from_env = DTFFT_BACKEND_MPI_RMA case ( \"mpi_rma_pipe\" ) backend_from_env = DTFFT_BACKEND_MPI_RMA_PIPELINED endselect if ( backend_from_env /= BACKEND_NOT_SET . and . . not . is_valid_backend ( backend_from_env ) ) then WRITE_ERROR ( \"Backend '\" // bcknd_env % raw // \"' is not available in this build.\" ) WRITE_ERROR ( \"Environment variable 'DTFFT_BACKEND' has been ignored\" ) backend_from_env = BACKEND_NOT_SET endif call bcknd_env % destroy () call destroy_strings ( backends ) endblock datatype_enabled_from_env = get_env ( \"ENABLE_MPI_DT\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) mpi_enabled_from_env = get_env ( \"ENABLE_MPI\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) pipelined_enabled_from_env = get_env ( \"ENABLE_PIPE\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) #ifdef DTFFT_WITH_CUDA nccl_enabled_from_env = get_env ( \"ENABLE_NCCL\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) nvshmem_enabled_from_env = get_env ( \"ENABLE_NVSHMEM\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) kernel_optimization_enabled_from_env = get_env ( \"ENABLE_KERNEL_OPTIMIZATION\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) n_configs_to_test_from_env = get_env ( \"CONFIGS_TO_TEST\" , VARIABLE_NOT_SET , min_valid_value = 0 ) forced_kernel_optimization_from_env = get_env ( \"FORCE_KERNEL_OPTIMIZATION\" , VARIABLE_NOT_SET , valid_values = [ 0 , 1 ]) #endif end subroutine init_environment pure subroutine dtfft_create_config ( config ) bind ( C , name = \"dtfft_create_config_c\" ) !! Creates a new configuration and sets default values. !! !! C interface type ( dtfft_config_t ), intent ( out ) :: config !! Configuration to create config = dtfft_config_t () end subroutine dtfft_create_config #ifdef DTFFT_WITH_CUDA pure function config_constructor ( & enable_log , enable_z_slab , enable_y_slab , & n_measure_warmup_iters , n_measure_iters , & platform , stream , backend , enable_datatype_backend , & enable_mpi_backends , enable_pipelined_backends , & enable_nccl_backends , enable_nvshmem_backends , & enable_kernel_optimization , n_configs_to_test , & force_kernel_optimization ) result ( config ) #else pure function config_constructor ( & enable_log , enable_z_slab , enable_y_slab , & n_measure_warmup_iters , n_measure_iters , & backend , enable_datatype_backend , & enable_mpi_backends , enable_pipelined_backends ) result ( config ) #endif !! Creates a new configuration logical , optional , intent ( in ) :: enable_log !! Should dtFFT use Z-slab optimization or not. logical , optional , intent ( in ) :: enable_z_slab !! Should dtFFT use Z-slab optimization or not. logical , optional , intent ( in ) :: enable_y_slab !! Should dtFFT use Y-slab optimization or not. integer ( int32 ), optional , intent ( in ) :: n_measure_warmup_iters !! Number of warmup iterations for measurements integer ( int32 ), optional , intent ( in ) :: n_measure_iters !! Number of measurement iterations #ifdef DTFFT_WITH_CUDA type ( dtfft_platform_t ), optional , intent ( in ) :: platform !! Selects platform to execute plan. type ( dtfft_stream_t ), optional , intent ( in ) :: stream !! Main CUDA stream that will be used in dtFFT. #endif type ( dtfft_backend_t ), optional , intent ( in ) :: backend !! Backend that will be used by dtFFT when `effort` is `DTFFT_ESTIMATE` or `DTFFT_MEASURE`. logical , optional , intent ( in ) :: enable_datatype_backend !! Should `DTFFT_BACKEND_MPI_DATATYPE` be enabled when `effort` is `DTFFT_PATIENT` or not. logical , optional , intent ( in ) :: enable_mpi_backends !! Should MPI GPU Backends be enabled when `effort` is `DTFFT_PATIENT` or not. logical , optional , intent ( in ) :: enable_pipelined_backends !! Should pipelined GPU backends be enabled when `effort` is `DTFFT_PATIENT` or not. #ifdef DTFFT_WITH_CUDA logical , optional , intent ( in ) :: enable_nccl_backends !! Should NCCL Backends be enabled when `effort` is `DTFFT_PATIENT` or not. logical , optional , intent ( in ) :: enable_nvshmem_backends !! Should NVSHMEM Backends be enabled when `effort` is `DTFFT_PATIENT` or not. logical , optional , intent ( in ) :: enable_kernel_optimization !! Should dtFFT try to optimize NVRTC kernel block size during autotune or not. integer ( int32 ), optional , intent ( in ) :: n_configs_to_test !! Number of top theoretical best performing blocks of threads to test for transposition kernels when `effort` is `DTFFT_PATIENT`. logical , optional , intent ( in ) :: force_kernel_optimization !! Whether to force kernel optimization when `effort` is not `DTFFT_PATIENT`. #endif type ( dtfft_config_t ) :: config !! Constructed `dtFFT` config ready to be set by call to [[dtfft_set_config]] config % enable_log = . false .; if ( present ( enable_log ) ) config % enable_log = enable_log config % enable_z_slab = . true .; if ( present ( enable_z_slab ) ) config % enable_z_slab = enable_z_slab config % enable_y_slab = . false .; if ( present ( enable_y_slab ) ) config % enable_y_slab = enable_y_slab config % n_measure_warmup_iters = CONF_DTFFT_MEASURE_WARMUP_ITERS if ( present ( n_measure_warmup_iters ) ) config % n_measure_warmup_iters = n_measure_warmup_iters config % n_measure_iters = CONF_DTFFT_MEASURE_ITERS if ( present ( n_measure_iters ) ) config % n_measure_iters = n_measure_iters #ifdef DTFFT_WITH_CUDA config % platform = DTFFT_PLATFORM_HOST ; if ( present ( platform ) ) config % platform = platform config % stream = NULL_STREAM ; if ( present ( stream ) ) config % stream = stream #endif config % backend = DEFAULT_BACKEND ; if ( present ( backend ) ) config % backend = backend config % enable_datatype_backend = . true .; if ( present ( enable_datatype_backend ) ) config % enable_datatype_backend = enable_datatype_backend config % enable_mpi_backends = . false .; if ( present ( enable_mpi_backends ) ) config % enable_mpi_backends = enable_mpi_backends config % enable_pipelined_backends = . true .; if ( present ( enable_pipelined_backends ) ) config % enable_pipelined_backends = enable_pipelined_backends #ifdef DTFFT_WITH_CUDA config % enable_nccl_backends = . true .; if ( present ( enable_nccl_backends ) ) config % enable_nccl_backends = enable_nccl_backends config % enable_nvshmem_backends = . true .; if ( present ( enable_nvshmem_backends ) ) config % enable_nvshmem_backends = enable_nvshmem_backends config % enable_kernel_optimization = . true .; if ( present ( enable_kernel_optimization ) ) config % enable_kernel_optimization = enable_kernel_optimization config % n_configs_to_test = CONF_DTFFT_CONFIGS_TO_TEST if ( present ( n_configs_to_test ) ) config % n_configs_to_test = n_configs_to_test config % force_kernel_optimization = . false .; if ( present ( force_kernel_optimization ) ) config % force_kernel_optimization = force_kernel_optimization #endif end function config_constructor subroutine dtfft_set_config ( config , error_code ) !! Sets configuration parameters type ( dtfft_config_t ), intent ( in ) :: config !! Configuration to set integer ( int32 ), optional , intent ( out ) :: error_code !! Error code integer ( int32 ) :: ierr ierr = init_internal () if ( ierr /= DTFFT_SUCCESS ) then if ( present ( error_code ) ) error_code = ierr return endif is_log_enabled = config % enable_log is_z_slab_enabled = config % enable_z_slab is_y_slab_enabled = config % enable_y_slab if ( config % n_measure_warmup_iters < 0 ) then if ( present ( error_code ) ) error_code = DTFFT_ERROR_INVALID_MEASURE_WARMUP_ITERS return endif n_measure_warmup_iters = config % n_measure_warmup_iters if ( config % n_measure_iters < 1 ) then if ( present ( error_code ) ) error_code = DTFFT_ERROR_INVALID_MEASURE_ITERS return endif n_measure_iters = config % n_measure_iters is_datatype_enabled = config % enable_datatype_backend is_mpi_enabled = config % enable_mpi_backends is_pipelined_enabled = config % enable_pipelined_backends #ifdef DTFFT_WITH_CUDA if ( . not . is_null_ptr ( config % stream % stream ) ) then block integer ( int32 ) :: ierr ierr = cudaStreamQuery ( config % stream ) if ( . not . any ( ierr == [ cudaSuccess , cudaErrorNotReady ]) ) then if ( present ( error_code ) ) error_code = DTFFT_ERROR_GPU_INVALID_STREAM return endif custom_stream = config % stream is_custom_stream = . true . endblock endif if ( . not . is_valid_platform ( config % platform ) ) then if ( present ( error_code ) ) error_code = DTFFT_ERROR_INVALID_PLATFORM return endif platform = config % platform is_nccl_enabled = config % enable_nccl_backends is_nvshmem_enabled = config % enable_nvshmem_backends is_forced_kernel_optimization = config % force_kernel_optimization is_kernel_optimization_enabled = config % enable_kernel_optimization n_configs_to_test = config % n_configs_to_test if ( n_configs_to_test <= 1 ) then is_kernel_optimization_enabled = . false . endif #endif if ( config % backend /= BACKEND_NOT_SET . and . . not . is_valid_backend ( config % backend )) then if ( present ( error_code ) ) error_code = DTFFT_ERROR_INVALID_BACKEND return endif backend = get_correct_backend ( config % backend ) if ( present ( error_code ) ) error_code = DTFFT_SUCCESS end subroutine dtfft_set_config elemental type ( dtfft_backend_t ) function get_correct_backend ( back ) type ( dtfft_backend_t ), intent ( in ) :: back if ( back == BACKEND_NOT_SET ) then #ifdef DTFFT_WITH_CUDA if ( get_conf_platform () == DTFFT_PLATFORM_CUDA ) then # ifdef DTFFT_WITH_NCCL get_correct_backend = DTFFT_BACKEND_NCCL # else get_correct_backend = DTFFT_BACKEND_MPI_P2P # endif else get_correct_backend = DTFFT_BACKEND_MPI_DATATYPE endif #else get_correct_backend = DTFFT_BACKEND_MPI_DATATYPE #endif else get_correct_backend = back endif end function get_correct_backend elemental logical function get_conf_internal_logical ( from_conf , from_env ) !! Returns value from configuration unless environment variable is set logical , intent ( in ) :: from_conf !! Value from configuration integer ( int32 ), intent ( in ) :: from_env !! Value from environment variable get_conf_internal_logical = from_conf if ( from_env /= VARIABLE_NOT_SET ) get_conf_internal_logical = from_env == 1 end function get_conf_internal_logical elemental integer ( int32 ) function get_conf_internal_int32 ( from_conf , from_env ) !! Returns value from configuration unless environment variable is set integer ( int32 ), intent ( in ) :: from_conf !! Value from configuration integer ( int32 ), intent ( in ) :: from_env !! Value from environment variable get_conf_internal_int32 = from_conf if ( from_env /= VARIABLE_NOT_SET ) get_conf_internal_int32 = from_env end function get_conf_internal_int32 elemental function get_conf_log_enabled () result ( bool ) !! Whether logging is enabled or not logical :: bool !! Result flag bool = get_conf_internal ( is_log_enabled , log_enabled_from_env ) end function get_conf_log_enabled elemental function get_conf_z_slab_enabled () result ( bool ) !! Whether Z-slab optimization is enabled or not logical :: bool !! Result flag bool = get_conf_internal ( is_z_slab_enabled , z_slab_from_env ) end function get_conf_z_slab_enabled elemental function get_conf_y_slab_enabled () result ( bool ) !! Whether Y-slab optimization is enabled or not logical :: bool !! Result flag bool = get_conf_internal ( is_y_slab_enabled , y_slab_from_env ) end function get_conf_y_slab_enabled elemental function get_conf_measure_warmup_iters () result ( iters ) !! Returns the number of warmup iterations integer ( int32 ) :: iters !! Result iters = get_conf_internal ( n_measure_warmup_iters , n_measure_warmup_iters_from_env ) end function get_conf_measure_warmup_iters elemental function get_conf_measure_iters () result ( iters ) !! Returns the number of measurement iterations integer ( int32 ) :: iters !! Result iters = get_conf_internal ( n_measure_iters , n_measure_iters_from_env ) end function get_conf_measure_iters elemental type ( dtfft_platform_t ) function get_conf_platform () !! Returns platform set by the user or default one get_conf_platform = platform if ( platform_from_env /= PLATFORM_NOT_SET ) get_conf_platform = platform_from_env end function get_conf_platform #ifdef DTFFT_WITH_CUDA type ( dtfft_stream_t ) function get_conf_stream () result ( stream ) !! Returns either the custom provided by user or creates a new one if ( is_custom_stream ) then stream = custom_stream return endif if (. not . is_stream_created ) then CUDA_CALL ( cudaStreamCreate ( main_stream ) ) is_stream_created = . true . endif stream = main_stream end function get_conf_stream subroutine destroy_stream !! Destroy the default stream if it was created if ( is_stream_created ) then CUDA_CALL ( cudaStreamDestroy ( main_stream ) ) is_stream_created = . false . endif end subroutine destroy_stream #endif elemental type ( dtfft_backend_t ) function get_conf_backend () !! Returns backend set by the user or default one get_conf_backend = get_correct_backend ( backend ) if ( backend_from_env /= BACKEND_NOT_SET ) get_conf_backend = backend_from_env end function get_conf_backend elemental function get_conf_datatype_enabled () result ( bool ) !! Whether MPI Datatype backend is enabled or not logical :: bool !! Result flag bool = get_conf_internal ( is_datatype_enabled , datatype_enabled_from_env ) end function get_conf_datatype_enabled elemental function get_conf_pipelined_enabled () result ( bool ) !! Whether pipelined backends are enabled or not logical :: bool !! Result flag bool = get_conf_internal ( is_pipelined_enabled , pipelined_enabled_from_env ) end function get_conf_pipelined_enabled elemental function get_conf_mpi_enabled () result ( bool ) !! Whether MPI backends are enabled or not logical :: bool !! Result flag #if !defined(DTFFT_WITH_NCCL) && !defined(DTFFT_WITH_NVSHMEM) if ( get_conf_platform () == DTFFT_PLATFORM_HOST ) then bool = get_conf_internal ( is_mpi_enabled , mpi_enabled_from_env ) else bool = . true . endif ! Should not be .false. if only MPI backends are possible #else bool = get_conf_internal ( is_mpi_enabled , mpi_enabled_from_env ) #endif end function get_conf_mpi_enabled #ifdef DTFFT_WITH_CUDA elemental function get_conf_nccl_enabled () result ( bool ) !! Whether NCCL backends are enabled or not logical :: bool !! Result flag # ifdef DTFFT_WITH_NCCL bool = get_conf_internal ( is_nccl_enabled , nccl_enabled_from_env ) # else bool = . false . # endif end function get_conf_nccl_enabled elemental function get_conf_nvshmem_enabled () result ( bool ) !! Whether nvshmem backends are enabled or not logical :: bool !! Result flag # ifdef DTFFT_WITH_NVSHMEM bool = get_conf_internal ( is_nvshmem_enabled , nvshmem_enabled_from_env ) # else bool = . false . # endif end function get_conf_nvshmem_enabled elemental function get_conf_kernel_optimization_enabled () result ( bool ) !! Whether kernel optimization is enabled or not logical :: bool !! Result flag bool = get_conf_internal ( is_kernel_optimization_enabled , kernel_optimization_enabled_from_env ) end function get_conf_kernel_optimization_enabled pure function get_conf_configs_to_test () result ( n ) !! Returns the number of configurations to test integer ( int32 ) :: n !! Result n = get_conf_internal ( n_configs_to_test , n_configs_to_test_from_env ) end function get_conf_configs_to_test elemental function get_conf_forced_kernel_optimization () result ( bool ) !! Whether forced kernel optimization is enabled or not logical :: bool !! Result flag bool = get_conf_internal ( is_forced_kernel_optimization , forced_kernel_optimization_from_env ) end function get_conf_forced_kernel_optimization #endif type ( string ) function get_env_base ( name ) result ( env ) !! Base function of obtaining dtFFT environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix type ( string ) :: full_name !! Prefixed environment variable name integer ( int32 ) :: env_val_len !! Length of the environment variable full_name = string ( \"DTFFT_\" // name ) call get_environment_variable ( full_name % raw , length = env_val_len ) allocate ( character ( env_val_len ) :: env % raw ) if ( env_val_len == 0 ) then call full_name % destroy () return endif call get_environment_variable ( full_name % raw , env % raw ) call full_name % destroy () end function get_env_base type ( string ) function get_env_string ( name , default , valid_values ) result ( env ) !! Obtains string environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix character ( len =* ), intent ( in ) :: default !! Name of environment variable without prefix type ( string ), intent ( in ) :: valid_values (:) !! List of valid variable values logical :: is_correct !! Is env value is correct integer ( int32 ) :: i !! Index in string integer ( int32 ) :: j !! Index in alphabet type ( string ) :: env_val_str !! String value of the environment variable env_val_str = get_env ( name ) if ( len ( env_val_str % raw ) == 0 ) then call env_val_str % destroy () env = string ( default ) return endif ! Converting to lowercase do i = 1 , len ( env_val_str % raw ) j = index ( UPPER_ALPHABET , env_val_str % raw ( i : i )) if ( j > 0 ) env_val_str % raw ( i : i ) = LOWER_ALPHABET ( j : j ) enddo is_correct = any ([( env_val_str % raw == valid_values ( i )% raw , i = 1 , size ( valid_values ))]) if ( is_correct ) then env = string ( env_val_str % raw ) call env_val_str % destroy () return endif WRITE_ERROR ( \"Invalid environment variable: `DTFFT_\" // name // \"`, it has been ignored\" ) call env_val_str % destroy () env = string ( default ) end function get_env_string integer ( int32 ) function get_env_int32 ( name , default , valid_values , min_valid_value ) result ( env ) !! Base Integer function of obtaining dtFFT environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix integer ( int32 ), intent ( in ) :: default !! Default value in case env is not set or it has wrong value integer ( int32 ), intent ( in ), optional :: valid_values (:) !! List of valid values integer ( int32 ), intent ( in ), optional :: min_valid_value !! Mininum valid value. Usually 0 or 1 type ( string ) :: env_val_str !! String value of the environment variable logical :: is_correct !! Is env value is correct integer ( int32 ) :: env_val_passed !! Value of the environment variable integer ( int32 ) :: io_status !! IO status of reading env variable #ifdef DTFFT_DEBUG if ( ( present ( valid_values ). and . present ( min_valid_value ) ) & . or .(. not . present ( valid_values ). and .. not . present ( min_valid_value )) & ) then INTERNAL_ERROR ( \"`get_env_int32`\" ) endif #endif env_val_str = get_env ( name ) if ( len ( env_val_str % raw ) == 0 ) then deallocate ( env_val_str % raw ) env = default return endif read ( env_val_str % raw , * , iostat = io_status ) env_val_passed if ( io_status /= 0 ) then WRITE_ERROR ( \"Invalid integer value for environment variable: `DTFFT_\" // name // \"`=<\" // env_val_str % raw // \">, it has been ignored\" ) env = default deallocate ( env_val_str % raw ) return endif is_correct = . false . if ( present ( valid_values ) ) then is_correct = any ( env_val_passed == valid_values ) endif if ( present ( min_valid_value ) ) then is_correct = env_val_passed >= min_valid_value endif if ( is_correct ) then env = env_val_passed deallocate ( env_val_str % raw ) return endif WRITE_ERROR ( \"Invalid integer value for environment variable: `DTFFT_\" // name // \"`=<\" // env_val_str % raw // \">, it has been ignored\" ) env = default deallocate ( env_val_str % raw ) end function get_env_int32 integer ( int8 ) function get_env_int8 ( name , default , valid_values ) result ( env ) !! Obtains int8 environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix integer ( int8 ), intent ( in ) :: default !! Default value in case env is not set or it has wrong value integer ( int32 ), intent ( in ) :: valid_values (:) !! List of valid values integer ( int32 ) :: val !! Value of the environment variable val = get_env ( name , int ( default , int32 ), valid_values ) env = int ( val , int8 ) end function get_env_int8 logical function get_env_logical ( name , default ) result ( env ) !! Obtains logical environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix logical , intent ( in ) :: default !! Default value in case env is not set or it has wrong value integer ( int32 ) :: def , val if ( default ) then def = 1 else def = 0 endif val = get_env ( name , def , [ 0 , 1 ]) env = val == 1 end function get_env_logical integer ( int8 ) function get_datatype_from_env ( name ) result ( env ) !! Obtains datatype id from environment variable character ( len =* ), intent ( in ) :: name !! Name of environment variable without prefix env = get_env ( name , 2_int8 , [ 1 , 2 ]) end function get_datatype_from_env end module dtfft_config","tags":"","loc":"sourcefile/dtfft_config.f90.html"},{"title":"dtfft_interface_nvrtc.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_nvrtc.f90~~EfferentGraph sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_nvrtc.f90~~AfferentGraph sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_nvrtc !! nvRTC Interfaces. !! !! nvRTC is loaded at runtime via dynamic loading due to explicit cuda_driver linking by cmake. use iso_c_binding use iso_fortran_env , only : int32 use dtfft_errors , only : DTFFT_SUCCESS use dtfft_utils , only : dynamic_load , string , destroy_strings , string_c2f implicit none private #include \"_dtfft_private.h\" public :: nvrtcGetErrorString public :: load_nvrtc public :: nvrtcProgram type , bind ( C ) :: nvrtcProgram !! nvrtcProgram is the unit of compilation, and an opaque handle for a program. type ( c_ptr ) :: cptr !! Actual pointer end type nvrtcProgram abstract interface function nvrtcGetErrorString_interface ( error_code ) & result ( string ) !! Helper function that returns a string describing the given nvrtcResult code !! For unrecognized enumeration values, it returns \"NVRTC_ERROR unknown\" import integer ( c_int ), value :: error_code !! CUDA Runtime Compilation API result code. type ( c_ptr ) :: string !! Pointer to C string end function nvrtcGetErrorString_interface end interface abstract interface function nvrtcCreateProgram_interface ( prog , src , name , numHeaders , headers , includeNames ) & result ( nvrtcResult ) !! Creates an instance of nvrtcProgram with the given input parameters, !! and sets the output parameter prog with it. import type ( nvrtcProgram ) :: prog !! CUDA Runtime Compilation program. character ( c_char ) :: src ( * ) !! CUDA program source. character ( c_char ) :: name ( * ) !! CUDA program name. integer ( c_int ), value :: numHeaders !! Number of headers used. Must be greater than or equal to 0. type ( c_ptr ), value :: headers !! Sources of the headers type ( c_ptr ), value :: includeNames !! Name of each header by which they can be included in the CUDA program source integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcCreateProgram_interface end interface abstract interface function nvrtcDestroyProgram_interface ( prog ) & result ( nvrtcResult ) !! Destroys the given program. import type ( nvrtcProgram ) :: prog !! CUDA Runtime Compilation program. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcDestroyProgram_interface end interface abstract interface function nvrtcCompileProgram_interface ( prog , numOptions , options ) & result ( nvrtcResult ) !! Compiles the given program. import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. integer ( c_int ), value :: numOptions !! Number of compiler options passed. type ( c_ptr ) :: options ( * ) !! Compiler options in the form of C string array integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcCompileProgram_interface end interface abstract interface function nvrtcGetProgramLogSize_interface ( prog , logSizeRet ) & result ( nvrtcResult ) !! Sets the value of ``logSizeRet`` with the size of the log generated by the previous compilation of ``prog``. !! The log is a null-terminated string. import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. integer ( c_size_t ) :: logSizeRet !! Size of the compilation log. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcGetProgramLogSize_interface end interface abstract interface function nvrtcGetProgramLog_interface ( prog , log ) & result ( nvrtcResult ) !! Stores the log generated by the previous compilation of prog in the memory pointed by log import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. type ( c_ptr ), value :: log !! Compilation log. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcGetProgramLog_interface end interface abstract interface function nvrtcGetCUBINSize_interface ( prog , cubinSizeRet ) & result ( nvrtcResult ) !! Sets the value of ``cubinSizeRet`` with the size of the cubin generated by the previous compilation of ``prog``. import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. integer ( c_size_t ) :: cubinSizeRet !! Size of the generated cubin. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcGetCUBINSize_interface end interface abstract interface function nvrtcGetCUBIN_interface ( prog , cubin ) & result ( nvrtcResult ) !! Stores the cubin generated by the previous compilation of ``prog`` in the memory pointed by ``cubin``. import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. type ( c_ptr ), value :: cubin !! Compiled and assembled result. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcGetCUBIN_interface end interface abstract interface function nvrtcGetLoweredName_interface ( prog , name_expression , lowered_name ) & result ( nvrtcResult ) !! Extracts the lowered (mangled) name for a global function or device/__constant__ variable, !! and updates *lowered_name to point to it. import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. character ( c_char ) :: name_expression ( * ) !! Name expression. type ( c_ptr ) :: lowered_name !! Mangled name. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcGetLoweredName_interface end interface abstract interface function nvrtcAddNameExpression_interface ( prog , name_expression ) & result ( nvrtcResult ) !! Notes the given name expression denoting the address of a global function or device/__constant__ variable. import type ( nvrtcProgram ), value :: prog !! CUDA Runtime Compilation program. character ( c_char ) :: name_expression ( * ) !! Name expression. integer ( c_int ) :: nvrtcResult !! The enumerated type nvrtcResult defines API call result codes. end function nvrtcAddNameExpression_interface end interface integer ( int32 ), parameter :: N_FUNCTIONS_TO_LOAD = 10 !! Number of functions to load from nvrtc library logical , save :: is_loaded = . false . !! Flag indicating whether the library is loaded type ( c_ptr ), save :: libnvrtc !! Handle to the loaded library type ( c_funptr ), save :: nvrtcFunctions ( N_FUNCTIONS_TO_LOAD ) !! Array of pointers to the nvRTC functions procedure ( nvrtcGetErrorString_interface ), pointer :: nvrtcGetErrorString_c !! Fortran pointer to the nvrtcGetErrorString function procedure ( nvrtcCreateProgram_interface ), pointer , public :: nvrtcCreateProgram !! Fortran pointer to the nvrtcCreateProgram function procedure ( nvrtcDestroyProgram_interface ), pointer , public :: nvrtcDestroyProgram !! Fortran pointer to the nvrtcDestroyProgram function procedure ( nvrtcCompileProgram_interface ), pointer , public :: nvrtcCompileProgram !! Fortran pointer to the nvrtcCompileProgram function procedure ( nvrtcGetProgramLogSize_interface ), pointer , public :: nvrtcGetProgramLogSize !! Fortran pointer to the nvrtcGetProgramLogSize function procedure ( nvrtcGetProgramLog_interface ), pointer , public :: nvrtcGetProgramLog !! Fortran pointer to the nvrtcGetProgramLog function procedure ( nvrtcGetCUBINSize_interface ), pointer , public :: nvrtcGetCUBINSize !! Fortran pointer to the nvrtcGetCUBINSize function procedure ( nvrtcGetCUBIN_interface ), pointer , public :: nvrtcGetCUBIN !! Fortran pointer to the nvrtcGetCUBIN function procedure ( nvrtcGetLoweredName_interface ), pointer , public :: nvrtcGetLoweredName !! Fortran pointer to the nvrtcGetLoweredName function procedure ( nvrtcAddNameExpression_interface ), pointer , public :: nvrtcAddNameExpression !! Fortran pointer to the nvrtcAddNameExpression function contains function nvrtcGetErrorString ( error_code ) result ( string ) !! Helper function that returns a string describing the given nvrtcResult code !! For unrecognized enumeration values, it returns \"NVRTC_ERROR unknown\" integer ( c_int ), intent ( in ) :: error_code !! CUDA Runtime Compilation API result code. character ( len = :), allocatable :: string !! Result string type ( c_ptr ) :: c_string !! Pointer to C string c_string = nvrtcGetErrorString_c ( error_code ) call string_c2f ( c_string , string ) end function nvrtcGetErrorString function load_nvrtc () result ( error_code ) !! Dynamically loads nvRTC library and its functions integer ( int32 ) :: error_code !! Error code type ( string ), allocatable :: func_names (:) !! Array of function names to load error_code = DTFFT_SUCCESS if ( is_loaded ) return allocate ( func_names ( N_FUNCTIONS_TO_LOAD )) func_names ( 1 ) = string ( \"nvrtcGetErrorString\" ) func_names ( 2 ) = string ( \"nvrtcCreateProgram\" ) func_names ( 3 ) = string ( \"nvrtcDestroyProgram\" ) func_names ( 4 ) = string ( \"nvrtcCompileProgram\" ) func_names ( 5 ) = string ( \"nvrtcGetProgramLog\" ) func_names ( 6 ) = string ( \"nvrtcGetCUBINSize\" ) func_names ( 7 ) = string ( \"nvrtcGetCUBIN\" ) func_names ( 8 ) = string ( \"nvrtcGetProgramLogSize\" ) func_names ( 9 ) = string ( \"nvrtcGetLoweredName\" ) func_names ( 10 ) = string ( \"nvrtcAddNameExpression\" ) error_code = dynamic_load ( \"libnvrtc.so\" , func_names , libnvrtc , nvrtcFunctions ) call destroy_strings ( func_names ) if ( error_code /= DTFFT_SUCCESS ) return call c_f_procpointer ( nvrtcFunctions ( 1 ), nvrtcGetErrorString_c ) call c_f_procpointer ( nvrtcFunctions ( 2 ), nvrtcCreateProgram ) call c_f_procpointer ( nvrtcFunctions ( 3 ), nvrtcDestroyProgram ) call c_f_procpointer ( nvrtcFunctions ( 4 ), nvrtcCompileProgram ) call c_f_procpointer ( nvrtcFunctions ( 5 ), nvrtcGetProgramLog ) call c_f_procpointer ( nvrtcFunctions ( 6 ), nvrtcGetCUBINSize ) call c_f_procpointer ( nvrtcFunctions ( 7 ), nvrtcGetCUBIN ) call c_f_procpointer ( nvrtcFunctions ( 8 ), nvrtcGetProgramLogSize ) call c_f_procpointer ( nvrtcFunctions ( 9 ), nvrtcGetLoweredName ) call c_f_procpointer ( nvrtcFunctions ( 10 ), nvrtcAddNameExpression ) is_loaded = . true . end function load_nvrtc end module dtfft_interface_nvrtc","tags":"","loc":"sourcefile/dtfft_interface_nvrtc.f90.html"},{"title":"dtfft_interface_cuda.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_cuda.f90~~EfferentGraph sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_cuda.f90~~AfferentGraph sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_cuda !! CUDA Driver Interfaces !! !! CUDA Driver is loaded at runtime via dynamic loading. use iso_c_binding use iso_fortran_env , only : int32 use dtfft_errors , only : DTFFT_SUCCESS use dtfft_parameters , only : dtfft_stream_t use dtfft_utils , only : string , dynamic_load , destroy_strings implicit none private #include \"_dtfft_private.h\" public :: load_cuda public :: cuLaunchKernel public :: dim3 type , bind ( C ) :: dim3 !! Dimension specification type integer ( c_int ) :: x , y , z end type integer ( int32 ), parameter , public :: MAX_KERNEL_ARGS = 9 public :: CUmodule type , bind ( C ) :: CUmodule !! CUDA module type ( c_ptr ) :: ptr !! Actual pointer end type CUmodule public :: CUfunction type , bind ( C ) :: CUfunction !! CUDA function type ( c_ptr ) :: ptr !! Actual pointer end type CUfunction abstract interface function cuModuleLoadData_interface ( mod , image ) & result ( cuResult ) !! Load a module's data with options. !! !! Takes a pointer image and loads the corresponding module module into the current context. !! The image may be a cubin or fatbin as output by nvcc, or a NULL-terminated PTX, either as output by nvcc or hand-written. import type ( CUmodule ) :: mod !! Returned module type ( c_ptr ), value :: image !! Module data to load integer ( c_int ) :: cuResult !! Driver result code end function cuModuleLoadData_interface function cuModuleUnload_interface ( hmod ) & result ( cuResult ) !! Unloads a module. !! !! Unloads a module ``hmod`` from the current context. !! Attempting to unload a module which was obtained from the Library Management API !! such as ``cuLibraryGetModule`` will return ``CUDA_ERROR_NOT_PERMITTED``. import type ( CUmodule ), value :: hmod !! Module to unload integer ( c_int ) :: cuResult !! Driver result code end function cuModuleUnload_interface function cuModuleGetFunction_interface ( hfunc , hmod , name ) & result ( cuResult ) !! Returns a function handle. !! !! Returns in ``hfunc`` the handle of the function of name name located in module hmod. !! If no function of that name exists, ``cuModuleGetFunction`` returns ``CUDA_ERROR_NOT_FOUND``. import type ( CUfunction ) :: hfunc !! Returns a function handle. type ( CUmodule ), value :: hmod !! Module to retrieve function from type ( c_ptr ), value :: name !! Name of function to retrieve integer ( c_int ) :: cuResult !! Driver result code end function cuModuleGetFunction_interface function cuLaunchKernel_interface ( func , gridDimX , gridDimY , gridDimZ , blockDimX , blockDimY , blockDimZ , sharedMemBytes , stream , kernelParams , extra ) & result ( cuResult ) !! Launches a CUDA function CUfunction. import type ( CUfunction ), value :: func !! CUDA function to launch integer ( c_int ), value :: gridDimX !! Grid dimensions in X integer ( c_int ), value :: gridDimY !! Grid dimensions in Y integer ( c_int ), value :: gridDimZ !! Grid dimensions in Z integer ( c_int ), value :: blockDimX !! Block dimensions in X integer ( c_int ), value :: blockDimY !! Block dimensions in Y integer ( c_int ), value :: blockDimZ !! Block dimensions in Z integer ( c_int ), value :: sharedMemBytes !! Dynamic shared memory size type ( dtfft_stream_t ), value :: stream !! Stream identifier type ( c_ptr ) :: kernelParams ( * ) !! Array of pointers to kernel parameters type ( c_ptr ) :: extra !! Dynamic shared-memory size per thread block in bytes integer ( c_int ) :: cuResult !! Driver result code end function cuLaunchKernel_interface end interface logical , save :: is_loaded = . false . !! Flag indicating whether the library is loaded type ( c_ptr ), save :: libcuda !! Handle to the loaded library type ( c_funptr ), save :: cuFunctions ( 4 ) !! Array of pointers to the CUDA functions procedure ( cuModuleLoadData_interface ), pointer , public :: cuModuleLoadData !! Fortran pointer to the cuModuleLoadData function procedure ( cuModuleUnload_interface ), pointer , public :: cuModuleUnload !! Fortran pointer to the cuModuleUnload function procedure ( cuModuleGetFunction_interface ), pointer , public :: cuModuleGetFunction !! Fortran pointer to the cuModuleGetFunction function procedure ( cuLaunchKernel_interface ), pointer :: cuLaunchKernel_ !! Fortran pointer to the cuLaunchKernel function contains function load_cuda () result ( error_code ) !! Loads the CUDA Driver library and needed symbols integer ( int32 ) :: error_code !! Error code type ( string ), allocatable :: func_names (:) error_code = DTFFT_SUCCESS if ( is_loaded ) return allocate ( func_names ( 4 )) func_names ( 1 ) = string ( \"cuModuleLoadData\" ) func_names ( 2 ) = string ( \"cuModuleUnload\" ) func_names ( 3 ) = string ( \"cuModuleGetFunction\" ) func_names ( 4 ) = string ( \"cuLaunchKernel\" ) error_code = dynamic_load ( \"libcuda.so\" , func_names , libcuda , cuFunctions ) call destroy_strings ( func_names ) if ( error_code /= DTFFT_SUCCESS ) return call c_f_procpointer ( cuFunctions ( 1 ), cuModuleLoadData ) call c_f_procpointer ( cuFunctions ( 2 ), cuModuleUnload ) call c_f_procpointer ( cuFunctions ( 3 ), cuModuleGetFunction ) call c_f_procpointer ( cuFunctions ( 4 ), cuLaunchKernel_ ) is_loaded = . true . end function load_cuda function cuLaunchKernel ( func , in , out , blocks , threads , stream , nargs , args ) result ( cuResult ) !! Launches a CUDA kernel type ( CUfunction ), intent ( in ) :: func !! Function CUfunction or Kernel CUkernel to launch type ( c_ptr ), target , intent ( in ) :: in !! Input pointer type ( c_ptr ), target , intent ( in ) :: out !! Output pointer type ( dim3 ), intent ( in ) :: blocks !! Grid in blocks type ( dim3 ), intent ( in ) :: threads !! Thread block type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream identifier integer ( int32 ), intent ( in ) :: nargs integer ( int32 ), target , intent ( in ) :: args ( MAX_KERNEL_ARGS ) !! Input parameters of kernel `func` integer ( c_int ) :: cuResult !! Driver result code type ( c_ptr ) :: params ( 15 ) integer ( int32 ) :: i , temp params (:) = c_null_ptr ! Addresses of pointers are required, not the pointers themselves params ( 1 ) = c_loc ( out ) params ( 2 ) = c_loc ( in ) temp = 2 do i = 1 , nargs params ( temp + i ) = c_loc ( args ( i )) enddo cuResult = cuLaunchKernel_ ( func , blocks % x , blocks % y , blocks % z , threads % x , threads % y , threads % z , 0 , stream , params , c_null_ptr ) end function cuLaunchKernel end module dtfft_interface_cuda","tags":"","loc":"sourcefile/dtfft_interface_cuda.f90.html"},{"title":"dtfft_executor_vkfft_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_executor_vkfft_m.f90~~EfferentGraph sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_executor_vkfft_m.f90~~AfferentGraph sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_executor_vkfft_m !! This module describes VkFFT based FFT Executor: [[vkfft_executor]] !! !! https://github.com/DTolm/VkFFT/tree/master use iso_c_binding , only : c_ptr , c_int , c_int8_t use iso_fortran_env , only : int8 , int32 , int64 use dtfft_abstract_executor , only : abstract_executor , FFT_C2C , FFT_R2C , FFT_R2R use dtfft_config , only : get_conf_stream , get_conf_platform use dtfft_errors use dtfft_interface_vkfft_m use dtfft_parameters implicit none private #include \"_dtfft_private.h\" public :: vkfft_executor type , extends ( abstract_executor ) :: vkfft_executor !! vkFFT FFT Executor private type ( vkfft_wrapper ), pointer :: wrapper => null () !! VkFFT Wrapper logical :: is_inverse_required !! Should be create separate inverse FFT Plan or not contains procedure , pass ( self ) :: create_private => create !! Creates FFT plan via vkFFT Interface procedure , pass ( self ) :: execute_private => execute !! Executes vkFFT plan procedure , pass ( self ) :: destroy_private => destroy !! Destroys vkFFT plan procedure , nopass :: mem_alloc !! Dummy method. Raises `error stop` procedure , nopass :: mem_free !! Dummy method. Raises `error stop` end type vkfft_executor contains subroutine create ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan via vkFFT Interface class ( vkfft_executor ), intent ( inout ) :: self !! vkFFT FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform integer ( c_int8_t ) :: r2c !! Is R2C transform required integer ( c_int8_t ) :: dct !! Is DCT transform required integer ( c_int8_t ) :: dst !! Is DST transform required integer ( c_int ) :: knd !! Kind of r2r transform integer ( c_int ) :: i !! Loop index integer ( c_int ) :: dims ( 2 ) !! Dimensions of transform integer ( c_int ) :: double_precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type ( dtfft_platform_t ) :: platfrom !! Platform of the executor error_code = DTFFT_SUCCESS do i = 1 , fft_rank dims ( i ) = fft_sizes ( fft_rank - i + 1 ) enddo platfrom = get_conf_platform () CHECK_CALL ( load_vkfft ( platfrom ), error_code ) if ( platfrom == DTFFT_PLATFORM_CUDA ) then self % wrapper => cuda_wrapper endif r2c = 0 dct = 0 dst = 0 self % is_inverse_required = . false . select case ( fft_type ) case ( FFT_R2C ) r2c = 1 self % is_inverse_required = . true . case ( FFT_R2R ) knd = r2r_kinds ( 1 )% val do i = 2 , fft_rank if ( knd /= r2r_kinds ( i )% val ) then error_code = DTFFT_ERROR_VKFFT_R2R_2D_PLAN return endif enddo select case ( knd ) case ( DTFFT_DCT_1 % val ) dct = 1 case ( DTFFT_DCT_2 % val ) dct = 2 case ( DTFFT_DCT_3 % val ) dct = 3 case ( DTFFT_DCT_4 % val ) dct = 4 case ( DTFFT_DST_1 % val ) dst = 1 case ( DTFFT_DST_2 % val ) dst = 2 case ( DTFFT_DST_3 % val ) dst = 3 case ( DTFFT_DST_4 % val ) dst = 4 endselect endselect if ( precision == DTFFT_DOUBLE ) then double_precision = 1 else double_precision = 0 endif call self % wrapper % create ( fft_rank , dims , double_precision , how_many , r2c , int ( 0 , int8 ), dct , dst , get_conf_stream (), self % plan_forward ) if ( self % is_inverse_required ) then call self % wrapper % create ( fft_rank , dims , double_precision , how_many , int ( 0 , int8 ), r2c , dct , dst , get_conf_stream (), self % plan_backward ) else self % plan_backward = self % plan_forward endif end subroutine create subroutine execute ( self , a , b , sign ) !! Executes vkFFT plan class ( vkfft_executor ), intent ( in ) :: self !! vkFFT FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform if ( self % is_inverse_required . and . sign == FFT_BACKWARD ) then call self % wrapper % execute ( self % plan_backward , a , b , sign ) else call self % wrapper % execute ( self % plan_forward , a , b , sign ) endif end subroutine execute subroutine destroy ( self ) !! Destroys vkFFT plan class ( vkfft_executor ), intent ( inout ) :: self !! vkFFT FFT Executor call self % wrapper % destroy ( self % plan_forward ) if ( self % is_inverse_required ) then call self % wrapper % destroy ( self % plan_backward ) endif end subroutine destroy subroutine mem_alloc ( alloc_bytes , ptr ) !! Dummy method. Raises `error stop` integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer INTERNAL_ERROR ( \"mem_alloc for VkFFT called\" ) end subroutine mem_alloc subroutine mem_free ( ptr ) !! Dummy method. Raises `error stop` type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free INTERNAL_ERROR ( \"mem_free for VkFFT called\" ) end subroutine mem_free end module dtfft_executor_vkfft_m","tags":"","loc":"sourcefile/dtfft_executor_vkfft_m.f90.html"},{"title":"dtfft_api.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_api.f90~~EfferentGraph sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_api !! This module is a Fortran part of C interface use iso_c_binding , only : c_int8_t , c_int32_t , c_size_t , & c_float , c_bool , c_char , & c_null_ptr , c_ptr , c_loc , & c_f_pointer use iso_fortran_env , only : int8 , int32 use dtfft_config , only : dtfft_config_t , dtfft_set_config use dtfft_errors use dtfft_parameters use dtfft_pencil , only : dtfft_pencil_t , dtfft_pencil_c , pencil_c2f , pencil_f2c use dtfft_plan , only : dtfft_plan_t , dtfft_plan_r2r_t , dtfft_plan_c2c_t , dtfft_plan_r2c_t use dtfft_utils , only : is_null_ptr , string_f2c #include \"_dtfft_mpi.h\" implicit none private #define CHECK_PLAN_CREATED(c_plan, f_plan)      \\ if ( is_null_ptr ( c_plan )) then ; \\ error_code = DTFFT_ERROR_PLAN_NOT_CREATED ; \\ return ; \\ endif ; \\ call c_f_pointer ( c_plan , f_plan ) type :: plan_c !! C pointer to Fortran plan class ( dtfft_plan_t ), allocatable :: p !! Actual Fortran plan end type plan_c contains pure TYPE_MPI_COMM function get_comm ( c_comm ) !! Converts C communicator to Fortran communicator integer ( c_int32_t ), intent ( in ) :: c_comm !! C communicator GET_MPI_VALUE ( get_comm ) = c_comm end function get_comm function dtfft_create_plan_r2r_c ( ndims , dims , kinds , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates R2R dtFFT Plan, allocates all structures and prepares FFT, C interface integer ( c_int8_t ), intent ( in ) :: ndims !! Rank of transform. Can be 2 or 3. type ( c_ptr ), value , intent ( in ) :: dims !! Global sizes of transform type ( c_ptr ), value , intent ( in ) :: kinds !! FFT R2R kinds integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. integer ( int32 ), pointer :: fdims (:) !! Fortran dims type ( dtfft_r2r_kind_t ), pointer :: fkinds (:) !! Fortran R2R kinds type ( plan_c ), pointer :: plan !! Pointer to Fortran object allocate ( plan ) allocate ( dtfft_plan_r2r_t :: plan % p ) call c_f_pointer ( dims , fdims , [ ndims ]) select type ( p => plan % p ) type is ( dtfft_plan_r2r_t ) if ( is_null_ptr ( kinds ) ) then call p % create ( fdims , comm = get_comm ( comm ), precision = precision , effort = effort , executor = executor , error_code = error_code ) else call c_f_pointer ( kinds , fkinds , [ ndims ]) call p % create ( fdims , fkinds , get_comm ( comm ), precision , effort , executor , error_code ) endif endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_r2r_c function dtfft_create_plan_r2r_pencil_c ( pencil , kinds , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates R2R dtFFT Plan from Pencil, allocates all structures and prepares FFT, C interface type ( dtfft_pencil_c ), intent ( in ) :: pencil !! C pointer to Fortran pencil type ( c_ptr ), value , intent ( in ) :: kinds !! FFT R2R kinds integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( dtfft_r2r_kind_t ), pointer :: fkinds (:) !! Fortran R2R kinds type ( plan_c ), pointer :: plan !! Pointer to Fortran object type ( dtfft_pencil_t ) :: pencil_ !! Fortran pencil call pencil_c2f ( pencil , pencil_ , error_code ) if ( error_code /= DTFFT_SUCCESS ) return allocate ( plan ) allocate ( dtfft_plan_r2r_t :: plan % p ) select type ( p => plan % p ) type is ( dtfft_plan_r2r_t ) if ( is_null_ptr ( kinds ) ) then call p % create ( pencil_ , comm = get_comm ( comm ), precision = precision , effort = effort , executor = executor , error_code = error_code ) else call c_f_pointer ( kinds , fkinds , [ pencil_ % ndims ]) call p % create ( pencil_ , fkinds , get_comm ( comm ), precision , effort , executor , error_code ) endif endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_r2r_pencil_c function dtfft_create_plan_c2c_c ( ndims , dims , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates C2C dtFFT Plan, allocates all structures and prepares FFT, C interface integer ( c_int8_t ), intent ( in ) :: ndims !! Rank of transform. Can be 2 or 3. type ( c_ptr ), value , intent ( in ) :: dims !! Global sizes of transform integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. integer ( int32 ), pointer :: fdims (:) !! Fortran dims type ( plan_c ), pointer :: plan !! Pointer to Fortran object allocate ( plan ) allocate ( dtfft_plan_c2c_t :: plan % p ) call c_f_pointer ( dims , fdims , [ ndims ]) select type ( p => plan % p ) class is ( dtfft_plan_c2c_t ) call p % create ( fdims , get_comm ( comm ), precision , effort , executor , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_c2c_c function dtfft_create_plan_c2c_pencil_c ( pencil , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates C2C dtFFT plan from Pencil, allocates all structures and prepares FFT, C interface type ( dtfft_pencil_c ), intent ( in ) :: pencil !! C pointer to Fortran pencil integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( dtfft_pencil_t ) :: pencil_ !! Fortran pencil type ( plan_c ), pointer :: plan !! Pointer to Fortran object call pencil_c2f ( pencil , pencil_ , error_code ) if ( error_code /= DTFFT_SUCCESS ) return allocate ( plan ) allocate ( dtfft_plan_c2c_t :: plan % p ) select type ( p => plan % p ) class is ( dtfft_plan_c2c_t ) call p % create ( pencil_ , get_comm ( comm ), precision , effort , executor , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_c2c_pencil_c #ifndef DTFFT_TRANSPOSE_ONLY function dtfft_create_plan_r2c_c ( ndims , dims , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates R2C dtFFT Plan, allocates all structures and prepares FFT, C interface integer ( c_int8_t ), intent ( in ) :: ndims !! Rank of transform. Can be 2 or 3. type ( c_ptr ), value , intent ( in ) :: dims !! Global sizes of transform integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. integer ( int32 ), pointer :: fdims (:) !! Fortran dims type ( plan_c ), pointer :: plan !! Pointer to Fortran object allocate ( plan ) allocate ( dtfft_plan_r2c_t :: plan % p ) call c_f_pointer ( dims , fdims , [ ndims ]) select type ( p => plan % p ) class is ( dtfft_plan_r2c_t ) call p % create ( fdims , executor , get_comm ( comm ), precision , effort , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_r2c_c function dtfft_create_plan_r2c_pencil_c ( pencil , comm , precision , effort , executor , plan_ptr ) & result ( error_code ) & bind ( C ) !! Creates R2C dtFFT Plan from Pencil, allocates all structures and prepares FFT, C interface type ( dtfft_pencil_c ), intent ( in ) :: pencil !! C pointer to Fortran pencil integer ( c_int32_t ), value , intent ( in ) :: comm !! Communicator type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of transform type ( dtfft_effort_t ), intent ( in ) :: effort !! ``dtFFT`` planner effort type type ( dtfft_executor_t ), intent ( in ) :: executor !! Type of External FFT Executor type ( c_ptr ), intent ( out ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( dtfft_pencil_t ) :: pencil_ !! Fortran pencil type ( plan_c ), pointer :: plan !! Pointer to Fortran object call pencil_c2f ( pencil , pencil_ , error_code ) if ( error_code /= DTFFT_SUCCESS ) return allocate ( plan ) allocate ( dtfft_plan_r2c_t :: plan % p ) select type ( p => plan % p ) class is ( dtfft_plan_r2c_t ) call p % create ( pencil_ , executor , get_comm ( comm ), precision , effort , error_code ) endselect plan_ptr = c_loc ( plan ) end function dtfft_create_plan_r2c_pencil_c #endif function dtfft_get_z_slab_enabled_c ( plan_ptr , is_z_slab_enabled ) & result ( error_code ) & bind ( C ) !! Checks if dtFFT Plan is using Z-slab optimization type ( c_ptr ), intent ( in ), value :: plan_ptr !! C pointer to Fortran plan logical ( c_bool ), intent ( out ) :: is_z_slab_enabled !! Is plan internally using Z-slab optimization integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) is_z_slab_enabled = plan % p % get_z_slab_enabled ( error_code ) end function dtfft_get_z_slab_enabled_c function dtfft_get_y_slab_enabled_c ( plan_ptr , is_y_slab_enabled ) & result ( error_code ) & bind ( C ) !! Checks if dtFFT Plan is using Y-slab optimization type ( c_ptr ), intent ( in ), value :: plan_ptr !! C pointer to Fortran plan logical ( c_bool ), intent ( out ) :: is_y_slab_enabled !! Is plan internally using Y-slab optimization integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) is_y_slab_enabled = plan % p % get_y_slab_enabled ( error_code ) end function dtfft_get_y_slab_enabled_c function dtfft_execute_c ( plan_ptr , in , out , execute_type , aux ) & result ( error_code ) & bind ( C ) !! Executes dtFFT Plan, C interface. `aux` can be NULL. type ( c_ptr ), value , intent ( in ) :: plan_ptr !! C pointer to Fortran plan type ( c_ptr ), value , intent ( in ) :: in !! Incomming pointer, not NULL type ( c_ptr ), value , intent ( in ) :: out !! Outgoing buffer, not NULL type ( dtfft_execute_t ), intent ( in ) :: execute_type !! Type of execution type ( c_ptr ), value , intent ( in ) :: aux !! Aux buffer, can be NULL integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % execute_ptr ( in , out , execute_type , aux , error_code ) end function dtfft_execute_c function dtfft_transpose_c ( plan_ptr , in , out , transpose_type ) & result ( error_code ) & bind ( C ) !! Executes single transposition, C interface. type ( c_ptr ), value , intent ( in ) :: plan_ptr !! C pointer to Fortran plan type ( c_ptr ), value , intent ( in ) :: in !! Incomming pointer, not NULL type ( c_ptr ), value , intent ( in ) :: out !! Outgoing buffer, not NULL type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % transpose_ptr ( in , out , transpose_type , error_code ) end function dtfft_transpose_c function dtfft_transpose_start_c ( plan_ptr , in , out , transpose_type , request ) & result ( error_code ) & bind ( C ) !! Starts asynchronous transposition, returns transpose handle, C interface. type ( c_ptr ), value , intent ( in ) :: plan_ptr !! C pointer to Fortran plan type ( c_ptr ), value , intent ( in ) :: in !! Incomming pointer, not NULL type ( c_ptr ), value , intent ( in ) :: out !! Outgoing buffer, not NULL type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transposition. type ( dtfft_request_t ), intent ( out ) :: request !! Async transpose handle integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) request = plan % p % transpose_start_ptr ( in , out , transpose_type , error_code ) end function dtfft_transpose_start_c function dtfft_transpose_end_c ( plan_ptr , request ) & result ( error_code ) & bind ( C ) !! Finishes asynchronous transposition, C interface. type ( c_ptr ), value , intent ( in ) :: plan_ptr !! C pointer to Fortran plan type ( dtfft_request_t ), intent ( inout ) :: request !! Async transpose handle integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % transpose_end ( request , error_code ) end function dtfft_transpose_end_c function dtfft_destroy_c ( plan_ptr ) & result ( error_code ) & bind ( C ) !! Destroys dtFFT Plan, C interface type ( c_ptr ) :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % destroy ( error_code ) deallocate ( plan % p ) deallocate ( plan ) plan_ptr = c_null_ptr end function dtfft_destroy_c function dtfft_get_local_sizes_c ( plan_ptr , in_starts , in_counts , out_starts , out_counts , alloc_size ) & result ( error_code ) & bind ( C ) !! Returns local sizes, counts in real and Fourier spaces and number of elements to be allocated for `in` and `out` buffers, !! C interface. type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ), intent ( out ), optional :: in_starts ( 3 ) !! Starts of local portion of data in 'real' space integer ( c_int32_t ), intent ( out ), optional :: in_counts ( 3 ) !! Counts of local portion of data in 'real' space integer ( c_int32_t ), intent ( out ), optional :: out_starts ( 3 ) !! Starts of local portion of data in 'fourier' space integer ( c_int32_t ), intent ( out ), optional :: out_counts ( 3 ) !! Counts of local portion of data in 'fourier' space integer ( c_size_t ), intent ( out ), optional :: alloc_size !! Minimum data needs to be allocated integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % get_local_sizes ( in_starts , in_counts , out_starts , out_counts , alloc_size , error_code ) end function dtfft_get_local_sizes_c function dtfft_get_alloc_size_c ( plan_ptr , alloc_size ) & result ( error_code ) & bind ( C ) !! Returns minimum number of bytes to be allocated for `in` and `out` buffers, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_size_t ), intent ( out ) :: alloc_size !! Minimum data needs to be allocated integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) alloc_size = plan % p % get_alloc_size ( error_code ) end function dtfft_get_alloc_size_c function dtfft_get_pencil_c ( plan_ptr , dim , pencil ) & result ( error_code ) & bind ( C ) !! Returns pencil decomposition info, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ), intent ( in ) :: dim !! Dimension requested type ( dtfft_pencil_c ) :: pencil !! Pencil pointer integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object type ( dtfft_pencil_t ) :: pencil_ !! Fortran pencil CHECK_PLAN_CREATED ( plan_ptr , plan ) pencil_ = plan % p % get_pencil ( dim , error_code ) call pencil_f2c ( pencil_ , pencil ) end function dtfft_get_pencil_c function dtfft_get_element_size_c ( plan_ptr , element_size ) & result ( error_code ) & bind ( C ) !! Returns size of element in bytes, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_size_t ), intent ( out ) :: element_size !! Size of element in bytes integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) element_size = plan % p % get_element_size ( error_code ) end function dtfft_get_element_size_c function dtfft_get_alloc_bytes_c ( plan_ptr , alloc_bytes ) & result ( error_code ) & bind ( C ) !! Returns minimum number of bytes required to execute plan, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_size_t ), intent ( out ) :: alloc_bytes !! Number of bytes required integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) alloc_bytes = plan % p % get_alloc_bytes ( error_code ) end function dtfft_get_alloc_bytes_c function dtfft_get_executor_c ( plan_ptr , executor ) & result ( error_code ) & bind ( C ) !! Returns executor type used in plan, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_executor_t ), intent ( out ) :: executor !! The enumerated type dtfft_executor_t integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) executor = plan % p % get_executor ( error_code ) end function dtfft_get_executor_c function dtfft_get_precision_c ( plan_ptr , precision ) & result ( error_code ) & bind ( C ) !! Returns precision used in plan, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_precision_t ), intent ( out ) :: precision !! The enumerated type dtfft_precision_t integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) precision = plan % p % get_precision ( error_code ) end function dtfft_get_precision_c function dtfft_get_dims_c ( plan_ptr , ndims , dims ) & result ( error_code ) & bind ( C ) !! Returns dimensions of plan, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_int8_t ), intent ( out ) :: ndims !! Number of dimensions type ( c_ptr ), intent ( out ) :: dims !! Array of dimensions integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object integer ( c_int32_t ), pointer :: dims_ (:) => null () CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % get_dims ( dims_ , error_code = error_code ) if ( error_code == DTFFT_SUCCESS ) then ndims = size ( dims_ , kind = c_int8_t ) dims = c_loc ( dims_ ) endif end function dtfft_get_dims_c function dtfft_get_grid_dims_c ( plan_ptr , ndims , grid_dims ) & result ( error_code ) & bind ( C ) !! Returns grid decomposition dimensions of plan, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_int8_t ), intent ( out ) :: ndims !! Number of dimensions type ( c_ptr ), intent ( out ) :: grid_dims !! Array of dimensions integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object integer ( c_int32_t ), pointer :: grid_dims_ (:) => null () CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % get_grid_dims ( grid_dims_ , error_code = error_code ) if ( error_code == DTFFT_SUCCESS ) then ndims = size ( grid_dims_ , kind = c_int8_t ) grid_dims = c_loc ( grid_dims_ ) endif end function dtfft_get_grid_dims_c function dtfft_set_config_c ( config ) & result ( error_code ) & bind ( C ) !! Sets dtFFT configuration, C interface type ( dtfft_config_t ), intent ( in ) :: config !! Configuration to set integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. call dtfft_set_config ( config , error_code ) end function dtfft_set_config_c function dtfft_report_c ( plan_ptr ) & result ( error_code ) & bind ( C ) !! Reports dtFFT Plan, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % report ( error_code ) end function dtfft_report_c function dtfft_mem_alloc_c ( plan_ptr , alloc_bytes , ptr ) & result ( error_code ) & bind ( C ) !! Allocates memory for dtFFT Plan, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan integer ( c_size_t ), value :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ) :: ptr !! Allocated pointer integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) ptr = plan % p % mem_alloc_ptr ( alloc_bytes , error_code ) end function dtfft_mem_alloc_c function dtfft_mem_free_c ( plan_ptr , ptr ) & result ( error_code ) & bind ( C ) !! Frees memory for dtFFT Plan, C interface type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( c_ptr ), value :: ptr !! Pointer to deallocate integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % mem_free_ptr ( ptr , error_code ) end function dtfft_mem_free_c subroutine dtfft_get_error_string_c ( error_code , error_string , error_string_size ) bind ( C ) !! Returns an explaination of ``error_code`` that could have been previously returned by one of dtFFT API calls, !! C interface integer ( c_int32_t ), intent ( in ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. character ( c_char ), intent ( out ) :: error_string ( * ) !! Explanation of error integer ( c_size_t ), intent ( out ) :: error_string_size !! Size of ``error_string`` call string_f2c ( dtfft_get_error_string ( error_code ), error_string , error_string_size ) end subroutine dtfft_get_error_string_c subroutine dtfft_get_precision_string_c ( precision , precision_string , precision_string_size ) bind ( C ) !! Returns string representation of ``dtfft_precision_t``, C interface type ( dtfft_precision_t ), intent ( in ) :: precision !! The enumerated type dtfft_precision_t character ( c_char ), intent ( out ) :: precision_string ( * ) !! Resulting string integer ( c_size_t ), intent ( out ) :: precision_string_size !! Size of string call string_f2c ( dtfft_get_precision_string ( precision ), precision_string , precision_string_size ) end subroutine dtfft_get_precision_string_c subroutine dtfft_get_executor_string_c ( executor , executor_string , executor_string_size ) bind ( C ) !! Returns string representation of ``dtfft_executor_t``, C interface type ( dtfft_executor_t ), intent ( in ) :: executor !! The enumerated type dtfft_executor_t character ( c_char ), intent ( out ) :: executor_string ( * ) !! Resulting string integer ( c_size_t ), intent ( out ) :: executor_string_size !! Size of string call string_f2c ( dtfft_get_executor_string ( executor ), executor_string , executor_string_size ) end subroutine dtfft_get_executor_string_c function dtfft_get_backend_c ( plan_ptr , backend ) & result ( error_code ) & bind ( C ) !! Returns selected [[dtfft_backend_t]] during autotuning type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_backend_t ), intent ( out ) :: backend !! The enumerated type dtfft_backend_t integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) backend = plan % p % get_backend ( error_code ) end function dtfft_get_backend_c subroutine dtfft_get_backend_string_c ( backend , backend_string , backend_string_size ) bind ( C ) !! Returns string representation of ``dtfft_backend_t`` type ( dtfft_backend_t ), intent ( in ) :: backend !! The enumerated type dtfft_backend_t character ( c_char ), intent ( out ) :: backend_string ( * ) !! Resulting string integer ( c_size_t ), intent ( out ) :: backend_string_size !! Size of string call string_f2c ( dtfft_get_backend_string ( backend ), backend_string , backend_string_size ) end subroutine dtfft_get_backend_string_c #ifdef DTFFT_WITH_CUDA function dtfft_get_stream_c ( plan_ptr , stream ) & result ( error_code ) & bind ( C ) !! Returns Stream associated with plan type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_stream_t ), intent ( out ) :: stream !! CUDA stream integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) call plan % p % get_stream ( stream , error_code ) end function dtfft_get_stream_c function dtfft_get_platform_c ( plan_ptr , platform ) & result ( error_code ) & bind ( C ) !! Returns selected [[dtfft_platform_t]] during autotuning type ( c_ptr ), value :: plan_ptr !! C pointer to Fortran plan type ( dtfft_platform_t ), intent ( out ) :: platform !! The enumerated type dtfft_platform_t integer ( c_int32_t ) :: error_code !! The enumerated type dtfft_error_t !! defines API call result codes. type ( plan_c ), pointer :: plan !! Pointer to Fortran object CHECK_PLAN_CREATED ( plan_ptr , plan ) platform = plan % p % get_platform ( error_code ) end function dtfft_get_platform_c #endif end module dtfft_api","tags":"","loc":"sourcefile/dtfft_api.f90.html"},{"title":"dtfft_interface_nvshmem.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_nvshmem.f90~~EfferentGraph sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_nvshmem.f90~~AfferentGraph sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_nvshmem !! NVSHMEM Interfaces use iso_c_binding use iso_fortran_env use dtfft_parameters use dtfft_utils #include \"_dtfft_mpi.h\" implicit none private public :: nvshmem_team_t public :: is_nvshmem_ptr ! public :: nvshmem_init, nvshmem_finalize ! public :: load_nvshmem type , bind ( C ) :: nvshmem_team_t !! NVSHMEM team. integer ( c_int32_t ) :: val !! Internal representation of the NVSHMEM team. end type nvshmem_team_t type ( nvshmem_team_t ), parameter , public :: NVSHMEM_TEAM_WORLD = nvshmem_team_t ( 0 ) !! Global NVSHMEM team. public :: nvshmem_malloc public :: nvshmem_free public :: nvshmemx_sync_all_on_stream public :: nvshmemx_float_alltoall_on_stream public :: nvshmem_ptr public :: nvshmem_my_pe ! public :: nvshmemx_init_status interface function nvshmem_malloc ( size ) result ( ptr ) bind ( C ) !! Allocates symmetric memory in the NVSHMEM heap. import type ( c_ptr ) :: ptr !! Pointer to the allocated memory. integer ( c_size_t ), value :: size !! Size of the allocation in bytes. end function nvshmem_malloc end interface interface nvshmem_free subroutine nvshmem_free ( ptr ) bind ( C ) !! Frees symmetric memory allocated by nvshmem_malloc. import type ( c_ptr ), value :: ptr !! Pointer to the memory to free. end subroutine nvshmem_free end interface interface subroutine nvshmemx_sync_all_on_stream ( stream ) bind ( C ) !! Synchronizes all PEs (Processing Elements) on the specified stream. import type ( dtfft_stream_t ), intent ( in ), value :: stream !! CUDA stream for synchronization. end subroutine nvshmemx_sync_all_on_stream end interface interface function nvshmemx_float_alltoall_on_stream ( team , dest , source , nelems , stream ) result ( ierr ) bind ( C ) !! Performs an all-to-all exchange of floating-point data on the specified stream. import integer ( c_int ) :: ierr !! Completion status. type ( nvshmem_team_t ), intent ( in ), value :: team !! NVSHMEM team. type ( c_ptr ), value :: dest !! Destination buffer. type ( c_ptr ), value :: source !! Source buffer. integer ( c_size_t ), intent ( in ), value :: nelems !! Number of elements to exchange. type ( dtfft_stream_t ), intent ( in ), value :: stream !! CUDA stream for the operation. end function nvshmemx_float_alltoall_on_stream end interface interface function nvshmem_ptr ( ptr , pe ) result ( pe_ptr ) bind ( C ) !! Returns a pointer to a symmetric memory location on a specified PE. import type ( c_ptr ) :: pe_ptr !! Pointer to the symmetric memory on the specified PE. type ( c_ptr ), value :: ptr !! Local pointer to the symmetric memory. integer ( c_int ), value :: pe !! PE (Processing Element) number. end function nvshmem_ptr end interface interface function nvshmem_my_pe () result ( pe ) bind ( C ) !! Returns the PE (Processing Element) number of the calling thread. import integer ( c_int ) :: pe !! PE number of the calling thread. end function nvshmem_my_pe end interface interface function nvshmemx_init_status () result ( status ) bind ( C ) import integer ( c_int ) :: status !! Completion status. end function nvshmemx_init_status end interface interface subroutine init_nvshmem ( comm ) bind ( C ) import integer ( c_int ), value :: comm !! MPI communicator (C handle) end subroutine init_nvshmem end interface interface subroutine nvshmem_finalize_ () bind ( C , name = \"nvshmemi_finalize\" ) !! Finalizes the NVSHMEM library. end subroutine nvshmem_finalize_ end interface logical , save :: is_init = . false . !! Flag indicating whether NVSHMEM is initialized logical , save :: is_external_init = . false . !! Flag indicating whether NVSHMEM was initialized externally ! logical, save :: is_loaded = .false. !   !! Flag indicating whether the library is loaded ! type(c_ptr), save :: libnvshmem !   !! Handle to the loaded library ! type(c_funptr), save :: nvshmemFunctions(7) !   !! Array of pointers to the NVSHMEM functions ! procedure(nvshmem_malloc_interface),              pointer, public :: nvshmem_malloc !   !! Fortran pointer to the nvshmem_malloc function ! procedure(nvshmem_free_interface),                pointer, public :: nvshmem_free !   !! Fortran pointer to the nvshmem_free function ! procedure(nvshmemx_sync_all_on_stream_interface), pointer, public :: nvshmemx_sync_all_on_stream !   !! Fortran pointer to the nvshmemx_sync_all_on_stream function ! procedure(nvshmemx_float_alltoall_on_stream_interface), pointer, public :: nvshmemx_float_alltoall_on_stream !   !! Fortran pointer to the nvshmemx_float_alltoall_on_stream function ! procedure(nvshmem_ptr_interface),                 pointer, public :: nvshmem_ptr !   !! Fortran pointer to the nvshmem_ptr function ! procedure(nvshmem_my_pe_interface),               pointer, public :: nvshmem_my_pe !   !! Fortran pointer to the nvshmem_my_pe function ! procedure(nvshmemx_init_status_interface),                pointer,  public  :: nvshmemx_init_status contains ! function load_nvshmem(cufftmp_handle) result(error_code) ! !! Loads the NVSHMEM library and needed symbols !   type(c_ptr),  intent(in)  :: cufftmp_handle !   integer(int32)  :: error_code !! Error code !   type(string), allocatable :: func_names(:) !   integer(int32) :: i !   error_code = DTFFT_SUCCESS ! if ( is_loaded ) return ! allocate(func_names(7)) ! func_names(1) = string(\"nvshmem_malloc\") ! func_names(2) = string(\"nvshmem_free\") ! func_names(3) = string(\"nvshmemx_sync_all_on_stream\") ! func_names(4) = string(\"nvshmemx_float_alltoall_on_stream\") ! func_names(5) = string(\"nvshmem_ptr\") ! func_names(6) = string(\"nvshmem_my_pe\") ! func_names(7) = string(\"nvshmemx_init_status\") ! ! error_code = dynamic_load(NVSHMEM_HOST_LIB, func_names, libnvshmem, nvshmemFunctions) ! ! call destroy_strings(func_names) ! ! if ( error_code /= DTFFT_SUCCESS ) return ! do i = 1, size(func_names) !   nvshmemFunctions(i) = load_symbol(cufftmp_handle, func_names(i)%raw) ! enddo ! call c_f_procpointer(nvshmemFunctions(1), nvshmem_malloc) ! call c_f_procpointer(nvshmemFunctions(2), nvshmem_free) ! call c_f_procpointer(nvshmemFunctions(3), nvshmemx_sync_all_on_stream) ! call c_f_procpointer(nvshmemFunctions(4), nvshmemx_float_alltoall_on_stream) ! call c_f_procpointer(nvshmemFunctions(5), nvshmem_ptr) ! call c_f_procpointer(nvshmemFunctions(6), nvshmem_my_pe) ! call c_f_procpointer(nvshmemFunctions(7), nvshmemx_init_status) ! print*, 'nvshmemx_init_status after load = ', nvshmemx_init_status() ! is_loaded = .true. ! end function load_nvshmem function is_nvshmem_ptr ( ptr ) result ( bool ) !! Checks if pointer is a symmetric nvshmem allocated pointer type ( c_ptr ) :: ptr !! Device pointer logical :: bool !! Result bool = . not . is_null_ptr ( nvshmem_ptr ( ptr , nvshmem_my_pe ()) ) end function is_nvshmem_ptr ! subroutine nvshmem_init(comm) ! !! Initializes NVSHMEM with the given MPI communicator !   TYPE_MPI_COMM, intent(in) :: comm  !! MPI communicator (Fortran handle) !   integer(c_int) :: status !   if ( is_init ) return !   status = nvshmemx_init_status() !   if( status == 0 ) then !     call init_nvshmem(GET_MPI_VALUE(comm)) !   else !     is_external_init = .true. !   endif !   is_init = .true. ! end subroutine nvshmem_init ! subroutine nvshmem_finalize() ! !! Finalizes NVSHMEM if it was initialized internally !   if ( is_init .and. .not.is_external_init ) then !     call nvshmem_finalize_() !     is_init = .false. !   endif ! end subroutine nvshmem_finalize end module dtfft_interface_nvshmem","tags":"","loc":"sourcefile/dtfft_interface_nvshmem.f90.html"},{"title":"dtfft_interface_cufft.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_cufft.f90~~EfferentGraph sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_cufft.f90~~AfferentGraph sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_cufft !! cuFFT Interfaces use iso_c_binding use iso_fortran_env use dtfft_parameters ! #ifdef DTFFT_WITH_NVSHMEM ! use dtfft_interface_nvshmem,              only: load_nvshmem ! #endif use dtfft_utils implicit none private public :: CUFFT_R2C , CUFFT_C2R , CUFFT_C2C public :: CUFFT_D2Z , CUFFT_Z2D , CUFFT_Z2Z public :: cufftGetErrorString ! public :: load_cufft integer ( c_int ), parameter , public :: CUFFT_COMM_MPI = 0 enum , bind ( C ) enumerator :: CUFFT_R2C = 42 enumerator :: CUFFT_C2R = 44 enumerator :: CUFFT_C2C = 41 enumerator :: CUFFT_D2Z = 106 enumerator :: CUFFT_Z2D = 108 enumerator :: CUFFT_Z2Z = 105 end enum enum , bind ( C ) enumerator :: CUFFT_SUCCESS = 0 enumerator :: CUFFT_INVALID_PLAN = 1 enumerator :: CUFFT_ALLOC_FAILED = 2 enumerator :: CUFFT_INVALID_TYPE = 3 enumerator :: CUFFT_INVALID_VALUE = 4 enumerator :: CUFFT_INTERNAL_ERROR = 5 enumerator :: CUFFT_EXEC_FAILED = 6 enumerator :: CUFFT_SETUP_FAILED = 7 enumerator :: CUFFT_INVALID_SIZE = 8 enumerator :: CUFFT_UNALIGNED_DATA = 9 enumerator :: CUFFT_INCOMPLETE_PARAMETER_LIST = 10 enumerator :: CUFFT_INVALID_DEVICE = 11 enumerator :: CUFFT_PARSE_ERROR = 12 enumerator :: CUFFT_NO_WORKSPACE = 13 enumerator :: CUFFT_NOT_IMPLEMENTED = 14 enumerator :: CUFFT_LICENSE_ERROR = 15 enumerator :: CUFFT_NOT_SUPPORTED = 16 end enum public :: cufftReshapeHandle type , bind ( C ) :: cufftReshapeHandle !! An opaque handle to a reshape operation. type ( c_ptr ) :: cptr end type cufftReshapeHandle public :: cufftPlanMany interface !! Creates a FFT plan configuration of dimension rank, with sizes specified in the array n. function cufftPlanMany ( plan , rank , n , inembed , istride , idist , onembed , ostride , odist , ffttype , batch ) & result ( cufftResult ) & bind ( C , name = \"cufftPlanMany\" ) import type ( c_ptr ) :: plan !! Pointer to an uninitialized cufftHandle object. integer ( c_int ), value :: rank !! Dimensionality of the transform (1, 2, or 3). integer ( c_int ) :: n ( * ) !! Array of size rank, describing the size of each dimension, !! n[0] being the size of the outermost !! and n[rank-1] innermost (contiguous) dimension of a transform. integer ( c_int ) :: inembed ( * ) !! Pointer of size rank that indicates the storage dimensions of the input data in memory. !! If set to NULL, all other advanced data layout parameters are ignored. integer ( c_int ), value :: istride !! Indicates the distance between two successive input elements in the least !! significant (i.e., innermost) dimension. integer ( c_int ), value :: idist !! Indicates the distance between the first element of two consecutive signals !! in a batch of the input data. integer ( c_int ) :: onembed ( * ) !! Pointer of size rank that indicates the storage dimensions of the output data in memory. !! If set to NULL, all other advanced data layout parameters are ignored. integer ( c_int ), value :: ostride !! Indicates the distance between two successive output elements in the output array !! in the least significant (i.e., innermost) dimension. integer ( c_int ), value :: odist !! Indicates the distance between the first element of two consecutive signals !! in a batch of the output data. integer ( c_int ), value :: ffttype !! The transform data type (e.g., CUFFT_R2C for single precision real to complex). integer ( c_int ), value :: batch !! Batch size for this transform. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftPlanMany end interface public :: cufftXtExec interface !! Executes any cuFFT transform regardless of precision and type. !! In case of complex-to-real and real-to-complex transforms, the direction parameter is ignored. function cufftXtExec ( plan , input , output , direction ) & result ( cufftResult ) & bind ( C , name = \"cufftXtExec\" ) import type ( c_ptr ), value :: plan !! cufftHandle returned by cufftCreate. type ( c_ptr ), value :: input !! Pointer to the input data (in GPU memory) to transform. type ( c_ptr ), value :: output !! Pointer to the output data (in GPU memory). integer ( c_int ), value :: direction !! The transform direction: CUFFT_FORWARD or CUFFT_INVERSE. !! Ignored for complex-to-real and real-to-complex transforms. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftXtExec end interface public :: cufftDestroy interface !! Frees all GPU resources associated with a cuFFT plan and destroys the internal plan data structure. function cufftDestroy ( plan ) & result ( cufftResult ) & bind ( C , name = \"cufftDestroy\" ) import type ( c_ptr ), value :: plan !! Object of the plan to be destroyed. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftDestroy end interface public :: cufftSetStream interface !! Associates a CUDA stream with a cuFFT plan. function cufftSetStream ( plan , stream ) & result ( cufftResult ) & bind ( C , name = \"cufftSetStream\" ) import type ( c_ptr ), value :: plan !! Object to associate with the stream. type ( dtfft_stream_t ), value :: stream !! A valid CUDA stream. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftSetStream end interface public :: cufftMpCreateReshape interface !! Initializes a reshape handle for future use. This function is not collective. function cufftMpCreateReshape ( reshapeHandle ) & result ( cufftResult ) & bind ( C , name = \"cufftMpCreateReshape\" ) import type ( cufftReshapeHandle ) :: reshapeHandle !! The reshape handle. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpCreateReshape end interface public :: cufftMpAttachReshapeComm interface !! Attaches a communication handle to a reshape. This function is not collective. function cufftMpAttachReshapeComm ( reshapeHandle , commType , comm ) & result ( cufftResult ) & bind ( C , name = \"cufftMpAttachReshapeComm\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. integer ( c_int ), value :: commType !! An enum describing the communication type of the handle. type ( c_ptr ) :: comm !! If commType is CUFFT_COMM_MPI, this should be a pointer to an MPI communicator. !! The pointer should remain valid until destruction of the handle. !! Otherwise, this should be NULL. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpAttachReshapeComm end interface public :: cufftMpGetReshapeSize interface !! Returns the amount (in bytes) of workspace required to execute the handle. function cufftMpGetReshapeSize ( reshapeHandle , workSize ) & result ( cufftResult ) & bind ( C , name = \"cufftMpGetReshapeSize\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. integer ( c_size_t ) :: workSize !! The size, in bytes, of the workspace required during reshape execution. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpGetReshapeSize end interface public :: cufftMpMakeReshape interface !! Creates a reshape intended to re-distribute a global array of 3D data. function cufftMpMakeReshape ( reshapeHandle , elementSize , rank , lower_input , upper_input , & lower_output , upper_output , & strides_input , strides_output ) & result ( cufftResult ) & bind ( C , name = \"cufftMpMakeReshape\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. integer ( c_long_long ), value :: elementSize !! The size of the individual elements, in bytes. Allowed values are 4, 8, and 16. integer ( c_int ), value :: rank !! The length of the lower_input, upper_input, lower_output, upper_output, strides_input, and strides_output arrays. rank should be 3. integer ( c_long_long ) :: lower_input ( * ) !! An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer ( c_long_long ) :: upper_input ( * ) !! An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the input descriptor. integer ( c_long_long ) :: lower_output ( * ) !! An array of length rank, representing the lower-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer ( c_long_long ) :: upper_output ( * ) !! An array of length rank, representing the upper-corner of the portion of the global nx * ny * nz array owned by the current process in the output descriptor. integer ( c_long_long ) :: strides_input ( * ) !! An array of length rank, representing the local data layout of the input descriptor in memory. All entries must be decreasing and positive. integer ( c_long_long ) :: strides_output ( * ) !! An array of length rank, representing the local data layout of the output descriptor in memory. All entries must be decreasing and positive. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpMakeReshape end interface public :: cufftMpExecReshapeAsync interface !! Executes the reshape, redistributing data_in into data_out using the workspace in workspace. function cufftMpExecReshapeAsync ( reshapeHandle , dataOut , dataIn , workSpace , stream ) & result ( cufftResult ) & bind ( C , name = \"cufftMpExecReshapeAsync\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. type ( c_ptr ), value :: dataOut !! A symmetric-heap pointer to the output data. This memory should be NVSHMEM allocated and identical on all processes. type ( c_ptr ), value :: dataIn !! A symmetric-heap pointer to the input data. This memory should be NVSHMEM allocated and identical on all processes. type ( c_ptr ), value :: workSpace !! A symmetric-heap pointer to the workspace data. This memory should be NVSHMEM allocated and identical on all processes. type ( dtfft_stream_t ), value :: stream !! The CUDA stream in which to run the reshape operation. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpExecReshapeAsync end interface public :: cufftMpDestroyReshape interface !! Destroys a reshape and all its associated data. function cufftMpDestroyReshape ( reshapeHandle ) & result ( cufftResult ) & bind ( C , name = \"cufftMpDestroyReshape\" ) import type ( cufftReshapeHandle ), value :: reshapeHandle !! The reshape handle. integer ( c_int ) :: cufftResult !! The enumerated type cufftResult defines API call result codes. end function cufftMpDestroyReshape end interface !   logical, save :: is_loaded = .false. !     !! Flag indicating whether the library is loaded !   type(c_ptr), save :: libcufft !     !! Handle to the loaded library ! #ifdef DTFFT_WITH_NVSHMEM !   character(len=*), parameter :: LIB_NAME = \"libcufftMp.so\" !   integer(c_int),   parameter :: CUFFT_MAX_FUNCTIONS = 10 ! #else !   character(len=*), parameter :: LIB_NAME = \"libcufft.so\" !   integer(c_int),   parameter :: CUFFT_MAX_FUNCTIONS = 4 ! #endif !   type(c_funptr), save :: cufftFunctions(CUFFT_MAX_FUNCTIONS) !     !! Array of pointers to the cuFFT functions !   procedure(cufftPlanMany_interface),             pointer, public :: cufftPlanMany !     !! Fortran pointer to the cufftPlanMany function !   procedure(cufftXtExec_interface),               pointer, public :: cufftXtExec !     !! Fortran pointer to the cufftXtExec function !   procedure(cufftDestroy_interface),              pointer, public :: cufftDestroy !     !! Fortran pointer to the cufftDestroy function !   procedure(cufftSetStream_interface),            pointer, public :: cufftSetStream !     !! Fortran pointer to the cufftSetStream function !   procedure(cufftMpCreateReshape_interface),      pointer, public :: cufftMpCreateReshape !     !! Fortran pointer to the cufftMpCreateReshape function !   procedure(cufftMpAttachReshapeComm_interface),  pointer, public :: cufftMpAttachReshapeComm !     !! Fortran pointer to the cufftMpAttachReshapeComm function !   procedure(cufftMpGetReshapeSize_interface),     pointer, public :: cufftMpGetReshapeSize !     !! Fortran pointer to the cufftMpGetReshapeSize function !   procedure(cufftMpMakeReshape_interface),        pointer, public :: cufftMpMakeReshape !     !! Fortran pointer to the cufftMpMakeReshape function !   procedure(cufftMpExecReshapeAsync_interface),   pointer, public :: cufftMpExecReshapeAsync !     !! Fortran pointer to the cufftMpExecReshapeAsync function !   procedure(cufftMpDestroyReshape_interface),     pointer, public :: cufftMpDestroyReshape !     !! Fortran pointer to the cufftMpDestroyReshape function contains !   function load_cufft() result(error_code) !   !! Loads the cuFFT library and needed symbols !     integer(int32)  :: error_code !! Error code !     type(string), allocatable :: func_names(:) !     error_code = DTFFT_SUCCESS ! !     if ( is_loaded ) return ! !     allocate(func_names(CUFFT_MAX_FUNCTIONS)) ! !     func_names(1) = string(\"cufftPlanMany\") ! !     func_names(2) = string(\"cufftXtExec\") ! !     func_names(3) = string(\"cufftDestroy\") ! !     func_names(4) = string(\"cufftSetStream\") ! ! #ifdef DTFFT_WITH_NVSHMEM ! !     func_names(5) = string(\"cufftMpCreateReshape\") ! !     func_names(6) = string(\"cufftMpAttachReshapeComm\") ! !     func_names(7) = string(\"cufftMpGetReshapeSize\") ! !     func_names(8) = string(\"cufftMpMakeReshape\") ! !     func_names(9) = string(\"cufftMpExecReshapeAsync\") ! !     func_names(10) = string(\"cufftMpDestroyReshape\") ! ! #endif ! !     error_code = dynamic_load(LIB_NAME, func_names, libcufft, cufftFunctions) ! !     call destroy_strings(func_names) ! !     if ( error_code /= DTFFT_SUCCESS ) return ! !     call c_f_procpointer(cufftFunctions(1), cufftPlanMany) ! !     call c_f_procpointer(cufftFunctions(2), cufftXtExec) ! !     call c_f_procpointer(cufftFunctions(3), cufftDestroy) ! !     call c_f_procpointer(cufftFunctions(4), cufftSetStream) ! ! #ifdef DTFFT_WITH_NVSHMEM ! !     call c_f_procpointer(cufftFunctions(5), cufftMpCreateReshape) ! !     call c_f_procpointer(cufftFunctions(6), cufftMpAttachReshapeComm) ! !     call c_f_procpointer(cufftFunctions(7), cufftMpGetReshapeSize) ! !     call c_f_procpointer(cufftFunctions(8), cufftMpMakeReshape) ! !     call c_f_procpointer(cufftFunctions(9), cufftMpExecReshapeAsync) ! !     call c_f_procpointer(cufftFunctions(10), cufftMpDestroyReshape) ! !     error_code = load_nvshmem(libcufft) ! ! #endif ! !     is_loaded = .true. !   end function load_cufft function cufftGetErrorString ( error_code ) result ( string ) !! Returns a string representation of the cuFFT error code. integer ( c_int32_t ), intent ( in ) :: error_code !! cuFFT error code character ( len = :), allocatable :: string !! String representation of the cuFFT error code select case ( error_code ) case ( CUFFT_SUCCESS ) allocate ( string , source = \"CUFFT_SUCCESS\" ) case ( CUFFT_INVALID_PLAN ) allocate ( string , source = \"CUFFT_INVALID_PLAN\" ) case ( CUFFT_ALLOC_FAILED ) allocate ( string , source = \"CUFFT_ALLOC_FAILED\" ) case ( CUFFT_INVALID_TYPE ) allocate ( string , source = \"CUFFT_INVALID_TYPE\" ) case ( CUFFT_INVALID_VALUE ) allocate ( string , source = \"CUFFT_INVALID_VALUE\" ) case ( CUFFT_INTERNAL_ERROR ) allocate ( string , source = \"CUFFT_INTERNAL_ERROR\" ) case ( CUFFT_EXEC_FAILED ) allocate ( string , source = \"CUFFT_EXEC_FAILED\" ) case ( CUFFT_SETUP_FAILED ) allocate ( string , source = \"CUFFT_SETUP_FAILED\" ) case ( CUFFT_INVALID_SIZE ) allocate ( string , source = \"CUFFT_INVALID_SIZE\" ) case ( CUFFT_UNALIGNED_DATA ) allocate ( string , source = \"CUFFT_UNALIGNED_DATA\" ) case ( CUFFT_INCOMPLETE_PARAMETER_LIST ) allocate ( string , source = \"CUFFT_INCOMPLETE_PARAMETER_LIST\" ) case ( CUFFT_INVALID_DEVICE ) allocate ( string , source = \"CUFFT_INVALID_DEVICE\" ) case ( CUFFT_PARSE_ERROR ) allocate ( string , source = \"CUFFT_PARSE_ERROR\" ) case ( CUFFT_NO_WORKSPACE ) allocate ( string , source = \"CUFFT_NO_WORKSPACE\" ) case ( CUFFT_NOT_IMPLEMENTED ) allocate ( string , source = \"CUFFT_NOT_IMPLEMENTED\" ) case ( CUFFT_LICENSE_ERROR ) allocate ( string , source = \"CUFFT_LICENSE_ERROR\" ) case ( CUFFT_NOT_SUPPORTED ) allocate ( string , source = \"CUFFT_NOT_SUPPORTED\" ) case default allocate ( string , source = \"Unknown CUFFT error code\" ) end select end function cufftGetErrorString end module dtfft_interface_cufft","tags":"","loc":"sourcefile/dtfft_interface_cufft.f90.html"},{"title":"dtfft_backend_mpi.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_backend_mpi.f90~~EfferentGraph sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_backend_mpi.f90~~AfferentGraph sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_backend_mpi !! MPI Based Backends [[backend_mpi]] use iso_fortran_env use iso_c_binding use dtfft_abstract_backend #ifdef DTFFT_WITH_CUDA use dtfft_interface_cuda_runtime #endif use dtfft_errors use dtfft_parameters use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_cuda.h\" #include \"_dtfft_private.h\" #include \"_dtfft_profile.h\" implicit none private public :: backend_mpi type :: mpi_backend_helper !! MPI Helper integer ( CNT_KIND ), allocatable :: counts (:) !! Counts of data to send or recv integer ( ADDR_KIND ), allocatable :: displs (:) !! Displacements of data to send or recv TYPE_MPI_REQUEST , allocatable :: requests (:) !! MPI Requests integer ( int32 ), allocatable :: process_map (:) !! Process map for pipelined communication integer ( int32 ) :: n_requests !! Number of requests contains procedure , pass ( self ) :: create => create_helper !! Creates MPI helper procedure , pass ( self ) :: destroy => destroy_helper !! Destroys MPI helper endtype mpi_backend_helper type , extends ( abstract_backend ) :: backend_mpi !! MPI Backend private logical :: is_active !! If async transpose is active type ( mpi_backend_helper ) :: send !! MPI Helper for send data type ( mpi_backend_helper ) :: recv !! MPI Helper for recv data logical :: is_rma !! Using RMA backend TYPE_MPI_WIN :: win !! MPI Window for RMA backend logical :: is_request_created !! Request created flag. Used for persistent functions contains procedure :: create_private => create_mpi !! Creates MPI backend procedure :: execute_private => execute_mpi !! Executes MPI backend procedure :: destroy_private => destroy_mpi !! Destroys MPI backend procedure :: execute_end => execute_end_mpi !! Finalizes async transpose procedure :: get_async_active !! Overrides abstract method and returns if async transpose is active end type backend_mpi contains subroutine create_helper ( self , counts , displs , max_requests ) !! Creates MPI helper class ( mpi_backend_helper ), intent ( inout ) :: self !! MPI Helper integer ( int64 ), intent ( in ) :: counts (:) !! Counts of data to send or recv integer ( int64 ), intent ( in ) :: displs (:) !! Displacements of data to send or recv integer ( int32 ), intent ( in ) :: max_requests !! Maximum number of requests required integer ( int32 ) :: i , n_counts n_counts = size ( counts ) allocate ( self % counts ( 0 : n_counts - 1 ), self % displs ( 0 : n_counts - 1 ) ) self % counts ( 0 :) = int ( counts (:), CNT_KIND ) self % displs ( 0 :) = int ( displs (:), ADDR_KIND ) if ( max_requests > 0 ) then allocate ( self % requests ( max_requests ) ) do i = 1 , max_requests self % requests ( i ) = MPI_REQUEST_NULL enddo endif self % n_requests = 0 end subroutine create_helper subroutine destroy_helper ( self , is_request_created ) !! Destroys MPI helper class ( mpi_backend_helper ), intent ( inout ) :: self !! MPI Helper logical , intent ( in ) :: is_request_created if ( allocated ( self % counts ) ) deallocate ( self % counts ) if ( allocated ( self % displs ) ) deallocate ( self % displs ) #if defined(ENABLE_PERSISTENT_COMM) || defined(DTFFT_WITH_RMA) block integer ( int32 ) :: mpi_ierr , i if ( is_request_created ) then do i = 1 , self % n_requests if ( self % requests ( i ) /= MPI_REQUEST_NULL ) & call MPI_Request_free ( self % requests ( i ), mpi_ierr ) enddo endif endblock #endif if ( allocated ( self % requests ) ) deallocate ( self % requests ) if ( allocated ( self % process_map ) ) deallocate ( self % process_map ) self % n_requests = 0 end subroutine destroy_helper subroutine create_mpi ( self , helper , base_storage ) !! Creates MPI backend class ( backend_mpi ), intent ( inout ) :: self !! MPI Backend type ( backend_helper ), intent ( in ) :: helper !! Backend helper (unused) integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element (unused) integer ( int32 ) :: mpi_err #ifdef DTFFT_DEBUG if ( . not . is_backend_mpi ( self % backend ) ) INTERNAL_ERROR ( \".not. is_backend_mpi\" ) #endif if ( self % backend == DTFFT_BACKEND_MPI_A2A ) then call self % send % create ( self % send_floats , self % send_displs - 1 , 1 ) call self % recv % create ( self % recv_floats , self % recv_displs - 1 , 0 ) else call self % send % create ( self % send_floats , self % send_displs , self % comm_size ) call self % recv % create ( self % recv_floats , self % recv_displs , self % comm_size ) endif self % is_rma = . false . #ifdef DTFFT_WITH_RMA if ( any ( self % backend == [ DTFFT_BACKEND_MPI_RMA , DTFFT_BACKEND_MPI_RMA_PIPELINED ]) ) then block integer ( int32 ), allocatable :: all_displs (:,:) self % is_rma = . true . self % win = MPI_WIN_NULL allocate ( all_displs ( 0 : self % comm_size - 1 , 0 : self % comm_size - 1 ) ) call MPI_Allgather ( self % send % displs , self % comm_size , MPI_INTEGER , all_displs , self % comm_size , MPI_INTEGER , self % comm , mpi_err ) self % send % displs (:) = all_displs ( self % comm_rank , :) - 1 deallocate ( all_displs ) endblock endif #endif self % is_request_created = . false . self % is_active = . false . end subroutine create_mpi subroutine destroy_mpi ( self ) !! Destroys MPI backend class ( backend_mpi ), intent ( inout ) :: self !! MPI Backend integer ( int32 ) :: mpi_ierr call self % send % destroy ( self % is_request_created ) call self % recv % destroy ( self % is_request_created ) #ifdef DTFFT_WITH_RMA if ( self % is_rma ) then if ( self % win /= MPI_WIN_NULL ) & call MPI_Win_free ( self % win , mpi_ierr ) endif #endif self % is_request_created = . false . self % is_active = . false . end subroutine destroy_mpi elemental logical function get_async_active ( self ) !! Returns if async transpose is active class ( backend_mpi ), intent ( in ) :: self !!  MPI Backend get_async_active = self % is_active end function get_async_active subroutine execute_mpi ( self , in , out , stream , aux , exec_type , error_code ) !! Executes MPI backend class ( backend_mpi ), intent ( inout ) :: self !! MPI Backend real ( real32 ), target , intent ( inout ) :: in (:) !! Send pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Main execution CUDA stream real ( real32 ), target , intent ( inout ) :: aux (:) !! Aux pointer type ( async_exec_t ), intent ( in ) :: exec_type !! Type of async execution integer ( int32 ), intent ( out ) :: error_code !! Error code integer ( int32 ) :: mpi_ierr !! MPI error code integer ( int32 ), allocatable :: indices (:) integer ( int32 ) :: total_completed , n_completed !! Request counter integer ( int32 ) :: need_completed integer ( int32 ) :: i !! Loop index error_code = DTFFT_SUCCESS if ( self % is_active ) then error_code = DTFFT_ERROR_TRANSPOSE_ACTIVE return endif #ifdef DTFFT_WITH_CUDA if ( self % platform == DTFFT_PLATFORM_CUDA ) then ! Need to sync stream since there is no way pass current stream to MPI CUDA_CALL ( cudaStreamSynchronize ( stream ) ) endif #endif if ( any ( self % backend == [ DTFFT_BACKEND_MPI_A2A , DTFFT_BACKEND_MPI_P2P ] ) ) then if ( self % backend == DTFFT_BACKEND_MPI_A2A ) then call run_mpi_a2a ( self % comm , self % send , self % recv , in , out , self % is_request_created ) else if ( self % backend == DTFFT_BACKEND_MPI_P2P ) then call run_mpi_p2p ( self % comm , self % send , self % recv , in , out , self % is_request_created ) endif self % is_active = . true . #ifdef DTFFT_WITH_RMA else if ( self % backend == DTFFT_BACKEND_MPI_RMA ) then call run_mpi_rma ( self % comm , self % send , self % recv , in , out , self % win , self % is_request_created ) self % is_active = . true . #endif else if ( self % backend == DTFFT_BACKEND_MPI_P2P_PIPELINED ) then call run_mpi_p2p ( self % comm , self % send , self % recv , in , aux , self % is_request_created ) #ifdef DTFFT_WITH_RMA else call run_mpi_rma ( self % comm , self % send , self % recv , in , aux , self % win , self % is_request_created ) #endif endif allocate ( indices ( self % recv % n_requests ) ) need_completed = self % recv % n_requests total_completed = 0 do while (. true .) ! Testing that all data has been recieved so we can unpack it call MPI_Waitsome ( self % recv % n_requests , self % recv % requests , n_completed , indices , MPI_STATUSES_IGNORE , mpi_ierr ) if ( n_completed == MPI_UNDEFINED . or . need_completed == 0 ) exit do i = 1 , n_completed #ifdef MPICH_FIX_REQUIRED call self % unpack_kernel % execute ( aux , out , stream , self % recv % process_map ( indices ( i ) + 1 ) + 1 ) #else call self % unpack_kernel % execute ( aux , out , stream , self % recv % process_map ( indices ( i )) + 1 ) #endif enddo total_completed = total_completed + n_completed if ( total_completed == need_completed ) exit enddo deallocate ( indices ) if ( self % send % n_requests > 0 ) then call MPI_Waitall ( self % send % n_requests , self % send % requests , MPI_STATUSES_IGNORE , mpi_ierr ) endif if ( self % is_rma ) then call MPI_Win_fence ( MPI_MODE_NOSUCCEED , self % win , error_code ) endif endif end subroutine execute_mpi subroutine execute_end_mpi ( self , error_code ) class ( backend_mpi ), intent ( inout ) :: self !! MPI Backend integer ( int32 ), intent ( out ) :: error_code !! Error code error_code = DTFFT_SUCCESS if ( self % is_pipelined ) return if ( . not . self % is_active ) then error_code = DTFFT_ERROR_TRANSPOSE_NOT_ACTIVE return endif if ( self % recv % n_requests > 0 ) then call MPI_Waitall ( self % recv % n_requests , self % recv % requests , MPI_STATUSES_IGNORE , error_code ) endif if ( self % send % n_requests > 0 ) then call MPI_Waitall ( self % send % n_requests , self % send % requests , MPI_STATUSES_IGNORE , error_code ) endif if ( self % is_rma ) then call MPI_Win_fence ( MPI_MODE_NOSUCCEED , self % win , error_code ) endif self % is_active = . false . end subroutine execute_end_mpi subroutine run_mpi_p2p ( comm , send , recv , in , out , is_request_created ) !! Executes MPI point-to-point communication TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator type ( mpi_backend_helper ), intent ( inout ) :: send !! MPI Helper for send data type ( mpi_backend_helper ), intent ( inout ) :: recv !! MPI Helper for recv data real ( real32 ), intent ( in ) :: in (:) !! Data to be sent real ( real32 ), intent ( inout ) :: out (:) !! Data to be received logical , intent ( inout ) :: is_request_created integer ( int32 ) :: send_request_counter , recv_request_counter integer ( int32 ) :: i , comm_size , mpi_ierr call MPI_Comm_size ( comm , comm_size , mpi_ierr ) if (. not . allocated ( recv % process_map )) then allocate ( recv % process_map ( comm_size )) endif #ifdef ENABLE_PERSISTENT_COMM if ( . not . is_request_created ) then recv_request_counter = 0 do i = 0 , comm_size - 1 if ( recv % counts ( i ) > 0 ) then recv_request_counter = recv_request_counter + 1 recv % process_map ( recv_request_counter ) = i call MPI_Recv_init ( out ( recv % displs ( i ) ), recv % counts ( i ), MPI_REAL , i , 0 , & comm , recv % requests ( recv_request_counter ), mpi_ierr ) endif enddo recv % n_requests = recv_request_counter send_request_counter = 0 do i = 0 , comm_size - 1 if ( send % counts ( i ) > 0 ) then send_request_counter = send_request_counter + 1 call MPI_Send_init ( in ( send % displs ( i ) ), send % counts ( i ), MPI_REAL , i , 0 , & comm , send % requests ( send_request_counter ), mpi_ierr ) endif enddo send % n_requests = send_request_counter is_request_created = . true . endif call MPI_Startall ( recv % n_requests , recv % requests , mpi_ierr ) call MPI_Startall ( send % n_requests , send % requests , mpi_ierr ) #else send_request_counter = 0 recv_request_counter = 0 do i = 0 , comm_size - 1 if ( recv % counts ( i ) > 0 ) then recv_request_counter = recv_request_counter + 1 recv % process_map ( recv_request_counter ) = i call MPI_Irecv ( out ( recv % displs ( i ) ), recv % counts ( i ), MPI_REAL , i , 0 , & comm , recv % requests ( recv_request_counter ), mpi_ierr ) endif enddo recv % n_requests = recv_request_counter do i = 0 , comm_size - 1 if ( send % counts ( i ) > 0 ) then send_request_counter = send_request_counter + 1 call MPI_Isend ( in ( send % displs ( i ) ), send % counts ( i ), MPI_REAL , i , 0 , & comm , send % requests ( send_request_counter ), mpi_ierr ) endif enddo send % n_requests = send_request_counter #endif end subroutine run_mpi_p2p subroutine run_mpi_a2a ( comm , send , recv , in , out , is_request_created ) !! Executes MPI all-to-all communication TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator type ( mpi_backend_helper ), intent ( inout ) :: send !! MPI Helper for send data type ( mpi_backend_helper ), intent ( inout ) :: recv !! MPI Helper for recv data real ( real32 ), intent ( in ) :: in (:) !! Data to be sent real ( real32 ), intent ( inout ) :: out (:) !! Data to be received logical , intent ( inout ) :: is_request_created integer ( int32 ) :: mpi_ierr #if defined(ENABLE_PERSISTENT_COLLECTIVES) if ( . not . is_request_created ) then call MPI_Alltoallv_init ( in , send % counts , send % displs , MPI_REAL , & out , recv % counts , recv % displs , MPI_REAL , & comm , MPI_INFO_NULL , send % requests ( 1 ), mpi_ierr ) is_request_created = . true . endif call MPI_Start ( send % requests ( 1 ), mpi_ierr ) #else call MPI_Ialltoallv ( in , send % counts , send % displs , MPI_REAL , & out , recv % counts , recv % displs , MPI_REAL , & comm , send % requests ( 1 ), mpi_ierr ) #endif send % n_requests = 1 end subroutine run_mpi_a2a #ifdef DTFFT_WITH_RMA subroutine run_mpi_rma ( comm , send , recv , in , out , win , is_created ) !! Executes MPI One-sided communication TYPE_MPI_COMM , intent ( in ) :: comm !! MPI communicator type ( mpi_backend_helper ), intent ( inout ) :: send !! MPI Helper for send data type ( mpi_backend_helper ), intent ( inout ) :: recv !! MPI Helper for recv data real ( real32 ), intent ( in ) :: in (:) !! Data to be sent real ( real32 ), intent ( inout ) :: out (:) !! Data to be received TYPE_MPI_WIN , intent ( inout ) :: win !! MPI Window logical , intent ( inout ) :: is_created integer ( int32 ) :: mpi_ierr , i , comm_size integer ( int32 ) :: recv_request_counter call MPI_Comm_size ( comm , comm_size , mpi_ierr ) if (. not . allocated ( recv % process_map )) then allocate ( recv % process_map ( comm_size )) endif if ( . not . is_created ) then call MPI_Win_create ( in , int ( size ( in ) * FLOAT_STORAGE_SIZE , MPI_ADDRESS_KIND ), int ( FLOAT_STORAGE_SIZE , int32 ), MPI_INFO_NULL , comm , win , mpi_ierr ) is_created = . true . endif call MPI_Win_fence ( MPI_MODE_NOPRECEDE , win , mpi_ierr ) recv_request_counter = 0 do i = 0 , comm_size - 1 if ( recv % counts ( i ) > 0 ) then recv_request_counter = recv_request_counter + 1 recv % process_map ( recv_request_counter ) = i call MPI_RGet ( out ( recv % displs ( i ) ), recv % counts ( i ), MPI_REAL , i , & int ( send % displs ( i ), MPI_ADDRESS_KIND ), recv % counts ( i ), MPI_REAL , win , recv % requests ( recv_request_counter ), mpi_ierr ) endif enddo recv % n_requests = recv_request_counter end subroutine run_mpi_rma #endif end module dtfft_backend_mpi","tags":"","loc":"sourcefile/dtfft_backend_mpi.f90.html"},{"title":"dtfft_kernel_host.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_kernel_host.f90~~EfferentGraph sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_kernel_host.f90~~AfferentGraph sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_kernel_host !! This module defines `kernel_host` type and its type bound procedures. !! The host kernel is an implementation of the `abstract_kernel` type !! that runs on the host CPU. use iso_c_binding use iso_fortran_env use dtfft_abstract_kernel use dtfft_parameters #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" implicit none private public :: kernel_host type , extends ( abstract_kernel ) :: kernel_host !! Host kernel implementation integer ( int64 ) :: base_storage contains procedure :: create_private => create_host !! Creates kernel procedure :: execute_private => execute_host !! Executes kernel procedure :: destroy_private => destroy_host !! Destroys kernel end type kernel_host contains subroutine create_host ( self , effort , base_storage , force_effort ) !! Creates kernel class ( kernel_host ), intent ( inout ) :: self !! Host kernel class type ( dtfft_effort_t ), intent ( in ) :: effort !! Effort level for generating transpose kernels integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element logical , optional , intent ( in ) :: force_effort !! Should effort be forced or not self % base_storage = base_storage end subroutine create_host subroutine execute_host ( self , in , out , stream , neighbor ) !! Executes host kernel class ( kernel_host ), intent ( inout ) :: self !! Host kernel class real ( real32 ), target , intent ( in ) :: in (:) !! Source host-allocated buffer real ( real32 ), target , intent ( inout ) :: out (:) !! Target host-allocated buffer type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to execute on, unused here integer ( int32 ), optional , intent ( in ) :: neighbor !! Source rank for pipelined unpacking type ( c_ptr ) :: pin , pout integer ( int32 ) :: scaler pin = c_loc ( in ) pout = c_loc ( out ) scaler = int ( self % base_storage / FLOAT_STORAGE_SIZE , int32 ) select case ( self % base_storage ) case ( FLOAT_STORAGE_SIZE ) select case ( self % kernel_type % val ) case ( KERNEL_PERMUTE_FORWARD % val ) call permute_forward_f32 ( in , out , self % dims ) case ( KERNEL_PERMUTE_BACKWARD % val ) call permute_backward_f32 ( in , out , self % dims ) case ( KERNEL_PERMUTE_BACKWARD_START % val ) call permute_backward_start_f32 ( in , out , self % dims ) case ( KERNEL_PERMUTE_BACKWARD_END % val ) call permute_backward_end_f32 ( in , out , self % dims , self % neighbor_data ) case ( KERNEL_UNPACK % val ) call unpack_f32 ( in , out , self % dims , self % neighbor_data ) case ( KERNEL_PERMUTE_BACKWARD_END_PIPELINED % val ) call permute_backward_end_pipelined_f32 ( in , out , self % dims , self % neighbor_data (:, neighbor )) case ( KERNEL_UNPACK_PIPELINED % val ) call unpack_pipelined_f32 ( in , out , self % dims , self % neighbor_data (:, neighbor )) endselect case ( DOUBLE_STORAGE_SIZE ) block real ( real64 ), pointer :: inbuf (:), outbuf (:) call c_f_pointer ( pin , inbuf , [ size ( in ) / scaler ]) call c_f_pointer ( pout , outbuf , [ size ( out ) / scaler ]) select case ( self % kernel_type % val ) case ( KERNEL_PERMUTE_FORWARD % val ) call permute_forward_f64 ( inbuf , outbuf , self % dims ) case ( KERNEL_PERMUTE_BACKWARD % val ) call permute_backward_f64 ( inbuf , outbuf , self % dims ) case ( KERNEL_PERMUTE_BACKWARD_START % val ) call permute_backward_start_f64 ( inbuf , outbuf , self % dims ) case ( KERNEL_PERMUTE_BACKWARD_END % val ) call permute_backward_end_f64 ( inbuf , outbuf , self % dims , self % neighbor_data ) case ( KERNEL_UNPACK % val ) call unpack_f64 ( inbuf , outbuf , self % dims , self % neighbor_data ) case ( KERNEL_PERMUTE_BACKWARD_END_PIPELINED % val ) call permute_backward_end_pipelined_f64 ( inbuf , outbuf , self % dims , self % neighbor_data (:, neighbor )) case ( KERNEL_UNPACK_PIPELINED % val ) call unpack_pipelined_f64 ( inbuf , outbuf , self % dims , self % neighbor_data (:, neighbor )) endselect endblock case ( DOUBLE_COMPLEX_STORAGE_SIZE ) block complex ( real64 ), pointer :: inbuf (:), outbuf (:) call c_f_pointer ( pin , inbuf , [ size ( in ) / scaler ]) call c_f_pointer ( pout , outbuf , [ size ( out ) / scaler ]) select case ( self % kernel_type % val ) case ( KERNEL_PERMUTE_FORWARD % val ) call permute_forward_f128 ( inbuf , outbuf , self % dims ) case ( KERNEL_PERMUTE_BACKWARD % val ) call permute_backward_f128 ( inbuf , outbuf , self % dims ) case ( KERNEL_PERMUTE_BACKWARD_START % val ) call permute_backward_start_f128 ( inbuf , outbuf , self % dims ) case ( KERNEL_PERMUTE_BACKWARD_END % val ) call permute_backward_end_f128 ( inbuf , outbuf , self % dims , self % neighbor_data ) case ( KERNEL_UNPACK % val ) call unpack_f128 ( inbuf , outbuf , self % dims , self % neighbor_data ) case ( KERNEL_PERMUTE_BACKWARD_END_PIPELINED % val ) call permute_backward_end_pipelined_f128 ( inbuf , outbuf , self % dims , self % neighbor_data (:, neighbor )) case ( KERNEL_UNPACK_PIPELINED % val ) call unpack_pipelined_f128 ( inbuf , outbuf , self % dims , self % neighbor_data (:, neighbor )) endselect endblock endselect end subroutine execute_host subroutine destroy_host ( self ) !! Destroys host kernel class ( kernel_host ), intent ( inout ) :: self !! Host kernel class if ( self % is_created ) return end subroutine destroy_host #define PREC _f128 #define BUFFER_TYPE complex(real64) #include \"_dtfft_kernel_host_routines.inc\" #define PREC _f64 #define BUFFER_TYPE real(real64) #include \"_dtfft_kernel_host_routines.inc\" #define PREC _f32 #define BUFFER_TYPE real(real32) #include \"_dtfft_kernel_host_routines.inc\" end module dtfft_kernel_host","tags":"","loc":"sourcefile/dtfft_kernel_host.f90.html"},{"title":"dtfft_interface_nccl.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_nccl.f90~~EfferentGraph sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_nccl.f90~~AfferentGraph sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_nccl !! NCCL Interfaces use iso_c_binding use dtfft_parameters , only : dtfft_stream_t use dtfft_utils , only : string_c2f implicit none private public :: ncclGetErrorString public :: ncclUniqueId type , bind ( c ) :: ncclUniqueId character ( c_char ) :: internal ( 128 ) end type ncclUniqueId public :: ncclComm type , bind ( c ) :: ncclComm type ( c_ptr ) :: member end type ncclComm public :: ncclDataType type , bind ( c ) :: ncclDataType integer ( c_int ) :: member end type ncclDataType type ( ncclDataType ), parameter , public :: ncclFloat = ncclDataType ( 7 ) interface !! Returns a human-readable string corresponding to the passed error code. function ncclGetErrorString_c ( ncclResult_t ) & result ( message ) & bind ( C , name = \"ncclGetErrorString\" ) import integer ( c_int32_t ), intent ( in ), value :: ncclResult_t !! Completion status of a NCCL function. type ( c_ptr ) :: message !! Pointer to message end function ncclGetErrorString_c endinterface public :: ncclGetUniqueId interface !! Generates an Id to be used in ncclCommInitRank. !! ncclGetUniqueId should be called once when creating a communicator and the Id should be !! distributed to all ranks in the communicator before calling ncclCommInitRank. !! uniqueId should point to a ncclUniqueId object allocated by the user. function ncclGetUniqueId ( uniqueId ) & result ( ncclResult_t ) & bind ( C , name = \"ncclGetUniqueId\" ) import type ( ncclUniqueId ), intent ( out ) :: uniqueId !! Unique ID integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclGetUniqueId end interface public :: ncclMemAlloc interface !! Allocate a GPU buffer with size. !! Allocated buffer head address will be returned by ptr, and the actual allocated size can be larger !! than requested because of the buffer granularity requirements from all types of NCCL optimizations. function ncclMemAlloc ( ptr , alloc_bytes ) & result ( ncclResult_t ) & bind ( C , name = \"ncclMemAlloc\" ) import type ( c_ptr ), intent ( out ) :: ptr !! Buffer address integer ( c_size_t ), intent ( in ), value :: alloc_bytes !! Number of bytes to allocate integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclMemAlloc end interface public :: ncclMemFree interface !! Free memory allocated by ncclMemAlloc(). function ncclMemFree ( ptr ) & result ( ncclResult_t ) & bind ( C , name = \"ncclMemFree\" ) import type ( c_ptr ), intent ( in ), value :: ptr !! Buffer address integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclMemFree end interface public :: ncclCommInitRank interface !! Creates a new communicator (multi thread/process version). !! !! rank must be between 0 and nranks-1 and unique within a communicator clique. !! Each rank is associated to a CUDA device, which has to be set before calling ncclCommInitRank. !! !! ncclCommInitRank implicitly synchronizes with other ranks, hence it must be called by different !! threads/processes or used within ncclGroupStart/ncclGroupEnd. function ncclCommInitRank ( comm , nranks , uniqueId , rank ) & result ( ncclResult_t ) & bind ( C , name = \"ncclCommInitRank\" ) import type ( ncclComm ) :: comm !! Communicator integer ( c_int ), value :: nranks !! Number of ranks in communicator type ( ncclUniqueId ), value :: uniqueId !! Unique ID integer ( c_int ), value :: rank !! Calling rank integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclCommInitRank end interface public :: ncclSend interface !! Send data from sendbuff to rank peer. !! !! Rank peer needs to call ncclRecv with the same datatype and the same count as this rank. !! !! This operation is blocking for the GPU. !! If multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, !! they must be fused within a ncclGroupStart()/ ncclGroupEnd() section. function ncclSend ( sendbuff , count , datatype , peer , comm , stream ) & result ( ncclResult_t ) & bind ( c , name = 'ncclSend' ) import real ( c_float ) :: sendbuff !! Buffer to send data from integer ( c_size_t ), value :: count !! Number of elements to send type ( ncclDataType ), value :: datatype !! Datatype to send integer ( c_int ), value :: peer !! Target GPU type ( ncclComm ), value :: comm !! Communicator type ( dtfft_stream_t ), value :: stream !! CUDA Stream integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclSend end interface public :: ncclRecv interface !! Receive data from rank peer into recvbuff. !! !! Rank peer needs to call ncclSend with the same datatype and the same count as this rank. !! This operation is blocking for the GPU. !! If multiple ncclSend() and ncclRecv() operations need to progress concurrently to complete, !! they must be fused within a ncclGroupStart()/ ncclGroupEnd() section. function ncclRecv ( recvbuff , count , datatype , peer , comm , stream ) & result ( ncclResult_t ) & bind ( c , name = 'ncclRecv' ) import real ( c_float ) :: recvbuff !! Buffer to recv data into integer ( c_size_t ), value :: count !! Number of elements to recv type ( ncclDataType ), value :: datatype !! Datatype to recv integer ( c_int ), value :: peer !! Source GPU type ( ncclComm ), value :: comm !! Communicator type ( dtfft_stream_t ), value :: stream !! CUDA Stream integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclRecv end interface public :: ncclGroupStart interface !! Start a group call. !! !! All subsequent calls to NCCL until ncclGroupEnd will not block due to inter-CPU synchronization. function ncclGroupStart () & result ( ncclResult_t ) & bind ( C , name = \"ncclGroupStart\" ) import integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclGroupStart end interface public :: ncclGroupEnd interface !! End a group call. !! !! Returns when all operations since ncclGroupStart have been processed. !! This means the communication primitives have been enqueued to the provided streams, !! but are not necessarily complete. function ncclGroupEnd () & result ( ncclResult_t ) & bind ( C , name = \"ncclGroupEnd\" ) import integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclGroupEnd end interface public :: ncclCommDestroy interface !! Destroy a communicator object comm. function ncclCommDestroy ( comm ) & result ( ncclResult_t ) & bind ( C , name = \"ncclCommDestroy\" ) import type ( ncclComm ), value :: comm !! Communicator integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclCommDestroy end interface public :: ncclCommRegister interface !! Register a buffer for collective communication. function ncclCommRegister ( comm , buff , size , handle ) & result ( ncclResult_t ) & bind ( C , name = \"ncclCommRegister\" ) import type ( ncclComm ), value :: comm !! Communicator type ( c_ptr ), value :: buff !! Buffer to register integer ( c_size_t ), value :: size !! Size of the buffer in bytes type ( c_ptr ) :: handle !! Handle to the registered buffer integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclCommRegister end interface public :: ncclCommDeregister interface !! Deregister a buffer for collective communication. function ncclCommDeregister ( comm , handle ) & result ( ncclResult_t ) & bind ( C , name = \"ncclCommDeregister\" ) import type ( ncclComm ), value :: comm !! Communicator type ( c_ptr ), value :: handle !! Handle to the registered buffer integer ( c_int32_t ) :: ncclResult_t !! Completion status end function ncclCommDeregister end interface contains function ncclGetErrorString ( ncclResult_t ) result ( string ) !! Generates an error message. integer ( c_int32_t ), intent ( in ) :: ncclResult_t !! Completion status of a function. character ( len = :), allocatable :: string !! Error message call string_c2f ( ncclGetErrorString_c ( ncclResult_t ), string ) end function ncclGetErrorString end module dtfft_interface_nccl","tags":"","loc":"sourcefile/dtfft_interface_nccl.f90.html"},{"title":"dtfft_backend_nccl.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_backend_nccl.f90~~EfferentGraph sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_backend_nccl.f90~~AfferentGraph sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_backend_nccl_m !! NCCL Based GPU Backends [[backend_nccl]] use iso_fortran_env use iso_c_binding , only : c_ptr , c_f_pointer use dtfft_abstract_backend , only : abstract_backend , backend_helper use dtfft_interface_cuda_runtime use dtfft_interface_nccl use dtfft_errors use dtfft_parameters use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_cuda.h\" #include \"_dtfft_private.h\" implicit none private public :: backend_nccl type , extends ( abstract_backend ) :: backend_nccl !! NCCL backend private type ( ncclComm ) :: nccl_comm !! NCCL Communicator contains procedure :: create_private => create_nccl !! Creates NCCL backend procedure :: execute_private => execute_nccl !! Executes NCCL backend procedure :: destroy_private => destroy_nccl !! Destroys NCCL backend end type backend_nccl contains subroutine create_nccl ( self , helper , base_storage ) !! Creates NCCL backend class ( backend_nccl ), intent ( inout ) :: self !! NCCL backend type ( backend_helper ), intent ( in ) :: helper !! Backend helper integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element (unused) #ifdef DTFFT_DEBUG if (. not . is_backend_nccl ( self % backend )) INTERNAL_ERROR ( \".not. is_backend_nccl\" ) if (. not . helper % is_nccl_created ) INTERNAL_ERROR ( \".not. helper%is_nccl_created\" ) #endif self % nccl_comm = helper % nccl_comm end subroutine create_nccl subroutine execute_nccl ( self , in , out , stream , aux , exec_type , error_code ) !! Executes NCCL backend class ( backend_nccl ), intent ( inout ) :: self !! NCCL backend real ( real32 ), target , intent ( inout ) :: in (:) !! Send pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Main execution CUDA stream real ( real32 ), target , intent ( inout ) :: aux (:) !! Aux pointer type ( async_exec_t ), intent ( in ) :: exec_type !! Type of async execution integer ( int32 ), intent ( out ) :: error_code !! Error code integer ( int32 ) :: i !! Counter integer ( int32 ) :: rnk !! Rank to send-recv real ( real32 ), pointer :: pin (:), pout (:) if ( self % is_pipelined ) then pin => in (:) pout => aux (:) else pin => in (:) pout => out (:) end if NCCL_CALL ( ncclGroupStart () ) do i = 0 , self % comm_size - 1 if ( i == self % comm_rank . and . self % is_pipelined ) cycle rnk = self % comm_mapping ( i ) if ( self % send_floats ( i ) > 0 ) then NCCL_CALL ( ncclSend ( pin ( self % send_displs ( i )), self % send_floats ( i ), ncclFloat , rnk , self % nccl_comm , stream ) ) end if if ( self % recv_floats ( i ) > 0 ) then NCCL_CALL ( ncclRecv ( pout ( self % recv_displs ( i )), self % recv_floats ( i ), ncclFloat , rnk , self % nccl_comm , stream ) ) end if end do NCCL_CALL ( ncclGroupEnd () ) if ( self % is_pipelined ) then do i = 0 , self % comm_size - 1 if ( self % recv_floats ( i ) > 0 ) then call self % unpack_kernel % execute ( pout , out , stream , i + 1 ) end if end do end if error_code = DTFFT_SUCCESS end subroutine execute_nccl subroutine destroy_nccl ( self ) !! Destroys NCCL backend class ( backend_nccl ), intent ( inout ) :: self !! NCCL backend end subroutine destroy_nccl end module dtfft_backend_nccl_m","tags":"","loc":"sourcefile/dtfft_backend_nccl.f90.html"},{"title":"dtfft_interface_nvtx.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_nvtx.f90~~EfferentGraph sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_nvtx.f90~~AfferentGraph sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_nvtx !! nvtx3 Interfaces use iso_c_binding use dtfft_utils implicit none private public :: push_nvtx_domain_range , pop_nvtx_domain_range type , bind ( C ) :: nvtxDomainHandle !! NVTX domain handle. type ( c_ptr ) :: handle !! Internal handle for the NVTX domain. end type nvtxDomainHandle type ( nvtxDomainHandle ), save :: domain_nvtx !! NVTX domain handle logical , save :: domain_created = . false . !! Has domain been created? interface subroutine nvtxDomainCreate_c ( name , domain ) bind ( C , name = \"nvtxDomainCreate_c\" ) !! Creates an NVTX domain with the specified name. import character ( c_char ), intent ( in ) :: name ( * ) !! Name of the NVTX domain. type ( nvtxDomainHandle ) :: domain !! Handle to the created NVTX domain. end subroutine nvtxDomainCreate_c end interface interface subroutine nvtxDomainRangePushEx_c ( domain , message , color ) bind ( C , name = \"nvtxDomainRangePushEx_c\" ) !! Pushes a range with a custom message and color onto the specified NVTX domain. import type ( nvtxDomainHandle ), value :: domain !! NVTX domain handle. character ( c_char ), intent ( in ) :: message ( * ) !! Custom message for the range. integer ( c_int ), value , intent ( in ) :: color !! Color for the range. end subroutine nvtxDomainRangePushEx_c end interface interface subroutine nvtxDomainRangePop_c ( domain ) bind ( C , name = \"nvtxDomainRangePop_c\" ) !! Pops a range from the specified NVTX domain. import type ( nvtxDomainHandle ), value :: domain !! NVTX domain handle. end subroutine nvtxDomainRangePop_c end interface contains subroutine create_nvtx_domain !! Creates a new NVTX domain character ( c_char ), allocatable :: cstr (:) !! C-style string call astring_f2c ( \"dtFFT\" , cstr ) call nvtxDomainCreate_c ( cstr , domain_nvtx ) domain_created = . true . deallocate ( cstr ) end subroutine create_nvtx_domain subroutine push_nvtx_domain_range ( message , color ) !! Pushes a range to the NVTX domain character ( len =* ), intent ( in ) :: message !! Message to push integer ( c_int ), intent ( in ) :: color !! Color of the range character ( c_char ), allocatable :: cstr (:) !! C-style string if ( . not . domain_created ) call create_nvtx_domain () call astring_f2c ( message , cstr ) call nvtxDomainRangePushEx_c ( domain_nvtx , cstr , color ) deallocate ( cstr ) end subroutine push_nvtx_domain_range subroutine pop_nvtx_domain_range () !! Pops a range from the NVTX domain call nvtxDomainRangePop_c ( domain_nvtx ) end subroutine pop_nvtx_domain_range end module dtfft_interface_nvtx","tags":"","loc":"sourcefile/dtfft_interface_nvtx.f90.html"},{"title":"dtfft_utils.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_utils.f90~~EfferentGraph sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_utils.f90~~AfferentGraph sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_utils !! All Utilities functions are located here use iso_c_binding use iso_fortran_env use dtfft_errors use dtfft_parameters #include \"_dtfft_mpi.h\" #include \"_dtfft_cuda.h\" #include \"_dtfft_private.h\" implicit none private public :: string_f2c public :: to_str public :: write_message public :: get_inverse_kind public :: is_same_ptr , is_null_ptr public :: mem_alloc_host , mem_free_host public :: create_subcomm_include_all , create_subcomm public :: string public :: destroy_strings #if defined(DTFFT_WITH_CUDA) || defined(DTFFT_WITH_MKL) public :: string_c2f #endif #ifdef DTFFT_WITH_CUDA public :: astring_f2c public :: count_unique public :: Comm_f2c public :: is_device_ptr public :: dynamic_load #endif interface to_str !! Convert various types to string module procedure int8_to_string module procedure int32_to_string module procedure int64_to_string module procedure double_to_string module procedure float_to_string end interface to_str interface is_null_ptr !! Checks if pointer is NULL module procedure is_null_ptr #ifdef DTFFT_WITH_CUDA module procedure is_null_funptr #endif end interface is_null_ptr #if defined(DTFFT_USE_MPI) public :: all_reduce_inplace interface all_reduce_inplace !! MPI Allreduce inplace workaround module procedure :: all_reduce_inplace_i32 module procedure :: all_reduce_inplace_i64 end interface all_reduce_inplace #endif #ifdef DTFFT_WITH_CUDA integer ( c_int ), parameter :: RTLD_LAZY = 1_c_int !! Each external function reference is bound the first time the function is called. integer ( c_int ), parameter :: RTLD_NOW = 2_c_int !! All external function references are bound when the library is loaded. interface function dlopen ( filename , mode ) bind ( C ) !! Load and link a dynamic library import type ( c_ptr ) :: dlopen !! Handle to the library character ( c_char ) :: filename ( * ) !! Name of the library integer ( c_int ), value :: mode !! Options to dlopen end function dlopen end interface interface function dlsym ( handle , name ) bind ( C ) !! Get address of a symbol from a dynamic library import type ( c_funptr ) :: dlsym !! Address of the symbol type ( c_ptr ), value :: handle !! Handle to the library character ( c_char ) :: name ( * ) !! Name of the symbol end function dlsym end interface interface function dlclose ( handle ) bind ( C ) !! Close a dynamic library import integer ( c_int ) :: dlclose !! Result of the operation type ( c_ptr ), value :: handle !! Handle to the library end function dlclose end interface interface function dlerror () bind ( C ) !! Get diagnostic information import type ( c_ptr ) :: dlerror !! Error message end function dlerror end interface #endif interface function aligned_alloc ( alignment , alloc_size ) result ( ptr ) bind ( C ) !! Allocates memory using C11 Standard alloc_align with 16 bytes alignment import integer ( c_size_t ), value :: alignment !! Alignment in bytes (16 bytes by default) integer ( c_size_t ), value :: alloc_size !! Number of bytes to allocate type ( c_ptr ) :: ptr !! Pointer to allocate end function aligned_alloc end interface interface subroutine mem_free_host ( ptr ) bind ( C , name = \"free\" ) !! Frees memory allocated with [[aligned_alloc]] import type ( c_ptr ), value :: ptr !! Pointer to free end subroutine mem_free_host end interface #ifdef DTFFT_WITH_CUDA interface type ( c_ptr ) function Comm_f2c ( fcomm ) bind ( C , name = \"Comm_f2c\" ) !! Converts Fortran communicator to C import integer ( c_int ), value :: fcomm !! Fortran communicator end function Comm_f2c end interface interface function is_device_ptr ( ptr ) result ( bool ) bind ( C ) !! Checks if pointer can be accessed from device import type ( c_ptr ), value :: ptr !! Device pointer logical ( c_bool ) :: bool !! Result end function is_device_ptr end interface #endif type :: string !! Class used to create array of strings character ( len = :), allocatable :: raw !! String contains procedure , pass ( self ) :: destroy => destroy_string end type string interface string !! Creates [[string]] object module procedure :: string_constructor end interface string contains type ( string ) function string_constructor ( str ) !! Creates [[string]] object character ( len =* ), intent ( in ) :: str !! String allocate ( string_constructor % raw , source = str ) end function string_constructor subroutine destroy_string ( self ) class ( string ), intent ( inout ) :: self if ( allocated ( self % raw ) ) deallocate ( self % raw ) end subroutine destroy_string subroutine destroy_strings ( strings ) !! Destroys array of [[string]] objects type ( string ), intent ( inout ), allocatable :: strings (:) !! Array of strings integer ( int32 ) :: i if ( . not . allocated ( strings ) ) return do i = 1 , size ( strings ) call strings ( i )% destroy () end do deallocate ( strings ) end subroutine destroy_strings subroutine string_f2c ( fstring , cstring , string_size ) !! Convert Fortran string to C string character ( len =* ), intent ( in ) :: fstring !! Fortran string character ( kind = c_char ), intent ( inout ) :: cstring ( * ) !! C string integer ( int64 ), optional , intent ( out ) :: string_size !! Size of the C string integer :: i , j !! Loop indices logical :: met_non_blank !! Have we met a non-blank character? j = 1 met_non_blank = . false . do i = 1 , len_trim ( fstring ) if ( met_non_blank ) then cstring ( j ) = fstring ( i : i ) j = j + 1 else if ( fstring ( i : i ) /= ' ' ) then met_non_blank = . true . cstring ( j ) = fstring ( i : i ) j = j + 1 end if end do cstring ( j ) = c_null_char if ( present ( string_size )) string_size = j end subroutine string_f2c #if defined(DTFFT_WITH_CUDA) || defined(DTFFT_WITH_MKL) subroutine string_c2f ( cstring , fstring ) !! Convert C string to Fortran string type ( c_ptr ) :: cstring !! C string character ( len = :), allocatable :: fstring !! Fortran string character ( c_char ), pointer :: cstring_ (:) character ( len = 4096 ) :: fstring_ !! Temporary Fortran string integer ( int32 ) :: l if ( is_null_ptr ( cstring ) ) then allocate ( fstring , source = \"\" ) return endif call c_f_pointer ( cstring , cstring_ , [ len ( fstring_ )]) l = 0 do while (. true .) l = l + 1 if ( cstring_ ( l ) == c_null_char ) exit if ( l == len ( fstring_ ) - 1 ) exit fstring_ ( l : l ) = cstring_ ( l ) enddo allocate ( fstring , source = fstring_ ( 1 : l ) ) end subroutine string_c2f #endif #ifdef DTFFT_WITH_CUDA subroutine astring_f2c ( fstring , cstring , string_size ) !! Convert Fortran string to C allocatable string character ( len =* ), intent ( in ) :: fstring !! Fortran string character ( kind = c_char ), allocatable , intent ( out ) :: cstring (:) !! C string integer ( int64 ), optional , intent ( out ) :: string_size !! Size of the C string allocate ( cstring ( len_trim ( fstring ) + 1 )) call string_f2c ( fstring , cstring , string_size ) end subroutine astring_f2c subroutine dl_error ( message ) !! Writes error message to the error unit character ( len =* ), intent ( in ) :: message !! Message to write character ( len = :), allocatable :: err_msg !! Error string call string_c2f ( dlerror (), err_msg ) WRITE_ERROR ( message // \": \" // err_msg ) deallocate ( err_msg ) end subroutine dl_error function load_library ( name ) result ( lib_handle ) !! Dynamically loads library character ( len =* ), intent ( in ) :: name !! Name of library to load type ( c_ptr ) :: lib_handle !! Loaded handle character ( c_char ), allocatable :: cname (:) !! Temporary string call astring_f2c ( name // c_null_char , cname ) lib_handle = dlopen ( cname , RTLD_LAZY ) deallocate ( cname ) if ( is_null_ptr ( lib_handle )) then call dl_error ( \"Failed to load library '\" // name // \"'\" ) endif end function load_library function load_symbol ( handle , name ) result ( symbol_handle ) !! Dynamically loads symbol from library type ( c_ptr ), intent ( in ) :: handle !! Loaded handle character ( len =* ), intent ( in ) :: name !! Name of function to load type ( c_funptr ) :: symbol_handle !! Function pointer character ( c_char ), allocatable :: cname (:) !! Temporary string if ( is_null_ptr ( handle ) ) INTERNAL_ERROR ( \"is_null_ptr(handle)\" ) call astring_f2c ( name // c_null_char , cname ) symbol_handle = dlsym ( handle , cname ) deallocate ( cname ) if ( is_null_ptr ( symbol_handle )) then call dl_error ( \"Failed to load symbol '\" // name // \"'\" ) endif end function load_symbol subroutine unload_library ( handle ) !! Unloads library type ( c_ptr ), intent ( in ) :: handle !! Loaded handle integer ( int32 ) :: ierr !! Error code ierr = dlclose ( handle ) if ( ierr /= 0 ) then call dl_error ( \"Failed to unload library\" ) endif end subroutine unload_library function dynamic_load ( name , symbol_names , handle , symbols ) result ( error_code ) !! Dynamically loads library and its symbols character ( len =* ), intent ( in ) :: name !! Name of library to load type ( string ), intent ( in ) :: symbol_names (:) !! Names of functions to load type ( c_ptr ), intent ( out ) :: handle !! Loaded handle type ( c_funptr ), intent ( out ) :: symbols (:) !! Function pointers integer ( int32 ) :: error_code !! Error code integer ( int32 ) :: i !! Loop index error_code = DTFFT_SUCCESS handle = load_library ( name ) if ( is_null_ptr ( handle ) ) then error_code = DTFFT_ERROR_DLOPEN_FAILED return endif do i = 1 , size ( symbol_names ) symbols ( i ) = load_symbol ( handle , symbol_names ( i )% raw ) if ( is_null_ptr ( symbols ( i )) ) then call unload_library ( handle ) symbols ( 1 : i ) = c_null_funptr error_code = DTFFT_ERROR_DLSYM_FAILED return endif end do end function dynamic_load #endif function int8_to_string ( n ) result ( str ) !! Convert 8-bit integer to string integer ( int8 ), intent ( in ) :: n !! Integer to convert character ( len = :), allocatable :: str !! Resulting string character ( len = 3 ) :: temp !! Temporary string write ( temp , '(I3)' ) n allocate ( str , source = trim ( adjustl ( temp )) ) end function int8_to_string function int32_to_string ( n ) result ( str ) !! Convert 32-bit integer to string integer ( int32 ), intent ( in ) :: n !! Integer to convert character ( len = :), allocatable :: str !! Resulting string character ( len = 11 ) :: temp !! Temporary string write ( temp , '(I11)' ) n allocate ( str , source = trim ( adjustl ( temp )) ) end function int32_to_string function int64_to_string ( n ) result ( str ) !! Convert 64-bit integer to string integer ( int64 ), intent ( in ) :: n !! Integer to convert character ( len = :), allocatable :: str !! Resulting string character ( len = 20 ) :: temp !! Temporary string write ( temp , '(I20)' ) n allocate ( str , source = trim ( adjustl ( temp )) ) end function int64_to_string function double_to_string ( n ) result ( str ) !! Convert double to string real ( real64 ), intent ( in ) :: n !! Double to convert character ( len = :), allocatable :: str !! Resulting string character ( len = 23 ) :: temp !! Temporary string write ( temp , '(F15.5)' ) n allocate ( str , source = trim ( adjustl ( temp )) ) end function double_to_string function float_to_string ( n ) result ( str ) !! Convert double to string real ( real32 ), intent ( in ) :: n !! Double to convert character ( len = :), allocatable :: str !! Resulting string character ( len = 15 ) :: temp !! Temporary string write ( temp , '(F10.2)' ) n allocate ( str , source = trim ( adjustl ( temp )) ) end function float_to_string subroutine write_message ( unit , message , prefix ) !! Write message to the specified unit integer ( int32 ), intent ( in ) :: unit !! Unit number character ( len =* ), intent ( in ) :: message !! Message to write character ( len =* ), intent ( in ), optional :: prefix !! Prefix to the message character ( len = :), allocatable :: prefix_ !! Dummy prefix integer ( int32 ) :: comm_rank !! Size of world communicator integer ( int32 ) :: ierr !! Error code logical :: is_finalized !! Is MPI Already finalized? call MPI_Finalized ( is_finalized , ierr ) if ( is_finalized ) then comm_rank = 0 else call MPI_Comm_rank ( MPI_COMM_WORLD , comm_rank , ierr ) endif if ( comm_rank /= 0 ) return if ( present ( prefix ) ) then allocate ( prefix_ , source = prefix ) else allocate ( prefix_ , source = \"\" ) endif write ( unit , '(a)' ) prefix_ // trim ( message ) flush ( unit ) deallocate ( prefix_ ) end subroutine write_message elemental function get_inverse_kind ( r2r_kind ) result ( result_kind ) !! Get the inverse R2R kind of transform for the given R2R kind type ( dtfft_r2r_kind_t ), intent ( in ) :: r2r_kind !! R2R kind type ( dtfft_r2r_kind_t ) :: result_kind result_kind = dtfft_r2r_kind_t ( - 1 ) select case ( r2r_kind % val ) case ( DTFFT_DCT_1 % val ) result_kind = DTFFT_DCT_1 case ( DTFFT_DCT_2 % val ) result_kind = DTFFT_DCT_3 case ( DTFFT_DCT_3 % val ) result_kind = DTFFT_DCT_2 case ( DTFFT_DCT_4 % val ) result_kind = DTFFT_DCT_4 case ( DTFFT_DST_1 % val ) result_kind = DTFFT_DST_1 case ( DTFFT_DST_2 % val ) result_kind = DTFFT_DST_3 case ( DTFFT_DST_3 % val ) result_kind = DTFFT_DST_2 case ( DTFFT_DST_4 % val ) result_kind = DTFFT_DST_4 endselect end function get_inverse_kind elemental logical function is_null_ptr ( ptr ) !! Checks if pointer is NULL type ( c_ptr ), intent ( in ) :: ptr !! Pointer to check is_null_ptr = . not . c_associated ( ptr ) end function is_null_ptr #ifdef DTFFT_WITH_CUDA elemental logical function is_null_funptr ( ptr ) !! Checks if pointer is NULL type ( c_funptr ), intent ( in ) :: ptr !! Pointer to check is_null_funptr = . not . c_associated ( ptr ) end function is_null_funptr #endif elemental logical function is_same_ptr ( ptr1 , ptr2 ) !! Checks if two pointer are the same type ( c_ptr ), intent ( in ) :: ptr1 !! First pointer type ( c_ptr ), intent ( in ) :: ptr2 !! Second pointer is_same_ptr = c_associated ( ptr1 , ptr2 ) end function is_same_ptr #ifdef DTFFT_WITH_CUDA integer ( int32 ) function count_unique ( x ) result ( n ) !! Count the number of unique elements in the array integer ( int32 ), intent ( in ) :: x (:) !! Array of integers integer ( int32 ), allocatable :: y (:) !! Array of unique integers allocate ( y , source = x ) n = 0 do while ( size ( y ) > 0 ) n = n + 1 y = pack ( y , mask = ( y (:) /= y ( 1 ))) ! drops all elements that are ! equals to the 1st one (included) end do deallocate ( y ) end function count_unique #endif function mem_alloc_host ( alloc_size ) result ( ptr ) !! Allocates memory using C11 Standard alloc_align with 16 bytes alignment integer ( int64 ), intent ( in ) :: alloc_size !! Number of bytes to allocate type ( c_ptr ) :: ptr !! Pointer to allocate integer ( int64 ) :: displ , alloc_size_ displ = mod ( alloc_size , int ( ALLOC_ALIGNMENT , int64 )) alloc_size_ = alloc_size if ( displ > 0 ) then alloc_size_ = alloc_size_ + ( ALLOC_ALIGNMENT - displ ) endif ptr = aligned_alloc ( int ( ALLOC_ALIGNMENT , c_size_t ), alloc_size_ ) end function mem_alloc_host subroutine create_subcomm_include_all ( old_comm , new_comm ) !! Creates communicator including all processes from `old_comm` TYPE_MPI_COMM , intent ( in ) :: old_comm !! Communicator to create group from TYPE_MPI_COMM , intent ( out ) :: new_comm !! New communicator integer ( int32 ), allocatable :: ranks (:) integer ( int32 ) :: i , comm_size , ierr call MPI_Comm_size ( old_comm , comm_size , ierr ) allocate ( ranks ( 0 : comm_size - 1 )) do i = 0 , comm_size - 1_int32 ranks ( i ) = i enddo call create_subcomm ( old_comm , ranks , new_comm ) deallocate ( ranks ) end subroutine create_subcomm_include_all subroutine create_subcomm ( old_comm , processes , new_comm ) !! Creates communicator with selected processes from `old_comm` TYPE_MPI_COMM , intent ( in ) :: old_comm !! Communicator to create group from integer ( int32 ), intent ( in ) :: processes (:) !! Ranks of processes in `old_comm` to include in new group TYPE_MPI_COMM , intent ( out ) :: new_comm !! New communicator TYPE_MPI_GROUP :: group , new_group integer ( int32 ) :: ierr call MPI_Comm_group ( old_comm , group , ierr ) call MPI_Group_incl ( group , size ( processes ), processes , new_group , ierr ) call MPI_Comm_create ( old_comm , new_group , new_comm , ierr ) call MPI_Group_free ( group , ierr ) call MPI_Group_free ( new_group , ierr ) end subroutine create_subcomm #if defined(DTFFT_USE_MPI) ! Some bug was noticed in mpich for macos ! For some reason MPI_IN_PLACE has not been recognized. ! This is some stupid workaround subroutine all_reduce_inplace_i64 ( buffer , op , comm , ierr ) integer ( int64 ), intent ( inout ) :: buffer integer ( int32 ), intent ( in ) :: op , comm integer ( int32 ), intent ( out ) :: ierr integer ( int64 ) :: tmp call MPI_Allreduce ( buffer , tmp , 1 , MPI_INTEGER8 , op , comm , ierr ) buffer = tmp end subroutine all_reduce_inplace_i64 subroutine all_reduce_inplace_i32 ( buffer , op , comm , ierr ) integer ( int32 ), intent ( inout ) :: buffer integer ( int32 ), intent ( in ) :: op , comm integer ( int32 ), intent ( out ) :: ierr integer ( int32 ) :: tmp call MPI_Allreduce ( buffer , tmp , 1 , MPI_INTEGER4 , op , comm , ierr ) buffer = tmp end subroutine all_reduce_inplace_i32 #endif end module dtfft_utils","tags":"","loc":"sourcefile/dtfft_utils.f90.html"},{"title":"dtfft.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft.f90~~EfferentGraph sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_interface_mkl_native_m.f90 dtfft_interface_mkl_native_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_native_m.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft !! Main ``dtFFT`` module. Should be used in a Fortran program. use dtfft_config use dtfft_errors use dtfft_parameters use dtfft_pencil use dtfft_plan implicit none private public :: dtfft_get_version public :: DTFFT_VERSION_MAJOR public :: DTFFT_VERSION_MINOR public :: DTFFT_VERSION_PATCH ! Plans public :: dtfft_plan_t public :: dtfft_plan_c2c_t #ifndef DTFFT_TRANSPOSE_ONLY public :: dtfft_plan_r2c_t #endif public :: dtfft_plan_r2r_t public :: dtfft_request_t public :: dtfft_pencil_t public :: dtfft_get_error_string public :: dtfft_get_precision_string public :: dtfft_get_executor_string public :: dtfft_execute_t , dtfft_transpose_t public :: dtfft_executor_t , dtfft_effort_t public :: dtfft_precision_t , dtfft_r2r_kind_t public :: operator ( == ) public :: operator ( /= ) ! Execute types public :: DTFFT_EXECUTE_FORWARD , & DTFFT_EXECUTE_BACKWARD ! Transpose types public :: DTFFT_TRANSPOSE_X_TO_Y , & DTFFT_TRANSPOSE_Y_TO_X , & DTFFT_TRANSPOSE_Y_TO_Z , & DTFFT_TRANSPOSE_Z_TO_Y , & DTFFT_TRANSPOSE_X_TO_Z , & DTFFT_TRANSPOSE_Z_TO_X ! 1d FFT External Executor types public :: DTFFT_EXECUTOR_NONE public :: DTFFT_EXECUTOR_FFTW3 public :: DTFFT_EXECUTOR_MKL public :: DTFFT_EXECUTOR_CUFFT public :: DTFFT_EXECUTOR_VKFFT ! Effort flags public :: DTFFT_ESTIMATE , & DTFFT_MEASURE , & DTFFT_PATIENT ! Precision flags public :: DTFFT_SINGLE , & DTFFT_DOUBLE ! Types of R2R Transform public :: DTFFT_DCT_1 , & DTFFT_DCT_2 , & DTFFT_DCT_3 , & DTFFT_DCT_4 , & DTFFT_DST_1 , & DTFFT_DST_2 , & DTFFT_DST_3 , & DTFFT_DST_4 public :: DTFFT_SUCCESS public :: DTFFT_ERROR_MPI_FINALIZED public :: DTFFT_ERROR_PLAN_NOT_CREATED public :: DTFFT_ERROR_INVALID_TRANSPOSE_TYPE public :: DTFFT_ERROR_INVALID_N_DIMENSIONS public :: DTFFT_ERROR_INVALID_DIMENSION_SIZE public :: DTFFT_ERROR_INVALID_COMM_TYPE public :: DTFFT_ERROR_INVALID_PRECISION public :: DTFFT_ERROR_INVALID_EFFORT public :: DTFFT_ERROR_INVALID_EXECUTOR public :: DTFFT_ERROR_INVALID_COMM_DIMS public :: DTFFT_ERROR_INVALID_COMM_FAST_DIM public :: DTFFT_ERROR_MISSING_R2R_KINDS public :: DTFFT_ERROR_INVALID_R2R_KINDS public :: DTFFT_ERROR_R2C_TRANSPOSE_PLAN public :: DTFFT_ERROR_INPLACE_TRANSPOSE public :: DTFFT_ERROR_INVALID_AUX public :: DTFFT_ERROR_INVALID_DIM public :: DTFFT_ERROR_INVALID_USAGE public :: DTFFT_ERROR_PLAN_IS_CREATED public :: DTFFT_ERROR_ALLOC_FAILED public :: DTFFT_ERROR_FREE_FAILED public :: DTFFT_ERROR_INVALID_ALLOC_BYTES public :: DTFFT_ERROR_DLOPEN_FAILED public :: DTFFT_ERROR_DLSYM_FAILED public :: DTFFT_ERROR_R2C_TRANSPOSE_CALLED public :: DTFFT_ERROR_PENCIL_ARRAYS_SIZE_MISMATCH public :: DTFFT_ERROR_PENCIL_ARRAYS_INVALID_SIZES public :: DTFFT_ERROR_PENCIL_INVALID_COUNTS public :: DTFFT_ERROR_PENCIL_INVALID_STARTS public :: DTFFT_ERROR_PENCIL_SHAPE_MISMATCH public :: DTFFT_ERROR_PENCIL_OVERLAP public :: DTFFT_ERROR_PENCIL_NOT_CONTINUOUS public :: DTFFT_ERROR_PENCIL_NOT_INITIALIZED public :: DTFFT_ERROR_INVALID_MEASURE_WARMUP_ITERS public :: DTFFT_ERROR_INVALID_MEASURE_ITERS public :: DTFFT_ERROR_INVALID_REQUEST public :: DTFFT_ERROR_TRANSPOSE_ACTIVE public :: DTFFT_ERROR_TRANSPOSE_NOT_ACTIVE public :: DTFFT_ERROR_R2R_FFT_NOT_SUPPORTED public :: DTFFT_ERROR_GPU_INVALID_STREAM public :: DTFFT_ERROR_INVALID_BACKEND public :: DTFFT_ERROR_GPU_NOT_SET public :: DTFFT_ERROR_VKFFT_R2R_2D_PLAN public :: DTFFT_ERROR_BACKENDS_DISABLED public :: DTFFT_ERROR_NOT_DEVICE_PTR public :: DTFFT_ERROR_NOT_NVSHMEM_PTR public :: DTFFT_ERROR_INVALID_PLATFORM public :: DTFFT_ERROR_INVALID_PLATFORM_EXECUTOR public :: DTFFT_ERROR_INVALID_PLATFORM_BACKEND public :: dtfft_config_t public :: dtfft_create_config , dtfft_set_config public :: DTFFT_BACKEND_MPI_DATATYPE public :: DTFFT_BACKEND_MPI_P2P public :: DTFFT_BACKEND_MPI_P2P_PIPELINED public :: DTFFT_BACKEND_MPI_A2A public :: DTFFT_BACKEND_MPI_RMA public :: DTFFT_BACKEND_MPI_RMA_PIPELINED public :: dtfft_backend_t public :: dtfft_get_backend_string #ifdef DTFFT_WITH_CUDA public :: dtfft_stream_t , dtfft_get_cuda_stream public :: dtfft_platform_t public :: DTFFT_PLATFORM_HOST , DTFFT_PLATFORM_CUDA public :: DTFFT_BACKEND_NCCL public :: DTFFT_BACKEND_NCCL_PIPELINED public :: DTFFT_BACKEND_CUFFTMP public :: DTFFT_BACKEND_CUFFTMP_PIPELINED #endif end module dtfft","tags":"","loc":"sourcefile/dtfft.f90.html"},{"title":"dtfft_kernel_device.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_kernel_device.f90~~EfferentGraph sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_kernel_device.f90~~AfferentGraph sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_kernel_device !! This module defines [[kernel_device]] type and its type bound procedures. !! It extends [[abstract_kernel]] type and implements its type bound procedures. use iso_c_binding use iso_fortran_env use dtfft_abstract_kernel use dtfft_config use dtfft_interface_cuda , only : MAX_KERNEL_ARGS , dim3 , CUfunction , cuLaunchKernel use dtfft_interface_cuda_runtime use dtfft_nvrtc_block_optimizer , only : N_CANDIDATES , & kernel_config , & generate_candidates , & evaluate_analytical_performance , & sort_candidates_by_score use dtfft_nvrtc_module_cache use dtfft_parameters use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_cuda.h\" #include \"_dtfft_profile.h\" #include \"_dtfft_private.h\" implicit none private public :: kernel_device integer ( int32 ), parameter , public :: DEF_TILE_SIZE = 32 !! Default tile size type , extends ( abstract_kernel ) :: kernel_device !! Device kernel class private type ( kernel_type_t ) :: internal_kernel_type !! Actual kernel type used for execution, can be different from `kernel_type` type ( CUfunction ) :: cuda_kernel !! Pointer to CUDA kernel. integer ( int32 ) :: tile_size !! Tile size used for this kernel integer ( int32 ) :: block_rows !! Number of rows in each block processed by each thread integer ( int64 ) :: copy_bytes !! Number of bytes to copy for `KERNEL_UNPACK_SIMPLE_COPY` kernel contains procedure :: create_private => create !! Creates kernel procedure :: execute_private => execute !! Executes kernel procedure :: destroy_private => destroy !! Destroys kernel end type kernel_device contains subroutine create ( self , effort , base_storage , force_effort ) !! Creates kernel class ( kernel_device ), intent ( inout ) :: self !! Device kernel class type ( dtfft_effort_t ), intent ( in ) :: effort !! Effort level for generating transpose kernels integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element logical , optional , intent ( in ) :: force_effort !! Should effort be forced or not type ( device_props ) :: props !! GPU architecture properties integer ( int32 ) :: device_id !! Device ID call self % destroy () if ( self % kernel_type == KERNEL_UNPACK_SIMPLE_COPY ) then self % is_created = . true . self % copy_bytes = base_storage * product ( self % dims ) return endif self % internal_kernel_type = self % kernel_type if ( self % kernel_type == KERNEL_UNPACK ) & self % internal_kernel_type = KERNEL_UNPACK_PIPELINED if ( self % kernel_type == KERNEL_PERMUTE_BACKWARD_END ) & self % internal_kernel_type = KERNEL_PERMUTE_BACKWARD_END_PIPELINED CUDA_CALL ( cudaGetDevice ( device_id ) ) call get_device_props ( device_id , props ) if ( allocated ( self % neighbor_data ) ) then call get_kernel ( self % dims , self % internal_kernel_type , effort , base_storage , props , & self % tile_size , self % block_rows , self % cuda_kernel , force_effort = force_effort , neighbor_data = self % neighbor_data (:, 1 )) else call get_kernel ( self % dims , self % internal_kernel_type , effort , base_storage , props , & self % tile_size , self % block_rows , self % cuda_kernel , force_effort = force_effort ) endif end subroutine create subroutine execute ( self , in , out , stream , neighbor ) !! Executes kernel on stream class ( kernel_device ), intent ( inout ) :: self !! Device kernel class real ( real32 ), target , intent ( in ) :: in (:) !! Device pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Device pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to execute on integer ( int32 ), optional , intent ( in ) :: neighbor !! Source rank for pipelined unpacking integer ( int32 ) :: nargs , neighbor_count , n integer ( int32 ) :: args ( MAX_KERNEL_ARGS ) type ( dim3 ) :: blocks , threads if ( self % kernel_type == KERNEL_UNPACK_SIMPLE_COPY ) then CUDA_CALL ( cudaMemcpyAsync ( c_loc ( out ), c_loc ( in ), self % copy_bytes , cudaMemcpyDeviceToDevice , stream ) ) #ifdef DTFFT_DEBUG CUDA_CALL ( cudaStreamSynchronize ( stream ) ) #endif return endif if ( any ( self % kernel_type == [ KERNEL_PERMUTE_FORWARD , KERNEL_PERMUTE_BACKWARD , KERNEL_PERMUTE_BACKWARD_START ]) ) then call get_kernel_launch_params ( self % kernel_type , self % dims , self % tile_size , self % block_rows , blocks , threads ) call get_kernel_args ( self % kernel_type , self % dims , nargs , args ) CUDA_CALL ( cuLaunchKernel ( self % cuda_kernel , c_loc ( in ), c_loc ( out ), blocks , threads , stream , nargs , args ) ) #ifdef DTFFT_DEBUG CUDA_CALL ( cudaStreamSynchronize ( stream ) ) #endif return endif if ( any ( self % kernel_type == [ KERNEL_UNPACK_PIPELINED , KERNEL_PERMUTE_BACKWARD_END_PIPELINED ]) ) then call get_kernel_launch_params ( self % kernel_type , self % neighbor_data ( 1 : 3 , neighbor ), self % tile_size , self % block_rows , blocks , threads ) call get_kernel_args ( self % kernel_type , self % dims , nargs , args , self % neighbor_data (:, neighbor )) CUDA_CALL ( cuLaunchKernel ( self % cuda_kernel , c_loc ( in ), c_loc ( out ), blocks , threads , stream , nargs , args ) ) #ifdef DTFFT_DEBUG CUDA_CALL ( cudaStreamSynchronize ( stream ) ) #endif return endif neighbor_count = size ( self % neighbor_data , dim = 2 ) do n = 1 , neighbor_count call get_kernel_launch_params ( self % internal_kernel_type , self % neighbor_data ( 1 : 3 , n ), self % tile_size , self % block_rows , blocks , threads ) call get_kernel_args ( self % internal_kernel_type , self % dims , nargs , args , self % neighbor_data (:, n )) CUDA_CALL ( cuLaunchKernel ( self % cuda_kernel , c_loc ( in ), c_loc ( out ), blocks , threads , stream , nargs , args ) ) #ifdef DTFFT_DEBUG CUDA_CALL ( cudaStreamSynchronize ( stream ) ) #endif enddo end subroutine execute subroutine destroy ( self ) !! Destroys kernel class ( kernel_device ), intent ( inout ) :: self !! Device kernel class if ( . not . self % is_created ) return if ( self % is_dummy . or . self % kernel_type == KERNEL_UNPACK_SIMPLE_COPY ) return end subroutine destroy subroutine get_kernel_args ( kernel_type , dims , nargs , args , neighbor_data ) !! Populates kernel arguments based on kernel type type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel integer ( int32 ), intent ( in ) :: dims (:) !! Local dimensions to process integer ( int32 ), intent ( out ) :: nargs !! Number of arguments set by this subroutine integer ( int32 ), intent ( out ) :: args ( MAX_KERNEL_ARGS ) !! Kernel arguments integer ( int32 ), optional , intent ( in ) :: neighbor_data (:) !! Neighbor data for pipelined kernels nargs = 0 nargs = nargs + 1 ; args ( nargs ) = dims ( 1 ) nargs = nargs + 1 ; args ( nargs ) = dims ( 2 ) if ( kernel_type == KERNEL_UNPACK_PIPELINED ) then nargs = nargs + 1 ; args ( nargs ) = neighbor_data ( 1 ) nargs = nargs + 1 ; args ( nargs ) = neighbor_data ( 2 ) nargs = nargs + 1 ; args ( nargs ) = neighbor_data ( 4 ) nargs = nargs + 1 ; args ( nargs ) = neighbor_data ( 5 ) endif if ( size ( dims ) == 2 . or . kernel_type == KERNEL_UNPACK_PIPELINED ) return if ( any ( kernel_type == [ KERNEL_PERMUTE_FORWARD , KERNEL_PERMUTE_BACKWARD , KERNEL_PERMUTE_BACKWARD_START ]) ) then nargs = nargs + 1 ; args ( nargs ) = dims ( 3 ) return endif nargs = nargs + 1 ; args ( nargs ) = neighbor_data ( 1 ) nargs = nargs + 1 ; args ( nargs ) = neighbor_data ( 2 ) nargs = nargs + 1 ; args ( nargs ) = neighbor_data ( 3 ) nargs = nargs + 1 ; args ( nargs ) = neighbor_data ( 4 ) nargs = nargs + 1 ; args ( nargs ) = neighbor_data ( 5 ) end subroutine get_kernel_args subroutine get_kernel_launch_params ( kernel_type , dims , tile_size , block_rows , blocks , threads ) !! Computes kernel launch parameters based on kernel type and dimensions type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel integer ( int32 ), intent ( in ) :: dims (:) !! Local dimensions to process integer ( int32 ), intent ( in ) :: tile_size !! Size of the tile in shared memory integer ( int32 ), intent ( in ) :: block_rows !! Number of rows in each block type ( dim3 ), intent ( out ) :: blocks !! Number of blocks to launch type ( dim3 ), intent ( out ) :: threads !! Number of threads per block integer ( int32 ) :: tile_dim , other_dim threads % x = tile_size threads % y = block_rows threads % z = 1 if ( any ( kernel_type == [ KERNEL_PERMUTE_FORWARD , KERNEL_PERMUTE_BACKWARD_END_PIPELINED , KERNEL_UNPACK_PIPELINED ]) ) then tile_dim = 2 other_dim = 3 else ! KERNEL_PERMUTE_BACKWARD_START or KERNEL_PERMUTE_BACKWARD tile_dim = 3 other_dim = 2 endif blocks % x = ( dims ( 1 ) + tile_size - 1 ) / tile_size blocks % y = ( dims ( tile_dim ) + tile_size - 1 ) / tile_size if ( size ( dims ) == 2 ) then blocks % z = 1 else blocks % z = dims ( other_dim ) endif end subroutine get_kernel_launch_params subroutine get_kernel ( dims , kernel_type , effort , base_storage , props , tile_size , block_rows , kernel , force_effort , neighbor_data ) !! Compiles kernel and caches it. Returns compiled kernel. integer ( int32 ), intent ( in ) :: dims (:) !! Local dimensions to process type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel to build type ( dtfft_effort_t ), intent ( in ) :: effort !! How thoroughly `dtFFT` searches for the optimal transpose kernel integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( device_props ), intent ( in ) :: props !! GPU architecture properties integer ( int32 ), intent ( out ) :: tile_size !! Size of the tile in shared memory integer ( int32 ), intent ( out ) :: block_rows !! Number of rows in each block processed by each thread type ( CUfunction ), intent ( out ) :: kernel !! Compiled kernel to return logical , optional , intent ( in ) :: force_effort !! Should effort be forced or not integer ( int32 ), optional , intent ( in ) :: neighbor_data (:) !! Neighbor data for pipelined kernels type ( kernel_config ) :: candidates ( N_CANDIDATES ) !! Candidate kernel configurations type ( kernel_config ) :: config !! Current candidate integer ( int32 ) :: num_candidates !! Number of candidate configurations generated integer ( int32 ) :: i !! Loop index real ( real32 ), allocatable :: scores (:) !! Scores for each candidate configuration integer ( int32 ), allocatable :: sorted (:) !! Sorted indices of candidate configurations integer ( int32 ) :: tile_dim !! Tile dimension integer ( int32 ) :: other_dim !! Dimension that is not part of shared memory integer ( int32 ) :: fixed_dims ( 3 ) !! Dimensions fixed to the shared memory integer ( int32 ) :: ndims !! Number of dimensions integer ( int32 ) :: test_size !! Number of test configurations to run integer ( int32 ) :: test_id !! Current test configuration ID integer ( int32 ) :: iter !! Loop index integer ( int32 ) :: best_kernel_id !! Best kernel configuration ID type ( c_ptr ) :: in !! Input buffer type ( c_ptr ) :: out !! Output buffer type ( dim3 ) :: blocks !! Blocks configuration type ( dim3 ) :: threads !! Threads configuration type ( cudaEvent ) :: timer_start !! Timer start event type ( cudaEvent ) :: timer_stop !! Timer stop event real ( real32 ) :: execution_time !! Execution time real ( real32 ) :: best_time !! Best execution time type ( dtfft_stream_t ) :: stream !! CUDA stream for kernel execution real ( real32 ) :: bandwidth !! Bandwidth for kernel execution integer ( int32 ) :: n_iters !! Number of iterations to perform when testing kernel integer ( int32 ) :: n_warmup_iters !! Number of warmup iterations to perform before testing kernel logical :: force_effort_ !! Should effort be forced or not character ( len = :), allocatable :: global_phase !! Global phase name for profiling character ( len = :), allocatable :: local_phase !! Local phase name for profiling integer ( int32 ) :: nargs !! Number of kernel arguments integer ( int32 ) :: args ( MAX_KERNEL_ARGS ) !! Kernel arguments if ( any ( kernel_type == [ KERNEL_PERMUTE_FORWARD , KERNEL_PERMUTE_BACKWARD_END_PIPELINED , KERNEL_UNPACK_PIPELINED ]) ) then tile_dim = 2 other_dim = 3 else ! KERNEL_PERMUTE_BACKWARD_START or KERNEL_PERMUTE_BACKWARD tile_dim = 3 other_dim = 2 endif ndims = size ( dims ) fixed_dims (:) = 1 fixed_dims ( 1 : ndims ) = dims ( 1 : ndims ) if ( is_unpack_kernel ( kernel_type ) ) fixed_dims ( 1 : ndims ) = neighbor_data ( 1 : ndims ) call generate_candidates ( fixed_dims , tile_dim , other_dim , base_storage , props , candidates , num_candidates ) allocate ( scores ( num_candidates ), sorted ( num_candidates )) do i = 1 , num_candidates scores ( i ) = evaluate_analytical_performance ( fixed_dims , tile_dim , other_dim , kernel_type , candidates ( i ), props , base_storage , neighbor_data ) enddo call sort_candidates_by_score ( scores , num_candidates , sorted ) call create_nvrtc_module ( ndims , kernel_type , base_storage , candidates ( 1 : num_candidates ), props ) force_effort_ = . false .; if ( present ( force_effort ) ) force_effort_ = force_effort if ( ( effort == DTFFT_ESTIMATE . and . force_effort_ ) . or . & . not . ( ( effort == DTFFT_PATIENT . and . get_conf_kernel_optimization_enabled ()) . or . get_conf_forced_kernel_optimization ()) ) then config = candidates ( sorted ( 1 )) tile_size = config % tile_size block_rows = config % block_rows kernel = get_kernel_instance ( ndims , kernel_type , base_storage , tile_size , block_rows ) deallocate ( scores , sorted ) return endif CUDA_CALL ( cudaMalloc ( in , base_storage * product ( dims )) ) CUDA_CALL ( cudaMalloc ( out , base_storage * product ( dims )) ) CUDA_CALL ( cudaEventCreate ( timer_start ) ) CUDA_CALL ( cudaEventCreate ( timer_stop ) ) stream = get_conf_stream () global_phase = \"Testing nvRTC kernel: '\" // get_kernel_string ( kernel_type ) // \"' perfomances...\" PHASE_BEGIN ( global_phase , COLOR_AUTOTUNE ) WRITE_INFO ( global_phase ) n_warmup_iters = get_conf_measure_warmup_iters () n_iters = get_conf_measure_iters () best_time = MAX_REAL32 test_size = get_conf_configs_to_test () if ( test_size > num_candidates ) test_size = num_candidates do test_id = 1 , test_size config = candidates ( sorted ( test_id )) tile_size = config % tile_size block_rows = config % block_rows call get_kernel_launch_params ( kernel_type , fixed_dims , tile_size , block_rows , blocks , threads ) call get_kernel_args ( kernel_type , dims , nargs , args , neighbor_data ) kernel = get_kernel_instance ( ndims , kernel_type , base_storage , tile_size , block_rows ) local_phase = \"Testing block: \" // to_str ( tile_size ) // \"x\" // to_str ( block_rows ) REGION_BEGIN ( local_phase , COLOR_AUTOTUNE2 ) WRITE_INFO ( \"    \" // local_phase ) REGION_BEGIN ( \"Warmup\" , COLOR_TRANSPOSE ) do iter = 1 , n_warmup_iters CUDA_CALL ( cuLaunchKernel ( kernel , in , out , blocks , threads , stream , nargs , args ) ) enddo CUDA_CALL ( cudaStreamSynchronize ( stream ) ) REGION_END ( \"Warmup\" ) REGION_BEGIN ( \"Measure\" , COLOR_EXECUTE ) CUDA_CALL ( cudaEventRecord ( timer_start , stream ) ) do iter = 1 , n_iters CUDA_CALL ( cuLaunchKernel ( kernel , in , out , blocks , threads , stream , nargs , args ) ) enddo CUDA_CALL ( cudaEventRecord ( timer_stop , stream ) ) CUDA_CALL ( cudaEventSynchronize ( timer_stop ) ) REGION_END ( \"Measure\" ) CUDA_CALL ( cudaEventElapsedTime ( execution_time , timer_start , timer_stop ) ) execution_time = execution_time / real ( n_iters , real32 ) bandwidth = 2.0 * 100 0.0 * real ( base_storage * product ( fixed_dims ), real32 ) / real ( 1024 * 1024 * 1024 , real32 ) / execution_time WRITE_INFO ( \"        Average execution time = \" // to_str ( real ( execution_time , real64 )) // \" [ms]\" ) WRITE_INFO ( \"        Bandwidth = \" // to_str ( bandwidth ) // \" [GB/s]\" ) if ( execution_time < best_time ) then best_time = execution_time best_kernel_id = test_id endif REGION_END ( local_phase ) enddo config = candidates ( sorted ( best_kernel_id )) PHASE_END ( global_phase ) tile_size = config % tile_size block_rows = config % block_rows kernel = get_kernel_instance ( ndims , kernel_type , base_storage , tile_size , block_rows ) WRITE_INFO ( \"  Best configuration is: \" // to_str ( tile_size ) // \"x\" // to_str ( block_rows )) CUDA_CALL ( cudaEventDestroy ( timer_start ) ) CUDA_CALL ( cudaEventDestroy ( timer_stop ) ) CUDA_CALL ( cudaFree ( in ) ) CUDA_CALL ( cudaFree ( out ) ) deallocate ( scores , sorted ) deallocate ( global_phase , local_phase ) end subroutine get_kernel end module dtfft_kernel_device","tags":"","loc":"sourcefile/dtfft_kernel_device.f90.html"},{"title":"dtfft_interface_cuda_runtime.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_cuda_runtime.f90~~EfferentGraph sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_cuda_runtime.f90~~AfferentGraph sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_cuda_runtime !! CUDA Runtime Interfaces use iso_c_binding use dtfft_parameters , only : dtfft_stream_t use dtfft_utils , only : string_c2f implicit none private public :: cudaGetErrorString public :: cudaSuccess , cudaErrorNotReady enum , bind ( c ) enumerator :: cudaSuccess = 0 enumerator :: cudaErrorInvalidValue = 1 enumerator :: cudaErrorMemoryAllocation = 2 enumerator :: cudaErrorInitializationError = 3 enumerator :: cudaErrorCudartUnloading = 4 enumerator :: cudaErrorProfilerDisabled = 5 enumerator :: cudaErrorProfilerNotInitialized = 6 enumerator :: cudaErrorProfilerAlreadyStarted = 7 enumerator :: cudaErrorProfilerAlreadyStopped = 8 enumerator :: cudaErrorInvalidConfiguration = 9 enumerator :: cudaErrorInvalidPitchValue = 12 enumerator :: cudaErrorInvalidSymbol = 13 enumerator :: cudaErrorInvalidHostPointer = 16 enumerator :: cudaErrorInvalidDevicePointer = 17 enumerator :: cudaErrorInvalidTexture = 18 enumerator :: cudaErrorInvalidTextureBinding = 19 enumerator :: cudaErrorInvalidChannelDescriptor = 20 enumerator :: cudaErrorInvalidMemcpyDirection = 21 enumerator :: cudaErrorAddressOfConstant = 22 enumerator :: cudaErrorTextureFetchFailed = 23 enumerator :: cudaErrorTextureNotBound = 24 enumerator :: cudaErrorSynchronizationError = 25 enumerator :: cudaErrorInvalidFilterSetting = 26 enumerator :: cudaErrorInvalidNormSetting = 27 enumerator :: cudaErrorMixedDeviceExecution = 28 enumerator :: cudaErrorNotYetImplemented = 31 enumerator :: cudaErrorMemoryValueTooLarge = 32 enumerator :: cudaErrorInsufficientDriver = 35 enumerator :: cudaErrorInvalidSurface = 37 enumerator :: cudaErrorDuplicateVariableName = 43 enumerator :: cudaErrorDuplicateTextureName = 44 enumerator :: cudaErrorDuplicateSurfaceName = 45 enumerator :: cudaErrorDevicesUnavailable = 46 enumerator :: cudaErrorIncompatibleDriverContext = 49 enumerator :: cudaErrorMissingConfiguration = 52 enumerator :: cudaErrorPriorLaunchFailure = 53 enumerator :: cudaErrorLaunchMaxDepthExceeded = 65 enumerator :: cudaErrorLaunchFileScopedTex = 66 enumerator :: cudaErrorLaunchFileScopedSurf = 67 enumerator :: cudaErrorSyncDepthExceeded = 68 enumerator :: cudaErrorLaunchPendingCountExceeded = 69 enumerator :: cudaErrorInvalidDeviceFunction = 98 enumerator :: cudaErrorNoDevice = 100 enumerator :: cudaErrorInvalidDevice = 101 enumerator :: cudaErrorStartupFailure = 127 enumerator :: cudaErrorInvalidKernelImage = 200 enumerator :: cudaErrorDeviceUninitialized = 201 enumerator :: cudaErrorMapBufferObjectFailed = 205 enumerator :: cudaErrorUnmapBufferObjectFailed = 206 enumerator :: cudaErrorArrayIsMapped = 207 enumerator :: cudaErrorAlreadyMapped = 208 enumerator :: cudaErrorNoKernelImageForDevice = 209 enumerator :: cudaErrorAlreadyAcquired = 210 enumerator :: cudaErrorNotMapped = 211 enumerator :: cudaErrorNotMappedAsArray = 212 enumerator :: cudaErrorNotMappedAsPointer = 213 enumerator :: cudaErrorECCUncorrectable = 214 enumerator :: cudaErrorUnsupportedLimit = 215 enumerator :: cudaErrorDeviceAlreadyInUse = 216 enumerator :: cudaErrorPeerAccessUnsupported = 217 enumerator :: cudaErrorInvalidPtx = 218 enumerator :: cudaErrorInvalidGraphicsContext = 219 enumerator :: cudaErrorNvlinkUncorrectable = 220 enumerator :: cudaErrorJitCompilerNotFound = 221 enumerator :: cudaErrorInvalidSource = 300 enumerator :: cudaErrorFileNotFound = 301 enumerator :: cudaErrorSharedObjectSymbolNotFound = 302 enumerator :: cudaErrorSharedObjectInitFailed = 303 enumerator :: cudaErrorOperatingSystem = 304 enumerator :: cudaErrorInvalidResourceHandle = 400 enumerator :: cudaErrorIllegalState = 401 enumerator :: cudaErrorSymbolNotFound = 500 enumerator :: cudaErrorNotReady = 600 enumerator :: cudaErrorIllegalAddress = 700 enumerator :: cudaErrorLaunchOutOfResources = 701 enumerator :: cudaErrorLaunchTimeout = 702 enumerator :: cudaErrorLaunchIncompatibleTexturing = 703 enumerator :: cudaErrorPeerAccessAlreadyEnabled = 704 enumerator :: cudaErrorPeerAccessNotEnabled = 705 enumerator :: cudaErrorSetOnActiveProcess = 708 enumerator :: cudaErrorContextIsDestroyed = 709 enumerator :: cudaErrorAssert = 710 enumerator :: cudaErrorTooManyPeers = 711 enumerator :: cudaErrorHostMemoryAlreadyRegistered = 712 enumerator :: cudaErrorHostMemoryNotRegistered = 713 enumerator :: cudaErrorHardwareStackError = 714 enumerator :: cudaErrorIllegalInstruction = 715 enumerator :: cudaErrorMisalignedAddress = 716 enumerator :: cudaErrorInvalidAddressSpace = 717 enumerator :: cudaErrorInvalidPc = 718 enumerator :: cudaErrorLaunchFailure = 719 enumerator :: cudaErrorCooperativeLaunchTooLarge = 720 enumerator :: cudaErrorNotPermitted = 800 enumerator :: cudaErrorNotSupported = 801 enumerator :: cudaErrorSystemNotReady = 802 enumerator :: cudaErrorSystemDriverMismatch = 803 enumerator :: cudaErrorCompatNotSupportedOnDevice = 804 enumerator :: cudaErrorStreamCaptureUnsupported = 900 enumerator :: cudaErrorStreamCaptureInvalidated = 901 enumerator :: cudaErrorStreamCaptureMerge = 902 enumerator :: cudaErrorStreamCaptureUnmatched = 903 enumerator :: cudaErrorStreamCaptureUnjoined = 904 enumerator :: cudaErrorStreamCaptureIsolation = 905 enumerator :: cudaErrorStreamCaptureImplicit = 906 enumerator :: cudaErrorCapturedEvent = 907 enumerator :: cudaErrorStreamCaptureWrongThread = 908 enumerator :: cudaErrorTimeout = 909 enumerator :: cudaErrorGraphExecUpdateFailure = 910 enumerator :: cudaErrorUnknown = 999 enumerator :: cudaErrorApiFailureBase = 10000 end enum public :: cudaMemcpyHostToHost , & cudaMemcpyHostToDevice , & cudaMemcpyDeviceToHost , & cudaMemcpyDeviceToDevice , & cudaMemcpyDefault enum , bind ( C ) enumerator :: cudaMemcpyHostToHost = 0 enumerator :: cudaMemcpyHostToDevice = 1 enumerator :: cudaMemcpyDeviceToHost = 2 enumerator :: cudaMemcpyDeviceToDevice = 3 enumerator :: cudaMemcpyDefault = 4 end enum public :: cudaEvent type , bind ( C ) :: cudaEvent !! CUDA event types type ( c_ptr ) :: event !! Handle end type cudaEvent integer ( c_int ), parameter , public :: cudaEventDisableTiming = 2 public :: cudaStreamQuery interface function cudaStreamQuery ( stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamQuery\" ) !! Queries an asynchronous stream for completion status. import type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if all operations in stream have completed, !! or `cudaErrorNotReady` if not. end function cudaStreamQuery endinterface public :: cudaStreamCreate interface function cudaStreamCreate ( stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamCreate\" ) !! Creates an asynchronous stream. import type ( dtfft_stream_t ) :: stream !! Pointer to the created stream integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the stream was created successfully, !! or an error code if there was an issue. end function cudaStreamCreate end interface public :: cudaStreamDestroy interface function cudaStreamDestroy ( stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamDestroy\" ) !! Destroys an asynchronous stream. import type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the stream was destroyed successfully, !! or an error code if there was an issue. end function cudaStreamDestroy end interface public :: cudaStreamSynchronize interface function cudaStreamSynchronize ( stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamSynchronize\" ) !! Waits for stream tasks to complete. import type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the stream tasks completed successfully, !! or an error code if there was an issue. end function cudaStreamSynchronize end interface interface function cudaGetErrorString_c ( errcode ) & result ( string ) & bind ( C , name = \"cudaGetErrorString\" ) !! Returns the string representation of an error code. import integer ( c_int ), value :: errcode !! Error code type ( c_ptr ) :: string !! Pointer to the error string end function cudaGetErrorString_c end interface public :: cudaMalloc interface function cudaMalloc ( ptr , count ) & result ( cudaError_t ) & bind ( C , name = \"cudaMalloc\" ) !! Allocates memory on the device. import type ( c_ptr ) :: ptr !! Pointer to allocated device memory integer ( c_size_t ), value :: count !! Requested allocation size in bytes integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if memory was allocated successfully, !! or `cudaErrorMemoryAllocation` if the memory could not be allocated. end function cudaMalloc end interface public :: cudaFree interface function cudaFree ( ptr ) & result ( cudaError_t ) & bind ( C , name = \"cudaFree\" ) !! Frees memory on the device. import type ( c_ptr ), value :: ptr !! Pointer to memory to free integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if memory was freed successfully, !! or an error code if there was an issue. end function cudaFree end interface public :: cudaMemset interface function cudaMemset ( ptr , val , count ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemset\" ) !! Initializes or sets device memory to a value. import type ( c_ptr ), value :: ptr !! Pointer to device memory integer ( c_int ), value :: val !! Value to set integer ( c_size_t ), value :: count !! Size in bytes to set integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the memory was set successfully, !! or an error code if there was an issue. end function cudaMemset end interface public :: cudaEventCreateWithFlags interface function cudaEventCreateWithFlags ( event , flags ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventCreateWithFlags\" ) !! Creates an event with the specified flags. import type ( cudaEvent ) :: event !! Event identifier integer ( c_int ), value :: flags !! Flags for event creation integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event was created successfully, !! or an error code if there was an issue. end function cudaEventCreateWithFlags end interface public :: cudaEventRecord interface function cudaEventRecord ( event , stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventRecord\" ) !! Records an event in a stream. import type ( cudaEvent ), value :: event !! Event identifier type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event was recorded successfully, !! or an error code if there was an issue. end function cudaEventRecord end interface public :: cudaStreamWaitEvent interface function cudaStreamWaitEvent ( stream , event , flags ) & result ( cudaError_t ) & bind ( C , name = \"cudaStreamWaitEvent\" ) !! Makes a stream wait on an event. import type ( dtfft_stream_t ), value :: stream !! Stream identifier type ( cudaEvent ), value :: event !! Event identifier integer ( c_int ), value :: flags !! Flags for the wait operation integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the stream is waiting successfully, !! or an error code if there was an issue. end function cudaStreamWaitEvent end interface public :: cudaEventDestroy interface function cudaEventDestroy ( event ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventDestroy\" ) !! Destroys an event. import type ( cudaEvent ), value :: event !! Event identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event was destroyed successfully, !! or an error code if there was an issue. end function cudaEventDestroy end interface public :: cudaEventCreate interface function cudaEventCreate ( event ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventCreate\" ) !! Creates an event. import type ( cudaEvent ) :: event !! Event identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event was created successfully, !! or an error code if there was an issue. end function cudaEventCreate end interface public :: cudaEventSynchronize interface function cudaEventSynchronize ( event ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventSynchronize\" ) !! Waits for an event to complete. import type ( cudaEvent ), value :: event !! Event identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the event completed successfully, !! or an error code if there was an issue. end function cudaEventSynchronize end interface public :: cudaEventElapsedTime interface function cudaEventElapsedTime ( time , start , end ) & result ( cudaError_t ) & bind ( C , name = \"cudaEventElapsedTime\" ) !! Computes the elapsed time between two events. import real ( c_float ) :: time !! Elapsed time in milliseconds type ( cudaEvent ), value :: start !! Starting event type ( cudaEvent ), value :: end !! Ending event integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the elapsed time was computed successfully, !! or an error code if there was an issue. end function cudaEventElapsedTime end interface public :: cudaMemcpyAsync interface cudaMemcpyAsync !! Copies data asynchronously between host and device. function cudaMemcpyAsync_ptr ( dst , src , count , kdir , stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpyAsync\" ) import type ( c_ptr ), value :: dst !! Destination pointer type ( c_ptr ), value :: src !! Source pointer integer ( c_size_t ), value :: count !! Size in bytes to copy integer ( c_int ), value :: kdir !! Direction of copy (host-to-device, device-to-host, etc.) type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was initiated successfully, !! or an error code if there was an issue. end function cudaMemcpyAsync_ptr function cudaMemcpyAsync_r32 ( dst , src , count , kdir , stream ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpyAsync\" ) import real ( c_float ) :: dst !! Destination array (32-bit float) real ( c_float ) :: src !! Source array (32-bit float) integer ( c_size_t ), value :: count !! Number of elements to copy integer ( c_int ), value :: kdir !! Direction of copy type ( dtfft_stream_t ), value :: stream !! Stream identifier integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was initiated successfully, !! or an error code if there was an issue. end function cudaMemcpyAsync_r32 end interface public :: cudaMemcpy interface cudaMemcpy !! Copies data synchronously between host and device. function cudaMemcpy_ptr ( dst , src , count , kdir ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpy\" ) import type ( c_ptr ), value :: dst !! Destination pointer type ( c_ptr ), value :: src !! Source pointer integer ( c_size_t ), value :: count !! Size in bytes to copy integer ( c_int ), value :: kdir !! Direction of copy integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was completed successfully, !! or an error code if there was an issue. end function cudaMemcpy_ptr function cudaMemcpy_r64 ( dst , src , count , kdir ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpy\" ) import real ( c_double ) :: dst ( * ) !! Destination array (64-bit float) real ( c_double ) :: src ( * ) !! Source array (64-bit float) integer ( c_size_t ), value :: count !! Number of bytes to copy integer ( c_int ), value :: kdir !! Direction of copy integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was completed successfully, !! or an error code if there was an issue. end function cudaMemcpy_r64 function cudaMemcpy_r32 ( dst , src , count , kdir ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemcpy\" ) import real ( c_float ) :: dst ( * ) !! Destination array (32-bit float) real ( c_float ) :: src ( * ) !! Source array (32-bit float) integer ( c_size_t ), value :: count !! Number of bytes to copy integer ( c_int ), value :: kdir !! Direction of copy integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the copy was completed successfully, !! or an error code if there was an issue. end function cudaMemcpy_r32 end interface public :: cudaGetDevice interface function cudaGetDevice ( num ) & result ( cudaError_t ) & bind ( C , name = \"cudaGetDevice\" ) !! Returns the current device. import integer ( c_int ) :: num !! Device number integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the device was retrieved successfully, !! or an error code if there was an issue. end function cudaGetDevice end interface public :: cudaGetDeviceCount interface function cudaGetDeviceCount ( num ) & result ( cudaError_t ) & bind ( C , name = \"cudaGetDeviceCount\" ) !! Returns the number of available devices. import integer ( c_int ) :: num !! Number of devices integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the device count was retrieved successfully, !! or an error code if there was an issue. end function cudaGetDeviceCount end interface public :: cudaSetDevice interface function cudaSetDevice ( num ) & result ( cudaError_t ) & bind ( C , name = \"cudaSetDevice\" ) !! Sets the current device. import integer ( c_int ), value :: num !! Device number integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the device was set successfully, !! or an error code if there was an issue. end function cudaSetDevice end interface public :: cudaMemGetInfo interface function cudaMemGetInfo ( free , total ) & result ( cudaError_t ) & bind ( C , name = \"cudaMemGetInfo\" ) !! Returns the amount of free and total memory on the device. import integer ( c_size_t ) :: free !! Free memory in bytes integer ( c_size_t ) :: total !! Total memory in bytes integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if the memory information was retrieved successfully, !! or an error code if there was an issue. end function cudaMemGetInfo end interface public :: cudaDeviceSynchronize interface function cudaDeviceSynchronize () & result ( cudaError_t ) & bind ( C , name = \"cudaDeviceSynchronize\" ) !! Synchronizes the device, blocking until all preceding tasks in all streams have completed. import integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if syncronization was !! or an error code if there was an issue. end function cudaDeviceSynchronize end interface public :: cudaGetLastError interface function cudaGetLastError () & result ( cudaError_t ) & bind ( C , name = \"cudaGetLastError\" ) !! Returns the last error from a runtime call. import integer ( c_int ) :: cudaError_t !! Returns `cudaSuccess` if no error was detected !! or an error code if there was an issue. end function cudaGetLastError end interface public :: device_props type , bind ( C ) :: device_props !! GPU device properties obtained from cudaDeviceProp integer ( c_int ) :: sm_count !! Number of multiprocessors on device (cudaDeviceProp.multiProcessorCount) integer ( c_int ) :: max_threads_per_sm !! Maximum resident threads per multiprocessor (cudaDeviceProp.maxThreadsPerMultiProcessor) integer ( c_int ) :: max_blocks_per_sm !! Maximum number of resident blocks per multiprocessor (cudaDeviceProp.maxBlocksPerMultiProcessor) integer ( c_size_t ) :: shared_mem_per_sm !! Shared memory per multiprocessor (cudaDeviceProp.sharedMemPerMultiprocessor) integer ( c_int ) :: max_threads_per_block !! Maximum number of threads per block (cudaDeviceProp.maxThreadsPerBlock) integer ( c_size_t ) :: shared_mem_per_block !! Shared memory available per block in bytes (cudaDeviceProp.sharedMemPerBlock) integer ( c_int ) :: l2_cache_size !! Size of L2 cache in bytes (cudaDeviceProp.l2CacheSize) integer ( c_int ) :: compute_capability_major !! Major compute capability (cudaDeviceProp.major) integer ( c_int ) :: compute_capability_minor !! Minor compute capability (cudaDeviceProp.minor) end type device_props public :: get_device_props interface subroutine get_device_props ( device , props ) & bind ( C , name = \"get_device_props_cuda\" ) !! Returns the CUDA device properties for a given device number. import integer ( c_int ), value :: device !! Device number type ( device_props ) :: props !! GPU Properties end subroutine get_device_props end interface contains function cudaGetErrorString ( errcode ) result ( string ) !! Helper function that returns a string describing the given nvrtcResult code !! If the error code is not recognized, \"unrecognized error code\" is returned. integer ( c_int ), intent ( in ) :: errcode !! CUDA Runtime Compilation API result code. character ( len = :), allocatable :: string !! Result string call string_c2f ( cudaGetErrorString_c ( errcode ), string ) end function cudaGetErrorString end module dtfft_interface_cuda_runtime","tags":"","loc":"sourcefile/dtfft_interface_cuda_runtime.f90.html"},{"title":"dtfft_abstract_executor.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_abstract_executor.f90~~EfferentGraph sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_abstract_executor.f90~~AfferentGraph sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_abstract_executor !! This module describes Abstraction for all FFT Executors: [[abstract_executor]] use iso_c_binding , only : c_loc , c_ptr , c_null_ptr use iso_fortran_env , only : int8 , int32 , int64 use dtfft_errors use dtfft_pencil , only : pencil use dtfft_parameters use dtfft_utils #include \"_dtfft_profile.h\" #include \"_dtfft_private.h\" implicit none private public :: abstract_executor integer ( int8 ), public , parameter :: FFT_C2C = 0 !! Complex to complex FFT integer ( int8 ), public , parameter :: FFT_R2C = 1 !! Real to complex FFT integer ( int8 ), public , parameter :: FFT_R2R = 2 !! Real to real FFT integer ( int8 ), public , parameter :: FFT_1D = 1 !! 1D FFT integer ( int8 ), public , parameter :: FFT_2D = 2 !! 2D FFT type , abstract :: abstract_executor !! The \"most\" abstract executor. !! All FFT executors are extending this class. type ( c_ptr ) :: plan_forward !! Pointer to forward plan type ( c_ptr ) :: plan_backward !! Pointer to backward plan logical , private :: is_created = . false . !! Is plan created? logical :: is_inverse_copied = . false . !! Is inverse plan copied? character ( len = :), allocatable :: profile contains procedure , non_overridable , pass ( self ), public :: create !! Creates FFT plan procedure , non_overridable , pass ( self ), public :: execute !! Executes plan procedure , non_overridable , pass ( self ), public :: destroy !! Destroys plan procedure ( mem_alloc_interface ), deferred , nopass , public :: mem_alloc !! Allocates aligned memory procedure ( mem_free_interface ), deferred , nopass , public :: mem_free !! Frees aligned memory procedure ( create_interface ), deferred , pass ( self ) :: create_private !! Creates FFT plan procedure ( execute_interface ), deferred , pass ( self ) :: execute_private !! Executes plan procedure ( destroy_interface ), deferred , pass ( self ) :: destroy_private !! Destroys plan end type abstract_executor abstract interface subroutine create_interface ( self , fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , error_code , r2r_kinds ) !! Creates FFT plan import class ( abstract_executor ), intent ( inout ) :: self !! FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE integer ( int32 ), intent ( in ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ), intent ( in ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ), intent ( in ) :: how_many !! Number of transforms to create integer ( int32 ), intent ( in ) :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), intent ( in ) :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), intent ( in ) :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ), intent ( inout ) :: error_code !! Error code to be returned to user type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform end subroutine create_interface subroutine execute_interface ( self , a , b , sign ) !! Executes plan import class ( abstract_executor ), intent ( in ) :: self !! FFT Executor type ( c_ptr ), intent ( in ) :: a !! Source pointer type ( c_ptr ), intent ( in ) :: b !! Target pointer integer ( int8 ), intent ( in ) :: sign !! Sign of transform end subroutine execute_interface subroutine destroy_interface ( self ) !! Destroys plan import class ( abstract_executor ), intent ( inout ) :: self !! FFT Executor end subroutine destroy_interface subroutine mem_alloc_interface ( alloc_bytes , ptr ) !! Allocates aligned memory import integer ( int64 ), intent ( in ) :: alloc_bytes !! Number of bytes to allocate type ( c_ptr ), intent ( out ) :: ptr !! Allocated pointer end subroutine mem_alloc_interface subroutine mem_free_interface ( ptr ) !! Frees aligned memory import type ( c_ptr ), intent ( in ) :: ptr !! Pointer to free end subroutine mem_free_interface end interface contains integer ( int32 ) function create ( self , fft_rank , fft_type , precision , real_pencil , complex_pencil , r2r_kinds ) !! Creates FFT plan class ( abstract_executor ), intent ( inout ) :: self !! FFT Executor integer ( int8 ), intent ( in ) :: fft_rank !! Rank of fft: 1 or 2 integer ( int8 ), intent ( in ) :: fft_type !! Type of fft: r2r, r2c, c2c type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision of fft: DTFFT_SINGLE or DTFFT_DOUBLE type ( pencil ), optional , intent ( in ) :: real_pencil !! Real data layout type ( pencil ), optional , intent ( in ) :: complex_pencil !! Complex data layout type ( dtfft_r2r_kind_t ), optional , intent ( in ) :: r2r_kinds (:) !! Kinds of r2r transform integer ( int32 ), allocatable :: fft_sizes (:) !! Dimensions of transform integer ( int32 ), allocatable :: inembed (:) !! Storage dimensions of the input data in memory. integer ( int32 ), allocatable :: onembed (:) !! Storage dimensions of the output data in memory. integer ( int32 ) :: idist !! Distance between the first element of two consecutive signals in a batch of the input data. integer ( int32 ) :: odist !! Distance between the first element of two consecutive signals in a batch of the output data. integer ( int32 ) :: how_many !! Number of transforms to create create = DTFFT_SUCCESS if ( self % is_created . and . . not . is_null_ptr ( self % plan_forward ) . and . . not . is_null_ptr ( self % plan_backward ) ) return self % plan_forward = c_null_ptr self % plan_backward = c_null_ptr self % is_created = . false . self % is_inverse_copied = . false . #ifdef DTFFT_DEBUG if ( fft_rank /= FFT_1D . and . fft_rank /= FFT_2D ) INTERNAL_ERROR ( \"fft_rank /= FFT_1D .and. fft_rank /= FFT_2D\" ) if ( ( fft_type == FFT_R2C ). and .(. not . present ( complex_pencil ) . or . . not . present ( real_pencil )) ) INTERNAL_ERROR ( \"(fft_type == FFT_R2C).and.(.not.present(complex_pencil) .or. .not.present(real_pencil))\" ) if ( ( fft_type == FFT_R2R ). and .(. not . present ( real_pencil ) . or .. not . present ( r2r_kinds )) ) INTERNAL_ERROR ( \"(fft_type == FFT_R2R).and.(.not.present(real_pencil) .or..not.present(r2r_kinds))\" ) #endif allocate ( fft_sizes ( fft_rank ), inembed ( fft_rank ), onembed ( fft_rank ) ) how_many = 0 select case ( fft_type ) case ( FFT_C2C ) select case ( fft_rank ) case ( FFT_1D ) fft_sizes ( 1 ) = complex_pencil % counts ( 1 ) case ( FFT_2D ) fft_sizes ( 1 ) = complex_pencil % counts ( 2 ) fft_sizes ( 2 ) = complex_pencil % counts ( 1 ) endselect inembed (:) = fft_sizes (:) onembed (:) = fft_sizes (:) idist = product ( fft_sizes ) odist = idist how_many = product ( complex_pencil % counts ) / idist case ( FFT_R2C ) select case ( fft_rank ) case ( FFT_1D ) fft_sizes ( 1 ) = real_pencil % counts ( 1 ) onembed ( 1 ) = complex_pencil % counts ( 1 ) case ( FFT_2D ) fft_sizes ( 1 ) = real_pencil % counts ( 2 ) fft_sizes ( 2 ) = real_pencil % counts ( 1 ) onembed ( 1 ) = complex_pencil % counts ( 2 ) onembed ( 2 ) = complex_pencil % counts ( 1 ) endselect inembed (:) = fft_sizes (:) idist = product ( inembed ) odist = product ( onembed ) how_many = product ( real_pencil % counts ) / idist case ( FFT_R2R ) select case ( fft_rank ) case ( FFT_1D ) fft_sizes ( 1 ) = real_pencil % counts ( 1 ) case ( FFT_2D ) fft_sizes ( 1 ) = real_pencil % counts ( 2 ) fft_sizes ( 2 ) = real_pencil % counts ( 1 ) endselect inembed (:) = fft_sizes (:) onembed (:) = fft_sizes (:) idist = product ( fft_sizes ) odist = idist how_many = product ( real_pencil % counts ) / idist endselect if ( how_many == 0 ) then return endif if ( fft_rank == 1 ) then self % profile = \"1D \" else self % profile = \"2D \" endif self % profile = self % profile // to_str ( fft_sizes ( 1 )) if ( fft_rank == 2 ) self % profile = self % profile // \"x\" // to_str ( fft_sizes ( 2 )) self % profile = self % profile // \"x\" // to_str ( how_many ) REGION_BEGIN ( \"dtfft_create_fft: \" // self % profile , COLOR_FFT ) call self % create_private ( fft_rank , fft_type , precision , idist , odist , how_many , fft_sizes , inembed , onembed , create , r2r_kinds ) REGION_END ( \"dtfft_create_fft: \" // self % profile ) ! This should only happen when current process do not have any data, so FFT plan is not required here if ( is_null_ptr ( self % plan_forward ) . or . is_null_ptr ( self % plan_backward ) ) return if ( create == DTFFT_SUCCESS ) self % is_created = . true . deallocate ( fft_sizes , inembed , onembed ) end function create subroutine execute ( self , in , out , sign ) !! Executes plan class ( abstract_executor ), intent ( in ) :: self !! FFT Executor type ( c_ptr ), intent ( in ) :: in !! Source buffer type ( c_ptr ), intent ( in ) :: out !! Target buffer integer ( int8 ), intent ( in ) :: sign !! Sign of transform if ( . not . self % is_created ) return REGION_BEGIN ( \"dtfft_execute_fft \" // self % profile , COLOR_FFT ) call self % execute_private ( in , out , sign ) REGION_END ( \"dtfft_execute_fft \" // self % profile ) end subroutine execute subroutine destroy ( self ) !! Destroys plan class ( abstract_executor ), intent ( inout ) :: self !! FFT Executor if ( allocated ( self % profile ) ) deallocate ( self % profile ) if ( self % is_created ) call self % destroy_private () self % plan_forward = c_null_ptr self % plan_backward = c_null_ptr self % is_created = . false . self % is_inverse_copied = . false . end subroutine destroy end module dtfft_abstract_executor","tags":"","loc":"sourcefile/dtfft_abstract_executor.f90.html"},{"title":"dtfft_transpose_handle_datatype.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_transpose_handle_datatype.f90~~EfferentGraph sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_transpose_handle_datatype.f90~~AfferentGraph sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_transpose_handle_datatype !! This module describes [[transpose_handle_datatype]] class !! This class implements transposition using MPI_Ialltoall(w) !! with custom MPI datatypes !! For the end user this is `DTFFT_BACKEND_MPI_DATATYPE` - backend. !! But since it does not perform sequence: transpose -> exchange -> unpack, it is internally treated as tranpose_handle. use iso_fortran_env use dtfft_abstract_transpose_handle , only : abstract_transpose_handle , create_args , execute_args use dtfft_errors use dtfft_parameters use dtfft_pencil , only : pencil , get_transpose_type use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" #include \"_dtfft_profile.h\" #include \"_dtfft_cuda.h\" implicit none private public :: transpose_handle_datatype integer ( MPI_ADDRESS_KIND ), parameter :: LB = 0 !! Lower bound for all derived datatypes #if defined (ENABLE_PERSISTENT_COMM) # if defined(ENABLE_PERSISTENT_COLLECTIVES) #   if defined(OMPI_FIX_REQUIRED) logical , parameter :: IS_P2P_ENABLED = . true . #   else logical , parameter :: IS_P2P_ENABLED = . false . #   endif # else logical , parameter :: IS_P2P_ENABLED = . true . # endif #else # if defined(OMPI_FIX_REQUIRED) logical , parameter :: IS_P2P_ENABLED = . true . # else logical , parameter :: IS_P2P_ENABLED = . false . # endif #endif !! Is point-to-point communication enabled type :: handle_t !! Transposition handle class TYPE_MPI_DATATYPE , allocatable :: dtypes (:) !! Datatypes buffer integer ( int32 ), allocatable :: counts (:) !! Number of datatypes (always equals 1) integer ( int32 ), allocatable :: displs (:) !! Displacements is bytes contains procedure , pass ( self ) :: create => create_handle !! Creates transposition handle procedure , pass ( self ) :: destroy => destroy_handle !! Destroys transposition handle end type handle_t type , extends ( abstract_transpose_handle ) :: transpose_handle_datatype !! Tranpose backend that uses MPI_Ialltoall(w) with custom MPI datatypes private TYPE_MPI_COMM :: comm !! 1d communicator logical :: is_even = . false . !! Is decomposition even logical :: is_active = . false . !! Is async transposition active type ( handle_t ) :: send !! Handle to send data type ( handle_t ) :: recv !! Handle to recieve data TYPE_MPI_REQUEST , allocatable :: requests (:) !! Requests for communication integer ( int32 ) :: n_requests !! Actual number of requests, can be less than size(requests) #if defined(ENABLE_PERSISTENT_COMM) logical :: is_request_created = . false . !! Is request created #endif contains private procedure , pass ( self ), public :: create_private => create !! Initializes class procedure , pass ( self ), public :: execute !! Performs MPI_Ialltoall(w) procedure , pass ( self ), public :: execute_end !! Waits for MPI_Ialltoall(w) to complete procedure , pass ( self ), public :: destroy !! Destroys class procedure , pass ( self ), public :: get_async_active !! Returns .true. if async transposition is active end type transpose_handle_datatype contains subroutine create_handle ( self , n ) !! Creates transposition handle class ( handle_t ), intent ( inout ) :: self !! Transposition handle integer ( int32 ), intent ( in ) :: n !! Number of datatypes to be created call self % destroy () allocate ( self % dtypes ( n ), source = MPI_DATATYPE_NULL ) allocate ( self % counts ( n ), source = 1_int32 ) allocate ( self % displs ( n ), source = 0_int32 ) end subroutine create_handle subroutine destroy_handle ( self ) !! Destroys transposition handle class ( handle_t ), intent ( inout ) :: self !! Transposition handle integer ( int32 ) :: i !! Counter integer ( int32 ) :: ierr !! Error code if ( allocated ( self % dtypes ) ) then do i = 1 , size ( self % dtypes ) call MPI_Type_free ( self % dtypes ( i ), ierr ) enddo deallocate ( self % dtypes ) endif if ( allocated ( self % displs ) ) deallocate ( self % displs ) if ( allocated ( self % counts ) ) deallocate ( self % counts ) end subroutine destroy_handle subroutine create ( self , comm , send , recv , transpose_type , base_storage , kwargs ) !! Creates `transpose_handle_datatype` class class ( transpose_handle_datatype ), intent ( inout ) :: self !! Transpose handle TYPE_MPI_COMM , intent ( in ) :: comm !! MPI Communicator type ( pencil ), intent ( in ) :: send !! Send pencil type ( pencil ), intent ( in ) :: recv !! Recv pencil type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transpose to create integer ( int64 ), intent ( in ) :: base_storage !! Base storage type ( create_args ), intent ( in ) :: kwargs !! Additional arguments integer ( int32 ) :: comm_size !! Size of 1d communicator integer ( int32 ) :: n_neighbors !! Number of datatypes to be created integer ( int32 ), allocatable :: recv_counts (:,:) !! Each processor should know how much data each processor recieves integer ( int32 ), allocatable :: send_counts (:,:) !! Each processor should know how much data each processor sends integer ( int32 ) :: i !! Counter integer ( int32 ) :: ierr !! Error code integer ( int32 ) :: send_displ , recv_displ call self % destroy () self % comm = comm call MPI_Comm_size ( comm , comm_size , ierr ) self % is_even = send % is_even . and . recv % is_even n_neighbors = comm_size ; if ( self % is_even ) n_neighbors = 1 self % is_active = . false . allocate ( self % requests ( 2 * comm_size )) #if defined(ENABLE_PERSISTENT_COMM) self % is_request_created = . false . #endif call self % send % create ( n_neighbors ) call self % recv % create ( n_neighbors ) allocate ( recv_counts ( recv % rank , comm_size ), source = 0_int32 ) allocate ( send_counts , source = recv_counts ) call MPI_Allgather ( recv % counts , int ( recv % rank , int32 ), MPI_INTEGER4 , recv_counts , int ( recv % rank , int32 ), MPI_INTEGER4 , comm , ierr ) call MPI_Allgather ( send % counts , int ( send % rank , int32 ), MPI_INTEGER4 , send_counts , int ( send % rank , int32 ), MPI_INTEGER4 , comm , ierr ) do i = 1 , n_neighbors if ( send % rank == 2 ) then call create_transpose_2d ( send , send_counts (:, i ), recv , recv_counts (:, i ), kwargs % datatype_id , kwargs % base_type , base_storage , & self % send % dtypes ( i ), send_displ , self % recv % dtypes ( i ), recv_displ ) else if ( any ( transpose_type == [ DTFFT_TRANSPOSE_X_TO_Y , DTFFT_TRANSPOSE_Y_TO_Z ]) ) then call create_forw_permutation ( send , send_counts (:, i ), recv , recv_counts (:, i ), kwargs % datatype_id , kwargs % base_type , base_storage , & self % send % dtypes ( i ), send_displ , self % recv % dtypes ( i ), recv_displ ) else if ( any ( transpose_type == [ DTFFT_TRANSPOSE_Y_TO_X , DTFFT_TRANSPOSE_Z_TO_Y ]) ) then call create_back_permutation ( send , send_counts (:, i ), recv , recv_counts (:, i ), kwargs % datatype_id , kwargs % base_type , base_storage , & self % send % dtypes ( i ), send_displ , self % recv % dtypes ( i ), recv_displ ) else if ( transpose_type == DTFFT_TRANSPOSE_X_TO_Z ) then call create_transpose_XZ ( send , send_counts (:, i ), recv , recv_counts (:, i ), kwargs % datatype_id , kwargs % base_type , base_storage , & self % send % dtypes ( i ), send_displ , self % recv % dtypes ( i ), recv_displ ) else call create_transpose_ZX ( send , send_counts (:, i ), recv , recv_counts (:, i ), kwargs % datatype_id , kwargs % base_type , base_storage , & self % send % dtypes ( i ), send_displ , self % recv % dtypes ( i ), recv_displ ) endif if ( self % is_even ) then self % send % displs ( i ) = send_displ self % recv % displs ( i ) = recv_displ else if ( i < n_neighbors ) then if ( any ( send % counts == 0 ) ) then self % send % displs ( i + 1 ) = self % send % displs ( i ) else self % send % displs ( i + 1 ) = self % send % displs ( i ) + send_displ endif if ( any ( recv % counts == 0 ) ) then self % recv % displs ( i + 1 ) = self % recv % displs ( i ) else self % recv % displs ( i + 1 ) = self % recv % displs ( i ) + recv_displ endif endif endif enddo if ( IS_P2P_ENABLED ) then self % send % displs (:) = self % send % displs (:) / int ( FLOAT_STORAGE_SIZE , int32 ) self % recv % displs (:) = self % recv % displs (:) / int ( FLOAT_STORAGE_SIZE , int32 ) if ( . not . self % is_even ) then if ( any ( send % counts == 0 ) ) self % send % counts (:) = 0 if ( any ( recv % counts == 0 ) ) self % recv % counts (:) = 0 do i = 1 , n_neighbors if ( any ( recv_counts (:, i ) == 0 ) ) then self % send % counts ( i ) = 0 endif if ( any ( send_counts (:, i ) == 0 ) ) then self % recv % counts ( i ) = 0 endif enddo endif endif deallocate ( recv_counts , send_counts ) end subroutine create subroutine execute ( self , in , out , kwargs , error_code ) !! Executes transposition class ( transpose_handle_datatype ), intent ( inout ) :: self !! Transpose handle real ( real32 ), intent ( inout ) :: in (:) !! Send pointer real ( real32 ), intent ( inout ) :: out (:) !! Recv pointer type ( execute_args ), intent ( inout ) :: kwargs !! Additional arguments integer ( int32 ), intent ( out ) :: error_code !! Result of execution integer ( int32 ) :: i , comm_size , ierr error_code = DTFFT_SUCCESS if ( self % is_active ) then error_code = DTFFT_ERROR_TRANSPOSE_ACTIVE return endif call MPI_Comm_size ( self % comm , comm_size , ierr ) #if defined (ENABLE_PERSISTENT_COMM) if ( . not . self % is_request_created ) then # if defined(ENABLE_PERSISTENT_COLLECTIVES) if ( self % is_even ) then self % n_requests = 1 call MPI_Alltoall_init ( in , 1 , self % send % dtypes ( 1 ), out , 1 , self % recv % dtypes ( 1 ), & self % comm , MPI_INFO_NULL , self % requests ( 1 ), ierr ) else #   if defined(OMPI_FIX_REQUIRED) self % n_requests = 0 do i = 1 , comm_size if ( self % recv % counts ( i ) > 0 ) then self % n_requests = self % n_requests + 1 call MPI_Recv_init ( out ( self % recv % displs ( i )), 1 , self % recv % dtypes ( i ), i - 1 , 0_int32 , & self % comm , self % requests ( self % n_requests ), ierr ) endif enddo do i = 1 , comm_size if ( self % send % counts ( i ) > 0 ) then self % n_requests = self % n_requests + 1 call MPI_Send_init ( in ( self % send % displs ( i )), 1 , self % send % dtypes ( i ), i - 1 , 0_int32 , & self % comm , self % requests ( self % n_requests ), ierr ) endif enddo #   else self % n_requests = 1 call MPI_Alltoallw_init ( in , self % send % counts , self % send % displs , self % send % dtypes , & out , self % recv % counts , self % recv % displs , self % recv % dtypes , & self % comm , MPI_INFO_NULL , self % requests ( 1 ), ierr ) endif #   endif # else self % n_requests = 0 if ( self % is_even ) then do i = 1 , comm_size self % n_requests = self % n_requests + 1 call MPI_Recv_init ( out (( i - 1 ) * self % recv % displs ( 1 ) + 1 ), 1 , self % recv % dtypes ( 1 ), i - 1 , 0_int32 , & self % comm , self % requests ( self % n_requests ), ierr ) enddo do i = 1 , comm_size self % n_requests = self % n_requests + 1 call MPI_Send_init ( in (( i - 1 ) * self % send % displs ( 1 ) + 1 ), 1 , self % send % dtypes ( 1 ), i - 1 , 0_int32 , & self % comm , self % requests ( self % n_requests ), ierr ) enddo else do i = 1 , comm_size if ( self % recv % counts ( i ) > 0 ) then self % n_requests = self % n_requests + 1 call MPI_Recv_init ( out ( self % recv % displs ( i ) + 1 ), 1 , self % recv % dtypes ( i ), i - 1 , 0_int32 , & self % comm , self % requests ( self % n_requests ), ierr ) endif enddo do i = 1 , comm_size if ( self % send % counts ( i ) > 0 ) then self % n_requests = self % n_requests + 1 call MPI_Send_init ( in ( self % send % displs ( i ) + 1 ), 1 , self % send % dtypes ( i ), i - 1 , 0_int32 , & self % comm , self % requests ( self % n_requests ), ierr ) endif enddo endif # endif self % is_request_created = . true . endif call MPI_Startall ( self % n_requests , self % requests , ierr ) #else if ( self % is_even ) then self % n_requests = 1 call MPI_Ialltoall ( in , 1 , self % send % dtypes ( 1 ), out , 1 , self % recv % dtypes ( 1 ), & self % comm , self % requests ( 1 ), ierr ) else # if defined(OMPI_FIX_REQUIRED) block integer ( int32 ) :: i , comm_size call MPI_Comm_size ( self % comm , comm_size , ierr ) self % n_requests = 0 do i = 1 , comm_size if ( self % recv % counts ( i ) > 0 ) then self % n_requests = self % n_requests + 1 call MPI_Irecv ( out ( self % recv % displs ( i ) + 1 ), 1 , self % recv % dtypes ( i ), i - 1 , 0_int32 , & self % comm , self % requests ( self % n_requests ), ierr ) endif enddo do i = 1 , comm_size if ( self % send % counts ( i ) > 0 ) then self % n_requests = self % n_requests + 1 call MPI_Isend ( in ( self % send % displs ( i ) + 1 ), 1 , self % send % dtypes ( i ), i - 1 , 0_int32 , & self % comm , self % requests ( self % n_requests ), ierr ) endif enddo endblock # else self % n_requests = 1 call MPI_Ialltoallw ( in , self % send % counts , self % send % displs , self % send % dtypes , & out , self % recv % counts , self % recv % displs , self % recv % dtypes , & self % comm , self % requests ( 1 ), ierr ) # endif endif #endif self % is_active = . true . if ( kwargs % exec_type == EXEC_BLOCKING ) call self % execute_end ( kwargs , error_code ) end subroutine execute subroutine execute_end ( self , kwargs , error_code ) !! Ends execution of transposition class ( transpose_handle_datatype ), intent ( inout ) :: self !! Transpose handle type ( execute_args ), intent ( inout ) :: kwargs !! Additional arguments integer ( int32 ), intent ( out ) :: error_code !! Error code integer ( int32 ) :: ierr !! Error code error_code = DTFFT_SUCCESS if ( . not . self % is_active ) then error_code = DTFFT_ERROR_TRANSPOSE_NOT_ACTIVE return endif call MPI_Waitall ( self % n_requests , self % requests , MPI_STATUSES_IGNORE , ierr ) self % is_active = . false . end subroutine execute_end elemental logical function get_async_active ( self ) !! Returns if async transpose is active class ( transpose_handle_datatype ), intent ( in ) :: self !! Transpose handle get_async_active = self % is_active end function get_async_active subroutine destroy ( self ) !! Destroys `transpose_handle_datatype` class class ( transpose_handle_datatype ), intent ( inout ) :: self !! Transpose handle call self % send % destroy () call self % recv % destroy () #if defined(ENABLE_PERSISTENT_COLLECTIVES) block integer ( int32 ) :: i , ierr if ( self % is_request_created ) then do i = 1 , self % n_requests call MPI_Request_free ( self % requests ( i ), ierr ) enddo self % is_request_created = . false . endif endblock #endif if ( allocated ( self % requests ) ) deallocate ( self % requests ) self % is_active = . false . self % is_even = . false . end subroutine destroy subroutine create_transpose_2d ( send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage , send_dtype , send_displ , recv_dtype , recv_displ ) !! Creates two-dimensional transposition datatypes class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE , intent ( out ) :: send_dtype !! Datatype used to send data integer ( int32 ), intent ( out ) :: send_displ !! Send displacement in bytes TYPE_MPI_DATATYPE , intent ( out ) :: recv_dtype !! Datatype used to recv data integer ( int32 ), intent ( out ) :: recv_displ !! Recv displacement in bytes TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype integer ( int32 ) :: ierr !! Error code send_displ = recv_counts ( 2 ) * int ( base_storage , int32 ) recv_displ = send_counts ( 2 ) * int ( base_storage , int32 ) if ( datatype_id == 1 ) then call MPI_Type_vector ( send % counts ( 2 ), recv_counts ( 2 ), send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( send_displ , MPI_ADDRESS_KIND ), send_dtype , ierr ) call free_datatypes ( temp1 ) call MPI_Type_vector ( recv % counts ( 2 ), 1 , recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send_counts ( 2 ), temp2 , recv_dtype , ierr ) call free_datatypes ( temp1 , temp2 ) else call MPI_Type_vector ( send % counts ( 2 ), 1 , send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 2 ), temp2 , send_dtype , ierr ) call free_datatypes ( temp1 , temp2 ) call MPI_Type_vector ( recv % counts ( 2 ), send_counts ( 2 ), recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), recv_dtype , ierr ) call free_datatypes ( temp1 ) endif call MPI_Type_commit ( send_dtype , ierr ) call MPI_Type_commit ( recv_dtype , ierr ) end subroutine create_transpose_2d subroutine create_forw_permutation ( send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage , send_dtype , send_displ , recv_dtype , recv_displ ) !! Creates three-dimensional X --> Y and Y -> Z transposition datatypes class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE , intent ( out ) :: send_dtype !! Datatype used to send data integer ( int32 ), intent ( out ) :: send_displ !! Send displacement in bytes TYPE_MPI_DATATYPE , intent ( out ) :: recv_dtype !! Datatype used to recv data integer ( int32 ), intent ( out ) :: recv_displ !! Recv displacement in bytes TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype TYPE_MPI_DATATYPE :: temp3 !! Temporary datatype TYPE_MPI_DATATYPE :: temp4 !! Temporary datatype integer ( int32 ) :: ierr !! Error code send_displ = recv_counts ( 3 ) * int ( base_storage , int32 ) recv_displ = send_counts ( 2 ) * int ( base_storage , int32 ) if ( datatype_id == 1 ) then ! This datatype_id has \"contiguous\" send and strided recieve datatype call MPI_Type_vector ( send % counts ( 2 ) * send % counts ( 3 ), recv_counts ( 3 ), send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( send_displ , MPI_ADDRESS_KIND ), send_dtype , ierr ) call free_datatypes ( temp1 ) call MPI_Type_vector ( recv % counts ( 3 ), 1 , recv % counts ( 1 ) * recv % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send_counts ( 2 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( recv % counts ( 2 ), 1 , int ( recv % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) call MPI_Type_create_resized ( temp4 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), recv_dtype , ierr ) call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) elseif ( datatype_id == 2 ) then ! This datatype_id has strided send and \"contiguous\" recieve datatypes call MPI_Type_vector ( send % counts ( 2 ) * send % counts ( 3 ), 1 , send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 3 ), temp2 , send_dtype , ierr ) call free_datatypes ( temp1 , temp2 ) call MPI_Type_vector ( recv % counts ( 2 ), send_counts ( 2 ), recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_create_hvector ( recv % counts ( 3 ), 1 , int ( recv % counts ( 1 ) * recv % counts ( 2 ) * base_storage , MPI_ADDRESS_KIND ), temp2 , temp3 , ierr ) call MPI_Type_create_resized ( temp3 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), recv_dtype , ierr ) call free_datatypes ( temp1 , temp2 , temp3 ) endif call MPI_Type_commit ( send_dtype , ierr ) call MPI_Type_commit ( recv_dtype , ierr ) end subroutine create_forw_permutation subroutine create_back_permutation ( send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage , send_dtype , send_displ , recv_dtype , recv_displ ) !! Creates three-dimensional Y --> X and Z --> Y transposition datatypes class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE , intent ( out ) :: send_dtype !! Datatype used to send data integer ( int32 ), intent ( out ) :: send_displ !! Send displacement in bytes TYPE_MPI_DATATYPE , intent ( out ) :: recv_dtype !! Datatype used to recv data integer ( int32 ), intent ( out ) :: recv_displ !! Recv displacement in bytes TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype TYPE_MPI_DATATYPE :: temp3 !! Temporary datatype TYPE_MPI_DATATYPE :: temp4 !! Temporary datatype integer ( int32 ) :: ierr !! Error code send_displ = recv_counts ( 2 ) * int ( base_storage , int32 ) recv_displ = send_counts ( 3 ) * int ( base_storage , int32 ) if ( datatype_id == 1 ) then ! This datatype_id has \"contiguous\" send and strided recieve datatype call MPI_Type_vector ( send % counts ( 2 ) * send % counts ( 3 ), recv_counts ( 2 ), send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( send_displ , MPI_ADDRESS_KIND ), send_dtype , ierr ) call free_datatypes ( temp1 ) call MPI_Type_vector ( recv % counts ( 2 ) * recv % counts ( 3 ), 1 , recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send_counts ( 3 ), temp2 , temp3 , ierr ) call MPI_Type_create_resized ( temp3 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), recv_dtype , ierr ) call free_datatypes ( temp1 , temp2 , temp3 ) elseif ( datatype_id == 2 ) then ! This datatype_id has strided send and \"contiguous\" recieve datatypes call MPI_Type_vector ( send % counts ( 3 ), 1 , send % counts ( 1 ) * send % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 2 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( send % counts ( 2 ), 1 , int ( send % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) call MPI_Type_create_resized ( temp4 , LB , int ( send_displ , MPI_ADDRESS_KIND ), send_dtype , ierr ) call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) call MPI_Type_vector ( recv % counts ( 2 ) * recv % counts ( 3 ), send_counts ( 3 ), recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), recv_dtype , ierr ) call free_datatypes ( temp1 ) endif call MPI_Type_commit ( send_dtype , ierr ) call MPI_Type_commit ( recv_dtype , ierr ) end subroutine create_back_permutation subroutine create_transpose_XZ ( send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage , send_dtype , send_displ , recv_dtype , recv_displ ) !! Creates three-dimensional X --> Z transposition datatypes !! Can only be used with 3D slab decomposition when slabs are distributed in Z direction class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE , intent ( out ) :: send_dtype !! Datatype used to send data integer ( int32 ), intent ( out ) :: send_displ !! Send displacement in bytes TYPE_MPI_DATATYPE , intent ( out ) :: recv_dtype !! Datatype used to recv data integer ( int32 ), intent ( out ) :: recv_displ !! Recv displacement in bytes TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype TYPE_MPI_DATATYPE :: temp3 !! Temporary datatype TYPE_MPI_DATATYPE :: temp4 !! Temporary datatype integer ( int32 ) :: ierr !! Error code send_displ = send % counts ( 1 ) * recv_counts ( 3 ) * int ( base_storage , int32 ) recv_displ = send_counts ( 3 ) * int ( base_storage , int32 ) if ( datatype_id == 1 ) then call MPI_Type_vector ( send % counts ( 3 ), send % counts ( 1 ), send % counts ( 1 ) * send % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( send % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 3 ), temp2 , send_dtype , ierr ) call free_datatypes ( temp1 , temp2 ) call MPI_Type_vector ( recv % counts ( 2 ), 1 , recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send_counts ( 3 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( recv % counts ( 3 ), 1 , int ( recv % counts ( 1 ) * recv % counts ( 2 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) call MPI_Type_create_resized ( temp4 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), recv_dtype , ierr ) call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) else call MPI_Type_vector ( send % counts ( 3 ), 1 , send % counts ( 1 ) * send % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( send % counts ( 1 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( recv_counts ( 3 ), 1 , int ( send % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) call MPI_Type_create_resized ( temp4 , LB , int ( send_displ , MPI_ADDRESS_KIND ), send_dtype , ierr ) call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) call MPI_Type_vector ( recv % counts ( 2 ) * recv % counts ( 3 ), send_counts ( 3 ), recv % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), recv_dtype , ierr ) call free_datatypes ( temp1 ) endif call MPI_Type_commit ( send_dtype , ierr ) call MPI_Type_commit ( recv_dtype , ierr ) end subroutine create_transpose_XZ subroutine create_transpose_ZX ( send , send_counts , recv , recv_counts , datatype_id , base_type , base_storage , send_dtype , send_displ , recv_dtype , recv_displ ) !! Creates three-dimensional Z --> X transposition datatypes !! Can only be used with 3D slab decomposition when slabs are distributed in Z direction class ( pencil ), intent ( in ) :: send !! Information about send buffer integer ( int32 ), intent ( in ) :: send_counts (:) !! Rank i is sending this counts class ( pencil ), intent ( in ) :: recv !! Information about send buffer integer ( int32 ), intent ( in ) :: recv_counts (:) !! Rank i is recieving this counts integer ( int8 ), intent ( in ) :: datatype_id !! Id of transpose plan to use TYPE_MPI_DATATYPE , intent ( in ) :: base_type !! Base MPI_Datatype integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element TYPE_MPI_DATATYPE , intent ( out ) :: send_dtype !! Datatype used to send data integer ( int32 ), intent ( out ) :: send_displ !! Send displacement in bytes TYPE_MPI_DATATYPE , intent ( out ) :: recv_dtype !! Datatype used to recv data integer ( int32 ), intent ( out ) :: recv_displ !! Recv displacement in bytes TYPE_MPI_DATATYPE :: temp1 !! Temporary datatype TYPE_MPI_DATATYPE :: temp2 !! Temporary datatype TYPE_MPI_DATATYPE :: temp3 !! Temporary datatype TYPE_MPI_DATATYPE :: temp4 !! Temporary datatype integer ( int32 ) :: ierr !! Error code send_displ = recv_counts ( 3 ) * int ( base_storage , int32 ) recv_displ = recv % counts ( 1 ) * send_counts ( 3 ) * int ( base_storage , int32 ) if ( datatype_id == 1 ) then call MPI_Type_vector ( send % counts ( 2 ) * send % counts ( 3 ), recv_counts ( 3 ), send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( send_displ , MPI_ADDRESS_KIND ), send_dtype , ierr ) call free_datatypes ( temp1 ) call MPI_Type_vector ( recv % counts ( 3 ), 1 , recv % counts ( 1 ) * recv % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv % counts ( 1 ), temp2 , temp3 , ierr ) call MPI_Type_create_hvector ( send_counts ( 3 ), 1 , int ( recv % counts ( 1 ) * base_storage , MPI_ADDRESS_KIND ), temp3 , temp4 , ierr ) call MPI_Type_create_resized ( temp4 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), recv_dtype , ierr ) call free_datatypes ( temp1 , temp2 , temp3 , temp4 ) else call MPI_Type_vector ( send % counts ( 2 ) * send % counts ( 3 ), 1 , send % counts ( 1 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( base_storage , MPI_ADDRESS_KIND ), temp2 , ierr ) call MPI_Type_contiguous ( recv_counts ( 3 ), temp2 , send_dtype , ierr ) call free_datatypes ( temp1 , temp2 ) call MPI_Type_vector ( recv % counts ( 3 ), recv % counts ( 1 ) * send_counts ( 3 ), recv % counts ( 1 ) * recv % counts ( 2 ), base_type , temp1 , ierr ) call MPI_Type_create_resized ( temp1 , LB , int ( recv_displ , MPI_ADDRESS_KIND ), recv_dtype , ierr ) call free_datatypes ( temp1 ) endif call MPI_Type_commit ( send_dtype , ierr ) call MPI_Type_commit ( recv_dtype , ierr ) end subroutine create_transpose_ZX subroutine free_datatypes ( t1 , t2 , t3 , t4 ) !! Frees temporary datatypes TYPE_MPI_DATATYPE , intent ( inout ), optional :: t1 !! Temporary datatype TYPE_MPI_DATATYPE , intent ( inout ), optional :: t2 !! Temporary datatype TYPE_MPI_DATATYPE , intent ( inout ), optional :: t3 !! Temporary datatype TYPE_MPI_DATATYPE , intent ( inout ), optional :: t4 !! Temporary datatype integer ( int32 ) :: ierr !! Error code if ( present ( t1 ) ) call MPI_Type_free ( t1 , ierr ) if ( present ( t2 ) ) call MPI_Type_free ( t2 , ierr ) if ( present ( t3 ) ) call MPI_Type_free ( t3 , ierr ) if ( present ( t4 ) ) call MPI_Type_free ( t4 , ierr ) end subroutine free_datatypes end module dtfft_transpose_handle_datatype","tags":"","loc":"sourcefile/dtfft_transpose_handle_datatype.f90.html"},{"title":"dtfft_interface_mkl_m.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_interface_mkl_m.f90~~EfferentGraph sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_interface_mkl_m.f90~~AfferentGraph sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_mkl_m !! This module creates C interface with MKL library use iso_c_binding , only : c_long , c_int , c_ptr , c_f_pointer , c_null_char , c_size_t use dtfft_utils , only : string_c2f implicit none private public :: mkl_dfti_create_desc , & mkl_dfti_set_value , & mkl_dfti_commit_desc , & mkl_dfti_execute , & mkl_dfti_free_desc , & mkl_dfti_mem_alloc , & mkl_dfti_mem_free public :: DftiErrorMessage interface function DftiErrorMessage_c ( error_code ) & result ( message ) & bind ( C , name = \"DftiErrorMessage\" ) !! Generates an error message. import integer ( c_long ), intent ( in ), value :: error_code !! Completion status of a function. type ( c_ptr ) :: message !! Pointer to message end function DftiErrorMessage_c end interface interface mkl_dfti_set_value !! Sets one particular configuration parameter with the specified configuration value. function mkl_dfti_set_integer ( desc , param , value ) & result ( status ) & bind ( C ) !! Sets one particular configuration parameter with integer value. import type ( c_ptr ), value :: desc !! FFT descriptor. integer ( c_int ), intent ( in ), value :: param !! Configuration parameter. integer ( c_int ), intent ( in ), value :: value !! Configuration value. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_set_integer function mkl_dfti_set_pointer ( desc , param , value ) & result ( status ) & bind ( C ) !! Sets one particular configuration parameter with pointer value. import type ( c_ptr ), value :: desc !! FFT descriptor. integer ( c_int ), intent ( in ), value :: param !! Configuration parameter. integer ( c_long ), intent ( in ) :: value ( * ) !! Configuration value. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_set_pointer end interface mkl_dfti_set_value interface function mkl_dfti_create_desc ( precision , domain , dim , length , desc ) & result ( status ) & bind ( C ) !! Allocates the descriptor data structure and initializes it with default configuration values. import integer ( c_int ), intent ( in ), value :: precision !! Precision of the transform: DFTI_SINGLE or DFTI_DOUBLE. integer ( c_int ), intent ( in ), value :: domain !! Forward domain of the transform: DFTI_COMPLEX or DFTI_REAL. integer ( c_long ), intent ( in ), value :: dim !! Dimension of the transform. integer ( c_long ), intent ( in ) :: length ( * ) !! Length of the transform for a one-dimensional transform. !! Lengths of each dimension for a multi-dimensional transform. type ( c_ptr ) :: desc !! FFT descriptor. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_create_desc end interface interface function mkl_dfti_commit_desc ( desc ) & result ( status ) & bind ( C ) !! Performs all initialization for the actual FFT computation. import type ( c_ptr ), value :: desc !! FFT descriptor. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_commit_desc end interface interface function mkl_dfti_execute ( desc , in , out , sign ) & result ( status ) & bind ( C ) !! Computes FFT. import type ( c_ptr ), value :: desc !! FFT descriptor. type ( c_ptr ), value :: in !! Data to be transformed type ( c_ptr ), value :: out !! The transformed data integer ( c_int ), intent ( in ), value :: sign !! Sign of transform integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_execute end interface interface function mkl_dfti_free_desc ( desc ) & result ( status ) & bind ( C ) !! Frees the memory allocated for a descriptor. import type ( c_ptr ), value :: desc !! FFT descriptor. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_free_desc end interface interface function mkl_dfti_mem_alloc ( alloc_bytes , ptr ) & result ( status ) & bind ( C ) !! Allocates pointer via `mkl_malloc` import integer ( c_size_t ), value :: alloc_bytes !! Number of bytes to allocate. type ( c_ptr ) :: ptr !! Pointer to allocated memory. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_mem_alloc end interface interface function mkl_dfti_mem_free ( ptr ) & result ( status ) & bind ( C ) !! Frees pointer via `mkl_free` import type ( c_ptr ), value :: ptr !! Pointer to allocated memory. integer ( c_long ) :: status !! Function completion status. end function mkl_dfti_mem_free end interface contains function DftiErrorMessage ( error_code ) result ( string ) !! Generates an error message. integer ( c_long ), intent ( in ) :: error_code !! Completion status of a function. character ( len = :), allocatable :: string !! Error message call string_c2f ( DftiErrorMessage_c ( error_code ), string ) end function DftiErrorMessage end module dtfft_interface_mkl_m","tags":"","loc":"sourcefile/dtfft_interface_mkl_m.f90.html"},{"title":"dtfft_abstract_transpose_handle.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_abstract_transpose_handle.f90~~EfferentGraph sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_abstract_transpose_handle.f90~~AfferentGraph sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_abstract_transpose_handle !! This module defines `abstract_transpose_handle` type and its type bound procedures. !! !! This handle is used to perform data transpositions between distributed pencils. !! The actual implementation of the handle is deferred to the !! `create_private`, `execute`, `execute_end`, `destroy` and `get_async_active` procedures. use iso_fortran_env use dtfft_abstract_backend use dtfft_parameters use dtfft_pencil #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" implicit none private public :: abstract_transpose_handle public :: create_args public :: execute_args type :: create_args !! Arguments for creating transpose handle type ( dtfft_platform_t ) :: platform !! Platform type type ( backend_helper ) :: helper !! Backend helper type ( dtfft_effort_t ) :: effort !! Effort level for generating transpose kernels type ( dtfft_backend_t ) :: backend !! Backend type logical :: force_effort !! Should effort be forced or not TYPE_MPI_DATATYPE :: base_type !! Base MPI Datatype integer ( int8 ) :: datatype_id !! Type of datatype to use integer ( int8 ) :: comm_id !! ID of communicator to use end type create_args type :: execute_args !! Arguments for executing transpose handle type ( dtfft_stream_t ) :: stream !! Stream to execute on type ( async_exec_t ) :: exec_type !! Async execution type real ( real32 ), pointer :: p1 (:) !! `aux` pointer for pipelined operations, `in` pointer for [[execute_end]] real ( real32 ), pointer :: p2 (:) !! `out` pointer for [[execute_end]] end type execute_args type , abstract :: abstract_transpose_handle !! Abstract transpose handle type contains procedure , non_overridable , pass ( self ) :: create !! Creates transpose handle procedure , pass ( self ) :: get_aux_size !! Returns number of bytes required by aux buffer procedure ( create_interface ), deferred :: create_private !! Creates transpose handle procedure ( execute_interface ), deferred :: execute !! Executes transpose handle procedure ( execute_end_interface ), deferred :: execute_end !! Finishes async transpose procedure ( destroy_interface ), deferred :: destroy !! Destroys transpose handle procedure ( get_async_active_interface ), deferred :: get_async_active !! Returns if async transpose is active end type abstract_transpose_handle abstract interface subroutine create_interface ( self , comm , send , recv , transpose_type , base_storage , kwargs ) !! Creates transpose handle import class ( abstract_transpose_handle ), intent ( inout ) :: self !! Abstract transpose handle TYPE_MPI_COMM , intent ( in ) :: comm !! MPI Communicator type ( pencil ), intent ( in ) :: send !! Send pencil type ( pencil ), intent ( in ) :: recv !! Recv pencil type ( dtfft_transpose_t ), intent ( in ) :: transpose_type !! Type of transpose to create integer ( int64 ), intent ( in ) :: base_storage !! Base storage type ( create_args ), intent ( in ) :: kwargs !! Additional arguments end subroutine create_interface subroutine execute_interface ( self , in , out , kwargs , error_code ) !! Executes transpose handle import class ( abstract_transpose_handle ), intent ( inout ) :: self !! Abstract Transpose Handle real ( real32 ), intent ( inout ) :: in (:) !! Send pointer real ( real32 ), intent ( inout ) :: out (:) !! Recv pointer type ( execute_args ), intent ( inout ) :: kwargs !! Additional arguments integer ( int32 ), intent ( out ) :: error_code !! Error code end subroutine execute_interface subroutine execute_end_interface ( self , kwargs , error_code ) !! Finishes async transpose import class ( abstract_transpose_handle ), intent ( inout ) :: self !! Abstract Transpose Handle type ( execute_args ), intent ( inout ) :: kwargs !! Additional arguments integer ( int32 ), intent ( out ) :: error_code !! Error code end subroutine execute_end_interface subroutine destroy_interface ( self ) !! Destroys transpose handle import class ( abstract_transpose_handle ), intent ( inout ) :: self !! Abstract Transpose Handle end subroutine destroy_interface elemental logical function get_async_active_interface ( self ) !! Returns if async transpose is active import class ( abstract_transpose_handle ), intent ( in ) :: self !! Abstract Transpose Handle end function get_async_active_interface end interface contains subroutine create ( self , send , recv , base_storage , kwargs ) !! Creates transpose handle class ( abstract_transpose_handle ), intent ( inout ) :: self !! Abstract transpose handle type ( pencil ), intent ( in ) :: send !! Send pencil type ( pencil ), intent ( in ) :: recv !! Recv pencil integer ( int64 ), intent ( in ) :: base_storage !! Base storage size type ( create_args ), intent ( inout ) :: kwargs !! Additional arguments type ( dtfft_transpose_t ) :: transpose_type TYPE_MPI_COMM :: comm integer ( int8 ) :: comm_id transpose_type = get_transpose_type ( send , recv ) select case ( abs ( transpose_type % val ) ) case ( DTFFT_TRANSPOSE_X_TO_Y % val ) comm_id = 2 case ( DTFFT_TRANSPOSE_Y_TO_Z % val ) comm_id = 3 case ( DTFFT_TRANSPOSE_X_TO_Z % val ) comm_id = 1 case default INTERNAL_ERROR ( \"unknown `abs(transpose_type)`\" ) endselect comm = kwargs % helper % comms ( comm_id ) kwargs % helper % tranpose_type = transpose_type kwargs % comm_id = comm_id call self % create_private ( comm , send , recv , transpose_type , base_storage , kwargs ) end subroutine create pure integer ( int64 ) function get_aux_size ( self ) !! Returns number of bytes required by aux buffer class ( abstract_transpose_handle ), intent ( in ) :: self !! Abstract Transpose Handle get_aux_size = 0 end function get_aux_size end module dtfft_abstract_transpose_handle","tags":"","loc":"sourcefile/dtfft_abstract_transpose_handle.f90.html"},{"title":"dtfft_backend_cufftmp.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_backend_cufftmp.f90~~EfferentGraph sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_errors.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_backend_cufftmp.f90~~AfferentGraph sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_backend_cufftmp_m !! cuFFTMp GPU Backend [[backend_cufftmp]] use iso_fortran_env use iso_c_binding use dtfft_abstract_backend , only : abstract_backend , backend_helper use dtfft_interface_nvshmem use dtfft_interface_cuda_runtime use dtfft_interface_cufft use dtfft_errors use dtfft_parameters use dtfft_pencil , only : pencil use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_cuda.h\" #include \"_dtfft_private.h\" implicit none private public :: backend_cufftmp type :: Box3D !! cuFFTMp Box integer ( c_long_long ) :: lower ( 3 ) !! Lower box boundaries integer ( c_long_long ) :: upper ( 3 ) !! Upper box boundaries integer ( c_long_long ) :: strides ( 3 ) !! Strides in memory end type Box3D type , extends ( abstract_backend ) :: backend_cufftmp !! cuFFTMp GPU Backend private type ( cufftReshapeHandle ) :: plan contains procedure :: create_private => create procedure :: execute_private => execute procedure :: destroy_private => destroy end type backend_cufftmp contains subroutine create ( self , helper , base_storage ) !! Creates cuFFTMp GPU Backend class ( backend_cufftmp ), intent ( inout ) :: self !! cuFFTMp GPU Backend type ( backend_helper ), intent ( in ) :: helper !! Backend helper integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes to store single element type ( Box3D ) :: inbox , outbox !! Reshape boxes type ( pencil ), pointer :: in , out type ( c_ptr ) :: c_comm integer ( int64 ) :: aux_size type ( dtfft_transpose_t ) :: tranpose_type tranpose_type = helper % tranpose_type select case ( tranpose_type % val ) case ( DTFFT_TRANSPOSE_X_TO_Y % val ) in => helper % pencils ( 1 ) out => helper % pencils ( 2 ) case ( DTFFT_TRANSPOSE_Y_TO_X % val ) in => helper % pencils ( 2 ) out => helper % pencils ( 1 ) case ( DTFFT_TRANSPOSE_Y_TO_Z % val ) in => helper % pencils ( 2 ) out => helper % pencils ( 3 ) case ( DTFFT_TRANSPOSE_Z_TO_Y % val ) in => helper % pencils ( 3 ) out => helper % pencils ( 2 ) case ( DTFFT_TRANSPOSE_X_TO_Z % val ) in => helper % pencils ( 1 ) out => helper % pencils ( 3 ) case ( DTFFT_TRANSPOSE_Z_TO_X % val ) in => helper % pencils ( 3 ) out => helper % pencils ( 1 ) case default INTERNAL_ERROR ( \"unknown `tranpose_type`\" ) end select if ( in % rank == 3 ) then if ( any ( tranpose_type == [ DTFFT_TRANSPOSE_X_TO_Z , DTFFT_TRANSPOSE_Y_TO_X , DTFFT_TRANSPOSE_Z_TO_Y ])) then inbox % lower = [ in % starts ( 2 ), in % starts ( 1 ), in % starts ( 3 )] inbox % upper = [ in % starts ( 2 ) + in % counts ( 2 ), in % starts ( 1 ) + in % counts ( 1 ), in % starts ( 3 ) + in % counts ( 3 )] inbox % strides = [ in % counts ( 1 ) * in % counts ( 3 ), in % counts ( 3 ), 1 ] else inbox % lower = [ in % starts ( 1 ), in % starts ( 3 ), in % starts ( 2 )] inbox % upper = [ in % starts ( 1 ) + in % counts ( 1 ), in % starts ( 3 ) + in % counts ( 3 ), in % starts ( 2 ) + in % counts ( 2 )] inbox % strides = [ in % counts ( 2 ) * in % counts ( 3 ), in % counts ( 2 ), 1 ] end if outbox % lower = [ out % starts ( 3 ), out % starts ( 2 ), out % starts ( 1 )] outbox % upper = [ out % starts ( 3 ) + out % counts ( 3 ), out % starts ( 2 ) + out % counts ( 2 ), out % starts ( 1 ) + out % counts ( 1 )] outbox % strides = [ out % counts ( 1 ) * out % counts ( 2 ), out % counts ( 1 ), 1 ] else inbox % lower = [ 0 , in % starts ( 1 ), in % starts ( 2 )] inbox % upper = [ 1 , in % starts ( 1 ) + in % counts ( 1 ), in % starts ( 2 ) + in % counts ( 2 )] inbox % strides = [ in % counts ( 1 ) * in % counts ( 2 ), in % counts ( 2 ), 1 ] outbox % lower = [ 0 , out % starts ( 2 ), out % starts ( 1 )] outbox % upper = [ 1 , out % starts ( 2 ) + out % counts ( 2 ), out % starts ( 1 ) + out % counts ( 1 )] outbox % strides = [ out % counts ( 1 ) * out % counts ( 2 ), out % counts ( 1 ), 1 ] end if CUFFT_CALL ( cufftMpCreateReshape ( self % plan ) ) c_comm = Comm_f2c ( GET_MPI_VALUE ( helper % comms ( 1 ))) CUFFT_CALL ( cufftMpAttachReshapeComm ( self % plan , CUFFT_COMM_MPI , c_comm ) ) CUFFT_CALL ( cufftMpMakeReshape ( self % plan , base_storage , 3 , inbox % lower , inbox % upper , outbox % lower , outbox % upper , inbox % strides , outbox % strides ) ) CUFFT_CALL ( cufftMpGetReshapeSize ( self % plan , aux_size ) ) self % aux_size = max ( aux_size , self % aux_size ) end subroutine create subroutine execute ( self , in , out , stream , aux , exec_type , error_code ) !! Executes cuFFTMp GPU Backend class ( backend_cufftmp ), intent ( inout ) :: self !! cuFFTMp GPU Backend real ( real32 ), target , intent ( inout ) :: in (:) !! Send pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Recv pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Main execution CUDA stream real ( real32 ), target , intent ( inout ) :: aux (:) !! Aux pointer type ( async_exec_t ), intent ( in ) :: exec_type !! Type of async execution integer ( int32 ), intent ( out ) :: error_code !! Error code integer ( int32 ) :: ierr ! call nvshmemx_sync_all_on_stream(stream) CUDA_CALL ( cudaStreamSynchronize ( stream ) ) call MPI_Barrier ( self % comm , ierr ) CUFFT_CALL ( cufftMpExecReshapeAsync ( self % plan , c_loc ( out ), c_loc ( in ), c_loc ( aux ), stream ) ) error_code = DTFFT_SUCCESS end subroutine execute subroutine destroy ( self ) !! Destroys cuFFTMp GPU Backend class ( backend_cufftmp ), intent ( inout ) :: self !! cuFFTMp GPU Backend CUFFT_CALL ( cufftMpDestroyReshape ( self % plan ) ) end subroutine destroy end module dtfft_backend_cufftmp_m","tags":"","loc":"sourcefile/dtfft_backend_cufftmp.f90.html"},{"title":"dtfft_interface_fftw_m.F90 – dtFFT","text":"Files dependent on this one sourcefile~~dtfft_interface_fftw_m.f90~~AfferentGraph sourcefile~dtfft_interface_fftw_m.f90 dtfft_interface_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_interface_fftw_m.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ module dtfft_interface_fftw_m !! This module creates interface with fftw3 library use iso_c_binding , only : c_ptr , c_int use dtfft_interface_fftw_native_m , only : C_FFTW_R2R_KIND , FFTW_MEASURE , FFTW_DESTROY_INPUT use dtfft_interface_fftw_native_m , only : fftw_destroy_plan , fftwf_destroy_plan use dtfft_interface_fftw_native_m , only : fftw_malloc , fftw_free implicit none private public :: C_FFTW_R2R_KIND , FFTW_MEASURE , FFTW_DESTROY_INPUT public :: fftw_destroy_plan , fftwf_destroy_plan public :: fftw_execute_dft , fftwf_execute_dft public :: fftw_execute_dft_r2c , fftwf_execute_dft_r2c public :: fftw_execute_dft_c2r , fftwf_execute_dft_c2r public :: fftw_execute_r2r , fftwf_execute_r2r public :: fftw_plan_many_dft , fftwf_plan_many_dft public :: fftw_plan_many_dft_r2c , fftwf_plan_many_dft_r2c public :: fftw_plan_many_dft_c2r , fftwf_plan_many_dft_c2r public :: fftw_plan_many_r2r , fftwf_plan_many_r2r public :: fftw_malloc , fftw_free interface subroutine fftw_execute_dft ( plan , in , out ) bind ( C ) !! Executes C2C plan, double precision. #include \"args_execute.i90\" end subroutine fftw_execute_dft subroutine fftwf_execute_dft ( plan , in , out ) bind ( C ) !! Executes C2C plan, single precision. #include \"args_execute.i90\" end subroutine fftwf_execute_dft subroutine fftw_execute_dft_r2c ( plan , in , out ) bind ( C ) !! Executes R2C plan, double precision. #include \"args_execute.i90\" end subroutine fftw_execute_dft_r2c subroutine fftwf_execute_dft_r2c ( plan , in , out ) bind ( C ) !! Executes R2C plan, single precision. #include \"args_execute.i90\" end subroutine fftwf_execute_dft_r2c subroutine fftw_execute_dft_c2r ( plan , in , out ) bind ( C ) !! Executes C2R plan, double precision. #include \"args_execute.i90\" end subroutine fftw_execute_dft_c2r subroutine fftwf_execute_dft_c2r ( plan , in , out ) bind ( C ) !! Executes C2R plan, single precision. #include \"args_execute.i90\" end subroutine fftwf_execute_dft_c2r subroutine fftw_execute_r2r ( plan , in , out ) bind ( C ) !! Executes R2R plan, double precision. #include \"args_execute.i90\" end subroutine fftw_execute_r2r subroutine fftwf_execute_r2r ( plan , in , out ) bind ( C ) !! Executes R2R plan, single precision. #include \"args_execute.i90\" end subroutine fftwf_execute_r2r type ( c_ptr ) function fftw_plan_many_dft ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , sign , flags ) bind ( C ) !! Creates C2C plan, double precision. #include \"args_create.i90\" integer ( C_INT ), value :: sign end function fftw_plan_many_dft type ( c_ptr ) function fftwf_plan_many_dft ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , sign , flags ) bind ( C ) !! Creates C2C plan, single precision. #include \"args_create.i90\" integer ( C_INT ), value :: sign end function fftwf_plan_many_dft type ( c_ptr ) function fftw_plan_many_dft_r2c ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates R2C plan, double precision. #include \"args_create.i90\" end function fftw_plan_many_dft_r2c type ( c_ptr ) function fftwf_plan_many_dft_r2c ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates R2C plan, single precision. #include \"args_create.i90\" end function fftwf_plan_many_dft_r2c type ( c_ptr ) function fftw_plan_many_dft_c2r ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates C2R plan, double precision. #include \"args_create.i90\" end function fftw_plan_many_dft_c2r type ( c_ptr ) function fftwf_plan_many_dft_c2r ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , flags ) bind ( C ) !! Creates C2R plan, single precision. #include \"args_create.i90\" end function fftwf_plan_many_dft_c2r type ( c_ptr ) function fftw_plan_many_r2r ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , kind , flags ) bind ( C ) !! Creates R2R plan, double precision. #include \"args_create.i90\" integer ( C_FFTW_R2R_KIND ), intent ( in ) :: kind ( * ) end function fftw_plan_many_r2r type ( c_ptr ) function fftwf_plan_many_r2r ( rank , n , howmany , in , inembed , istride , idist , out , onembed , ostride , odist , kind , flags ) bind ( C ) !! Creates R2R plan, single precision. #include \"args_create.i90\" integer ( C_FFTW_R2R_KIND ), intent ( in ) :: kind ( * ) end function fftwf_plan_many_r2r end interface end module dtfft_interface_fftw_m","tags":"","loc":"sourcefile/dtfft_interface_fftw_m.f90.html"},{"title":"dtfft_parameters.F90 – dtFFT","text":"Files dependent on this one sourcefile~~dtfft_parameters.f90~~AfferentGraph sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90 dtfft_config.F90 sourcefile~dtfft.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_pencil.f90 dtfft_pencil.F90 sourcefile~dtfft.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_cuda_runtime.f90 dtfft_interface_cuda_runtime.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_nccl.f90 dtfft_interface_nccl.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_executor.f90 dtfft_abstract_executor.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_executor.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_interface_cufft.f90 dtfft_interface_cufft.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_interface_nvshmem.f90 dtfft_interface_nvshmem.F90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_config.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_cufft_m.f90 dtfft_executor_cufft_m.F90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_interface_cufft.f90 sourcefile~dtfft_executor_cufft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_fftw_m.f90 dtfft_executor_fftw_m.F90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_executor_fftw_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_executor_mkl_m.f90 dtfft_executor_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_mkl_m.f90 dtfft_interface_mkl_m.F90 sourcefile~dtfft_executor_mkl_m.f90->sourcefile~dtfft_interface_mkl_m.f90 sourcefile~dtfft_executor_vkfft_m.f90 dtfft_executor_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_interface_vkfft_m.f90 dtfft_interface_vkfft_m.F90 sourcefile~dtfft_executor_vkfft_m.f90->sourcefile~dtfft_interface_vkfft_m.f90 sourcefile~dtfft_interface_cuda.f90 dtfft_interface_cuda.F90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cuda_runtime.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_cufft.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nccl.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_nvshmem.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_vkfft_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90 dtfft_interface_nvrtc.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_pencil.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_abstract_executor.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_cufft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_fftw_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_mkl_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_executor_vkfft_m.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nccl.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvshmem.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_pencil.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvrtc.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_interface_mkl_m.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvrtc.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_config.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_interface_cuda_runtime.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_parameters !! This module defines common ``dtFFT`` parameters use iso_c_binding , only : c_int32_t , c_null_ptr , c_ptr use iso_fortran_env , only : int8 , int32 , int64 , real32 , real64 #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" implicit none private public :: dtfft_execute_t , dtfft_transpose_t public :: dtfft_executor_t , dtfft_effort_t public :: dtfft_precision_t , dtfft_r2r_kind_t public :: is_valid_execute_type , is_valid_transpose_type public :: is_valid_executor , is_valid_effort public :: is_valid_precision , is_valid_r2r_kind public :: is_valid_dimension , is_valid_comm_type public :: dtfft_get_version public :: dtfft_get_precision_string , dtfft_get_executor_string public :: dtfft_backend_t , dtfft_stream_t public :: dtfft_get_backend_string public :: is_backend_pipelined , is_backend_mpi public :: is_valid_backend , is_backend_nccl , is_backend_cufftmp , is_backend_nvshmem #ifdef DTFFT_WITH_CUDA public :: is_valid_platform public :: is_host_executor , is_cuda_executor public :: dtfft_get_cuda_stream #endif integer ( int32 ), parameter , public :: DTFFT_VERSION_MAJOR = CONF_DTFFT_VERSION_MAJOR !! dtFFT Major Version integer ( int32 ), parameter , public :: DTFFT_VERSION_MINOR = CONF_DTFFT_VERSION_MINOR !! dtFFT Minor Version integer ( int32 ), parameter , public :: DTFFT_VERSION_PATCH = CONF_DTFFT_VERSION_PATCH !! dtFFT Patch Version integer ( int32 ), parameter , public :: DTFFT_VERSION_CODE = CONF_DTFFT_VERSION_CODE !! dtFFT Version Code. Can be used in Version comparison interface dtfft_get_version !! Get dtFFT version module procedure :: dtfft_get_version_current !! Get current version module procedure :: dtfft_get_version_required !! Get required version end interface dtfft_get_version real ( real32 ), parameter , public :: MAX_REAL32 = huge ( 1._real32 ) !! Maximum value of real32 integer ( int32 ), parameter , public :: MAX_INT32 = huge ( 1_int32 ) !! Maximum value of int32 !------------------------------------------------------------------------------------------------ ! Execute types !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_execute_t !! Type that is used during call to `execute` method integer ( c_int32_t ) :: val !! Internal value end type dtfft_execute_t type ( dtfft_execute_t ), parameter , public :: DTFFT_EXECUTE_FORWARD = dtfft_execute_t ( CONF_DTFFT_EXECUTE_FORWARD ) !! Perform XYZ --> YZX --> ZXY plan execution (Forward) type ( dtfft_execute_t ), parameter , public :: DTFFT_EXECUTE_BACKWARD = dtfft_execute_t ( CONF_DTFFT_EXECUTE_BACKWARD ) !! Perform ZXY --> YZX --> XYZ plan execution (Backward) type ( dtfft_execute_t ), parameter :: VALID_EXECUTE_TYPES ( * ) = [ DTFFT_EXECUTE_FORWARD , DTFFT_EXECUTE_BACKWARD ] !! Valid execute types !------------------------------------------------------------------------------------------------ ! Transpose types !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_transpose_t !! Type that is used during call to [[dtfft_plan_t(type):transpose]] method integer ( c_int32_t ) :: val !! Internal value end type dtfft_transpose_t type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_X_TO_Y = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_X_TO_Y ) !! Perform single transposition, from X aligned to Y aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_Y_TO_X = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_Y_TO_X ) !! Perform single transposition, from Y aligned to X aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_X_TO_Z = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_X_TO_Z ) !! Perform single transposition, from X aligned to Z aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_Y_TO_Z = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_Y_TO_Z ) !! Perform single transposition, from Y aligned to Z aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_Z_TO_Y = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_Z_TO_Y ) !! Perform single transposition, from Z aligned to Y aligned type ( dtfft_transpose_t ), parameter , public :: DTFFT_TRANSPOSE_Z_TO_X = dtfft_transpose_t ( CONF_DTFFT_TRANSPOSE_Z_TO_X ) !! Perform single transposition, from Z aligned to X aligned type ( dtfft_transpose_t ), parameter :: VALID_TRANSPOSE_TYPES ( * ) = [ DTFFT_TRANSPOSE_X_TO_Y , DTFFT_TRANSPOSE_Y_TO_X , DTFFT_TRANSPOSE_Y_TO_Z , DTFFT_TRANSPOSE_Z_TO_Y , DTFFT_TRANSPOSE_X_TO_Z , DTFFT_TRANSPOSE_Z_TO_X ] !! Types of transpose that are valid to pass to `transpose` method character ( len =* ), parameter , public :: TRANSPOSE_NAMES ( - 3 : 3 ) = [ \"Z_TO_X\" , \"Z_TO_Y\" , \"Y_TO_X\" , \" NULL \" , \"X_TO_Y\" , \"Y_TO_Z\" , \"X_TO_Z\" ] !! String representation of `dtfft_transpose_t` !------------------------------------------------------------------------------------------------ ! External FFT executor types !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_executor_t !! Type that specifies external FFT executor integer ( c_int32_t ) :: val !! Internal value end type dtfft_executor_t type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_NONE = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_NONE ) !! Do not setup any executor. If this type is provided, then `execute` method should not be called. !! Use `transpose` method instead type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_FFTW3 = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_FFTW3 ) !! FFTW3 executor type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_MKL = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_MKL ) !! MKL executor type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_CUFFT = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_CUFFT ) !! cuFFT GPU executor type ( dtfft_executor_t ), parameter , public :: DTFFT_EXECUTOR_VKFFT = dtfft_executor_t ( CONF_DTFFT_EXECUTOR_VKFFT ) !! VkFFT GPU executor type ( dtfft_executor_t ), parameter :: VALID_EXECUTORS ( * ) = [ DTFFT_EXECUTOR_NONE & #ifdef DTFFT_WITH_FFTW , DTFFT_EXECUTOR_FFTW3 & #endif #ifdef DTFFT_WITH_MKL , DTFFT_EXECUTOR_MKL & #endif #ifdef DTFFT_WITH_CUFFT , DTFFT_EXECUTOR_CUFFT & #endif #ifdef DTFFT_WITH_VKFFT , DTFFT_EXECUTOR_VKFFT & #endif ] !! List of valid executors #ifdef DTFFT_WITH_CUDA type ( dtfft_executor_t ), parameter :: HOST_EXECUTORS ( * ) = [ DTFFT_EXECUTOR_NONE , DTFFT_EXECUTOR_FFTW3 , DTFFT_EXECUTOR_MKL ] !! List of host executors type ( dtfft_executor_t ), parameter :: CUDA_EXECUTORS ( * ) = [ DTFFT_EXECUTOR_NONE , DTFFT_EXECUTOR_CUFFT , DTFFT_EXECUTOR_VKFFT ] !! List of CUDA executors #endif !------------------------------------------------------------------------------------------------ ! FFT Execution directions !------------------------------------------------------------------------------------------------ integer ( int8 ), parameter , public :: FFT_FORWARD = CONF_FFT_FORWARD !! Forward c2c transform integer ( int8 ), parameter , public :: FFT_BACKWARD = CONF_FFT_BACKWARD !! Backward c2c transform !------------------------------------------------------------------------------------------------ ! Effort flags. !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_effort_t !! Type that specifies effort that dtFFT should use when creating plan integer ( c_int32_t ) :: val !! Internal value end type dtfft_effort_t type ( dtfft_effort_t ), parameter , public :: DTFFT_ESTIMATE = dtfft_effort_t ( CONF_DTFFT_ESTIMATE ) !! Estimate flag. ``dtFFT`` will use default decomposition provided by MPI_Dims_create type ( dtfft_effort_t ), parameter , public :: DTFFT_MEASURE = dtfft_effort_t ( CONF_DTFFT_MEASURE ) !! Measure flag. ``dtFFT`` will run transpose routines to find the best grid decomposition. !! Passing this flag and MPI Communicator with Cartesian topology to `plan%create` makes dtFFT do nothing. type ( dtfft_effort_t ), parameter , public :: DTFFT_PATIENT = dtfft_effort_t ( CONF_DTFFT_PATIENT ) !! Patient flag. Same as `DTFFT_MEASURE`, but different MPI datatypes will also be tested type ( dtfft_effort_t ), parameter :: VALID_EFFORTS ( * ) = [ DTFFT_ESTIMATE , DTFFT_MEASURE , DTFFT_PATIENT ] !! Valid effort flags !------------------------------------------------------------------------------------------------ ! Precision flags !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_precision_t !! Type that specifies precision of dtFFT plan integer ( c_int32_t ) :: val !! Internal value end type dtfft_precision_t type ( dtfft_precision_t ), parameter , public :: DTFFT_SINGLE = dtfft_precision_t ( CONF_DTFFT_SINGLE ) !! Use single precision type ( dtfft_precision_t ), parameter , public :: DTFFT_DOUBLE = dtfft_precision_t ( CONF_DTFFT_DOUBLE ) !! Use double precision type ( dtfft_precision_t ), parameter :: VALID_PRECISIONS ( * ) = [ DTFFT_SINGLE , DTFFT_DOUBLE ] !! Valid precision flags !------------------------------------------------------------------------------------------------ ! R2R Transform kinds ! This parameters matches FFTW definitions. Hope they will never change there. !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_r2r_kind_t !! Type that specifies various kinds of R2R FFTs integer ( c_int32_t ) :: val !! Internal value end type dtfft_r2r_kind_t type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DCT_1 = dtfft_r2r_kind_t ( CONF_DTFFT_DCT_1 ) !! DCT-I (Logical N=2*(n-1), inverse is `DTFFT_DCT_1`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DCT_2 = dtfft_r2r_kind_t ( CONF_DTFFT_DCT_2 ) !! DCT-II (Logical N=2*n, inverse is `DTFFT_DCT_3`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DCT_3 = dtfft_r2r_kind_t ( CONF_DTFFT_DCT_3 ) !! DCT-III (Logical N=2*n, inverse is `DTFFT_DCT_2`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DCT_4 = dtfft_r2r_kind_t ( CONF_DTFFT_DCT_4 ) !! DCT-IV (Logical N=2*n, inverse is `DTFFT_DCT_4`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DST_1 = dtfft_r2r_kind_t ( CONF_DTFFT_DST_1 ) !! DST-I (Logical N=2*(n+1), inverse is `DTFFT_DST_1`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DST_2 = dtfft_r2r_kind_t ( CONF_DTFFT_DST_2 ) !! DST-II (Logical N=2*n, inverse is `DTFFT_DST_3`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DST_3 = dtfft_r2r_kind_t ( CONF_DTFFT_DST_3 ) !! DST-III (Logical N=2*n, inverse is `DTFFT_DST_2`) type ( dtfft_r2r_kind_t ), parameter , public :: DTFFT_DST_4 = dtfft_r2r_kind_t ( CONF_DTFFT_DST_4 ) !! DST-IV (Logical N=2*n, inverse is `DTFFT_DST_4`) type ( dtfft_r2r_kind_t ), parameter :: VALID_R2R_KINDS ( * ) = [ DTFFT_DCT_1 , DTFFT_DCT_2 , DTFFT_DCT_3 , DTFFT_DCT_4 , DTFFT_DST_1 , DTFFT_DST_2 , DTFFT_DST_3 , DTFFT_DST_4 ] !! Array of valid R2R kinds public :: operator ( == ) interface operator ( == ) module procedure execute_type_eq !! Check if two `dtfft_execute_t` are equal module procedure transpose_type_eq !! Check if two `dtfft_transpose_t` are equal module procedure executor_eq !! Check if two `dtfft_executor_t` are equal module procedure effort_eq !! Check if two `dtfft_effort_t` are equal module procedure precision_eq !! Check if two `dtfft_precision_t` are equal module procedure r2r_kind_eq !! Check if two `dtfft_r2r_kind_t` are equal module procedure platform_eq !! Check if two `dtfft_platform_t` are equal module procedure exec_eq module procedure gpu_backend_eq !! Check if two `dtfft_backend_t` are equal end interface public :: operator ( /= ) interface operator ( /= ) module procedure execute_type_ne !! Check if two `dtfft_execute_t` are not equal module procedure transpose_type_ne !! Check if two `dtfft_transpose_t` are not equal module procedure executor_ne !! Check if two `dtfft_executor_t` are not equal module procedure effort_ne !! Check if two `dtfft_effort_t` are not equal module procedure precision_ne !! Check if two `dtfft_precision_t` are not equal module procedure r2r_kind_ne !! Check if two `dtfft_r2r_kind_t` are not equal module procedure platform_ne !! Check if two `dtfft_platform_t` are not equal module procedure gpu_backend_ne !! Check if two `dtfft_backend_t` are not equal end interface !------------------------------------------------------------------------------------------------ ! Storage sizes !------------------------------------------------------------------------------------------------ integer ( int64 ), parameter , public :: DOUBLE_COMPLEX_STORAGE_SIZE = storage_size (( 1._real64 , 1._real64 )) / 8_int64 !! Number of bytes to store single double precision complex element integer ( int64 ), parameter , public :: COMPLEX_STORAGE_SIZE = storage_size (( 1._real32 , 1._real32 )) / 8_int64 !! Number of bytes to store single float precision complex element integer ( int64 ), parameter , public :: DOUBLE_STORAGE_SIZE = storage_size ( 1._real64 ) / 8_int64 !! Number of bytes to store single double precision real element integer ( int64 ), parameter , public :: FLOAT_STORAGE_SIZE = storage_size ( 1._real32 ) / 8_int64 !! Number of bytes to store single single precision real element integer ( int8 ), parameter :: VALID_DIMENSIONS ( * ) = [ 2_int8 , 3_int8 ] !! Valid dimensions for `plan.create` integer ( int32 ), parameter :: VALID_COMM_TYPES ( * ) = [ MPI_UNDEFINED , MPI_CART ] !! Valid communicator types for `plan.create` integer ( int32 ), parameter , public :: COLOR_CREATE = int ( Z '00FAB53C' ) !! Color for `plan.create` integer ( int32 ), parameter , public :: COLOR_EXECUTE = int ( Z '00E25DFC' ) !! Color for `plan.execute` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE = int ( Z '00B175BD' ) !! Color for `plan.transpose` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_XY = int ( Z '005DFCCA' ) !! Color for `DTFFT_TRANSPOSE_X_TO_Y` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_YX = int ( Z '0076A797' ) !! Color for `DTFFT_TRANSPOSE_Y_TO_X` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_YZ = int ( Z '00E3CF9F' ) !! Color for `DTFFT_TRANSPOSE_Y_TO_Z` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_ZY = int ( Z '008C826A' ) !! Color for `DTFFT_TRANSPOSE_Z_TO_Y` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_XZ = int ( Z '00546F66' ) !! Color for `DTFFT_TRANSPOSE_X_TO_Z` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_ZX = int ( Z '007A6D7D' ) !! Color for `DTFFT_TRANSPOSE_Z_TO_X` integer ( int32 ), parameter , public :: COLOR_FFT = int ( Z '00FCD05D' ) !! Color for FFT integer ( int32 ), parameter , public :: COLOR_AUTOTUNE = int ( Z '006075FF' ) !! Color for Autotune integer ( int32 ), parameter , public :: COLOR_AUTOTUNE2 = int ( Z '0056E874' ) !! Color for Autotune2 integer ( int32 ), parameter , public :: COLOR_DESTROY = int ( Z '00000000' ) !! Color for `plan.destroy` integer ( int32 ), parameter , public :: COLOR_TRANSPOSE_PALLETTE ( - 3 : 3 ) = [ COLOR_TRANSPOSE_ZX , COLOR_TRANSPOSE_ZY , COLOR_TRANSPOSE_YX , 0 , COLOR_TRANSPOSE_XY , COLOR_TRANSPOSE_YZ , COLOR_TRANSPOSE_XZ ] !! Color pallete for `plan.transpose` integer ( int32 ), parameter , public :: VARIABLE_NOT_SET = - 111 !! Default value when environ is not set !------------------------------------------------------------------------------------------------ ! Backends that are responsible for transfering data between processes !------------------------------------------------------------------------------------------------ type , bind ( C ) :: dtfft_backend_t !! Type that specifies various backends present in dtFFT integer ( c_int32_t ) :: val !! Internal value end type dtfft_backend_t type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_DATATYPE = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_DATATYPE ) !! Backend that uses MPI datatypes !! This is default backend for Host build. !! Not really recommended to use for GPU usage, since it is a 'million' times slower than other backends. type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_P2P = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_P2P ) !! MPI peer-to-peer algorithm type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_A2A = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_A2A ) !! MPI backend using MPI_Alltoallv type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_RMA = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_RMA ) !! MPI RMA backend type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_RMA_PIPELINED = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_RMA_PIPELINED ) !! MPI Pipelined RMA backend type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_NCCL = dtfft_backend_t ( CONF_DTFFT_BACKEND_NCCL ) !! NCCL backend type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_MPI_P2P_PIPELINED = dtfft_backend_t ( CONF_DTFFT_BACKEND_MPI_P2P_PIPELINED ) !! MPI peer-to-peer algorithm with overlapping data copying and unpacking type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_NCCL_PIPELINED = dtfft_backend_t ( CONF_DTFFT_BACKEND_NCCL_PIPELINED ) !! NCCL backend with overlapping data copying and unpacking type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_CUFFTMP = dtfft_backend_t ( CONF_DTFFT_BACKEND_CUFFTMP ) !! cuFFTMp backend type ( dtfft_backend_t ), parameter , public :: DTFFT_BACKEND_CUFFTMP_PIPELINED = dtfft_backend_t ( CONF_DTFFT_BACKEND_CUFFTMP_PIPELINED ) !! cuFFTMp backend that uses extra buffer to gain performance type ( dtfft_backend_t ), parameter , public :: BACKEND_NOT_SET = dtfft_backend_t ( VARIABLE_NOT_SET ) !! Backend is not used type ( dtfft_backend_t ), parameter :: PIPELINED_BACKENDS ( * ) = [ DTFFT_BACKEND_MPI_P2P_PIPELINED , DTFFT_BACKEND_NCCL_PIPELINED , DTFFT_BACKEND_CUFFTMP_PIPELINED , DTFFT_BACKEND_MPI_RMA_PIPELINED ] !! List of pipelined backends type ( dtfft_backend_t ), parameter :: MPI_BACKENDS ( * ) = [ DTFFT_BACKEND_MPI_P2P , DTFFT_BACKEND_MPI_A2A , DTFFT_BACKEND_MPI_P2P_PIPELINED , DTFFT_BACKEND_MPI_RMA , DTFFT_BACKEND_MPI_RMA_PIPELINED ] !! List of MPI backends type ( dtfft_backend_t ), parameter :: NCCL_BACKENDS ( * ) = [ DTFFT_BACKEND_NCCL , DTFFT_BACKEND_NCCL_PIPELINED ] !! List of NCCL backends type ( dtfft_backend_t ), parameter :: CUFFTMP_BACKENDS ( * ) = [ DTFFT_BACKEND_CUFFTMP , DTFFT_BACKEND_CUFFTMP_PIPELINED ] !! List of cuFFTMp backends type ( dtfft_backend_t ), parameter :: NVSHMEM_BACKENDS ( * ) = [ DTFFT_BACKEND_CUFFTMP , DTFFT_BACKEND_CUFFTMP_PIPELINED ] !! List of NVSHMEM-based backends type ( dtfft_backend_t ), parameter , public :: VALID_BACKENDS ( * ) = [ DTFFT_BACKEND_MPI_DATATYPE & , DTFFT_BACKEND_MPI_P2P & , DTFFT_BACKEND_MPI_A2A & , DTFFT_BACKEND_MPI_P2P_PIPELINED & #ifdef DTFFT_WITH_RMA , DTFFT_BACKEND_MPI_RMA & , DTFFT_BACKEND_MPI_RMA_PIPELINED & #endif #ifdef DTFFT_WITH_NCCL , DTFFT_BACKEND_NCCL_PIPELINED & , DTFFT_BACKEND_NCCL & #endif #ifdef DTFFT_WITH_NVSHMEM , DTFFT_BACKEND_CUFFTMP & , DTFFT_BACKEND_CUFFTMP_PIPELINED & #endif ] !! List of valid GPU backends that `dtFFT` was compiled for type , bind ( C ) :: dtfft_stream_t !! `dtFFT` stream representation. type ( c_ptr ) :: stream !! Actual stream end type dtfft_stream_t type ( dtfft_stream_t ), parameter , public :: NULL_STREAM = dtfft_stream_t ( c_null_ptr ) #ifdef DTFFT_WITH_CUDA interface dtfft_stream_t !! Creates [[dtfft_stream_t]] from integer(cuda_stream_kind) module procedure stream_from_int64 end interface dtfft_stream_t #endif public :: dtfft_platform_t type , bind ( C ) :: dtfft_platform_t !! Type that specifies runtime platform, e.g. Host, CUDA, HIP integer ( c_int32_t ) :: val !! Internal value end type dtfft_platform_t type ( dtfft_platform_t ), public , parameter :: DTFFT_PLATFORM_HOST = dtfft_platform_t ( CONF_DTFFT_PLATFORM_HOST ) !! Host platform type ( dtfft_platform_t ), public , parameter :: DTFFT_PLATFORM_CUDA = dtfft_platform_t ( CONF_DTFFT_PLATFORM_CUDA ) !! CUDA platform #ifdef DTFFT_WITH_CUDA type ( dtfft_platform_t ), parameter :: VALID_PLATFORMS ( * ) = [ DTFFT_PLATFORM_HOST , DTFFT_PLATFORM_CUDA ] !! Valid platforms #endif ! type(dtfft_platform_t), public, parameter :: DTFFT_PLATFORM_HIP = dtfft_platform_t(3) type ( dtfft_platform_t ), public , parameter :: PLATFORM_NOT_SET = dtfft_platform_t ( VARIABLE_NOT_SET ) public :: dtfft_request_t type , bind ( C ) :: dtfft_request_t type ( c_ptr ) :: val = c_null_ptr end type dtfft_request_t public :: async_exec_t type :: async_exec_t integer ( int32 ) :: val end type async_exec_t type ( async_exec_t ), parameter , public :: EXEC_BLOCKING = async_exec_t ( 1 ) !! Blocking execution type ( async_exec_t ), parameter , public :: EXEC_NONBLOCKING = async_exec_t ( 2 ) !! Non-blocking execution contains MAKE_EQ_FUN ( dtfft_execute_t , execute_type_eq ) MAKE_EQ_FUN ( dtfft_transpose_t , transpose_type_eq ) MAKE_EQ_FUN ( dtfft_executor_t , executor_eq ) MAKE_EQ_FUN ( dtfft_effort_t , effort_eq ) MAKE_EQ_FUN ( dtfft_precision_t , precision_eq ) MAKE_EQ_FUN ( dtfft_r2r_kind_t , r2r_kind_eq ) MAKE_EQ_FUN ( dtfft_platform_t , platform_eq ) MAKE_EQ_FUN ( async_exec_t , exec_eq ) MAKE_NE_FUN ( dtfft_execute_t , execute_type_ne ) MAKE_NE_FUN ( dtfft_transpose_t , transpose_type_ne ) MAKE_NE_FUN ( dtfft_executor_t , executor_ne ) MAKE_NE_FUN ( dtfft_effort_t , effort_ne ) MAKE_NE_FUN ( dtfft_precision_t , precision_ne ) MAKE_NE_FUN ( dtfft_r2r_kind_t , r2r_kind_ne ) MAKE_NE_FUN ( dtfft_platform_t , platform_ne ) MAKE_VALID_FUN_DTYPE ( dtfft_execute_t , is_valid_execute_type , VALID_EXECUTE_TYPES ) MAKE_VALID_FUN_DTYPE ( dtfft_transpose_t , is_valid_transpose_type , VALID_TRANSPOSE_TYPES ) MAKE_VALID_FUN_DTYPE ( dtfft_executor_t , is_valid_executor , VALID_EXECUTORS ) MAKE_VALID_FUN_DTYPE ( dtfft_effort_t , is_valid_effort , VALID_EFFORTS ) MAKE_VALID_FUN_DTYPE ( dtfft_precision_t , is_valid_precision , VALID_PRECISIONS ) MAKE_VALID_FUN_DTYPE ( dtfft_r2r_kind_t , is_valid_r2r_kind , VALID_R2R_KINDS ) MAKE_VALID_FUN ( integer ( int8 ), is_valid_dimension , VALID_DIMENSIONS ) MAKE_VALID_FUN ( integer ( int32 ), is_valid_comm_type , VALID_COMM_TYPES ) integer ( c_int32_t ) function dtfft_get_version_current () bind ( C ) !! Returns the current version code dtfft_get_version_current = DTFFT_VERSION_CODE end function dtfft_get_version_current integer ( int32 ) function dtfft_get_version_required ( major , minor , patch ) !! Returns the version code required by the user integer ( int32 ), intent ( in ) :: major !! Major version integer ( int32 ), intent ( in ) :: minor !! Minor version integer ( int32 ), intent ( in ) :: patch !! Patch version dtfft_get_version_required = CONF_DTFFT_VERSION ( major , minor , patch ) end function dtfft_get_version_required function dtfft_get_precision_string ( precision ) result ( string ) !! Gets the string description of a precision type ( dtfft_precision_t ), intent ( in ) :: precision !! Precision type character ( len = :), allocatable :: string !! Precision string select case ( precision % val ) case ( DTFFT_SINGLE % val ) allocate ( string , source = \"Single\" ) case ( DTFFT_DOUBLE % val ) allocate ( string , source = \"Double\" ) case default allocate ( string , source = \"Unknown precision\" ) endselect end function dtfft_get_precision_string function dtfft_get_executor_string ( executor ) result ( string ) !! Gets the string description of an executor type ( dtfft_executor_t ), intent ( in ) :: executor !! Executor type character ( len = :), allocatable :: string !! Executor string select case ( executor % val ) case ( DTFFT_EXECUTOR_NONE % val ) allocate ( string , source = \"None\" ) case ( DTFFT_EXECUTOR_FFTW3 % val ) allocate ( string , source = \"FFTW3\" ) case ( DTFFT_EXECUTOR_MKL % val ) allocate ( string , source = \"MKL\" ) case ( DTFFT_EXECUTOR_CUFFT % val ) allocate ( string , source = \"CUFFT\" ) case ( DTFFT_EXECUTOR_VKFFT % val ) allocate ( string , source = \"VKFFT\" ) case default allocate ( string , source = \"Unknown executor\" ) endselect end function dtfft_get_executor_string function dtfft_get_backend_string ( backend ) result ( string ) !! Gets the string description of a GPU backend type ( dtfft_backend_t ), intent ( in ) :: backend !! GPU backend character ( len = :), allocatable :: string !! Backend string select case ( backend % val ) case ( DTFFT_BACKEND_MPI_DATATYPE % val ) allocate ( string , source = \"MPI_DATATYPE\" ) case ( DTFFT_BACKEND_MPI_P2P % val ) allocate ( string , source = \"MPI_P2P\" ) case ( DTFFT_BACKEND_MPI_A2A % val ) allocate ( string , source = \"MPI_A2A\" ) case ( DTFFT_BACKEND_MPI_RMA % val ) allocate ( string , source = \"MPI_RMA\" ) case ( DTFFT_BACKEND_MPI_RMA_PIPELINED % val ) allocate ( string , source = \"MPI_RMA_PIPELINED\" ) case ( DTFFT_BACKEND_NCCL % val ) allocate ( string , source = \"NCCL\" ) case ( DTFFT_BACKEND_CUFFTMP % val ) allocate ( string , source = \"CUFFTMP\" ) case ( DTFFT_BACKEND_MPI_P2P_PIPELINED % val ) allocate ( string , source = \"MPI_P2P_PIPELINED\" ) case ( DTFFT_BACKEND_NCCL_PIPELINED % val ) allocate ( string , source = \"NCCL_PIPELINED\" ) case ( DTFFT_BACKEND_CUFFTMP_PIPELINED % val ) allocate ( string , source = \"CUFFTMP_PIPELINED\" ) case ( BACKEND_NOT_SET % val ) allocate ( string , source = \"None\" ) case default allocate ( string , source = \"Unknown backend\" ) endselect end function dtfft_get_backend_string MAKE_EQ_FUN ( dtfft_backend_t , gpu_backend_eq ) MAKE_NE_FUN ( dtfft_backend_t , gpu_backend_ne ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_pipelined , PIPELINED_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_mpi , MPI_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_valid_backend , VALID_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_nccl , NCCL_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_cufftmp , CUFFTMP_BACKENDS ) MAKE_VALID_FUN_DTYPE ( dtfft_backend_t , is_backend_nvshmem , NVSHMEM_BACKENDS ) #ifdef DTFFT_WITH_CUDA MAKE_VALID_FUN_DTYPE ( dtfft_executor_t , is_host_executor , HOST_EXECUTORS ) MAKE_VALID_FUN_DTYPE ( dtfft_executor_t , is_cuda_executor , CUDA_EXECUTORS ) MAKE_VALID_FUN_DTYPE ( dtfft_platform_t , is_valid_platform , VALID_PLATFORMS ) function stream_from_int64 ( cuda_stream ) result ( stream ) !! Creates [[dtfft_stream_t]] from integer(cuda_stream_kind) integer ( int64 ), intent ( in ) :: cuda_stream !! CUDA stream type ( dtfft_stream_t ) :: stream !! dtfft Stream stream = transfer ( cuda_stream , stream ) end function stream_from_int64 function dtfft_get_cuda_stream ( stream ) result ( cuda_stream ) !! Returns the CUDA stream from [[dtfft_stream_t]] type ( dtfft_stream_t ), intent ( in ) :: stream !! dtfft stream integer ( int64 ) :: cuda_stream !! CUDA stream cuda_stream = transfer ( stream , int64 ) end function dtfft_get_cuda_stream #endif end module dtfft_parameters","tags":"","loc":"sourcefile/dtfft_parameters.f90.html"},{"title":"dtfft_abstract_kernel.F90 – dtFFT","text":"This file depends on sourcefile~~dtfft_abstract_kernel.f90~~EfferentGraph sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_interface_nvtx.f90 dtfft_interface_nvtx.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_interface_nvtx.f90 sourcefile~dtfft_parameters.f90 dtfft_parameters.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_utils.f90 dtfft_utils.F90 sourcefile~dtfft_abstract_kernel.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_interface_nvtx.f90->sourcefile~dtfft_utils.f90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_parameters.f90 sourcefile~dtfft_errors.f90 dtfft_errors.F90 sourcefile~dtfft_utils.f90->sourcefile~dtfft_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dtfft_abstract_kernel.f90~~AfferentGraph sourcefile~dtfft_abstract_kernel.f90 dtfft_abstract_kernel.F90 sourcefile~dtfft_abstract_backend.f90 dtfft_abstract_backend.F90 sourcefile~dtfft_abstract_backend.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_kernel_device.f90 dtfft_kernel_device.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90 dtfft_nvrtc_block_optimizer.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90 dtfft_nvrtc_module_cache.F90 sourcefile~dtfft_kernel_device.f90->sourcefile~dtfft_nvrtc_module_cache.f90 sourcefile~dtfft_kernel_host.f90 dtfft_kernel_host.F90 sourcefile~dtfft_kernel_host.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_block_optimizer.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90 dtfft_nvrtc_module.F90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_block_optimizer.f90 sourcefile~dtfft_nvrtc_module_cache.f90->sourcefile~dtfft_nvrtc_module.f90 sourcefile~dtfft_transpose_handle_generic.f90 dtfft_transpose_handle_generic.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_kernel.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_kernel_host.f90 sourcefile~dtfft_abstract_transpose_handle.f90 dtfft_abstract_transpose_handle.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_backend_cufftmp.f90 dtfft_backend_cufftmp.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_cufftmp.f90 sourcefile~dtfft_backend_mpi.f90 dtfft_backend_mpi.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_mpi.f90 sourcefile~dtfft_backend_nccl.f90 dtfft_backend_nccl.F90 sourcefile~dtfft_transpose_handle_generic.f90->sourcefile~dtfft_backend_nccl.f90 sourcefile~dtfft_abstract_transpose_handle.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_cufftmp.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_mpi.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_backend_nccl.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90 dtfft_transpose_plan.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_backend.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_kernel_device.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_generic.f90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft_transpose_handle_datatype.f90 dtfft_transpose_handle_datatype.F90 sourcefile~dtfft_transpose_plan.f90->sourcefile~dtfft_transpose_handle_datatype.f90 sourcefile~dtfft_plan.f90 dtfft_plan.F90 sourcefile~dtfft_plan.f90->sourcefile~dtfft_transpose_plan.f90 sourcefile~dtfft_transpose_handle_datatype.f90->sourcefile~dtfft_abstract_transpose_handle.f90 sourcefile~dtfft.f90 dtfft.F90 sourcefile~dtfft.f90->sourcefile~dtfft_plan.f90 sourcefile~dtfft_api.f90 dtfft_api.F90 sourcefile~dtfft_api.f90->sourcefile~dtfft_plan.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !------------------------------------------------------------------------------------------------ ! Copyright (c) 2021 - 2025, Oleg Shatrov ! All rights reserved. ! This file is part of dtFFT library. ! dtFFT is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! dtFFT is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <https://www.gnu.org/licenses/>. !------------------------------------------------------------------------------------------------ #include \"dtfft_config.h\" module dtfft_abstract_kernel !! This module defines `abstract_kernel` type and its type bound procedures. !! !! The abstract kernel is used in `transpose_handle_generic` type and !! is resposible for packing/unpacking/permute operations. !! The actual implementation of the kernel is deferred to the !! `create_private`, `execute_private` and `destroy_private` procedures. use iso_fortran_env use dtfft_parameters , only : dtfft_effort_t , dtfft_stream_t , COLOR_EXECUTE use dtfft_utils #include \"_dtfft_mpi.h\" #include \"_dtfft_private.h\" #include \"_dtfft_profile.h\" implicit none private public :: abstract_kernel public :: kernel_type_t , get_kernel_string public :: is_unpack_kernel , is_transpose_kernel public :: operator ( == ) interface operator ( == ) module procedure kernel_type_eq !! Check if two `kernel_type_t` are equal end interface public :: operator ( /= ) interface operator ( /= ) module procedure kernel_type_ne !! Check if two `kernel_type_t` are not equal end interface type :: kernel_type_t !! nvRTC Kernel type integer ( int32 ) :: val end type kernel_type_t type ( kernel_type_t ), parameter , public :: KERNEL_DUMMY = kernel_type_t ( - 1 ) !! Dummy kernel, does nothing ! type(kernel_type_t), parameter, public  :: KERNEL_TRANSPOSE           = kernel_type_t(1) !   !! Basic transpose kernel type. ! type(kernel_type_t), parameter, public  :: KERNEL_TRANSPOSE_PACKED    = kernel_type_t(2) !   !! Transposes data and packs it into contiguous buffer. !   !! Should be used only in X-Y 3D plans. type ( kernel_type_t ), parameter , public :: KERNEL_UNPACK = kernel_type_t ( 3 ) !! Unpacks contiguous buffer. type ( kernel_type_t ), parameter , public :: KERNEL_UNPACK_SIMPLE_COPY = kernel_type_t ( 4 ) !! Doesn't actually unpacks anything. Performs ``cudaMemcpyAsync`` call. !! Should be used only when backend is ``DTFFT_BACKEND_CUFFTMP``. type ( kernel_type_t ), parameter , public :: KERNEL_UNPACK_PIPELINED = kernel_type_t ( 5 ) !! Unpacks pack of contiguous buffer recieved from rank. ! type(kernel_type_t), parameter, public  :: KERNEL_UNPACK_PARTIAL      = kernel_type_t(6) !! Unpacks contiguous buffer recieved from everyone except myself. !! Should be used only when backend is ``DTFFT_BACKEND_NCCL_PIPELINED``. type ( kernel_type_t ), parameter , public :: KERNEL_PERMUTE_FORWARD = kernel_type_t ( 7 ) type ( kernel_type_t ), parameter , public :: KERNEL_PERMUTE_BACKWARD = kernel_type_t ( 8 ) type ( kernel_type_t ), parameter , public :: KERNEL_PERMUTE_BACKWARD_START = kernel_type_t ( 9 ) type ( kernel_type_t ), parameter , public :: KERNEL_PERMUTE_BACKWARD_END = kernel_type_t ( 10 ) type ( kernel_type_t ), parameter , public :: KERNEL_PERMUTE_BACKWARD_END_PIPELINED = kernel_type_t ( 11 ) ! type(kernel_type_t), parameter, public  :: KERNEL_PERMUTE_BACKWARD_END_PARTIAL = kernel_type_t(12) !! Unpacks contiguous buffer recieved from everyone except myself. !! Should be used only when backend is ``DTFFT_BACKEND_NCCL_PIPELINED``. type ( kernel_type_t ), parameter :: TRANSPOSE_KERNELS ( * ) = [ KERNEL_PERMUTE_FORWARD , KERNEL_PERMUTE_BACKWARD , KERNEL_PERMUTE_BACKWARD_START ] !! List of all transpose kernel types type ( kernel_type_t ), parameter :: UNPACK_KERNELS ( * ) = [ KERNEL_PERMUTE_BACKWARD_END_PIPELINED , KERNEL_UNPACK_PIPELINED ] !! List of all unpack kernel types type , abstract :: abstract_kernel !! Abstract kernel type !! !! This kernel type is used in `transpose_handle_generic` type and !! is resposible for packing/unpacking/permute operations. logical :: is_created = . false . !! Kernel is created flag. logical :: is_dummy = . false . !! If kernel should do anything or not. type ( kernel_type_t ) :: kernel_type !! Type of the kernel character ( len = :), allocatable :: kernel_string integer ( int32 ), allocatable :: neighbor_data (:,:) !! Neighbor data for pipelined unpacking integer ( int32 ), allocatable :: dims (:) !! Local dimensions to process contains procedure , pass ( self ) :: create !! Creates kernel procedure , pass ( self ) :: execute !! Executes kernel procedure , pass ( self ) :: destroy !! Destroys kernel procedure ( create_interface ), deferred :: create_private !! Creates underlying kernel procedure ( execute_interface ), deferred :: execute_private !! Executes underlying kernel procedure ( destroy_interface ), deferred :: destroy_private !! Destroys underlying kernel end type abstract_kernel abstract interface subroutine create_interface ( self , effort , base_storage , force_effort ) import !! Creates underlying kernel class ( abstract_kernel ), intent ( inout ) :: self !! Abstract kernel type ( dtfft_effort_t ), intent ( in ) :: effort !! Effort level for generating transpose kernels integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element logical , optional , intent ( in ) :: force_effort !! Should effort be forced or not end subroutine create_interface subroutine execute_interface ( self , in , out , stream , neighbor ) import !! Executes underlying kernel class ( abstract_kernel ), intent ( inout ) :: self !! Abstract kernel real ( real32 ), target , intent ( in ) :: in (:) !! Source buffer, can be device or host pointer real ( real32 ), target , intent ( inout ) :: out (:) !! Target buffer, can be device or host pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to execute on, used only for device pointers integer ( int32 ), optional , intent ( in ) :: neighbor !! Source rank for pipelined unpacking end subroutine execute_interface subroutine destroy_interface ( self ) import !! Destroys underlying kernel class ( abstract_kernel ), intent ( inout ) :: self !! Abstract kernel end subroutine destroy_interface end interface contains function get_kernel_string ( kernel ) result ( string ) !! Gets the string description of a kernel type ( kernel_type_t ), intent ( in ) :: kernel !! kernel type character ( len = :), allocatable :: string !! kernel string select case ( kernel % val ) case ( KERNEL_UNPACK % val ) allocate ( string , source = \"dtfft_kernel_unpack\" ) case ( KERNEL_UNPACK_PIPELINED % val ) allocate ( string , source = \"dtfft_kernel_unpack_pipe\" ) ! case ( KERNEL_UNPACK_PARTIAL%val ) !   allocate(string, source=\"Unpack part\") case ( KERNEL_PERMUTE_FORWARD % val ) allocate ( string , source = \"dtfft_kernel_forward\" ) case ( KERNEL_PERMUTE_BACKWARD % val ) allocate ( string , source = \"dtfft_kernel_backward\" ) case ( KERNEL_PERMUTE_BACKWARD_START % val ) allocate ( string , source = \"dtfft_kernel_backward_start\" ) case ( KERNEL_PERMUTE_BACKWARD_END % val ) allocate ( string , source = \"dtfft_kernel_backward_end\" ) case ( KERNEL_PERMUTE_BACKWARD_END_PIPELINED % val ) allocate ( string , source = \"dtfft_kernel_backward_end_pipe\" ) ! case ( KERNEL_PERMUTE_BACKWARD_END_PARTIAL%val ) !   allocate(string, source=\"Backward end part\") case default allocate ( string , source = \"Unknown kernel\" ) endselect end function get_kernel_string subroutine create ( self , dims , effort , base_storage , kernel_type , neighbor_data , force_effort ) !! Creates kernel class ( abstract_kernel ), intent ( inout ) :: self !! Abstract kernel integer ( int32 ), intent ( in ) :: dims (:) !! Local dimensions to process type ( dtfft_effort_t ), intent ( in ) :: effort !! Effort level for generating transpose kernels integer ( int64 ), intent ( in ) :: base_storage !! Number of bytes needed to store single element type ( kernel_type_t ), intent ( in ) :: kernel_type !! Type of kernel to build integer ( int32 ), optional , intent ( in ) :: neighbor_data (:,:) !! Optional pointers for unpack kernels logical , optional , intent ( in ) :: force_effort !! Should effort be forced or not call self % destroy () if ( any ( dims == 0 ) . or . kernel_type == KERNEL_DUMMY ) then self % is_created = . true . self % is_dummy = . true . return endif self % is_dummy = . false . self % kernel_type = kernel_type #ifdef DTFFT_DEBUG if ( any ( kernel_type == [ KERNEL_PERMUTE_BACKWARD_START , KERNEL_PERMUTE_BACKWARD_END , & KERNEL_PERMUTE_BACKWARD_END_PIPELINED ]) ) then if ( size ( dims ) /= 3 ) INTERNAL_ERROR ( \"2-step permutation is only valid for 3d grid\" ) endif #endif if ( any ( kernel_type == [ KERNEL_UNPACK , KERNEL_UNPACK_PIPELINED , & KERNEL_PERMUTE_BACKWARD_END , KERNEL_PERMUTE_BACKWARD_END_PIPELINED ]) ) then #ifdef DTFFT_DEBUG if ( . not . present ( neighbor_data ) ) INTERNAL_ERROR ( \"Neighbor data required\" ) #endif allocate ( self % neighbor_data , source = neighbor_data ) endif allocate ( self % dims , source = dims ) if ( size ( dims ) == 2 . and . kernel_type == KERNEL_PERMUTE_BACKWARD ) then self % kernel_type = KERNEL_PERMUTE_FORWARD endif allocate ( self % kernel_string , source = get_kernel_string ( self % kernel_type ) ) call self % create_private ( effort , base_storage , force_effort ) self % is_created = . true . end subroutine create subroutine execute ( self , in , out , stream , neighbor ) !! Executes kernel class ( abstract_kernel ), intent ( inout ) :: self !! Abstract kernel real ( real32 ), intent ( in ) :: in (:) !! Source buffer, can be device or host pointer real ( real32 ), intent ( inout ) :: out (:) !! Target buffer, can be device or host pointer type ( dtfft_stream_t ), intent ( in ) :: stream !! Stream to execute on, used only for device pointers integer ( int32 ), optional , intent ( in ) :: neighbor !! Source rank for pipelined unpacking if ( self % is_dummy ) return REGION_BEGIN ( self % kernel_string , COLOR_EXECUTE ) #ifdef DTFFT_DEBUG if ( . not . self % is_created ) INTERNAL_ERROR ( \"`execute` called while plan not created\" ) if ( any ( self % kernel_type == [ KERNEL_UNPACK_PIPELINED , KERNEL_PERMUTE_BACKWARD_END_PIPELINED ]) ) then if ( . not . present ( neighbor ) ) INTERNAL_ERROR ( \"Neighbor is not passed\" ) if ( neighbor < 1 . or . neighbor > size ( self % neighbor_data , dim = 2 ) ) INTERNAL_ERROR ( \"Neighbor index out of bounds\" ) endif #endif call self % execute_private ( in , out , stream , neighbor ) REGION_END ( self % kernel_string ) end subroutine execute subroutine destroy ( self ) !! Destroys kernel class ( abstract_kernel ), intent ( inout ) :: self !! Abstract kernel if ( . not . self % is_created ) return if ( self % is_dummy ) then self % is_created = . false . return endif call self % destroy_private () if ( allocated ( self % dims ) ) deallocate ( self % dims ) if ( allocated ( self % neighbor_data ) ) deallocate ( self % neighbor_data ) if ( allocated ( self % kernel_string ) ) deallocate ( self % kernel_string ) self % is_created = . false . end subroutine destroy MAKE_EQ_FUN ( kernel_type_t , kernel_type_eq ) MAKE_NE_FUN ( kernel_type_t , kernel_type_ne ) MAKE_VALID_FUN_DTYPE ( kernel_type_t , is_transpose_kernel , TRANSPOSE_KERNELS ) MAKE_VALID_FUN_DTYPE ( kernel_type_t , is_unpack_kernel , UNPACK_KERNELS ) end module dtfft_abstract_kernel","tags":"","loc":"sourcefile/dtfft_abstract_kernel.f90.html"}]}